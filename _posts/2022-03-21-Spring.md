---
title: Spring
date: 2022-03-21 17:23:46 +0800
categories: [기술면접]
tags: [spring]  # TAG는 반드시 소문자로 이루어져야함!
---

### 프레임워크 / 라이브러리
프레임워크는 소프트웨어의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게끔 뼈대를 제공하는 것이다. 애플리케이션의 전체적인 흐름을 쥐고 필요한 개발자의 코드를 가져온다.

라이브러리는 자주 사용되는 로직을 재사용하기 편리하도록 잘 정리한 일련의 코드들의 집합이다. 개발자가 필요하다고 생각하는 기능을 구현하기 위해 라이브러리를 가져온다.

제어의 주체가 누구냐에 따라 구분 했을 때 개발자가 코드를 제어할 수 있다면 '라이브러리', 개발자의 코드를 제어한다면 '프레임워크'이다.

### 스프링 프레임워크 란?
자바 엔터프라이즈 개발을 편하게 해주는 경량화된 오픈 소스 애플리케이션 프레임워크이다. 자바 객체를 직접 관리하여 Spring 컨테이너로부터 필요한 객체를 가져와 사용한다.

__경량화__ 되어 있다는 말은 스프링 자체가 가볍거나 작은 규모라는 의미가 아니라 `불필요하게 무겁지 않다`는 의미로 스프링 전에 사용하던 EJB의 과도한 개발환경과 코드를 대비시키기 위한 의미이다.
스프링의 장점은 가볍고 단순한 환경 (톰캣, 제티 등)에서도 엔터프라이즈 개발의 고급 기술을 대부분 사용할 수 있다는 점이다.

__엔터프라이즈 개발을 편하게 한다__ 는 말은 EJB가 처음 등장했을 때도 나왔던 말이지만 EJB와 다르게 스프링은 개발자들이 프레임워크가 제공하는 기술이 아닌 자신이 작성하는 애플리케이션의 로직에 더 많은 관심과 시간을 쏟게 해준다.
초기 스프링의 기본 설정과 적용 기술만 잘 선택한다면 개발자가 신경 쓸 일이 거의 없다. 따라서 엔터프라이즈 개발에서 필연적으로 요구되는 기술적인 요구를 충족하면서도 개발을 복잡하게 만들지 않는다.

일반적인 라이브러리나 프레임워크는 특정 업무 분야나 한 가지 기술에 특화된 목표를 가지고 만들어진다. 그래서 특정 계층에서 주로 동작하는 한 가지 기술분야에 집중되는데
__애플리케이션 프레임워크__ 는 특정 계층이나 기술, 업무 분야에 국한되지 않고 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크를 말한다. 개발의 전 과정을 빠르고 편리하며 효율적으로 진행하는데 일차적인 목표를 두는 프레임워크다.

**EJB-기업 환경의 시스템을 구현하기 위한 서버 측 컴포넌트 모델, 일반적으로 업무 로직을 가지고 있는 서버 어플리케이션을 지칭한다.

[참고](https://12bme.tistory.com/157)

### 프레임워크 사용 목적?
개발자 간의 능력 차이, 개발자의 구성에 따라 프로젝트 결과에도 큰 차이가 발생할 수 있다. 이러한 상황을 극복하기 위해 미리 기본 흐름이나 구조가 정해진 프레임워크를 사용한다면 결과물에 일정한 품질이 보장되고, 개발시간 단축이라는 장점이 생긴다.

### 스프링 특징
1. 경량 컨테이너
2. IoC기반의 프레임워크
3. POJO 기반의 프레임워크
4. AOP 지원
5. MVC 패턴
6. WAS에 독립적인 개발 환경

### IoC
제어의 역전이란 뜻으로 자바 기반의 개발 초기에는 자바 객체를 생성하고 의존관계를 연결하는 등의 제어권을 개발자가 가지고 있었으나 이 제어권을 컨테이너 쪽으로 넘어가
객체의 생성부터 생명주기의 관리까지 모든 객체의 제어권이 바뀌었다는 것을 의미한다.

객체의 의존성을 역전시키게 되면 객체간의 결합도를 줄이고 유연한 코드를 작성할 수 있어 가독성이 좋아지고, 코드의 중복을 제거하며, 유지 보수를 편하게 할 수 있게 한다.

### IoC 컨테이너
기본적으로 객체를 생성하고 객체간의 의존성을 이어주는 역할을 한다.

1) BeanFactory : IoC컨테이너의 기능을 정의한 인터페이스로 Bean(IoC컨테이너에 의해 생성되고 관리되는 객체)의 생성, 의존성 주입, 생명주기 관리 등의 기능을 제공한다.
2) ApplicationContext : BeanFactory 인터페이스를 상속받는데 BeanFactory가 제공하는 기능 외에 AOP, 메세지 처리, 이벤트 처리등의 기능을 제공한다.

### DI
의존성 주입이라는 의미로 객체간의 의존성을 컨테이너가 자동으로 연결해주는 것이다. 개발자가 Bean 설정 파일에 의존관계가 필요한 정보를 추가하면 컨테이너가 자동으로 연결해준다.

### Field 주입 / 생성자 주입 / Setter 주입
1) Field 주입 : 객체의 인스턴스 필드에 의존성이 주입되는 것으로 변수 선언부에 @Autowired 어노테이션을 붙여 사용한다. 코드가 간결해서 많이 이용하지만 참조관계를 눈으로 확인하기 어렵고, 의존성 주입이 간단하기 때문에
의존성 주입을 막 추가하는 경우 단일책임의 원칙을 위반하게 된다. final을 붙일 수 없기 때문에 객체가 변할 수 있다.
2) 생성자 주입 : 객체가 생성되는 시점에 의존성이 주입되는 것으로 생성자의 호출 시점에 1회 호출되는 것이 보장된다. 주입받은 객체가 변하지 않거나 반드시 객체의 주입이 필요한 경우에 강제하기 위해 사용한다.
3) Setter 주입 : 객체의 set 메서드가 호출되는 시점에 의존성이 주입되는 것으로 주입받는 객체가 변경될 가능성이 있는 경우에 사용한다.

DI 프레임워크의 대부분이 생성자 주입을 권장하는데 그 이유는
1) 변경가능성을 배제하고 불변성을 보장해 준다.
2) 테스트 코드의 작성이 용이해진다.
3) final 키워드 작성 가능 및 Lombok과 결합을 통해 코드를 간결하게 작성할 수 있다.
4) 순환참조 문제를 애플리케이션 구동 시점에 파악하여 방지할 수 있다.

### POJO
Plain Old Java Object 의 약자로 평범하고 오래된 자바 객체라는 뜻이다. 이는 다른 클래스나 인터페이스를 상속받아 메서드가 추가된 클래스가 아닌 일반적으로 알고 있는 getter, setter 같이 `기본적인 기능만 가진 자바 객체`를 말한다.

진정한 POJO란 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 말한다.

### AOP
AOP는 관점지향 프로그래밍으로 불린다. 기능별로 클래스를 분리했음에도 불구하고, 로그, 트랙잭션, 자원해제 등 공통적으로 반복되는 중복코드가 발생하게 되는데
이를 해결하기 위해 개발 코드에서는 `비즈니스 로직에 집중`하고, 실행시 비즈니스 로직의 앞 뒤에 해당 공통 관심사를 수행할 수 있게 하여 `중복 코드를 줄이는 방식`을 AOP라 한다.

AOP는 프록시 패턴을 사용하는데 프록시 패턴은 어떤 기능을 추가하려 할 때 기존 코드를 변경하지 않고 기능을 추가할 수 있다.

**프록시 패턴 : 대리인이라는 뜻으로 무엇인가 대신 처리한다는 의미이다. 어떤 객체를 사용하고자 할 때 객체를 직접적으로 참조하는 것이 아니라 해당 객체를 __대행하는 객체__ 를 통해 대상객체에 접근하는 방식을 사용하여
해당 객체가 메모리에 존재하지 않아도 기본 정보를 참조하거나 설정할 수 있고 객체가 실제 필요한 시점까지 생성을 미룰 수 있다.

### Interceptor / Filter
개발시 공통 업무에 관한 코드들을 따로 빼서 관리하는 방법으로 filter, interceptor, AOP가 있다. 이 세 방법은 요청 흐름에 따라 차이가 발생한다.

순서) Filter → Interceptor → AOP → Interceptor → Filter

* Filter :



### Bean 등록 방법


### Servlet


### Spring MVC
Spring은 MVC 패턴을 따르는데 이는 Model, View, Controller로 이루어진 구조이다.
Model은 데이터를 담고 있는 객체이고, View는 화면을 담당하여 클라이언트 쪽이 처리를 한다. Controller는 데이터 흐름과 제어를 처리하여 사용자의 요청에 대한  처리를 한다.

뷰의 영역과 비즈니스 로직이 분리되어 있다는 점이 큰 장점이다.

### Model1 / Model2
* Model1 : view와 controller가 합쳐진 것으로 비즈니스 영역에서 프레젠테이션 영역을 같이 처리하는 것이다. 개발이 쉽고 간단하지만 유지보수가 어렵다.
* Model2 : Model, View, Controller로 나누어진 것으로 자신이 수행하는 기능에 따라 분리되어 모듈화 되어 있어 각 영역별로 개발을 수행하는 개발자들의 역할도 분리된다. 따라서 동시에 여러 분야를 개발할 수 있다는 장점을 갖고, 개발 시간이 오래 걸린다는 단점을 갖는다.

따라서 규모가 작고 개발 후 주기적인 유지보수가 거의 없는 경우에는 Model1 프로젝트가 적합하고, 반대의 경우에는 Model2가 적합하다고 할 수 있다.

### VO / DTO
__VO__ : Value Object 값 그 자체를 표현하는 객체이다. 로직을 포함할 수 있고, 객체의 불변성을 보장한다. 핵심 역할은 equlas(), hashcode()를 오버라이딩 하는 것이다.

__DTO__ : Data Transfer Object 계층 간 데이터 교환을 위해 사용하는 객체이다. 데이터 교환만을 위해 사용하므로 로직을 갖지 않고, getter/setter 메소드만 갖는다.

단순히 데이터를 전달하는 객체라는 것에서는 동일한 개념이나, VO는 객체 안의 값을 통해서도 비교해야하는 중요 로직에서 사용할 데이터를 담기 위해 사용하고, DTO는 단순히 데이터를 전달하는 용도로 사용한다.

### Controller, RestController


### RESTful


### Json


### DAO




### Maven


### Spring Security
### AJAX


### Mybatis


### 스프링 vs 스프링 부트
