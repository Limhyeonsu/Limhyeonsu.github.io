---
title: 8장 누가 액세스하고 있는지를 확인하는 인증
date: 2022-04-22 13:19:02 +0900
categories: [BOOK, 그림으로 배우는 Http & Network]
tags: [http, network]  # TAG는 반드시 소문자로 이루어져야함!
---

## 8.1 인증이란?
서버에 액세스하고 있는 사람이 누군지 알려면 상대방 클라이언트에 이름을 알려달라고 해야 한다. 하지만 이름을 밝히더라도 그것이 정말인지 알 수가 없다. 그래서 본인인지 확인하기 위해 본인만 알고있는 정보나 본인만이 가지고 있는 정보등으로 확인할 필요가 있다.
이러한 정보는 주로 패스워드, 원타임 토큰, 전자 증명서, 바이오 매트릭스, IC 카드 등이 있다.

HTTP/1.1 에서 이용할수 있는 인증 방법으로는 BASIC 인증, DIGEST 인증, SSL 클라이언트 인증, 폼 베이스 인증이 있다.

## 8.2 BASIC 인증
BASIC 인증은 웹 서버와 대응하고 있는 클라이언트 사이에서 이뤄지는 인증 방식이다.

<img src="/assets/img/posting_img/book/network/BASIC.jpeg" width="700px">

1. BASIC 인증이 필요한 리소스에 리퀘스트가 있을 경우 서버는 401 상태코드와 함께 인증이 필요하나는 것을 필드에 포함해서 리스폰스를 반환한다.
2. 클라이언트는 인증을 위해 ID, 패스워드를 서버에 송신해야한다. 이때 송신하는 문자열은 : 콜론으로 연결하여 Base64 형식으로 인코딩한다.
3. 리퀘스트를 수신한 서버는 인증 정보가 정확한지 여부를 판단하고 정확하다면 리스폰스를 반환한다.

BASIC에서 사용하는 Base64 인코딩 방식은 암호화는 아니기 때문에 아무런 부가 정보 없이도 복호화 할 수 있다. 그리고 한 번 인증을 하면 일반 브라우저에서는 로그아웃할 수 없다는 문제도 있다. 그래서 그다지 사용되고 있지는 않다.

## 8.3 DIGEST 인증
DIGEST 인증은 챌린지 리스폰스 방식이 사용되고 있어 BASIC 인증과 같이 패스워드를 있는 그대로 직접 보내는 일은 없다.

챌린지 리스폰스 방식이란 최초에 상대방에게 인증 요구를 보내고 상대방 측에서 받은 챌린지 코드를 사용해서 리스폰스 코드를 계산하고, 이 값을 상대에게 송신하여 인증을 하는 방법이다. BASIC에 비하면 패스워드가 누출될 가능성이 줄어든다.

<img src="/assets/img/posting_img/book/network/DIGEST.jpeg" width="700px">

1. 인증이 필요한 리소스에 리퀘스트가 있을 경우 서버는 401 상태코드와 함께 '챌린지 코드(nonce)'를 필드에 포함하려 리스폰스를 반환한다. 이때 반드시 포함되어야 하는 정보는 `realm`, `nonce`이다. (nonce는 401 리스폰스 반환시마다 생성되는 유일한 문자열이다.)
2. 클라이언트는 인증을 위해 필요한 정보를 헤더에 담아 리스폰스를 반환한다. 이때 반드시 포함되어야 하는 정보는 `username`, `realm`, `nonce`, `uri`, `response`이다.
3. 리퀘스트를 받은 서버는 인증 정보가 정확한 것인지 아닌지 판단하고 정확한 경우 리소스를 포함한 리스폰스를 반환한다.

DIGEST 인증은 BASIC에 비해서는 높은 보안 등급을 제공하고 있지만 HTTPS의 클라이언트 인증등과 비교하면 낮다. 따라서 BASIC과 마찬가지로 그다지 사용되고 있지는 않다.

## 8.3 SSL 클라이언트 인증
유저의 id나 패스워드를 사용한 인증 방식은 도난되었을 때 제3자가 위장을 하는 경우가 있어 이를 방지하기 위한 대책으로 SSL 클라이언트 인증이 사용된다. 이 인증은 HTTPS의 클라이언트 인증서를 이용한 인증 방식이다.
SSL 클라이언트 인증을 할 땐 사전에 클라이언트에 증명서를 배포하고 install을 해야한다.

1. 인증이 필요한 리소스의 리퀘스트가 있는 경우 서버는 클라이언트에게 증명서를 요구하는 'Certificate Request' 메시지를 송신한다.
2. 유저는 클라이언트 증명서를 선택하고 'Client Certificate' 메시지를 송신한다.
3. 증명서를 검증하여 정확하다면 클라이언트의 공개키를 취득하고 이후 HTTPS에 의한 암호를 개시한다.

SSL 클라이언트 인증은 `2-factor` 인증에서 사용되는데 이는 패스워드란 한 개의 요소로만 인증하는 것이 아닌 이용자가 가진 다른 정보를 병용해서 인증을 하는 방법이다.(즉 인증 정보가 2개)
그리고 SSL 클라이언트 인증은 클라이언트 증명서를 이용해야 하는데 이를 이용하기 위해서는 비용이 필요하다. 따라서 안전하게 운용하기 위해서는 상당한 비용이 발생하게 된다.

## 8.4 폼 베이스 인증
클라이언트가 서버 상의 웹 애플리케이션에 자격정보를 송신하여 그 자격 정보의 검증 결과에 따라 인증하는 방식이다.

인증의 대부분은 폼 페이스 인증을 사용한다. HTTP 표준인 BASIC, DIGEST 인증은 사용상의 문제와 보안적인 문제로 거의 사용되지 않고 SSL 클라이언트 인증은 비용 등의 문제로 널리 사용되고 있지 못하다.
그리고 폼 페이스 인증은 표준 사양이 결정되어 있지 않지만 일반적으로 자주 사용되는 방법이 세션 관리를 위해서 쿠키를 사용하는 방법이다.

1. 서버에 id, 패스워드 등의 자격정보를 포함한 리퀘스트 송신
2. 서버 측에서는 유저를 식별하기 위해 세션 ID 발행, 클라이언트 측에 송신시 Set-Coookie 헤더 필드에 세션 ID를 저장해서 리스폰스를 반환한다.
3. 서버 측에서 세션 ID를 받은 클라이언트는 쿠키로 저장한다. 그리고 이후 리퀘스트 송신시 쿠키에 저장한 세션ID를 서버에 전송한다.
