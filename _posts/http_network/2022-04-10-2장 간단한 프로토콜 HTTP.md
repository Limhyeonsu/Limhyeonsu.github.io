---
published: true
title: 2장 간단한 프로토콜 HTTP
date: 2022-04-10 19:55:10 +0900
categories: [BOOK, 그림으로 배우는 Http & Network]
tags: [http, network]  # TAG는 반드시 소문자로 이루어져야함!
---

## 2.1 HTTP는 클라이언트와 서버 간에 통신을 한다.
텍스트와 이미지 등과 같은 리소스를 필요하다고 요구하는 쪽이 클라이언트가 되고, 이러한 리소스를 제공하는 쪽이 서버가 된다. HTTP는 클라이언트와 서버의 역할을 명확하게 구별하고 있다.

## 2.2 리퀘스트와 리스폰스를 교환하여 성립
HTTP는 클라이언트로부터 리퀘스트가 송신되며, 그 결과가 서버로부터 리스폰스로 되돌아온다. 즉 반드시 클라이언트 측으로부터 통신이 시작된다.

<img src="/assets/img/posting_img/book/network/req.jpeg" width="500px">
<img src="/assets/img/posting_img/book/network/resp.jpeg" width="500px">

## 2.3 HTTP는 상태를 유지하지 않는 프로토콜
HTTP는 상태를 계속 유지하지 않는 stateless 프로토콜이다. 따라서 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해서는 전혀 기억하지 않는다.
이는 많은 데이터를 매우 빠르고 확실하게 처리하는 범위성을 확보하기 웨해서 이와 같이 간단하게 설계되어 있는 것이다.

하지만 stateless 특성만으로 처리하기 어려운 일이 증가하게 되었고(예. 로그인 상태 유지 등) 상태를 유지하고 싶은 요구에 부응하기 위해 '쿠키'라는 기술이 도입되었다.

## 2.4 리퀘스트 URI로 리소스를 식별
클라이언트는 리소스를 호출시마다 리퀘스트를 송신할 때에 리퀘스트 안에 URI를 포함한다. 모든 URI를 리퀘스트 URI에 포함하던가 Host 헤더 필드에 네트워크 로케이션을 포한하는 등의 방법이 있다.

## 2.5 서버에 임무를 부여하는 HTTP 메소드
HTTP/1.1 에서 사용할 수 있는 메소드
* GET(리소스 획득) : GET 메소드는 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구한다.
* POST(엔티티 전송) : POST는 엔티티를 전송하기 위해서 사용된다.
* PUT(파일 전송) : FTP에 의한 파일 업로드와 같이 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구한다.
* HEAD(메시지 헤더 취득) : GET과 같은 기능이지만 메시지 바디는 돌려주지 않는다. 주로 URI 유효성과 리소스 갱신 시간을 확인하는 목적등으로 사용된다.
* DELETE(파일 삭제) : PUT 메소드와 반대로 동작, PUT 메소드와 같이 인증 기능이 없기 때문에 일반적인 웹 사이트에서는 사용되고 있지 않다.
* OPTIONS(제공하고 있는 메소드의 문의) : 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용된다.
* TRACE(경로 조사) : Web 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백을 발생시킨다.
* CONNECT(프록시에 터널링 요구) : 프록시에 터널 접속 확립을 요함으로써 TCP 통신을 터널링 시키기 위해서 사용된다. 주로 SSL, TLS 등의 프로토콜 암호화된 것을 터널링 시키기 위해서 사용

## 2.6 메소드를 사용해서 지시를 내린다
리퀘스트 URI로 지정한 리소스에 리퀘스트를 보내는 경우에는 메소드라 불리는 명령이 있다. 메소드는 리소스에 어떠한 행동을 하기 원하는지를 지시하기 위해 존재한다. 또 메소드는 대소문자를 구별하기 때문에 대문자로 기재해야 한다.

<img src="/assets/img/posting_img/book/network/HTTPMethod.jpeg" width="700px">

## 2.7 지속 연결로 접속량을 절약
HTTP 초기 버전에서는 HTTP 통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 할 필요가 있었다. 그로인해 리퀘스트를 보낼 때마다 매번 TCP 연결과 종료를 하게 되는 쓸모없는 일이 발생되어 통신량이 늘어나게 된다.

이러한 문제를 해결하기 위해  `지속 연결`이라는 방법을 고안하였다. 이는 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다. 지속 연결을 하는 이점으로 TCP 커넥션의 연결과 종료의
반복되는 오버헤드를 줄여주기 때문에 서버에 대한 부하가 경감된다. 또 오버헤드를 줄인 만큼 요청과 응답이 빠르게 완료되기 때문에 웹 페이지를 빨리 표시할 수 있다. (지속 연결은 HTTP 1.1에서 표준)

또 지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인화를 가능하게 한다. (예전에는 1요청 1응답이여서 응답이 없으면 요청을 더 못보냈다. 이러한 단점을 보안한 것이 파이프라인화이다.)

## 2.8 쿠키를 사용한 상태 관리
HTTP는 상태를 관리하지 않기 때문에 인증이 필요한 웹 페이지 등에서 문제를 일으킬 수 있다. 이로 인하여 쿠키라는 시스템이 도입되었는데 이는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템이다.
서버에서 쿠키를 발행하여 클라이언트에 보존하게 된다. 이후 클라이언트가 같은 서버로 리퀘스트를 보낼때 자동으로 쿠키값을 넣어서 송신하고 서버에서 이를 확인하여 이전 상태를 알 수 있다.
