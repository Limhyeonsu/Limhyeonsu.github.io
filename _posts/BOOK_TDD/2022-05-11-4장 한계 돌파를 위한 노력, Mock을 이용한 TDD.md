---
title: 4장 한계 돌파를 위한 노력, Mock을 이용한 TDD
date: 2022-05-11 24:10:45 +0900
categories: [BOOK, TDD 실천법과 도구]
tags: [tdd]  # TAG는 반드시 소문자로 이루어져야함!
---

### 4.1 Mock 객체
#### Mock 객체란 무엇인가?
Mock 이란 조각하기 쉬운 재료를 이용하여 추후 만들어질 제춤의 외양을 흉내 낸 모조품을 말한다. 즉 실제 모듈과 비슷하게 보이도록 만든 가짜 객체를 Mock 객체라고 한다.

예) 사용자 암호를 변경하는 기능을 구현하기 위해 테스트 케이스를 작성하는데 추가 요구사항으로 사용자의 패스워드를 반드시 암호화한 다음에 저장해야 한다.
암호화 모듈의 스펙은 interface로 정해져 있고, 이 모듈은 다른 팀에서 구현하기로 결정한다고 했을 때 다른팀에서 암호화 모듈을 완성할 때까지 테스트를 진행하기가 어렵다.
이럴때 스펙이 정해져 있으니 암호화 모듈처럼 보이는 객체를 만들어서 테스트에 사용할 수 있다.

정리하자면 __우리가 구현하는데 필요하지만 실제로 준비하기엔 여러가지 어려움이 따르는 대상을 필요한 부분만큼만 채워서 만들어진 객체__ 를 말한다.

#### 언제 Mock 객체를 만들 것인가?
테스트 케이스 작성이 어려운 상황과 Mock 객체가 필요한 상황은 종종 일치하곤 한다. 대부분의 경우 모듈이 가진 `의존성`이 근본적인 원인이 된다. 모듈이 필요로 하는 읜존성은 테스트 작성을 어렵게 만든다.
그리고 그 의존성을 단절시키기 위해 Mock 객체가 사용된다.

1. 테스트 작성을 위한 환경 구축의 어려운 경우 : 환경 구축을 위한 작업시간이 많이 필요한 경우, 특정 모듈을 아직 갖고 있지 않아서 ,타 부서와의 협의나 정책이 필요한 경우에 Mock이 필요하다.
2. 테스트가 특정 경우나 순간에 의존적인 경우 : 특히 예외처리를 테스트할 때 많이 접한다. Mock을 이용하면 특정 상태를 가상으로 만들어놓을 수 있다.
3. 테스트 시간이 오래 걸리는 경우

### 4.2 Mock에 대한 기본적인 분류 개념, 테스트 더블
제라드 메스자로스가 만든 단어로 테스트 더블은 오리지널 객체를 사용해서 테스트를 진행하기 어려울 경우 이를 대신해서 테스트를 진행할 수 있도록 만들어주는 객체를 지칭한다. Mock 객체는 테스트 더블의 하위로 분류되어 있다.

예) 고객이 쿠폰을 발급받아 저장하고, 그 내역을 확인할 수 있는 기능 구현
```
public interface ICoupon {
  public String getName();                //쿠폰 이름
  public boolean isValid();               //쿠폰 유효 여부 확인
  public int getDiscountPercent();        //할인율
  public boolean isAppliable(Item item);  //해당 아이템에 적용 가능 여부
  public void doExpire();                 //사용할 수 없는 쿠폰으로 만듬
}
```
```
public class UserTest{
  @Test
  public void testAddCoupon() throws Exception {
    User user = new User("area88");
    assertEquals("쿠폰 수령 전", 0, user.getTotalCouponCount());

    ICoupon coupon = ?????

    user.addCoupon(coupon);
    assertEquals("쿠폰 수령 후", 1, user.getTotalCouponCount());
  }
}
```
위 예제에서 ICoupon은 테스트 대상은 아니고 테스트에 사용되는 일종의 테스트 픽스처이다. 하지만 이 구현 객체가 없으면 정상적인 테스트 케이스를 작성할 수 없다. 이때 테스트 더블을 활용하여 이 상황을 극복할 수 있다.

#### 더미 객체
더미 객체는 단순한 껍데기에 해당한다. 오로지 인스턴스화될 수 있는 수준으로만 ICoupon 인터페이스를 구현한 객체다.
```
public class DummyCoupon implements ICoupon{
    @Override
    public String getName() {
        return null;
    }

    @Override
    public boolean isValid() {
        return false;
    }

    @Override
    public int getDiscountPercent() {
        return 0;
    }

    @Override
    public boolean isAppliable(Item item) {
        return false;
    }

    @Override
    public void doExpire() {

    }
}
```
```
public class UserTest{
  @Test
  public void testAddCoupon() throws Exception {
  User user = new User("area88");
  assertEquals("쿠폰 수령 전", 0, user.getTotalCouponCount());

      ICoupon coupon = new DummyCoupon();

      user.addCoupon(coupon);
      assertEquals("쿠폰 수령 후", 1, user.getTotalCouponCount());
  }
}
```
더미 객체는 단지 인스턴스화된 객체가 필요할 뿐 해당 객체의 기능까지는 필요하지 않은 경우에 사용한다.(정상 동작은 보장되지 않음)

#### 테스트 스텁
테스트 스텁은 더미 객체가 마치 실제로 동작하는 것처럼 보이게 만들어놓은 객체다. 더미 객체와 다르게 테스트 스텁은 객체의 특정 상태를 가정해서 만들어놓은 단순 구현체다.
특정 값을 리턴해주거나 특정 메시지를 출력하는 등의 작업을 한다.

```
public class StubCoupon implements ICoupon{
    @Override
    public String getName() {
        return "VIP 고객 한가위 감사쿠폰";
    }

    @Override
    public boolean isValid() {
        return true;
    }

    @Override
    public int getDiscountPercent() {
        return 7;
    }

    @Override
    public boolean isAppliable(Item item) {
        return true;
    }

    @Override
    public void doExpire() {

    }
}
```
단지 인스턴스화될 수 있는 객체 수준이면 더미, 인스턴스화된 객체가 특정 상태나 모습을 대표하면 스텁이다.

```
@Test
public void testGetLastOccupiedCoupone() throws Exception {
  User user = new User("area88");
  ICoupon coupon = new StubCoupone();
  user.addCoupon(coupon);
  ICoupone lastCoupone = user.getLastOccupiedCoupone();

  assertEquals("쿠폰 할인율", 7, lastCoupone.getDiscountPercent());
  assertEquals("쿠폰 이름", "VIP 고객 한가위 감사 쿠폰", userCoupone.getName());
}
```
스텁은 특정 객체가 상태를 대신해주고 있긴 하지만 하드코딩된 형태이기 때문에 로직이 들어가는 부분은 테스트할 수 없다.
특정 쿠폰이 구매 제품에 적용되는지 여부에 따라 결제액이 바뀌는걸 테스트하는 경우 할인이 적용되는 아이템과 할인이 적용되지 않은 아이템에 대한 테스트가 필요하다. 이런 경우 아이템에 따라 쿠폰이 적용 가능한지 안한지로 판단하여 하드코딩 하여 작성할 수 있다.

이렇게 테스트 더블로 만들어진 객체가 발전하면 단순 스텁을 벗어나서 실제 로직이 구현된 것처럼 보이는데 그런 객체를 페이크 객체라고 한다.

#### 페이크 객체
페이크 객체는 스텁과 경계를 구분짓기 어려우나 스텁은 하나의 인스턴스를 대표하는데 주로 쓰이고, 페이크는 여러 개의 인스턴스를 대표할 수 있는 경우이거나 좀 더 복잡한 구현이 들어가 있는 객체를 지칭한다.
```
public class FakeCoupone implement ICoupone {
  List<String> categoryList = new ArrayList();

  public FakeCoupone() {
    categoryList.add("부엌칼");
    categoryList.add("아동 장난감");
    categoryList.add("조리기구");
  }

  @Override
  public boolean isAppliable(Item item) {
    if(this.categoryList.contains(item.getCategory()) {
      return true;
    }
    retuen false;
}
```
페이크 객체는 복잡한 로직이나 객체 내부에서 필요로 하는 다른 외부 객체들의 동작을, 비교적 단순화하여 구현한 객체다. (복잡도 = 더미 < 테스트 스텁 < 페이크 객체)

#### 테스트 스파이
테스트에 사용되는 객체에 대해서도 특정 객체가 사용됐는지 그리고 객체의 예상된 메소드가 정상적으로 호출됐는지를 확인해야 하는 상황이 발생한다.
보통은 호출 여부를 몰래 감시해서 기록했다가, 나중에 요청이 들어오면 해당 기록 정보를 전달해준다. 그런 목적으로 만들어진 테스트 더블을 테스트 스파이라고 부른다.
```
@Test
public void testGetOrderPrice_discounableItem() throws Exception {
  PriceCalculator calculator = new PriceCalculator();
  Item item = new Item("LightSavor", "부엌칼", 100000);
  ICoupon coupon = new FakeCoupon();

  //getOrderPrice를 구하기 위해서는 isAppliable 메소드가 1번 호출되어야 한다는 것이 가정되어 있다.
  assertEquals("쿠폰으로 인해 할인된 가격", 93000, calculator.getOrderPrice(item, coupon));
}
```
```
  @Override
  public boolean isAppliable(Item item) {
    isAppliableCallCount++; //호출되면 증가
    if(this.categoryList.contains(item.getCategory()) {
      return true;
    }
```
```
//테스트 스파이
public int getIsAppliableCallCount() {
  return this.isAppliableCallCount;
}
```
테스트 스파이는 아주 특수한 경우를 제외하고 잘 쓰이지 않는다. 대부분의 Mock 프레임워크들은 기본적으로 테스트 스파이 기능을 제공해준다.

[상태 기반 테스트, 행위 기반 테스트]
상태 기반 테스트는 테스트 대상 클래스의 메소드를 호출하고, 그 `결과 값과 예상 값을 비교`하는 식이다. 특정 메소드를 거친 후, 객체의 상태에 대해 예상값과 비교하는 방식이 상태 기반 테스트이다.

행위 기반 테스트는 올바른 로직 수행에 대한 판단의 근거로 `특정한 동작의 수행 여부`를 이용한다.

#### Mock 객체
일반적으로 테스트 더블은 상태 기반으로 테스트 케이스를 작성하고, Mock 객체는 행위를 기반으로 테스트 케이스를 작성한다.
행위기반 테스트는 복잡한 시나리오가 사용되는 경우가 많고, 모양이나 작성 등 여러가지 측면에서 어색한 경우가 많기 때문에 만일 상태 기반으로 테스트를 할 수 있는 상황이라면 굳이 행위 기반 테스트 케이스는 만들지 않는 것이 좋다.

#### Mock 객체라는 용어가 주는 혼란스러움 정리
Mock 객체는 넓은 의미로 일반적인 가성 임시 구현체의 의미로 사용되는 경우가 많다. 테스트 더블과 거의 동등한 의미로 사용되는 경우가 많았기 때문에 따라서 Mock 객체라는 단어를 테스트 더블과 동일한 의미로 사용할 것이다.

**테스트 케이스 작성시 매번 클래스를 구현하는 것은 번거로울 수 있다 그럴땐 명시적인 클래스 보다는 '익명 클래스'로 만들어서 사용하
