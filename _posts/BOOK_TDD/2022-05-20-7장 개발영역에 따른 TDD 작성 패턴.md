---
title: 7장 개발 영역에 따른 TDD 작성 패턴
date: 2022-05-20 08:33:45 +0900
categories: [BOOK, TDD 실천법과 도구]
tags: [tdd]  # TAG는 반드시 소문자로 이루어져야함!
---

### 7.3 일반적인 애플리케이션
TDD가 가장 적극적으로 사용되고 효율이 높은 부분은 애플리케이션의 업무 로직을 구현할 때다.

#### 생성자 테스트
단순 클래스를 생성하기 위한 생성자의 경우 테스트 케이스를 작성하지 않는다. 다만 객체 사용을 위한 필수 값을 설정하는 경우에는 필요에 따라 테스트케이스를 작성한다.
또 선행조건이나 업무로직을 직접 기술하는 경우도 있는데 이럴 경우는 테스트 케이스를 작성해야 한다.

#### DTO 스타일의 객체 테스트
단순 getter/setter로 이루어진 DTO는 굳이 테스트 케이스를 작성하지 않으나 특정 목적을 가진 불변 객체의 경우에는 테스트 케이스를 작성하기도 한다.

#### 닭과 달걀 메소드 테스트
메소드가 서로 맞물린 경우 완전히 하나만 독립적으로 테스트하기 어려운 경우가 있다. 좋은 테스트 케이스 작성법 중 하나가 한 번에 실패 케이스를 하나씩 작성하는 것이나
이 상황에서는 어느 한쪽만 먼저 구현하기 어려운 상황이 된다.
* 실패하는 테스트 케이스가 두 개인 상태에서 작업하기(일반적인 방법)
* 안정성이 검증된 제3의 모듈을 사용하기(가능하다면 권장)
* 자바 리플렉션을 이용해 강제로 확인하기(대체로 비권장)

테스트 케이스를 리플렉션을 통해 해결하는 것은 잘못된 접근 방식이다. 리플렉션은 정말 부득이한 경우가 아니면 사용하지 않는다.
예를 들면 private메소드를 부득이 테스트해야 하거나 소스코드 없는 외부 모듈을 받았는데 신뢰도 검증을 위해 해당 모듈의 내부 메소드를 테스트해야 하는 경우 등이 특별한 예외에 해당한다.

#### 배열 테스트
* JUnit 4의 assertArrayEquals를 이용한다 - 기본적으로 순서를 따지기 때문에 순서를 고려하지 않을 경우 Arrays.sort를 이용하자
* Unitils의 assertReflectionEquals나 assertLenientEquals를 이용한다. -
* JUnit 3의 경우라면 List로 변환해서 비교한다.

#### 객체 동치성 테스트
객체 비교시 정말 동일한 객체인지를 판별해내야하는 '동일성 테스트'인지 아니면 같은 값을 같는 객체인지만 판별하면 되는 '동치성 테스트' 인지 구분해서 생각해야 한다.
두 객체를 서로 동치비교하는 방법에는 다음과 같이 있다.
* 내부 상태(필드값)를 직접 꺼내와서 각각 비교한다.
* toString을 중첩구현해 놓고, toString 값으로 비교한다.
* equals 메소드를 중첩 구현한다. (개념적으로 가장 올바른 방법이다.)
* Unitils의 assertReflectionEquals를 이용한다.

#### 컬렉션 테스트
* 자바 기본형이나 String이 컬렉션에 들어가 있는 경우 - 곧바로 비교 가능
* 일반 객체가 컬렉션에 들어 있는 경우 - 객체가 equals를 중첩구현 했다면 문제가 없지만, 안했다면 객체의 id값을 비교하기 때문에 값이 서로 다르다고 인식한다.
