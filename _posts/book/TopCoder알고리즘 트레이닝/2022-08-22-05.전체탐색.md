---
title: 05. 전체탐색
date: 2022-08-22 22:20:00 +0900
categories: [BOOK, TopCoder알고리즘 트레이닝]
tags: [algorithm]  # TAG는 반드시 소문자로 이루어져야함!
---


전체 탐색과 시뮬레이션의 차이
* 시뮬레이션은 수행해야 하는 과정이 모두 나와있는 문제
* 전체 탐색은 모든 패턴을 조사해야 하는 것과 그것을 필요로 하는 문제

전체 탐색의 형태로 다음과 같은 것이 있다.
1. 모든 패턴을 찾고 가장 좋은 답을 찾는 것
2. 모든 패턴을 찾고 조건을 충족하는 패턴이 몇 개인지 찾는 것

답이 같은 두 문제여도 어떠한 작업을 수행할지 적혀있으면 시뮬레이션 문제이고, 없으면 전체 탐색 문제이다.

## 5-1. 즐거운 파티
```
화이트씨는 다재다능한 사람입니다. 그래서 그에게는 친구가 많습니다. 하지만 불행하게도 그의 친구들은 다재다능하지 않습니다. 각각의 친구는 2가지 주제에만 관심이 있고 다른 주제로 이야기하는 것을 싫어합니다.
그래서 파티를 개최할 때마다 모두가 즐겁게 파티를 보내려면 어떤 친구를 초대할지가 큰 문제입니다. 화이트씨는 그 동안의 경험으로 초대된 친구 모두가 공통의 흥미 있는 화제가 있을 때 파티를 즐긴다는 것을 알았습니다.
문자열 배열 first, second가 주어집니다. 화이트씨의 i번째 친구가 흥미 있는 화제는 first[i]와 second[i]입니다. 즐거운 파티가 되려면 화이트씨가 초대할 수 있는 친구는 최대 몇 명인지 리턴하세요

[클래스와 함수 정의]
class : InterestingParty
method : public int bestInvitation(String[] first, String[] second)

[제약조건]
* first : 1~50개의 요소를 갖는 배열이다.
* second : first와 같은 크기의 배열이다.
* first, second 공통 : 각 요소는 1~15개의 문자이며, 각 문자는 영어 소문자이고, i번째 요소 first[i]와 second[i]의 내용은 다르다.

[입력데이터와 출력 데이터]
//0.
String[] first = {"fishing", "gardening", "swimming", "fishing"};
String[] second = {"hunting", "fishing", "fishing", "biting"};

//1.
String[] first = new String[]{"variety", "diversity", "loquacity", "courtesy"};
String[] second = new String[]{"talking", "speaking", "discussion", "meeting"};

//2.
String[] first = new String[]{"snakes", "programming", "cobra", "monty"};
String[] second = new String[]{"python", "python", "anaconda", "python"};

//3.
String[] first = new String[]{"t", "o", "p", "c", "o", "d", "e", "r", "s", "i", "n", "g", "l", "e", "r", "o", "u", "n", "d", "m", "a", "t", "c", "h", "f", "o", "u", "r", "n", "i"};
String[] second = new String[]{"n", "e", "f", "o", "u", "r", "j", "a", "n", "u", "a", "r", "y", "t", "w", "e", "n", "t", "y", "t", "w", "o", "s", "a", "t", "u", "r", "d", "a", "y"};
```

## 나의 답
```java
public class InterestingParty {
   public int bestInvitation(String[] first, String[] second)
       //두 배열을 하나로 합친 배열을 만든다
       String[] result = new String[first.length + second.length];
       System.arraycopy(first, 0, result, 0, first.length);
       System.arraycopy(second, 0, result, first.length, second.length);

       //배열에서 중복되는 값에 대해 그룹핑하여 카운트를 value로 담은 map을 반환한다.
       Map<String, Integer> map = Arrays.stream(result).collect(Collectors.groupingBy(f -> f, Collectors.counting()));

       //map의 value중 가장 큰 값을 추출한다.
       return Collections.max(map.values());
   }
}


import ex2.InterestingParty;

import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
       //1.
       String[] first = {"fishing", "gardening", "swimming", "fishing"};
       String[] second = {"hunting", "fishing", "fishing", "biting"};

       //2.
       first = new String[]{"variety", "diversity", "loquacity", "courtesy"};
       second = new String[]{"talking", "speaking", "discussion", "meeting"};

       //3.
       first = new String[]{"snakes", "programming", "cobra", "monty"};
       second = new String[]{"python", "python", "anaconda", "python"};

       //4.
       first = new String[]{"t", "o", "p", "c", "o", "d", "e", "r", "s", "i", "n", "g", "l", "e", "r", "o", "u", "n", "d", "m", "a", "t", "c", "h", "f", "o", "u", "r", "n", "i"};
       second = new String[]{"n", "e", "f", "o", "u", "r", "j", "a", "n", "u", "a", "r", "y", "t", "w", "e", "n", "t", "y", "t", "w", "o", "s", "a", "t", "u", "r", "d", "a", "y"};

       InterestingParty interestingParty = new InterestingParty();
       System.out.println(interestingParty.bestInvitation(first,second));
    }
}
```
