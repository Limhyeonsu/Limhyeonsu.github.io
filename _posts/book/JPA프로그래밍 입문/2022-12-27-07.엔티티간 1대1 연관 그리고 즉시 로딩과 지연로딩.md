---
title: 7. 엔티티간 1:1 연관 그리고 즉시 로딩과 지연 로딩
date: 2022-12-27 23:24:38 +0900
categories: [BOOK, JPA 프로그래밍 입문]
tags: [sql]  # TAG는 반드시 소문자로 이루어져야함!
---

## 01. 키를 참조하는 1:1 연관 매핑
예) 서비스에서 사용자에게 멤버십 카드를 발급해 준다고 하면 시스템은 사용자를 표현하기 위한 User 엔티티와 멤버십 카드를 표현하기 위한 MembershipCard 엔티티를 갖게 된다. 한 명의 사용자는 한 장의 멤버십 카드를 소유할 수 있다고 가정했을 때 User 엔티티와 MembershipCard는 1:1 관계를 갖는다.

User와 MembershipCard는 각자 자신의 식별자를 가지며 MembershipCard는 1:1 연관을 맺는 User 객체를 속성(참조키)으로 갖고 있다.

테이블에서는 membership_card 테이블의 user 테이블의 PK를 참조하지만 엔티티 클래스에서는 User 객체를 참조하고 있다.

MembershipCard 객체를 생성하려면 membership_card 테이블과 user 테이블을 함께 조회한 뒤에 MembershipCard 객체와 User 객체를 알맞게 생성해야한다. 이를 쿼리를 이용해 개발자가 직접 처리한다면 복잡하지만 JPA를 이용하면 간단한 설정으로 두 엔티티 객체 간의 1:1 연관을 처리할 수 있다.

## 02. 참조키를 이용한 1:1 단방향 연관
```java
@Entity
@Table(name="membership_card")
public class MembershipCard {
    @Id
    @Column(name="card_number")
    private String number;

    @OneToOne   //User 엔티티와 1:1 연관을 가짐을 설정
    @JoinColumn(name="user_email")  //User 객체의 식별자에 해당하는 참조키로 user_email을 지정
    private User owner;     //User 엔티티에 대한 참조
    @Temporal(TemporalType.DATE)
    @Column(name="expirt_date")
    private Date expiryDate;
    private boolean enabled;

    //....
}

```
```java
em.getTransaction().begin();
User owner = em.find(User.class, "asds@asd.com");

MembershipCard memCard = new MembershipCard("1234", owner, new Date());
em.persist(memCard);

em.getTransaction().commit();
```

만약 영속 객체가 아닌 User 객체를 MembershipCard의 owner 필드에 할당하면 어떻게 될까?

```java
em.getTransaction().begin();
User notPersistenceUser = new User("jvm@asd.com", "JVM", new Date());
MembershipCard memCard = new MembershipCard("1234", notPersistenceUser, new Date());
em.persist(memCard);
em.getTransaction().commit();
```
영속 컨텍스트에 저장되지 않은 User 객체를 MembershipCard에 할당하게 되면 에러가 발생한다. `즉 연관에 사용할 엔티티 객체는 반드시 영속 상태로 존재해야 한다.`

## 03. 1:1 연관의 즉시 로딩과 지연 로딩
EntityManager.find()를 이용해서 MembershipCard 객체를 구하면 외부 조인을 이용해서 연관된 User 객체를 한 쿼리로 함께 로딩한다.

이렇게 연관된 객체를 함께 로딩하는 것을 즉시 로딩이라고 한다. 즉시 로딩은 연관된 객체를 함께 불러오는데 이는 연관된 객체를 함께 사용하지 않으면 필요 없는 객체를 로딩하게 된다는 것을 뜻한다.

연관 객체가 필요없는 기능이 더 많다면 `지연 로딩`을 사용해서 연관된 객체가 필요할 때만 로딩하도록 구현할 수 있다. 지연 로딩은 연관 객체를 실제 사용하는 시점에 로딩하는 방식이다. 지연 로딩을 설정하는 방식은 @OneToOne(fetch=FetchType.LAZY)

```java
//지연 로딩을 설정하면 이때 membership_card만 조회한다.
MembershipCard memCard = em.find(MembershipCard.class, "5678");
//실제 User 객체가 필요할 때 user 테이블을 조회한다.
System.out.println(memCard.getOwner().getName());
```

fetch 속성은 즉시 로딩을 기본 값으로 갖기 때문에 지연 로딩이 필요한 경우 설정해주자

## 04. 참조키를 이용한 1:1 양방향 연관
JPA는 두 엔티티 간의 양방향 연관을 지원한다. 테이블 구조는 단방향 구조이지만 MembershipCard 클래스, User 클래스를 서로 참조하는 연관을 가질 수 있다.

<img src="/assets/img/posting_img/book/JPA%20프로그래밍%20입문/양방향연관관계.jpeg" width="700px">

참조키를 이용한 1:1 연관을 양방향으로 설정하기 위해서 다음과 같이 한다.

```java
@Entity
@Table(name="user")
public class User {
    @Id@Basic
    private String email;

    //...

    //MembershipCard의 user 객체의 변수명인 "owner"로 설정한다.
    @OneToOne(mappedBy="owner")
    priavate MembershipCard membershipCard;
}
```

DB 테이블에서 두 엔티티 간의 연관은 참조키를 통해서 이루어진다. JPA의 1:1 연관도 내부적으로 DB 테이블의 참조를 기반으로 구현하기 때문에 본질적으로 참조의 방향은 단방향이다. 위 예에서 MembershipCard 엔티티에서 User 엔티티로의 단방향 참조를 갖게 된다. 즉 DB 데이터를 기준으로 User에서 MembershipCard로의 연관은 존재하지 않는다.

JPA는 1:1 연관에서 물리적으로 존재하지 않는 연관을 처리하기 위해 mappedBy를 사용한다. 위 예에서 mappedBy의 속성값은 owner인데 이는 양방향 연관에서 연관을 소유한 쪽이 상대방 엔티티의 owner 속성이라는 것을 의미한다.
