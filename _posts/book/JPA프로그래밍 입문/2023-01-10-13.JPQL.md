---
title: 13. JPQL
date: 2023-01-10 20:39:44 +0900
categories: [BOOK, JPA 프로그래밍 입문]
tags: [sql]  # TAG는 반드시 소문자로 이루어져야함!
---

## 01. JPQL
JPQL은 JPA에서 사용하는 쿼리 언어이다. SQL의 쿼리 언어와 매우 유사하나 테이블과 칼럼 이름 대신 매핑한 엔티티 이름과 속성 이름을 사용한다는 점이 차이가 있다.

```
//엔티티 이름과 엔티티 속성을 사용한다.
select
from Review r
where r.hotel =:hotel
order by r.id desc
```

## 02. JPQL 기본 코드
`select 별칭 from 엔티티이름 as 별칭` 엔티티 이름 뒤에는 별칭이 오는데 이 별칭은 엔티티를 참조할 때 사용한다. 별칭은 필수이며 as는 생략할 수 있다.

```java
TypedQuery<User> query = em.createQuery("select u from User u", User.class);
List<User> users = query.getResultList(); // SQL을 실행하고 그 결과를 리턴
for(User u : users) {
  //...
}

//TypedQuery와 달리 타입을 지정하지 않는다.
Query query = em.createQuery("select u from User u");
List users = query.getResultList();
for(Object o : users) {
  User user = (User)o;
}
```

### 2.1 order by를 이용한 정렬
```
select p from Player p order by p.name asc
select p from Player p order by p.name desc
select p from Player p order by p.team.id, p.name
```

## 03. 검색 조건 지정
```java
TypedQuery<Player> query = em.createQuery(
  "select p from Player p where p.team.id = "T1", Player.class);
List<Player> players = query.getResultList();

//인텍스 기반 파라미터를 이용해 입력 파라미터를 지정
TypedQuery<Player> query2 = em.createQuery(
  "select p from Player p where p.team.id = ? and p.salary = ? , Player.class);
query2.setParameter(0, "T1");
query2.setParameter(1, 1000);
List<Player> players2 = query2.getResultList();

//파라미터 값으로 엔티티 지정
//엔티티를 이용하면 연관에 대한 직접 비교를 할 수 있다.
Team team = em.find(Team.class, "T1");
TypedQuery<Player> query3 = em.createQuery(
  "select p from Player p where p.team.id = :team and p.salary > :minSalary , Player.class);
query3.setParameter("team", team);
query3.setParameter("minSalary", 1000);
List<Player> players3 = query3.getResultList();
```

### 3-1. 비교 연산자
| 연산자                | 설명                              |
|--------------------|---------------------------------|
| =                  | 값이 같은지 비교                       |
| <>                 | 값이 다른지 비교                       |
| `>,>=,<,<=`          | 값의 크기 비교                        |
| between            | 값이 사이에 포함되는지 비교                 |
| in, not in         | 지정한 목록에 값이 존재하는지 또는 존재하지 않는지 비교 |
| like, not like     | 지정한 문자열을 포함하는지 검사               |
| is null, is not null | 값이 null인지 또는 null이 아닌지          |


### 3-2. 콜렉션 비교
특정 엔티티나 값이 콜렉션에 속해있는지 검사하고 싶다면 member of 연산자나 not member of 연산자를 사용하면 된다.

```java
Player player = em.find(Player.class, "P1");
TypedQuery<Team> query = em.createQuery(
  "select t from Team t where :player member of t.players order by t.name", Team.class);
query.setParameter("player", player);
List<Team> teams = query.getResultList();
```
```
# 실제 query 실행
select t.id, t.name
from Team
where ? in (select p.player_id from Player p where t.id = p.team.id)
order by t.name
```
is empty, is not empty를 사용하면 엔티티 콜렉션에 대해 콜렉션이 비어있는지 비교할 수 있다.

## 3-3. exists, all, any
특정 값이 존재하는지 검사하고 싶을 때 exists, all, any 중 하나를 사용한다.

* exists : 특정 값이 존재 할 때
* not exists : 특정 값이 존재하지 않을 때
* all : 서브 쿼리 결과가 조건을 모두 충족하는지 검사
* any : 서브 쿼리 결과가 조건을 충족하는 대상중 하나 이상 충족하는지 검사

## 04. 페이징 처리
Query, TypedQuery를 사용하면 간단하게 페이징 처리를 할 수 있다.

```java
TypedQuery<Review> query = em.createQuery("select r from Review r where r.hotel.id = :hotelId order by r.id desc", Review.class);
query.setParameter("hotelId", "H-001");
query.setFirstResult(10);   //조회할 첫 번째 결과의 위치 지정
query.setMaxResults(5);     //조회할 최대 갯수
List<Review> reivews = query.getResultLiat();
```

## 05. 지정 속성 조회
### 5-1. 배열로 조회하기
```java
TypedQuery<Object[]> query = em.createQuery("select p.id, p.name, p.salary from Player p", Object[].class);
List<Object[]> rows = query.getResultList();
for(Object[] row: rows) {
  String id = (String)row[0];
  String name = (String)row[1];
  int salary = (int)row[2];
  //...
}
```
select 절에서 선택한 대상이 두 개 이상일 때 결과 타입은 Object 배열이다. Object 배열은 순서대로 값을 보관하기 때문에 배열의 각 데이터를 사용할 때는 위 코드처럼 해당 타입으로 알맞게 변환해주어야 한다.

### 5-2. 특정 객체로 조회하기
```java
public class IdName{
  private String id;
  private String name;

  public IdName(String id, String name) {
    this.id = id;
    this.name = name;
  }

  public String getId() {
    return id;
  }

  public String getName() {
    return name;
  }
}
```
```java
//생성자를 이용해서 결과 객체를 생성한다.
TypedQuery<IdName> query = em.createQuery("select new com.common.IdName(p.id, p.name) from Player p", IdName.class);
List<IdName> rows = query.getResultList();
```

## 06. 한 개 행 조회
결과가 여러개인 경우 getResultList() 메서드를 이용했다. 결과가 정확하게 한 행인 경우에는 getResultList() 대신에 `getSingleResult()` 메서드를 사용할 수 있다.

```java
TypedQuery<Long> query = em.createQuery("select count(p) from Player p", Long.class);
Long count = query.getSingleResult();
```
getSingleResult() 사용시 주의할 점은 __결과가 반드시 1개여야 한다는 것이다.__ 결과가 없거나 두 개 이상일 경우 exception이 발생한다.
