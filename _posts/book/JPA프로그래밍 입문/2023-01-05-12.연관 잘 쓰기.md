---
title: 12. 연관 잘 쓰기
date: 2023-01-05 20:24:23 +0900
categories: [BOOK, JPA 프로그래밍 입문]
tags: [sql]  # TAG는 반드시 소문자로 이루어져야함!
---

## 01. 연관의 복잡성
### 1.1 로딩 설정의 어려움
```java
Order order = em.find(Order.class, orderId);
List<OrderLine> orderLines = order.getOrderLines();
for(OrderLine ol: orderLines) {
  Content content = ol.getProduct().getContent();
  System.out.println(content.getTitle() + "" + content.getCast());
}

```
위 코드는 Order 엔티티에서 시작해서 OrderLine, Product, Content를 접근하고 있다. 모든 연관을 즉시 로딩으로 설정했다면 Order를 로딩하는 시점에 OrderLine, Product, Content를 로딩하기 위한 쿼리도 함께 실행할 것이다. 그렇다고 해서 지연 로딩과 즉시 로딩을 적절하게 섞어 쓰기도 쉽지 않다. 상황에 따라 필요한 연관 객체가 다를 수 있어 특정 연관을 지연 로딩이나 즉시 로딩으로 한정할 수 없다.

### 1.2 편리한 객체 탐색과 높은 결합도
모든 엔티티를 연관으로 연결하면 객체 탐색을 통해 쉽게 원하는 객체에 접근할 수 있다.

```java
//객체들이 연관으로 연결되어 있으면 연관된 객체의 데이터를 쉽게 변경할 수 있다.
public class Order {
  private User orderer;

  public void changeShippingAddress(Address newShippingAddress, boolean useUserAddress) {
    this.shippingAddress = newShippingAddress;
    if(useUserAddress) {
      //연관된 User 데이터를 변경
      orderer.setAddress(newShippingAddress);
    }
  }
}
```
이렇게 한 엔티티에서 다른 엔티티의 상태를 변경하는 기능을 실행하면 엔티티가 서로 강하게 엮이게 되면서 서로 수정을 어렵게 만드는 원인이 될 수 있다.

## 02. 연관 범위 한정과 식별자를 통한 간접 참조
엔티티 간의 참조가 많아질수록 한 엔티티의 기능을 변경할 때 여러 엔티티를 함께 수정해야 할 가능성이 커진다. 이는 코드 변경을 어렵게 만드는 원인이 될 수 있다. 그러기 위해 다음의 방법을 적용한다.
* 연관 범위를 도메인을 기준으로 한정
* 도메인을 넘어서는 엔티티 간에는 식별자를 이용한 간접 참조

<img src="/assets/img/posting_img/book/JPA%20프로그래밍%20입문/연관을정리한구조.jpeg" width="700px">

위 그림을 보면 특정 영역 안에서는 연관을 이용해 직접 참조를 유지했지만, 영역을 벗어나는 관계에 대해서는 식별자를 이용해서 간접적으로 참조했다.

식별자를 통한 간접 참조 방식을 사용하면 식별자로 연관된 엔티티를 검색하는 과정이 추가되기 때문에 다소 코드가 길어진다. 하지만 앞선 로딩 설정의 어려움과 엔티티 간의 결합도 증가를 완화할 수 있다.

## 03. 상태 변경 관련 기능과 조회 관련 기능
연관을 한정해서 사용하면 설정이나 코드 복잡도가 줄어드는 장점이 있다. 하지만 데이터 조회시 여러 엔티티를 직접 조회해야 하는 불편함도 있다. 이런 불편함을 해결하는 방법으로 상태를 변경하는 기능과 조회하는 기능을 분래해서 생각하는 것이다.

데이터를 새로 생성하거나 수정하거나 삭제하는 상태 변경 기능은 한두 개의 엔티티만 로딩하기 때문에 식별자로 연관된 엔티티를 직접 로딩해야하는 불편함이 크지 않다.

조회 관련 기느은 한 개 이상의 엔티티를 함께 조회하는 경우가 많다. 이렇게 여러 엔티티의 데이터를 조합해야 하는 조회 기능은 조회 기능애 맞는 모델을 따로 구현하는 것을 고려해보자

```java
//예) 주문 목록 > Order + OrderLine + Product
public class OrderSummary {
  private String id;
  private String ordererName;
  private Timestamp orderDate;
  private int totalAmounts;
  private String firstProductName;
  private String firstProductId;

  //...
}
```
도메인이 커질수록 한 개의 모델로 상태 변경 기능과 조회 기능을 구현하기 어려워진다. 로딩 방식의 문제뿐 아니라 상태 변경 시점과 조회 시점에 필요한 데이터가 다르기 때문이다.

조회 시점에 필요한 데이터와 변경 시점에 다루는 데이터의 차이가 클수록 조회 전용 모델을 별도로 만들 것을 고려해 봐야 한다.

## 04. 식별자를 공유하는 1:1 연관이 엔티티와 밸류 관계인지 확인
모든 테이블을 엔티티로 매핑하는 것은 모델의 의미를 약화시킬 수 있다. 한 도메인 영역세 속하면서 식별자 공유 방식으로 1:1 연관을 맺는 두 엔티티가 동일한 라이프사이클을 갖게 된다. 그렇게 되면 이 관계는 두 엔티티의 1:1 연관이 아닌 엔티티와 밸류 관계일 가능성이 크다.

```java
//1:1 연관
@Entity
public class Appeal {
  @Id
  private String id;

  @OneToOne(mapperdBy="appeal")
  private AppealStatus status;
}

@Entity
@Table(name="appeal_atatus")
public class AppealStatus {
  @Id
  priavate String id;

  @OneToOne
  @primaryKeyColumn
  priavate Appeal appeal;

  //...
}
```

```java
//엔티티-밸류 관계
@Entity
SecondaryTable(
  name="appeal_status",
  pkJoinColumns=@PrimaryKeyJoinColumn(
        name="id",
        referencedColumnName="id")
)
public class Appeal{
  @Id
  private String id;

  @Embedded
  private AppealStatus status;
  //...
}

@Embeddedable
public class AppealStatus{
  //...
}
```
