---
title: 9. 값의 콜렉션 매핑
date: 2022-12-30 00:01:12 +0900
categories: [BOOK, JPA 프로그래밍 입문]
tags: [sql]  # TAG는 반드시 소문자로 이루어져야함!
---

## 01. 값 콜렉션
JPA는 String, Int와 같은 단순 값에 대한 콜렉션을 지원한다.

또 @Embeddable로 설정한 밸류 값에 대한 콜렉션도 매핑할 수 있다. (List, Set, Map, Collection)

## 02. 단순 값 List 매핑
유적지 관광객을 위한 하루 이동 경로 목록을 제공하기 위한 모델을 예로 들면 관광 경로 정보를 담기 위한 클래스 Itinerary 클래스로 표현할 수 있다. 이 클래스에는 차례대로 이동할 관광지 목록을 저장하기 위해 `List<String>` 타입인 sites 속성을 정의하고 있다.

그리고 위 클래스를 DB에 매핑하려면 다음과 같이 두 개의 테이블을 사용한다.

<img src="/assets/img/posting_img/book/JPA%20프로그래밍%20입문/Itinerary.jpeg" width="700px">

Itinerary 클래스와 두 테이블 사이의 매핑은 @ElementCollection 애노테이션을 사용한다.

```java
@Entity
public class Itinerary {
    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String description;

    @ElementCollection  //값 콜렉션임을 지정
    @CollectionTable(
        name="itinerary_site",   //콜렉션의 값은 itinerary_site 테이블에 저장
        joinColumns=@joinColumn(name="itinerary_id"))   //컬렉션이 속할 엔티티 식별자 컬럼 지정
    @OrderColumn(name="list_idx")       //리스트의 인덱스 값 컬럼 지정
    @Column(name="site")
    private List<String> sites;

    //...

    public void changeSites(List<String> sites) {
        this.sites = sites;
    }

    public void clearSites() {
        sites.clear();
    }
}
```

### 2.1 List의 저장과 조회
```java
em.getTransaction().begin();
List<String> sites = Arrays.asList("경복궁", "청계천", "명동", "인사동");
Itinerary itinerary  = new Itinerary("광화문-종로 인근", "설명", sites);
em.persist(itinerary);
em.getTransaction().commit();
```
위 코드를 실행한 쿼리 결과를 보면 sites 속성에 저장된 각 값의 인덱스 값을 list_idx 컬럼에 저장하는 것을 볼 수 있다.

@ElementCollection 애노테이션의 fetch 속성은 기본값이 LAZY라서 sites.get(0) 코드를 실행하는 시점에 데이터를 읽어온다.

### 2.2 List 변경
Itinerary 클래스는 다음의 두 가지 방법으로 sites 콜렉션의 값을 변경할 수 있다.
* changeSites() 메서드를 이용해서 sites 속성에 새로운 컬렉션을 할당 > 실행한 쿼리를 보면 delete 쿼리를 이용해 기존 컬렉션 데이터를 삭제한 후 insert 쿼리를 이용해서 새로운 컬렉션의 데이터를 추가한다.
* getSites() 메서드로 구한 컬렉션을 수정 > 기존 항목을 변경하면 update, 새로 추가하면 insert 쿼리를 실행한다.

### 2.3 List 전체 삭제
```java
em.getTransaction().begin();
Itinerary itinerary = em.find(Itinerary.class, 1L);
itinerary.cleatSites();  //sites.clear()
em.getTransaction().commit();
```
컬렉션의 데이터를 삭제하려면 clear() 메서드를 사용하거나 null을 할당하는 방법이 있다.

## 03. 밸류 객체 List 매핑
Itinerary 클래스의 이동경로 저장시 단순 장소 이름뿐만 아니라 관광 시간도 포함하려할때 String 대신 다음의 밸류 타입을 사용해야 한다.

```java
public class SiteInfo {
    private String site;
    private int time;
    //...
}

public class itinerary {
    //...

    @ElementCollection
    @CollectionTable(
        name="itinerary_site",
        joinColumns=@joinColumn(name="itinerary_id"))
    @OrderColumn(name="list_idx")
    //@Column이 없어진거 말고는 설정이 똑같다
    private List<SiteInfo> sites;

}
```
동작 방식은 단순 값 리스트의 매핑과 동일하다.

그리고 @ElementCollection로 매핑한 클래스의 컬럼 이름 대신 다른 컬럼 이름을 사용하고 싶다면 @AttrubuteOverride 애노테이션이나 @AttributeOverrides 애노테이션을 사용하면 된다.

## 04 List 요소와 null
```java
em.getTransaction().begin();
Itinerary itinerary = em.find(Itinerary.class, 1L);
itinerary.getSites().set(1, null);
em.getTransaction().commit();
```

List의 전체 길이가 4라고 할 때 중간에 인덱스 1을 삭제하면 테이블에 인텍스 1에 해당하는 데이터가 null로 할당된다.

```java
Itinerary itinerary = em.find(Itinerary.class, 1L);
List<String> sites = itinerary.getSites();
sites.size() == 4;      //true
sites.get(1) == null;   //true
```

## 05. 단순 값 Set 매핑
집합은 중복을 허용하지 않는 컬렉션이다. 예) 사용자마다 관심사를 위한 키워드를 등록하는 경우

```java
public class User {
    private String email;

    //...

    private Set<String> keywords = new HashSet<>();

    //getter, setter
}

```

```java
Set<String> keywords = new HashSet<>();
keywords.add("역사");
keywords.add("유적");
keywords.add("전통음식");
user.setKeywords(keywords)
```

|user_email|keyword|
|----------|-------|
|user@email.com|역사|
|user@email.com|유적|
|user@email.com|전통음식|

```java
@Entity
@Table(name="user")
public class User {

    @Id@Basic
    private String email;
    @Basic private String name;

    @Basic @Temporal(TemporalType.TIMESTAMP)
    @Column(name="create_date")
    private Date createDate;

    @ElemtentCollection
    @CollectionTable(
        name="user_keyword",
        joinColumns=@JoinColumn(name="user_email"))
    @Column(name="keyword")
    private Set<String> keywords = new HashSet<>();

    //…
}

```
@OrderColumn 애노테이션을 사용하지 않는 것을 제외하면 List 타입의 단순 값을 매핑할 때와 같다
