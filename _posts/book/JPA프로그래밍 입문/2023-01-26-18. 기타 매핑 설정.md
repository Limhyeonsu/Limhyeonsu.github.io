---
title: 18. 기타 매핑 설정
date: 2023-01-26 22:42:21 +0900
categories: [BOOK, JPA 프로그래밍 입문]
tags: [jpa, sql]  # TAG는 반드시 소문자로 이루어져야함!
---

## 01. 상속 매핑
예) 시스템에 일반 이슈, 방문 예약, 민원의 세 가지 이슈 종류가 있다고 할 때 이 이슈 타입을 상속을 이용해서 설계할 수 있다.

<img src="/assets/img/posting_img/book/JPA%20프로그래밍%20입문/이슈를상속으로구현.jpeg" width="700px">

JPA에서는 같은 클래스 계층을 테이블과 매핑하는 다음과 같은 방식을 지원한다.

### 1-1. 클래스 계층을 한 개 테이블로 매핑
상속 관계의 엔티티를 매핑하는 가장 쉬운 방법은 클래스 계층을 한 테이블에 매핑하는 것이다. 한 테이블에 계층의 전체 클래스를 매핑하려면 매핑 대상 클래스를 식별할 수 있어야 한다. 대상 클래스를 구분하기 위해 타입 식별 컬럼을 추가로 필요로 한다.

<img src="/assets/img/posting_img/book/JPA%20프로그래밍%20입문/클래스계층.jpeg" width="700px">

```java
@Entity
@Table(name="issue")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE) //상속 매핑 방식 설정, SINGLE_TABLE : 한 테이블로 상속 계층을 매핑한다.
@DiscriminatorColumn(name="issue_type") //타입 식별값을 저장할 컬럼 지정
@DiscriminatorValue("IS") //Issue 타입을 위한 식별 값을 지정
public class Issue {
  @Id
  @GeneratedValue(strategy=GenerationType.IDENTITY)
  private Long id;

  @Temporal(TemporalType.TIMESTAMP)
  @Column(name="issue_date")
  private Date issueDate;

  @Column(name="customer_name")
  private String customerName;

  @Column(name="customer_cp")
  private String customerCp;
  private String content;
  private boolean closed;
}
```

```java
@Entity
@DiscriminatorValue("VR")
public class VisitReservation extends Issue {
  @Column(name="assignee_emp_id")
  private String assigneeEngineerId;

  @Temporal(TemporalType.TIMESTAMP)
  @Column(name="schedule_date")
  private Date scheduleDate;

}
```

```java
@Entity
@DiscriminatorValue("AP")
public class Appeal extends Issue {
  private String response;

}
```

위 엔티티를 저장하는 save()를 사용하면 @DiscriminatorValue로 지정한 값을 issue_type 컬럼의 값으로 사용한다.

단일 객체를 조회할 때는 상속 계층에 있는 타입중 알맞은 타입을 지정해서 조회하면 된다. `em.find(Appeal.class, id);` 로 하면 where 조건절에 issue_type = 'AP'가 자동으로 들어간다.

### 1-2. 계층의 클래스마다 테이블로 매핑
예) 첨부 파일 정보를 표현하는 모델이 있을 때 처음 요구사항은 고정된 폴더에 파일을 저장하는 방식이였다가 시간이 지나 폴더를 고정하지 않고 파일을 저장할 경로를 지정하는 방식이 추가되었다. 그리고 클라우드에 올린 파일 정보를 추가할 수 있는 방식도 추가되었다.

<img src="/assets/img/posting_img/book/JPA%20프로그래밍%20입문/첨부파일모델.jpeg" width="300px">
<img src="/assets/img/posting_img/book/JPA%20프로그래밍%20입문/계층클래스테이블매핑.jpeg" width="300px">

눈여겨볼 점은 하위 클래스에 해당하는 테이블은 상위 클래스에 해당하는 테이블의 주요키를 공유한다는 점이다.

```java
@Entity
@Table(name="attach_file")
@Inheritance(strategy=InheritanceType.JOINED) //JOINED : 계층 클래스마다 테이블을 사용하면 각 테이블을 조인해서 필요한 데이터를 조회
public class AttachFile {
  @Id
  private String id;
  private String name;

  @Column(name="upload_date")
  @Temporal(TemporalType.TIMESTAMP)
  private Date uploadDate;
}
```

```java
@Entity
@Table(name="local_file")
public class LocalFile extends AttachFile {
  private String path;
}
```

```java
@Entity
@Table(name="cloud_file")
public class CloudFile extends AttachFile {
  private String provider;
  private String url;
}
```

계층마다 테이블을 매핑하기 때문에 엔티티를 저장하면, 엔티티 타입에 따라 매핑된 모든 테이블에 데이터를 나눠서 저장한다. 엔티티를 조회할 때에는 엔티티 타입에 따라 사용하는 쿼리가 달라진다. `em.find(Attach.class, "F001");`로 실행해 보면 attach_file 테이블 뿐만 아니라 local_file 테이블과 cloud_file 테이블을 외부 조인을 이용해서 함께 조회한다.
