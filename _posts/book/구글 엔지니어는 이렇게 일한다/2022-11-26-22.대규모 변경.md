---
title: 22. 대규모 변경
date: 2022-11-26 23:15:03 +0900
categories: [BOOK, 구글 엔지니어는 이렇게 일한다]
tags: [software_engineering]  # TAG는 반드시 소문자로 이루어져야함!
---

## 22.1 대규모 변경이란?
우리 경험상 대규보 변경(LSC)는 논리적으로는 연관되어 있으나 현실적인 한계 때문에 원자적으로 서브밋할 수 없는 변경들의 집합이다.

구글의 경우 LSC는 거의 항상 자동화 도구를 이용해 생성한다. LSC를 만드는 이유는 다양하지만 LSC로 인해 생성되는 변경들은 대체로 다음과 같다.
* 코드베이스 전반을 훑는 분석도구로 찾은 공통 안티패턴 청소
* 폐기 대상 API 호출 대체
* 저수준 인프라 개선사항 활성화
* 사용자들을 옛 시스템에서 새로운 시스템으로 마이그레이션

LSC를 촉발하는 원인은 다양하다. 더 효율적인 프로그래밍 이디엄을 적용하거나 내부 라이브러리의 인터페이스가 바뀌었을 수 있고 잠재해 있던 문제들을 신버전 컴파일러가 찾아줘서 모두 해결해야 할 수도 있다. 구글에서 수행하는 LSC의 대다수는 기능은 거의 변경하지 않는다. 주로 명확성, 최적화, 미래 호환성 개선이 목표이다.

## 22.2 누가 대규모 변경을 처리하나?
구글에서는 LSC의 상당 비중을 인프라팀이 수행한다. 하지만 LSC 도구들과 지원 자원들은 누구나 이용할 수 있다. 이 일을 인프라팀이 수행하는 이유는
1. 하부 시스템을 구축하고 관리하는 인프라팀들은 그 시스템을 활용하는 수만 개의 참조를 수정하는 데 필요한 도메인 지식 역시 갖추고 있다. 인프라팀이 이미 잘 아는 전문 지식을 다른 모든 팀에게 새로 배우도록 시키는 것도 비효율적이다.
2. 합당한 보상 없이 할 일만 늘어나는 상황을 좋아할 사람은 없다. 반드시 마이그레이션해야 할 만큼 새로운 시스템이 중요하다면 비용을 조직 차원에서 부담하는 게 맞다.
3. 대규모로 변경해야 할 시스템을 소유한 팀이 주도해야 변경을 완료하는 데 유리하다.


## 22.3 원자적 변경을 가로막는 원인
### 22.3.1 기술적 한계
대부분의 버전 관리 시스템에서는 기능을 수행하는 비용이 변경의 크기에 비례해 커진다. 파일 수천 개를 원자적으로 커밋하기에는 메모리나 프로세싱 능력이 부족할 수 있다. 중앙집중형 버전 관리 시스템에서는 커밋 중에는 다른 사용자가 쓰기 작업을 하지 못한다. 다시 말해 거대한 커밋은 다른 사용자들의 일을 멈춰세운다.

### 22.3.2 병합 충돌
변경의 규모가 커질수록 자연스럽게 병합 시 충돌이 생길 가능성이 커진다. 버전 관리 시스템은 변경하려는 파일보다 중앙 리포지터리에 있는 파일의 버전이 높다면 수동으로 업데이트후 병합하는 기능을 제공한다. 이 일을 완벽하게 처리해주는 시스템은 없다.

### 22.3.3 유령의 묘지
유령의 묘지란 너무 오래되고 둔하고 복잡해서 아무도 손대려 하지 않는 시스템을 뜻한다.

구글은 충실한 테스트가 유령의 묘지 퇴출에 아주 효과적임을 깨달았다. 소프트웨어가 철저하게 테스트된다면 변경해도 이상이 생기지 않으리라는 믿음이 생긴다.

### 22.3.4 이질성
LSC가 가능하려면 LSC에 수반되는 작업 대부분을 사람이 아니라 컴퓨터가 처리해줘야 한다. 사람과 달리 컴퓨터는 모호한 일은 잘 처리하지 못한다. 그래서 컴퓨터가 변경 코드를 정확한 위치에 올바르게 반영하려면 환경이 일관되어야 한다.

### 22.3.5 테스트
모든 변경은 테스트되어야 한다. 하지만 변경의 덩치가 커지면 제대로 테스트하기가 훨씬 어렵다. 구글의 CI 시스템은 변경이 직접적으로 영향을 주는 테스트뿐 아니라 변경된 파일들을 간접적으로 이용하는 코드의 테스트도 모두 수행한다.

작고 독립적인 변경은 검증하기가 쉽다. 수정된 파일이 25개뿐이라면 근본 원인을 어렵지 않게 찾을 수 있다. 하지만 파일 10,000개가 수정됐다면 쉽지 않다.

사례) 595~596p

### 22.3.6 코드 리뷰
모든 변경은 서브밋하기 전에 리뷰를 거쳐야 한다. LSC도 예외가 아니다. 거대한 커밋을 검토하기란 지루하고 번거롭고 오류가 스며들기 쉽다.

사례) 597p
