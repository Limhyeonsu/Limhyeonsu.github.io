---
title: 13. 테스트 대역
date: 2022-11-07 17:41:18 +0900
categories: [BOOK, 구글 엔지니어는 이렇게 일한다]
tags: [software_engineering]  # TAG는 반드시 소문자로 이루어져야함!
---

예를 들어 외부 서버에 요청을 보내고 응답을 받아 데이터베이스에 저장하는 함수를 검증하는 경우 테스트 몇 개만 작성하면 충분할 것이다. 하지만 이런 테스트를 수백, 수천개 작성하게 된다면 전체를 한 번에 수행하는데만 몇 시간씩 걸리고 예기치 못한 네트워크 실패나 테스트들끼리 테이터를 덮어쓰는 등의 일이 발생하여 테스트 스위트가 불규칙적으로 실패하기 시작할 것이다.

이런 상황에서는 테스트 대역이 아주 유용하다. `테스트 대역은 실제 구현 대신 사용할 수 있는 객체나 함수를 말한다.`

아마도 가장 직관적인 유형의 테스트 대역은 실제와 비슷하게 동작하되 더 간단하게 구현한 객체일 것이다. (예. 인메모리 데이터베이스[휘발성 메모리])

## 13.1 테스트 대역이 소프트웨어 개발에 미치는 영향
* 테스트 용이성 - 코드베이스가 테스트하기 쉽도록 설계되어 있어야 한다. 그래야 테스트에서 실제 구현을 테스트 대역으로 교체할 수 있다.
* 적용 가능성 - 테스트 대역을 제대로 활용하면 엔지니어링 속도가 크게 개선되겠지만 잘못 사용하면 오히려 깨지기 쉽고 복잡하고 효율도 나쁜 테스트로 전락한다.
* 충실성 - 테스트 대역이 실제 구현의 행위와 얼마나 유사하냐를 말한다.

## 13.2 테스트 대역 @구글
구글은 여러 경험들이 쌓여 테스트 대역을 올바르게 사용하는 관례를 발전시켰다. 어렵게 깨우친 교휸 하나로 테스트 대역을 쉽게 만들어주는 모의 객체 프레임워크를 과용하면 위험하다는 것이다. 모의 객체 프레임워크를 처음 도입했을 때는 만능 요술램프처럼 보였으나 몇 해가 지나자 커다란 대가를 치르게 되었다. 테스트를 작성하기는 쉬웠지만 버그는 잘 찾아내지 못했고 끊임없이 보수해야 했다.

그래서 오늘날에는 많은 엔지니어가 모의 객체 프레임워크를 피하고 실제에 더 가까운 테스트를 작성한다.

## 13.3 기본 개념
### 13.3.1 테스트 대역 예
```java
//예) 신용카드 서비스
class PaymentProcessor {
  private CreditCardService creditCardService;
  ....
  boolean makePayment(CreditCard creditCard, Money amount) {
    if(creditCard.isExpired()) {return false;}
    boolean success = creditCardService.chargeCreditCard(creditCard, amount);
    return success;
  }
}

//기초적인 테스트 대역
class TestDoubleCreditCardService implements CreditCardService {
  @Override
  public boolean chargeCreditCard(CreditCard creditCard, Money amount) {
    return true;
  }
}

//테스트 대역 적용
@Test
public void cardIsExpired_returnFalse() {
  boolean success = paymentProcessor.makePayment(EXPIRED_CARD, AMOUNT);
  assertThat(success).isFalse();
}
```

### 13.3.2 이어주기
단위 테스트를 고려해 짜인 코드를 테스트하기 쉽다라고 말한다. 그리고 이어주기는 제품 코드 차원에서 테스트 대역을 활용할 수 있는 길을 터줘서 테스트하기 쉽게끔 만들어주는 걸 뜻한다. 대표적인 이어주기 기술로는 `의존성 주입`이 있다.

```java
class PaymentProcessor {
  private CreditCardService creditCardService;

  //생성자에서 CreditCardService의 인스턴스를 직접 생성하지 않고 대신 인수로 건네 받는다.
  PaymentProcessor(CreditCardService creditCardService) {
    this.creditCardService = creditCardService;
  }
  ...
}
```
```java
//CreditCardService 인스턴스를 생성할 책임은 생성자를 호출하는 측에 주어진다. CreditCardService구현을 넘길수도 있고 다음과 같이 테스트 대역을 넘길 수 있다.
PaymentProcessor paymentProcessor = new PaymentProcessor(new TestDoubleCreditCardService());
```

### 13.3.3 모의 객체 프레임워크
모의 객체 프레임워크는 테스트 대역을 쉽게 만들어주는 소프트웨어 라이브러리이다. 즉 객체를 대역으로 대체할 수 있게 해준다. 모의 객체는 구체적인 동작 방식을 테스트가 지정할 수 있는 테스트 대역을 말한다. 업계에서 많이 쓰이는 프로그래밍 언어라면 대부분 모의 객체 프레임워크가 존재한다. (예. java의 mokito)

## 13.4 테스트 대역 활용 기법
### 13.4.1 속이기(가짜 객체)
가짜 객체는 실제 구현과 비슷하게 동작하도록 가볍게 구현한 대역이다. 인메모리 데이터베이스가 좋은 예이다.
```java
//가짜 객체는 빠르고 쉽게 만들 수 있다.
AuthorizationService fakeAuthorizationService = new FakeAuthorizationService();
AccessManager accessManager = new AccessManager(fakeAuthorizationService);

//모르는 사용자의 ID로는 접근을 불허한다.
asserFalse(accessManager.userHasAccess(USER_ID));

//사용자 ID를 인증 서비스에 등록한 다음에는 접근을 허용한다.
fakeAuthorizationService.addAuthorizedUser(new User(USER_ID));
assertThat(accessManager.userHasAccess(USER_ID)).isTrue();
```

### 13.4.2 뭉개기(스텁)
스텁은 원래는 없던 행위를 부여하는 과정을 말한다. 예) 대상 함수가 반환할 값을 지정한다고 하면, 이를 반환값을 뭉갠다(스텁한다)라고 말한다.

```java
//모의 객체 프레임워크로 생성한 테스트 대역을 건낸다.
AccessManager accessManager = new AccessManager(mockAuthorizationService);

//USER_ID에 해당하는 사용자를 찾지 못하면(null을 반환하면) 접근을 불허한다.
when(mockAuthorizationService.lookupUser(USER_ID)).thenReturn(null);
assertThat(accessManager.userHasAccess(USER_ID)).isFalse();

//null이 아니면 접근을 허용한다.
when(mockAuthorizationService.lookupUser(USER_ID)).thenReturn(USER);
assertThat(accessManager.userHasAccess(USER_ID)).isTrue();
```

### 13.4.3 상호작용 테스트하기
상호작용 테스트란 대상 함수를 실제로 호출하지 않고도 그 함수가 어떻게 호출되는지를 검증하는 기법이다.

스텁과 비슷하게 상호작용 테스트에도 주로 모의 객체 프레임워크를 활용한다.
