---
title: 12. 단위 테스트
date: 2022-11-04 22:01:18 +0900
categories: [BOOK, 구글 엔지니어는 이렇게 일한다]
tags: [software_engineering]  # TAG는 반드시 소문자로 이루어져야함!
---

구글에서 말하는 단위 테스트는 단일 클래스나 메서드처럼 범위가 상대적으로 좁은 테스트를 뜻한다.

테스트의 가장 중요한 목적은 버그 예방이다. 그 다음으로는 엔지니어의 생산성 개선이 있다. 범위가 넓은 테스트와 비교했을 때 단위 테스트는 생산성을 끌어올리는 훌륭한 수단이 될 수 있다.
* 단위 테스트는 대체로 작은 테스트에 속한다. 작은 테스트는 빠르고, 결정적이여서 수시로 수행하여 즉각적인 피드백을 받을 수 있다.
* 단위 테스트는 작성하기 쉽다.
* 빠르게 작성할 수 있어 테스트 커버리지를 높이기 좋다. 기존 동작을 망가뜨리지 않으리라는 확신 속에서 코드를 변경할 수 있다.
* 실패시 원인을 파악하기 쉽다.
* 대상 시스템의 사용법과 의도한 동작 방식을 알려주는 문서자료 혹은 예제 코드 역할을 해준다.

단위 테스트는 일상에서 비중이 크기 때문에 구글은 테스트 유지보수성을 상당히 중시한다. 유지보수하기 쉬운 테스트란 한 번 작성해두면 실패하지 않는 한 엔지니어가 신경 쓸 필요없고, 실패한다면 원인을 바로 알 수 있는 진짜 버그를 찾았다는 뜻이다.

## 12.1 유지보수하기 쉬워야 한다.
주변에서 흔히 목격되는 테스트 작성의 문제의 원인으로
1. 버그도 없고 자신의 검증 대상과 관련없는 변경 때문에 실패하는 깨지기 쉬운 테스트들이 도사리고 있다.
2. 무엇이 잘못되어 실패했는지 어떻게 고쳐야 하는지 파악하기 어려운 불명확한 테스트들이다.

## 12.2 깨지기 쉬운 테스트 예방하기
깨지기 쉬운 테스트란 실제로는 버그가 없음에도, 검증 대상 코드와는 관련조차 없는 변경 때문에 실패하는 테스트를 말한다. 이러한 테스트는 엔지니어가 직접 진단하고 수정해야 한다.

### 12.2.1 변하지 않는 테스트로 만들기 위해 노력하자
기본적인 변경 유형은 다음과 같다.
* 순수 리팩터링 - 외부 인터페이스는 놔두고 내부만 리팩터링 하는 경우 테스트는 변경되지 않아야 한다. 리팩터링 과정에서 테스트를 변경해야 한다면 원인은 1)시스템의 행위가 달라졌다, 2)테스트의 추상화 수준이 적절하지 않았다.
* 새로운 기능 추가 - 새로운 기능이나 행위를 추가할 때는 기존 행위들에 영향을 주지 않아야 한다. 기존 테스트를 변경해야 한다면 해당 테스트가 검증하는 기능에 의도치 않은 영향을 주었거나 테스트 자체에 문제가 있다는 뜻이다.
* 버그 수정 - 버그 수정은 새로운 기능 추가와 비슷하다.
* 행위 변경 - 시스템의 기존 행위를 변경하는 경우로 기존 테스트 역시 변경되어야 한다.

`리팩터링, 새 기능 추가, 버그수정`시에는 기존 테스트를 손볼 일이 없어야 한다.

### 12.2.2 공개 API를 이용해 테스트하자
테스트가 시스템을 사용자와 똑같은 방식으로 사용하게 하면 테스트가 실패한 경우 사용자도 똑같은 문제를 겪는다. 그렇게 되면 테스트가 사용자에게 유용한 예제 코드와 문서자료가 되어준다는 이점을 얻을 수 있다.

어디까지가 공개 API냐가 항상 명확한 것은 아니며 이는 단위 테스트에서 말하는 단위가 무엇이냐를 규정하는 핵심적인 질문으로 이어진다. 이런 맥락에서 공개 API란 이런 단위의 코드 소유자가 서드파티에 노출한 API를 뜻한다.(??)

어디까지가 공개 API인가를 정하는 일에 정답은 없지만 경험법칙으로 다음과 같이 있다.
* 소수의 다른 클래스를 보조하는 용도가 다인 메서드나 클래스는 직접 테스트하지 말고 이들을 보조하는 클래스를 통해 우회적으로 테스트해야 한다.
* 소유자의 통제 없이 누구든 접근할 수 있게 설계된 패키지나 클래스라면 예외없이 직접 테스트해야하는 단위로 취급해야 한다.
* 소유자만이 접근할 수 있지만 다방면으로 유용한 기능을 제공하도록 설계된 패키지나 클래스 역시 직접 테스트해야 하는 단위로 본다.

### 12.2.3 상호작용이 아니라 상태를 테스트하자
시스템이 기대한대로 동작하는지 검증하는 방법으로 다음과 같이 있다.
1. 상태 테스트 - 메서드 호출 후 시스템 자체를 관찰한다.
2. 상호작용 테스트 - 호출을 처리하는 과정에서 시스템이 다른 모듈들과 협력해서 기대한 일련의 동작을 수행하는지를 확인한다.

대체로 상호작용 테스트가 상태 테스트보다 깨지기 쉽다. 우리가 원하는 것은 결과가 무엇이냐 이지만, 상호작용 테스트는 결과에 도달하기까지 시스템이 어떻게 작동하냐를 확인하려 들기 때문이다.

잠재적으로 문제가 될 수 있는 상호작용 테스트가 만들어지는 가장 큰 원인은 바로 모의 객체 프레임워크에 지나치게 의존하기 때문이다. 모의 객체 프레임워크를 이용하면 테스트 대역을 만들기 쉽고, 이는 자신을 향한 모든 호출을 기록하고 검증할 수 있게 해준다. 이러한 편리함에 엔지니어들에게 깨지기 쉬운 상호작용 테스트를 만들도록 유혹한다.

그래서 우리는 진짜 객체가 빠르고 결정적이라면 진짜 객체를 사용해야 한다.

## 12.3 명확한 테스트 작성하기
깨지기 쉬운 요소를 제거했더라도 언젠가는 테스트가 실패한다. 실패하는 이유로는
1. 대상 시스템에 문제가 있거나 불완전한 경우
2. 테스트 자체에 결함이 있는 경우

테스트 실패의 이유를 얼마나 빠르게 찾느냐는 테스트 명확성에 달려있다. __명확한 테스트는 존재 이유와 실패 원인을 엔지니어가 곧바로 알아차릴 수 있는 테스트를 말한다.__ 명확한 테스트는 대상 시스템의 문서자료 역할을 해주고, 새로운 테스트를 작성하기 쉽게 도와주는 토대가 되어주는 등의 이점도 제공한다.

제품의 코드가 명확하지 않은 문제와는 다르다. 대체로 제품 코드는 해당 코드를 제거했을 때 어디에 문제가 생기는지나 호출 관계 등을 파헤쳐보면 비교적 쉽게 목적을 알아낼 수 있다. 반면 불명확한 테스트는 목적을 결코 알아내지 못할 가능성도 크다.

### 12.3.1 완전하고 간결하게 만들자
완전하고 간결성은 테스트를 명확하게 만드는 데 도움이 되는 거시적인 특성이다. 완전한 테스트는 결과에 도달하기까지의 논리를 읽는 이가 이해하는 데 필요한 모든 정보를 본문에 담고 있는 테스트를 말한다. 간결한 테스트는 코드가 산만하지 않고 관련 없는 정보는 포함하지 않는 테스트이다.

### 12.3.2 메서드가 아니라 행위를 테스트하
