---
title: 17. Code Search
date: 2022-11-17 18:36:22 +0900
categories: [BOOK, 구글 엔지니어는 이렇게 일한다]
tags: [software_engineering]  # TAG는 반드시 소문자로 이루어져야함!
---

Code Search는 구글이 이용하는 코드 브라우징 및 검색 도구로 프런트엔드 UI와 다양한 백엔드 요소로 이루어져 있다. 구글의 거대한 코드베이스를 감당하며 쉽게 확장할 수 있는 도구가 필요해서 만들어졌다.

Code Search는 대규모 코드를 읽고, 이해하고, 탐색하는 데 최적화되었다. 이를 위해 클라우드 기반 백엔드를 적극 활용하여 콘텐츠를 찾고 상호참조를 식별해낸다.

## 17.1 Code Search UI
Code Search UI의 핵심 요소는 당연히 검색창이다. 웹 검색처럼 타이핑을 시작하면 제안 기능이 작동하여 개발자가 파일, 심볼, 디렉터리로 빠르게 찾아 들어갈 수 있다. 검색 자체는 성능 좋은 파일에서 찾기 정도로 생각할 수 있다. 여기에 관련성 랭킹과 코드 강조, 범위 인식, 주석 및 문자열 인식 같은 개선이 더해져 있다.

또 Code Search는 Piper와도 통합되어 있어서 파일의 변경 이력도 보여준다. 파일의 이전 버전을 확인하고, 어디가 변경되었는지, 누가 작성했는지 확인할 수 있다.

## 17.2 구글 개발자가 Code Search를 이용하는 방법
Code Search와 비슷한 기능을 제공하는 다른 도구들도 있지만 구글 개발자들은 검색하고 파일 내용을 살펴보기 위해 무엇보다 코드를 이해하기 위해 Code Search UI를 적극 활용한다. 구글 개발자가 Code Search로 하려는 일은 코드에 대한 답을 찾고 코드의 의도를 분명하게 이해하는 것이다.

### 17.2.1 어디에?
Code Search는 두 가지 방식으로 도와준다.
1. 결과에 랭킹을 매겨 보여주고 표현력 좋은 질의어를 제공하는 것이다.
2. 결과를 동료과 공유하기 쉽게 해준다.

### 17.2.2 무엇을?
Code Search 사용량의 1/4은 전통적인 파일 브라우징에 쓰인다. 코드 베이스의 이 부분이 무슨 일을 하는가?라는 질문에 답하는 거라 볼 수 있다.

### 17.2.3 어떻게?
약 1/3을 차지하는 쓰임은 다른 사람이 어떻게 썼는지를 보는 것이다. 특정 문제에 이용할 라이브러리를 찾은 다음, 그 안에서 가장 적합한 구현을 선택하게 도와준다.

### 17.2.4 왜?
Code Search 사용량의 약 16%는 이 코드가 왜 추가되었나? 혹은 왜 이런식으로 동작하지?의 답을 찾는 것이다. 여기서 특정 시점에서 코드베이스의 정확한 상태를 찾고 탐색할 수 있는 기능이 중요하다.

### 17.2.5 누가 언제?
Code Search 사용량의 약 8%는 특정 코드 조각을 누가 언제 추가했는지를 찾는데 쓰인다. 이때는 버전 관리 시스템과 연계해 동작한다.

## 17.3 독립된 웹 도구로 만든 이유
다른 회사에서는 Code Search의 기능 대부분을 로컬 IDE에서 수행한다. 구글은 왜 독립된 도구로 만들었을까?

### 17.3.1 대규모 코드베이스 지원
구글의 코드베이스가 너무 거대해서 코드베이스 전체를 로컬로 복사하는 게 불가능하다. 로컬에서 감당할 수 있는 규모라 해도 로컬 검색과 상호참조 인텍스를 생성하느라 IDE 구동 시간이 느려져서 개발자 생산성을 떨어드린다. 반면 인덱스를 중앙에서 생성할 경우 한 번만 해두면 모두에게 혜택이 돌아온다. 변경된 코드가 서브밋되면 변경된 파일들의 인덱스만 갱신하면 되므로 전역 인덱스는 병렬로 따로 갱신할 수 있다.

상호참조 인덱스는 같은 방식으로 즉각 갱신할 수가 없다. 상호참조 인덱스를 만드는 데 매일 막대한 컴퓨팅 자원을 사용한다.

### 17.3.2 설정 없이 모든 코드 보기
Code Search의 웹 UI는 아무런 설정(프로젝트 설명, 빌드 환경) 없이도 이용할 수 있다. 어디에서 등장하는 코드든 상관없이 매우 쉽고 빠르게 찾아 검토할 수 있다.

### 17.3.3 기능 특화
IDE가 아니기 때문에 편집이 아닌 코드 탐색과 이해에 사용자 경험을 최적화할 수 있었다.

### 17.3.4 다른 도구에 통합
소스 코드 관련 정보를 회부에 제공하는 플랫폼으로 자리 잡았다. 예1) Code Search를 통합한 로그 뷰어, 로그 뷰어는 로그 문장으로부터 해당 소스 코드로 연결해줄 때 Code Search가 제공하는 링크를 이용하는 것이다. 예2) 코드랩이나 다른 문서자료에서도 API, 예시, 구현 코드를 참조하는 경우가 많다.

### 17.3.5 API 제공
Code Search는 검색, 상호참조, 구문 강조 기능을 API로 제공하여 다른 도구 개발자가 가져다 쓸 수 있다.

## 17.4 규모가 설계에 미치는 영향
코드 검색을 확장하는 데 가장 큰 걸림돌은 전체 코드의 크기이다. 수 MB 정도의 작은 리포지터리라면 별다른 고민 없이 grep으로 검색해도 된다. 수백 MB로 늘어나면 간단한 로컬 인덱스를 도입해 검색 속도를 10배 이상 높일 수 있다. 코드량이 GB나 TB 단위로 가면 클라우드로 옮겨 서버를 여러 대 띄우면 쓸만한 검색 속도를 유지할 수 있다. 이처럼 중앙집중형 검색 솔루션은 이용자 수와 코드량이 늘면 함께 비대해진다.

### 17.4.1 검색 쿼리 지연시간
대체로 사람은 지연시간이 200밀리초보다 짧기만 하면 UI가 빠르다고 느낀다. 하지만 1초가 넘어가면 주의가 분산되기 시작하고, 10초가 더 흐르면 전혀 다른 일을 하기 시작하여 생산성을 급격히 떨어뜨릴 가능성이 크다.

Code Search가 처리하는 쿼리의 상당수가 코드베이스를 탐색하는 과정에서 발생한다.

검색에서는 글자 두어 개 타이핑하는 것만으로 원하는 파일을 찾을 수 있다. 이렇게 하기 위해서는 현재 보고 있는 파일 같은 맥락 정보를 검색 백엔드에 제공해야 한다. 맥락 정보를 이용해 검색 범위를 특정 프로젝트로 한정하거나 물리적인 거리순으로 추천하는 것이다.

### 17.4.2 인덱싱 지연시간
개발자는 자신이 방금 수정한 코드나 그로 인한 변경 사항들을 검토해야 하는데 수정 내용이 반영되어 있지 않으면 혼란을 불러올 수 있다. 작은 수정이든 리팩터링이든 완전히 새로 작성한 코드든 마찬가지이다. 개발자는 자신이 IDE에서 작은 프로젝트를 진행할 때와 똑같이 모든 코드가 최신 버전이기를 기대한다.

검색 후 대체 형태로 이루어지는 리팩터링도 마찬가지이다. 제거한 코드는 검색 결과에서 곧장 사라져야 한다. 편의성 면에서도 그렇지만, 잔재가 남아 있으면 후속 리패터링에 지장을 준다.

문제가 생겼는데 인덱스와 실행 중인 코드가 다르면 진짜 원인을 감추거나 혼선을 줄 수 있다. 실제 구글에서는 상호참조 기능에서 이 문제를 겪는다. 구글 규모에서는 인덱스 생성에 몇 시간이 걸리고, 너무 복잡하여 인덱스를 하나의 버전만 유지하기 때문이다.
