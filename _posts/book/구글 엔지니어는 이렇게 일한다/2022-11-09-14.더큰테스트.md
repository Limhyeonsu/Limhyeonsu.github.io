---
title: 14. 더 큰 테스트
date: 2022-11-09 21:42:08 +0900
categories: [BOOK, 구글 엔지니어는 이렇게 일한다]
tags: [software_engineering]  # TAG는 반드시 소문자로 이루어져야함!
---

## 14.1 더 큰 테스트란?
더 큰 테스트들은 작은 테스트와 많은 면에서 다르다. 따라야 하는 제약도 다르다.

[특성]
* 느릴 수 있다. 구글에서 대규모 테스트의 기본 타임아웃 값은 15분~1시간이다.
* 밀폐되지 않을 수 있다. 대규모 테스트는 다른 테스트나 최종 사용자와 자원 및 트래픽을 공유하기도 한다.
* 비결정적일 수 있다.

이러한 단점들에도 불구하고 더 큰 테스트를 이용하는 이유는 단위 테스트는 호환성 문제가 있는지 확인하는 데 그다지 도움이 안되고, 개별 함수, 객체, 모듈에 대한 확신을 심어준다. 반면 더 큰 테스트는 시스템 전체가 의도대로 동작한다는 확신을 더해주는 역할을한다.

### 14.1.1 충실성
더 큰 테스트가 존재하는 첫 번째 이유는 바로 충실성(실제 행위를 얼마나 반영했느냐)을 높이기 위함이다. 더 큰 테스트는 환경 충실성의 낮음-높음 사이에서 가장 적합한 지점을 찾아내는 것이다. 충실성이 높아질수록 비용이 커져서 테스트 실패시 입는 손해도 크다.

### 14.1.2 단위 테스트가 손 대기 어려운 영역
1. 부정확한 테스트 대역
2. 설정 문제 - 단위 테스트는 주어진 바이너리 내의 코드를 다룬다. 일반적으로 바이너리는 단독으로 실행될 수 없고, 배포 설정, 시작 스크립트 같은 게 필요할 때가 많다.
3. 과부하 시 나타나는 문제 - 성능, 부하, 스트레스 테스트는 바이너리에 상당한 양의 트래픽을 일으키므로 통상적인 단위 테스트 모델에 녹이기 어렵다.
4. 예기치 못한 동작, 입력, 부작용 - 단위 테스트의 범위는 작성자의 상상력에 갇히게 된다. 단위 테스트만으로는 공대 API에 명시되지 않은 행위까지 모두 확인할 가능성이 극히 낮다.
5. 창발적 행위와 진공 효과


### 14.1.3 더 큰 테스트를 만들지 않는 이유
좋은 단위 테스트라면 높은 신뢰성, 빠른 속도, 높은 확장성의 특징을 갖는다. 반면 더 큰 테스트에서는 이 특징을 하나도 갖지 못하는 경우도 생긴다. 예)더 큰 테스트는 많은 인프라를 이용하기 때문에 결과가 비결정적일 때가 많다.

그리고 극복해야 할 과제가 두 가지가 더 있다.
1. 소유권 문제 - 단위 테스트는 소유자가 누구인지 명확하다 더 큰 테스트는 다수의 단위에 걸져 있어 관련 소유자가 많다. 이로인해 시간이 흐를수록 소유권이 더 모호해지고 유지보수의 책임, 테스트 실패시 누가 문제를 해결할지에 대한 문제가 발생한다.
2. 표준화 부족 - 더 큰 테스트는 작성하고 실행하고 디버깅하기 위한 인프라와 프로세스가 부실하다. 그로인해 미치는 영향이 상당히 크다. 더 큰 테스트는 실행 방식이 너무 다양하여 테스트를 수행하는 표준화된 방식이 없으므로 자연스럽게 인프라의 지원을 받지 못한다.

## 14.2 더 큰 테스트 @구글
1. 구글은 테스트 피라미드를 장려했다. 대다수 테스트가 단위 테스트가 되길 원하여 단일 테스트에 집중했다.
2. 훗날 C/J Build를 대신하여 TAP을 공식 지속적 빌드 시스템으로 도입하였는데 TAP은 특정한 조건을 충족하는 테스트인 경우에만 C/J Build를 대체할 수 있었다.

### 14.2.1 더 큰 테스트와 수명
더 큰 테스트들은 시간이라는 관점에서 어떤 영향을 줄까? 단위 테스트는 기대 수명이 몇 시간 이상만 되면 충분히 가치가 있다.

더 큰 테스트들은 모두 수명이 더 긴 소프트웨어에 유용하다. 하지만 수명이 길어질수록 주 관심사가 테스트의 유지보수로 옮겨간다.

건강한 상태를 오래 유지하는 핵심은 개발 시작 후 며칠 안으로 단위 테스트를 만들어 테스트 피라미드를 쌓기 시작하는 것이다. 그런 다음 수동 테스트를 자동화된 통합 테스트로 대체해 피라미드 위층으로 올린다. __오랫동안 코드를 건강하게 유지하려면 단위 테스트와 수동 테스트 사이의 간극을 매우는데 소홀해서는 안 된다.__

### 14.2.2 구글 규모에서의 더 큰 테스트
규모가 큰 소프트웨어라면 더 큰 테스트가 그만큼 더 필요하고 유용하다. 하지만 작성하고 수행하고 관리하고 디버깅하는 복잡도는 규모가 커질수록 함께 증가한다. (382~383p)

**통합 테스트라 하더라도 가능한 한 작을수록 좋다. 작은 통합 테스트들로 나눠 연결하는 것으로 '연쇄 테스트'라는 방법이 있다.

## 14.3 큰 테스트의 구조
1. 테스트 대상 시스템 확보
2. 필요한 테스트 데이터 준비
3. 대상 시스템을 이용해 동작 수행
4. 행위 검증

### 14.3.1 테스트 대상 시스템
대규모 테스트의 핵심은 테스트 대상 시스템(SUT)이다. 대규모 테스트에서의 SUT는 대체로 하나 이상의 독립된 프로세스에서 수행된다.

<img src="/assets/img/posting_img/book/구글엔지니어/테스트대상시스템.jpeg" width="700px">

SUT의 형태는 주로 다음 두 요소에 의해 결정된다.
* 밀폐성 - SUT는 현재 테스트하려는 기능과 관련 없는 구성요소를 사용하거나 상호작용하지 못해야 한다.
* 충실성 - SUT는 테스트 중인 프로덕션 시스템을 충실히 반영해야 한다.

그런데 이 두 요소가 충돌할 때가 많다.
1. 단일 프로세스 SUT - SUT 전체가 하나의 바이너리로 패키징되고, 테스트 코드까지 함께 패키징된다. 충실성 측면에서는 프로덕션의 토폴리지나 설정과 거리가 가장 먼 테스트가 된다.
2. 단일 머신 SUT - SUT는 독립된 바이너리로 구성되고, 테스트도 별도의 바이너리로 만들어지나 모두가 하나의 머신에서 구동한다.
3. 다중 머신 SUT - SUT를 여러 머신에 분산시킨다. 단일 머신 SUT보다 충실성이 높지만 여러 머신 사이를 잇는 네트워크가 불안정성을 키워 테스트에 예기치 못한 영향을 줄 가능성이 커진다.
4. 공유 환경(스테이징과 프로덕션) - SUT를 독립적으로 실행하는 대신 테스트에서 공유 환경을 직접 사용한다. 하지만 공유 환경을 함께 이용중인 다른 엔지니어와 충돌할 수 있고, 테스트 만을 위해 임의로 변경할 수 없다.
5. 하이브리드 - 어떤 SUT는 혼합된 형태를 띈다.
