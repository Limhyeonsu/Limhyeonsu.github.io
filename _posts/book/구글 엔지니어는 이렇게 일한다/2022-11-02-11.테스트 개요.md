---
title: 11. 테스트 개요
date: 2022-11-02 17:22:12 +0900
categories: [BOOK, 구글 엔지니어는 이렇게 일한다]
tags: [software_engineering]  # TAG는 반드시 소문자로 이루어져야함!
---

테스트는 처음부터 프로그래밍과 함께였다. 하지만 오랫동안 테스트 프로세스는 크게 개선되지 못 했고, 대부분 수동으로 이루어져 오류가 나기 쉬운 프로세스였다. 2000년대 초부터 테스트 방식이 진화되었고 그 진회의 중심에는 개발자가 주도하는 테스트와 자동 테스트가 있었다.

자동 테스트는 버그가 몰래 숨어들어 고객을 놀라게 하는 시태를 막아준다. 또 새로운 기능을 추가하거나 코드가 더 건실해지도록 리팩터링하거나 대규모 재설계를 진행하는 상황에서 자동 테스트는 실수를 빠르게 잡아주므로 안심하고 소프트웨어를 변경할 수 있다.

테스트 체계가 잘 갖춰져 있다면 변화를 두려워할 이유가 없다. 따라서 테스트 체계를 소프트웨어 개발의 핵심 역량으로 취급할 수 있다. 시스템을 더 많이 더 빠르게 변경하고 싶다면 더 빠르게 테스트하는 방법을 모색해야 한다.

한편 테스트를 작성하는 행위가 시스템의 설계도 개선해준다. 자동 테스트를 작성하면 여러 문제를 개발 주기의 초반에 잡아내게 된다. 그 결과 모듈화가 더 잘되어 미래의 변화에 훨씬 유연한 소프트웨어가 만들어진다.

## 11.1 테스트를 작성하는 이유
테스트는 다음 요소들로 정의할 수 있다.
* 테스트하려는 단 하나의 행위
* 특정한 입력
* 관측 가능한 출력 혹은 동작
* 통제된 조건

간단한 테스트가 수백, 수천개 모이면(test suit) 제품이 전체적으로 의도한 설계대로 잘 작동하는지, 혹은 언제 그렇지 못한 지를 이야기할 수 있게 된다. 테스트 스위트를 건실하게 만들고 유지하는 데는 많은 노력이 든다. 코드베이스의 덩치가 커지면 테스트 스위트도 커지는데 이때 테스트 결과가 일관되지 못하거나 느려지는 문제가 나타나기도 한다. 이러한 문제를 해결하지 못하면 테스트 스위트의 존재가 위태로워진다.

테스트는 좋은 제품을 빠르게 만들 수 있게 해줄 뿐 아니라 우리 삶에서 중요한 제품과 서비스의 안전을 보장하는 데도 점점 핵심적인 역할을 하고 있다.

구글은 `문제가 터진 후에야 테스트를 고민해서는 안 된다.` 라고 결론을 지었다.

### 11.1.1 구글 웹 서버 이야기
283~284p

### 11.1.2 오늘날의 개발 속도에 맞는 테스트
대부분의 소프트웨어는 기능과 자원 플랫폼이 너무 폭증해서 사람이 모든 행위를 수동으로 검증할 수 있는 한계를 아득히 넘어섰다. 모든 기능을 사람이 조작하여 제품 품질을 확인하는 방식은 확장이 불가능하다. 그래서 테스트에서의 해법은 단 하나 `자동화` 뿐이다.

### 11.1.3 작성하고, 수행하고, 조치하라
가장 순수한 형태의 자동 테스트는 `테스트 작성, 테스트 수행, 실패한 테스트에 대한 조치` 이렇게 세 가지 활동으로 이루어 진다. 자동 테스트는 적은 양의 코드로 구성된다. 테스트 코드는 환경을 원하는 모습으로 설정하고, 시스템을 호출하고, 결과를 검증한다.

과거의 품질보증(QA) 프로세스와 달리 오늘날의 개발자들은 자신의 코드를 검사하는 자동 테스트를 작성하고 수행하는데 능동적이고 핵심적인 역할을 한다.

테스트 작성은 테스트 자동화 프로세스의 첫 번째 단계일 뿐이다. 테스트를 작성한 후에는 작성한 테스트를 수시로 실행해야 한다. `자동 테스트의 핵심은 같은 동작을 끊임없이 반복하는 데 있다.` 그리고 테스트 프로세스가 얼마나 효과적이냐는 이러한 테스트 실패를 어떻게 처리하느냐에 달려 있다. 실패 테스트가 해결되지 못하고 빠르게 쌓여간다면 테스트에 투자한 노력이 허사가 되니 그렇게 되지 않도록 하는 것이 중요하다.

### 11.1.4 테스트 코드가 주는 혜택
* 디버깅 감소 - 테스트를 거친 코드는 통상적으로 결함이 적다. 테스트를 한 번 작성해두면 프로젝트가 살아 있는 내내 결함을 예방해주고 디버깅에서 해방시켜주는 식으로 지속해서 혜택을 준다.
* 자신 있게 변경 - 좋은 테스트들로 무장한 팀은 자신감을 가지고 변경들을 리뷰하고 수용할 수 있다.
* 더 나은 문서자료 - 한 번에 하나의 행위만 집중해 검증하는 명확한 테스트는 마치 실행 가능한 문서와 같다. 코드가 특정 상황에서 어떻게 동작하는지 궁금하다면 그 상황을 검증하는 테스트를 보면 된다.
* 더 단순한 리뷰 - 코드 리뷰시 다양한 측면에서 코드를 검사해주는 테스트가 준비되어 있다면 리뷰어가 변경된 코드가 제대로 작동하는지를 검증하는 시간을 크게 줄여준다.
* 사려 깊은 설계 -  새로 작성한 코드의 테스트를 작성하는 일은 실질적으로 해당 코드의 API가 잘 설계되어 있는지를 시험하는 행위이다.
* 고품질의 릴리스를 빠르게

## 11.2 테스트 스위트 설계하기
엔지니어들은 커다란 시스템 규모의 테스트를 작성하는 편을 선호하지만, 이러한 테스트는 작은 테스트와 비교하여 느리고 신뢰도가 낮고 디버깅하기도 어렵다. 고통을 줄이고자 하는 욕구가 엔지니어들을 점점 더 작은 테스트를 작성하도록 이끌었다. 그러면서 더 작은 테스트가 더 빠르고, 안정적이고, 평균적으로 고통이 적다는 걸 깨우쳤다.

테스트에서 작다는 의미에는 두 가지 요소가 있다. '크기', '범위'

### 11.2.1 테스트 크기
테스트의 크기를 가늠하는 기준은 코드 줄 수가 아니라 어떻게 동작하고, 무엇을 하고, 얼마나 많은 자원을 소비하는지로 평가한다.

테스트 스위트에 바라는 품질은 `속도와 결정성`이다. 실제로 범위와 상관없이 작은 테스트는 더 많은 인프라나 자원을 사용하는 테스트보다 거의 항상 더 빠르고 더 결정적이다.

#### 작은 테스트
가장 작은 테스트는 __제약이 가장 엄격__ 하다. 가장 중요한 제약은 바로 테스트가 단 하나의 프로세스에서 실행되어야 한다는 것이다.

서버를 두고 독립된 테스트 프로세스에 연결해 수행하는 방식도 허용되지 않고, 또 데이터베이스와 같은 제 3의 프로그램을 수행해서도 안 된다. 그리고 작은 테스트는 sleep, I/O 연산 같은 블로킹 호출을 사용해서는 안 된다. (네트워크, 디스트에 접근 불가) 그래서 블로킹 호출을 수반하는 대상을 검사하는 테스트 코드는 테스트 대역을 사용해야 한다.

제약이 과한 이유는 작은 테스트 케이스 수백개로 이루어진 테스트 스위트가 하루종일 실행되는 환경에서 불규칙한 테스트가 단 몇 개만 있어도 원인을 찾아 헤매느라 생산성이 급격하게 떨어질 것이기 때문이다.

#### 중간 크기 테스트
중간 크기 테스트는 여러 프로세스와 스레드를 활용할 수 있고, 로컬 호스트로의 네트워크 호출 같은 블로킹 호출도 이용할 수 있다. 단, 외부 시스템과의 통신은 여전히 불허하다.

유연성이 커지면 반대급부로 테스트는 느려지고, 비결정적이 될 가능성이 높아진다. 여러 프로세스에 걸쳐 있거나 블로킹 호출을 하기 시작하면 운영체제나 서드파티 프로세스에 의존하게 된다. 외부 요인이 개입되므로 성능과 결정성을 온전히 우리 스스로가 보장할 수 없다는 뜻이다.

#### 큰 테스트
큰 테스트는 로컬 호스트 제약에서 해방되어, 테스트와 대상 시스템이 여러 대의 기기를 활용할 수 있게 된다. 더 유연해지는 만큼 위험도 늘어나 여러 기기에 걸쳐있는 시스템을 네트워크로 연결해 다루게 되면서 단일 기기에서 구동할 때보다 느려지거나 비결정성이 커질 가능성이 훨씬 높아진다.

#### 테스트 크기와 무관한 공통 특성
모든 테스트는 setup, execute, tear down 하는데 필요한 모든 정보를 담고 있어야 한다. 또 테스트 수행 순서 같은 외부 환경에 관해서는 가능한한 아무것도 가정하지 않아야 한다.

테스트는 확인하려는 행위를 수행하는 데 필요한 정보만을 포함해야 한다. 깔끔한 코드는 테스트 실패 원인을 진단하는 데도 도움이 된다. 테스트는 무엇을 검사하는지가 명확해야 한다.

#### 실제 상황에서의 테스트 크기
테스트 크기를 명확히 정의한 덕분에 구글은 규칙을 실무에 적용할 수 있는 도구들을 만들 수 있었다.
