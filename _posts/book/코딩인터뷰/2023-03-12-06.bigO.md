---
title: 06. big-O
date: 2023-03-12 22:00:37 +0900
categories: [BOOK, 코딩 인터뷰 완전분석]
tags: []  # TAG는 반드시 소문자로 이루어져야함!
---

big-O 시간은 알고리즘의 효율성을 나타내는 지표 혹은 언어다. 이를 제대로 이해하지 못하면 알고리즘을 개발하는 데 큰 고비를 겪을 수 있다.

## 비유하기
디스크에 있는 파일을 다른 지역에 살고 있는 친구에게 가능하면 빨리 보내려고 한다고 가정할 때, 파일의 크기가 작다면 온라인을 통한 전송이 빠를 것이다. 하지만 파일이 1TB라면 하루이상 걸릴 수 있다. 그럴땐 직접 차를 타고 가는 것이 빠를지도 모른다.

## 시간 복잡도
위 내용이 바로 점근적 실행 시간, 또는 big-O 시간에 대한 개념이다. 위의 데이터 전송 예시의 알고리즘 실행 시간을 다음과 같이 설명할 수 있다.
* 온라인 전송 : O(s), s는 파일의 크기가 된다. 따라서 파일의 크기가 증가함에 따라 전송 시간 또한 선형적으로 증가한다.
* 직접 전송 : 파일의 크기와 관계없이 O(1), 상수 시간만큼 소요된다.

상수가 얼마나 큰지 또는 선형식이 얼마나 천천히 증가하는지에 관계없이 숫자가 커지다 보면 선형식은 언젠가 상수를 뛰어 넘게 된다.

__big-O, big-ϴ, big-Ω__
* O(big-O) : 학계에서 big-O는 `시간의 상한`을 나타낸다. 배열의 모든 값을 출력하는 알고리즘은 O(N)으로 표현할 수 있지만, 이외에 N보다 큰 big-O 시간으로 표현할 수도 있다.
* Ω(big-Omega) : 학계에서 Ω는 `등가 개념 혹은 하한`을 나타낸다. 알고리즘은 Ω 수행시간보다 빠를 수 없게 된다.
* ϴ(big-theta) : 학계에서는 ϴ는 `O와 Ω 둘 다를 의미`한다. 어떤 알고리즘의 수행 시간이 O(N)이면서 Ω(N)이라면, 이 알고리즘의 수행 시간을 ϴ(N)로 표현할 수 있다.

__최선의 경우, 최악의 경우, 평균적인 경우__ : 알고리즘의 수행시간을 세 가지 다른 방법으로 나타낼 수 있다. 퀵 정렬의 관점에서 보면 퀵 정렬은 축이 되는 원소 하나를 무작위로 뽑은 뒤 이보다 작은 원소들은 앞에, 큰 원소들은 뒤에 놓이도록 원소의 위치를 바꾼다. 그 결과 부분 정렬이 완성되고, 그 뒤 왼쪽과 오른쪽 부분을 이와 비슷한 방식으로 재귀적으로 정렬해 나간다.

* 최선의 경우 : 만약 모든 원소가 동일하다면 퀵 정렬은 평균적으로 단순히 배열을 한 차례 순회하고 끝날 것이다. 즉 수행시간이 O(N)이 된다.
* 최악의 경우 : 운이 없게 배열에서 가장 큰 원소가 계속해서 축이 된다면 이런 경우에 수행시간은 O(N²)으로 악화된다.
* 평균적인 경우 : 보통 최선의 경우와 최악의 경우가 반복적으로 일어나는 일은 많지 않다. 따라서 수행시간은 평균적으로 O(N log N)이라고 말할 수 있다.

## 공간 복잡도
알고리즘에서는 시간뿐 아니라 메모리 또한 신경 써야 한다. 공간 복잡도는 시간 복잡도와 평행선을 달리는 개념이다. 크기가 n인 배열을 만들고자 한다면 O(n)의 공간이 필요하다. n * n 크기의 2차원 배열을 만들고자 한다면 O(n²)의 공간이 필요하다.

## 상수항은 무시하라
big-O는 단순히 증가하는 비율을 나타내는 개념이므로 특수한 입력에 한해 O(N)코드가 O(1) 코드보다 빠르게 동작하는 것은 매우 가능성 있는 얘기다. 이런 이유로 우리는 수행시간에서 상수항을 무시해 버린다. 즉 O(2N)으로 표기되어야 할 알고리즘을 실제로는 O(N)으로 표기한다.

big-O 표기법은 수행 시간이 어떻게 변화하는지를 표현해주는 도구이다. 따라서 O(N)이 언제나 O(2N)보다 나은 것은 아니라는 사실만 받아드리자

## 지배적이지 않은 항은 무시하라
수식에서 지배적이지 않은 항은 무시해도 된다.
* O(N² + N)은 O(N²)
* O(N + logN)은 O(N)
* O(5 * 2ᴺ + 1000N¹⁰⁰)은 O(2ᴺ)

## 여러 부분으로 이루어진 알고리즘 : 덧셈 vs 곱셈

```java
//덧셈 수행 시간 O(A+B)
for(int a: arrA) {
  print(a);
}

for(int b: arrB) {
  print(b);
}

//곱셈 수행 시간 O(A*B)
for(int a: arrA) {
  for(int b: arrB) {
    print(a + ", " + b);
  }
}
```

만약 알고리즘이 A 일을 모두 끝마친 후에 B 일을 수행하라의 형태라면 A와 B의 수행 시간을 더해야 한다.

만약 알고리즘이 A 일을 할 때마다 B 일을 수행하라의 형태라면 A와 B의 수행 시간을 곱해야 한다.
