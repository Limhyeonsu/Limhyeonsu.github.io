---
title: 09. 면접문제
date: 2023-04-01 22:14:48 +0900
categories: [BOOK, 코딩 인터뷰 완전분석]
tags: []  # TAG는 반드시 소문자로 이루어져야함!
---

## 01. 배열과 문자열
배열이나 문자열에 대한 문제들은 서로 대체 가능하다.

### 해시 테이블
해시테이블을 효율적인 탐색을 위한 자료구조로서 키(key)를 값에 대응시킨다. 간단한 해시 테이블을 구현하기 위해선 연결리스트와 해시 코드 함수만 있으면 된다. 키와 값을 해시테이블에 넣을때는 다음의 과정을 거친다.
1. 처음에 키의 해시 코드를 계산한다.(키의 자료형은 보통 int, long이 된다. 키의 개수는 무한대지만 int의 개수는 유한하므로 서로 다른 두 개의 키가 같은 해시 코드를 가리킬 수 있다.)
2. hash(key) % array.length와 같은 방식으로 해시 코드를 이용해서 배열의 인덱스를 구한다.(서로 다른 해시코드가 같은 인덱스를 가리킬 수 있다.)
3. 배열의 각 인덱스에는 키와 값으로 이루어진 연결 리스트가 존재한다. 키와 값을 해당 인덱스에 저장한다. (충돌에 대비해서 반드시 연결리스트를 이용해야 한다.)

키에 상응하는 값을 찾기 위해서는 다음과 같은 과정을 반복해야 한다.
1. 주어진 키로부터 해시 코드를 계산한다.
2. 해시 코드를 이용해서 인덱스를 계산한다.
3. 해당 키에 상응하는 값을 연결리스트에서 탐색한다.

충돌이 자주 발생한다면 최악의 경우 수행 시간은 O(N)이 된다. (N은 키의 갯수) 충돌을 최소화하도록 잘 구현된 경우 탐색시간은 O(1)이다.

또 다른 구현법으로는 균형 이진 탐색 트리를 사용하는 방법이 있다. 이 경우 탐색 시간이 O(logN)이 된다. 이 방법은 크기가 큰 배열을 미리 할당해 놓지 않아도 되기 때문에 잠재적으로 적은 공간을 사용한다는 장점이 있다.

### ArrayList와 가변 크기 배열
특정 언어에서 배열의 크기를 자동으로 조절할 수 있다. 자바 같은 언어에서 배열은 길이가 고정되어 있다. 동적 가변 크기 기능이 내재되어 있는 배열과 비슷한 자료구조를 원할 때는 보통 ArrayList를 사용한다. ArrayList는 필요에 따라 크기를 변화시킬 수 있으면서도 O(1)의 접근 시간을 유지한다. 통상적으로 배열이 가득 차는 순간, 배열의 크기를 두 배로 늘린다. 크기를 늘리는 순간은 O(N)이지만, 자주 발생하는 일이 아니라서 상환입력시간으로 계산했을 때 여전히 O(1)이 된다.

### StringBuilder
문자열 리스트가 주어졌을 때 이 문자열을 하나로 이어붙이려는 경우 이때 수행시간은 어떻게 될까?
```java
String joinWord(String[] words) {
  String sentence = "";
  for(String w : words) {
    sentence = sentence + w;
  }
  return sentence;
}
```
문자열을 이어붙일 때마다 두 개의 문자열을 읽어 들인 뒤 문자를 하나하나 새로운 문자열에 복사해야 한다. 따라서 총 수행시간은 O(x+2x+...nx) -> O(xn²)이 된다.

StringBuilder를 사용하면 이 문제를 해결할 수 있다. 이는 단순하게 가변 크기 배열을 이용해서 필요한 경우에만 문자열을 복사하게끔 해준다.
```java
String joinWord(String[] words) {
  StringBuilder sentence = new StringBuilder();
  for(String w : words) {
    sentence.append(w);
  }
  return sentence.toString();
}
```

### 면접 문제
1. 중복이 없는가 : 문자열이 주어졌을 때, 중복되어 등장하는 문자열이 있는지 확인하는 알고리즘을 작성하라
2. 순열 확인 : 문자열 두 개가 주어졌을 때, 이 둘이 서로 순열 관계에 있는지 확인하는 메서드를 작성하라 (순열이란? 문자열을 재배치하는 것을 뜻한다.)
3. URI화 : 문자열에 들어있는 모든 공백을 '%20'으로 바꿔주는 메서드를 작성하라, 모든 문자를 다 담을 수 있을 만큼 충분한 공간이 이미 확보되어 있으면 문자열의 최종 길이가 함께 주어진다고 가정해도 된다.
4. 회문 순열 : 주어진 문자열이 회문의 순열인지 아닌지 확인하는 함수를 작성하라 (회문이란? 앞으로 읽으나 뒤로 읽으나 같은 단어 혹은 구절을 의미한다.)
5. 하나 빼기 : 문자열을 같게 만들기 위한 편집 횟수가 1회 이내인지 확인하는 함수를 작성하라 (문자열 편집에는 문자삽입, 문자삭제, 문자교체)가 있다.
6. 문자열 압축 : 반복되는 문자의 개수를 세는 방식의 기본적인 문자열 압축 메서드를 작성하라 예)aabccccaaaa -> a2b1c4a4 만약 압축된 문자열의 길이가 기존 문자열의 길이보다 길다면 기존 문자열을 반환해야 한다.
7. 행렬 회전 : 이미지를 표현하는 N X N 행렬이 있다. 이미지의 각 픽셀은 4 바이트로 표현된다. 이때, 이미지를 90도 회전시키는 메서드를 작성하라. 행렬을 추가로 사용하지 않고서도 할 수 있겠는가
8. O 행렬 : M X N 행렬의 한 원소가 0일 경우, 해당 원소가 속한 행과 열의 모든 원소를 0으로 설정하는 알고리즘을 작성하라.
9. 문자열 회전 : 한 단어가 다른 문자열에 포함되어 있는지 판별하는 isSubstring이라는 메서드가 있다고 할 때, s1과 s2의 두 문자열이 주어졌고, s2가 s1을 회전시킨 결과인지 판별하고자 한다. isSubstring을 한 번만 호출해서 판별할 수 있는 코드를 작성하라

## 02. 연결리스트
연결리스트는 차례로 연결된 노드를 표현해주는 자료구조이다. 단방향 연결리스트에서 각 노드는 다음 노드를 가리킨다. 양방향 연결리스트에서 각 노드는 다음 노드와 이전 노드를 함께 가리킨다.

배열과 달리 연결리스트에서는 특정 인덱스를 상수 시간에 접근할 수 없다. 즉 리스트에서 k번째 원소를 찾고 싶다면 처음부터 k번 루프를 돌아야 한다. 리스트의 장점은 리스트의 시작 지점에서 아이템을 추가하거나 삭제하는 연산을 상수 시간에 할 수 있다는 점이다.

### 연결리스트 만들기
```java
//단방향 연결리스트
class Node {
  Node next = null;
  int data;

  public Node(int d) {
    data = d;
  }

  void appendToTail(int d) {
    Node end = new Node(d);
    Node n = this;
    while(n.next != null) {
      n = n.next;
    }
    n.next = end;
  }
}
```
연결리스트에 접근할 때 head 노드의 주소를 참조하는 방법을 사용했다. 이런식으로 구현할 때는 약간 조심해야 하는 부분이 있는데 여러 객체들이 동시에 연결리스트에 참조하는 도중에 head가 바뀌면 어떻게 해야 할지 생각해 봐야 하는 것이다. head가 바뀌었음에도 어떤 객체들은 이전 head를 계속 가리키고 있을 수도 있다.

할 수 있다면, Node 클래스를 포함하는 LinkedList 클래스를 만드는 게 좋다. 그렇게 하면 해당 클래스 안에 head Node 변수를 단 하나만 정의해 놓음으로써 위의 문제점을 완전히 해결할 수 있기 때문이다.

면접에서 연결리스트에 대해 이야기 할 때는 단방향 연결리스트에 대한 이야기인지 양방향 연결리스트에 대한 이야기인지 반드시 인지하고 있어야 한다.

### 단방향 연결리스트에서 노드 삭제
연결리스트에서 노드를 삭제하는 연산은 꽤 직관적이다. 노드 n이 주어지면, 그 이전 노드 prev를 찾아 prev.next를 n.next와 같도록 설정한다. 리스트가 양방향 연결리스트인 경우에는 n.next가 가리키는 노드를 갱신하여 n.next.prev가 n.prev와 같도록 설정해야 한다. 여기서 유의할 점은 1)널 포인터 검사를 반드시 해야한다. 2)필요하면 head와 tail 포인터도 갱신해야 한다.

### Runner 기법
Runner는 부가 포인터라고도 하며, 연결리스트 문제에서 많이 활용되는 기법이다. `연결리스트를 순회할 때 두 개의 포인터를 동시에 사용하는 것`이다. 이때 한 포인터가 다른 포인터보다 앞서도록 한다.

### 재귀 문제
연결리스트 관련 문제 가운데 상당수는 재귀 호출에 의존한다. 연결리스트 문제를 푸는 데 어려움을 겪고 있다면, 재귀적 접근법은 통할지 확인해 봐야 한다.

### 면접 문제
1. 중복 없애기 : 정렬되어 있지 않은 연결리스트가 주어졌을 때 이 리스트에서 중복되는 원소를 제거하는 코드를 작성하라
2. 뒤에서 k번째 원소 구하기 : 단방향 연결리스트가 주어졌을 때 뒤에서 k번째 원소를 찾는 알고리즘을 구하라
3. 중간 노드 삭제 : 단방향 연결리스트가 주어졌을 때 중간에 있는 노드 하나를 삭제하는 알고리즘을 구현하라(단, 삭제할 노드에만 접근할 수 있다.)
4. 분할 값 : x가 주어졌을 때 x보다 작은 노드들을 x보다 크거나 같은 노드들보다 앞에 오도록 하는 코드를 작성하라
5. 리스트의 합 : 표현된 숫자 두 개가 있을 때, 이 두수를 더하여 그 합을 연결리스트로 반환하는 함수를 작성하라. 예)(7->1->6) + (5->9->2) = 617 + 295
6. 회문 : 주어진 연결리스트가 회문인지 검사하는 함수를 작성하라
7. 교집합 : 단방향 연결리스트 두 개가 주어졌을 때 이 두 리스트의 교집합 노드를 찾은 뒤 반환하는 코드를 작성하라 (교집합은 노드의 값이 아닌 주소가 완전히 같은 경우를 말한다.)
8. 루프 발견 : 순환 연결리스트가 주어졌을 때, 순환되는 부분의 첫째 노드를 반환하는 알고리즘을 작성하라

## 03. 스택과 큐
### 스택 구현하기
스택 자료구조는 말그대로 데이터를 쌓아 올린다는 의미이다. 문제의 종류에 따라 배열보다 스택에 데이터를 저장하는 것이 더 적합한 방법일 수 있다.

스택은 Last-In-First-Out 에 따라 자료를 배열한다.
* pop() : 스택에서 가장 위에 있는 항목을 제거한다.
* push(item) : item 하나를 스택의 가장 윗 부분에 추가한다.
* peek() : 스택의 가장 위에 있는 항목을 반환한다.
* isEmpty() : 스택이 비어있을 때 true를 반환한다.

배열과 달리 스택은 상수 시간에 i번째 항목에 접근할 수 없다. 하지만 스택에서 데이터를 추가하거나 삭제하는 연산은 상수 시간에 가능하다.

```java
public class MyStack {
  private static class StackNode{
    private T data;
    private StackNode next;
    public StackNode(T data) {
      this.data = data;
    }
  }

    private StackNode top;
    public T pop() {
      if (top = null) throw new EmptyStackException() ;
      T item = top. data;
      top = top.next;
      return item;
    }
라      StackNode t = new StackNode (item);
      t.next = top;
      top = t.
    }
    public T peek(){
      if (top == null) throw new EmptyStackException ();
      return top.data;
    }
    public boolean isEmpty () {
      return top == null;
  }
}
```
스택이 유용한 경우는 재귀 알고리즘을 사용할 때다. 재귀적으로 함수를 호출해야 하는 경우에 임시 데이터를 스택에 넣어 주고, 재귀 함수를 빠져나와 퇴각 검색을 할 때는 스택에 넣어 두었던 임시 데이터를 빼 줘야 한다.

### 큐 구현하기
큐는 First-In-First-Out 순서에 따른다. 큐에 저장되는 항목들은 큐에 추가되는 순서대로 제거된다.
* add(item) : item을 리스트 끝 부분에 추가한다.
* remove() : 리스트의 첫 번째 항목을 제거한다.
* peek() : 큐에서 가장 위에 있는 항목을 반환한다.
* isEmpty() : 큐가 비어 있을 때는 true를 반환한다.

```java
public class MyQueue {
  private static class QueueNode {
    private T data;
    private QueueNode next;
    public QueueNode (T data) {
      this. data = data;
    }
 }
  private QueueNode first;
  private QueueNode last;

  public void add (T item) {
    QueueNode t = new QueueNode(item);
    if (last != null) {
      last.next = t;
    }
    last = t;
    if (first == null) {
      first = last;
    }
  }

  public T remove() {
    if (first == null) throw new NoSuchElementException ();
    T data = first. data;
    first = first. next;
    if (first == null) {
      last = null;
    }
    return data;
  }
  public T peek() {
    if (first == null) throw new NoSuchElementException () ;
    return first.data;
  }
  public boolean isEmpty () {
    return first == null;
  }
```
큐에서 처음과 마지막 노드를 갱신할 때 실수가 나오기 쉽다. 큐는 너비 우선 탐색을 하거나 캐시를 구현하는 경우에 종종 사용된다.

### 면접 문제
1. 한 개로 세 개 : 배열 한 개로 스택 세 개를 어떻게 구현할지 설명하라
2. 스택 Min : 기본적인 push와 pop 기능이 구현된 스택에서 최소값을 반환하는 min 함수를 추가하려고 한다. 어떻게 설계할 수 있겠는가?
3. 접시 무더기 : 접시 무더기를 생각해보면 접시를 너무 높이 쌓으면 무너져 내릴 것이다. 현실에서는 무더기가 어느 정도 높아지면 새로운 무더리를 만든다. 이것을 흉내내는 자료구조 SetOfStack을 구현해보라
4. 스택으로 큐 : 스택 두 개로 큐 하나를 구현한 MyQueue 클래스를 구현하라
5. 스택 정렬 : 가장 작은 값이 위로 오도록 스택을 정렬하는 프로그램을 작성하라
6. 동물 보호소 : 먼저 들어온 동물이 먼저 나가는 동물 보호소가 있을때 사람들은 보호소에서 가장 오래된 동물부터 입양할 수 있는데 개와 고양이중 어떤 동물을 데려갈지 선택할 수 있다. 이 시스템을 자료구조로 구현하

## 04. 트리와 그래프
트리에서 탐색하는 것이 배열이나 연결리스트처럼 선형으로 구성된 자료구조에서 탐색하는 것보다 훨씬 까다롭다. 또 최악의 수행시간과 평균적 수행시간이 매우 크게 바뀔 수 있어서, 알고리즘을 살펴볼 때에는 두 가지 측면 모두를 반드시 따져 봐야 한다.

### 트리의 종류
트리를 이해하기 위한 좋은 방법 중 하나는 재귀적 설명법을 사용하는 것이다.
* 트리는 하나의 루트 노드를 갖는다.
* 루트 노드는 0개 이상의 자시 노드를 갖고 있다.
* 그 자식노드 또한 0개 이상의 자식 노드를 갖고 있다.

트리에는 사이클이 존재할 수 없다. 노드들은 특정 순서로 나열될 수도 있고, 그럴 수 없을 수도 있다. 각 노드는 어떤 자료형으로도 표현 가능하다.

트리 및 그래프 문제들은 대부분 세부사항이 모호하거나 가정 자체가 틀린 경우가 많다. 아래의 이슈들을 유의하고 명확하게 해줄 것을 요구하자.
1. 트리 vs 이진 트리 : 이진 트리는 각 노드가 최대 두 개의 자식을 갖는 트리를 말한다.
2. 이진 트리 vs 이진 탐색 트리 : 이진 탐색 트리는 모든 노드가 특정 순서를 따르는 속성이 있는 이진 트리를 일컫는다. 많은 지원자들이 트리 문제가 주어지면 이진 탐색트리 일 것이라고 가정해 버린다. 이진탐색 트리인지 아닌지 확실하게 묻도록 하자
3. 균형 vs 비균형 : 많은 트리가 균형 잡혀 있긴 하지만, 전부 그런것은 아니다. 면접관에게 어느쪽인지 묻도록 하자.
4. 완전 이진 트리 : 완전 이진 트리는 트리의 모든 높이에서 노드가 꽉 차 있는 이진 트리를 말한다. 마지막 단계는 꽉차있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져야 한다.
5. 전 이진 트리 : 전 이진 트리는 모든 노드의 자식이 없거나 정확히 두 개 있는 경우를 말한다. (자식이 하나만 있는 노드가 존재해서는 안 된다.)
6. 포화 이진 트리 : 포화 이진 트리는 전 이진 트리이면서 완전 이진 트리인 경우를 말한다. 모든 말단 노드는 같은 높이에 있어야 하며, 마지막 단계에서 노드의 개수가 최대가 되어야 한다.

### 이진 트리 순회
1. 중위 순회 : 중위 순회는 왼쪽 가지, 현재 노드, 오른쪽 가지 순서로 노드를 방문하고 출력하는 방법을 말한다. 이진 탐색 트리를 이 방식으로 순회한다면 오름차순으로 방문하게 된다.
2. 전위 순회 : 전위 순회는 자식 노드보다 현재 노드를 먼저 방문하는 방법을 말한다. 전위 순회에서 가장 먼저 방문하게 될 노드는 언제나 루트이다.
3. 후위 순회 : 후위 순회는 모든 자식 노드들을 먼저 방문한 뒤 마지막에 현재 노드를 방문하는 방법을 말한다. 후위 순회에서 가장 마지막에 방문하게 될 노드는 언제나 루트이다.

### 이진 힙(최소힙과 최대힙)
최소힙은 트리의 마지막 단계에서 오른쪽 부분을 뺀 나머지 부분이 가득 채워져 있다는 점에서 완전 이진 트리이며, 각 노드의 원소가 자식들의 원소보다 작다는 특성이 있다. 따라서 루트는 트리 전체에서 가장 작은 원소가 된다. 최대 힙은 원소가 내림차순으로 정렬되어 있다는 점만 다를 뿐 최소힙과 완전히 같다.

1. 삽입 : 최소힙에 원소를 삽입할 때는 언제나 트리의 밑바닥에서부터 삽입을 시작한다. 완전 트리의 속성에 위배되지 않게 새로운 원소는 밑바닥 가장 오른쪽 위치로 삽입된다. 힙에 있는 노드의 개수를 n이라 할 때, 연산은 O(log n)시간이 걸린다.
2. 최소 원소 뽑아내기 : 최소힙에서 최소 원소를 찾기란 가장 쉬운 일이다. 최소 원소는 언제나 가장 위에 놓인다. 최솟값을 어떻게 힙에서 제거하느냐가 까다로운 부분이다.

### 트라이(접두사 트리)
트라이는 n-차 트리의 변종으로 각 노드에 문자를 저장하는 자료구조이다. 따라서 트리를 아래쪽으로 순회하면 단어 하나가 나온다.

널 노드라고도 불리우는 * 노드는 종종 단어의 끝을 나타낸다. * 노드의 실제 구현은 특별한 종류의 자식 노드로 표현될 수도 있다.

트라이에서 각 노드는 1개에서 ALPHABET_SIZE + 1개까지 자식을 갖고 있을 수 있다. 트라이는 길이가 K인 문자열이 주어졌을 때 O(K) 시간에 해당 문자열이 유효한 접두사인지 확인할 수 있다.

