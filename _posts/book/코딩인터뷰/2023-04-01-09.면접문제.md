---
title: 09. 면접문제
date: 2023-04-01 22:14:48 +0900
categories: [BOOK, 코딩 인터뷰 완전분석]
tags: []  # TAG는 반드시 소문자로 이루어져야함!
---

## 01. 배열과 문자열
배열이나 문자열에 대한 문제들은 서로 대체 가능하다.

### 해시 테이블
해시테이블을 효율적인 탐색을 위한 자료구조로서 키(key)를 값에 대응시킨다. 간단한 해시 테이블을 구현하기 위해선 연결리스트와 해시 코드 함수만 있으면 된다. 키와 값을 해시테이블에 넣을때는 다음의 과정을 거친다.
1. 처음에 키의 해시 코드를 계산한다.(키의 자료형은 보통 int, long이 된다. 키의 개수는 무한대지만 int의 개수는 유한하므로 서로 다른 두 개의 키가 같은 해시 코드를 가리킬 수 있다.)
2. hash(key) % array.length와 같은 방식으로 해시 코드를 이용해서 배열의 인덱스를 구한다.(서로 다른 해시코드가 같은 인덱스를 가리킬 수 있다.)
3. 배열의 각 인덱스에는 키와 값으로 이루어진 연결 리스트가 존재한다. 키와 값을 해당 인덱스에 저장한다. (충돌에 대비해서 반드시 연결리스트를 이용해야 한다.)

키에 상응하는 값을 찾기 위해서는 다음과 같은 과정을 반복해야 한다.
1. 주어진 키로부터 해시 코드를 계산한다.
2. 해시 코드를 이용해서 인덱스를 계산한다.
3. 해당 키에 상응하는 값을 연결리스트에서 탐색한다.

충돌이 자주 발생한다면 최악의 경우 수행 시간은 O(N)이 된다. (N은 키의 갯수) 충돌을 최소화하도록 잘 구현된 경우 탐색시간은 O(1)이다.

또 다른 구현법으로는 균형 이진 탐색 트리를 사용하는 방법이 있다. 이 경우 탐색 시간이 O(logN)이 된다. 이 방법은 크기가 큰 배열을 미리 할당해 놓지 않아도 되기 때문에 잠재적으로 적은 공간을 사용한다는 장점이 있다.

### ArrayList와 가변 크기 배열
특정 언어에서 배열의 크기를 자동으로 조절할 수 있다. 자바 같은 언어에서 배열은 길이가 고정되어 있다. 동적 가변 크기 기능이 내재되어 있는 배열과 비슷한 자료구조를 원할 때는 보통 ArrayList를 사용한다. ArrayList는 필요에 따라 크기를 변화시킬 수 있으면서도 O(1)의 접근 시간을 유지한다. 통상적으로 배열이 가득 차는 순간, 배열의 크기를 두 배로 늘린다. 크기를 늘리는 순간은 O(N)이지만, 자주 발생하는 일이 아니라서 상환입력시간으로 계산했을 때 여전히 O(1)이 된다.

### StringBuilder
문자열 리스트가 주어졌을 때 이 문자열을 하나로 이어붙이려는 경우 이때 수행시간은 어떻게 될까?
```java
String joinWord(String[] words) {
  String sentence = "";
  for(String w : words) {
    sentence = sentence + w;
  }
  return sentence;
}
```
문자열을 이어붙일 때마다 두 개의 문자열을 읽어 들인 뒤 문자를 하나하나 새로운 문자열에 복사해야 한다. 따라서 총 수행시간은 O(x+2x+...nx) -> O(xn²)이 된다.

StringBuilder를 사용하면 이 문제를 해결할 수 있다. 이는 단순하게 가변 크기 배열을 이용해서 필요한 경우에만 문자열을 복사하게끔 해준다.
```java
String joinWord(String[] words) {
  StringBuilder sentence = new StringBuilder();
  for(String w : words) {
    sentence.append(w);
  }
  return sentence.toString();
}
```

### 면접 문제
1. 중복이 없는가 : 문자열이 주어졌을 때, 중복되어 등장하는 문자열이 있는지 확인하는 알고리즘을 작성하라
2. 순열 확인 : 문자열 두 개가 주어졌을 때, 이 둘이 서로 순열 관계에 있는지 확인하는 메서드를 작성하라 (순열이란? 문자열을 재배치하는 것을 뜻한다.)
3. URI화 : 문자열에 들어있는 모든 공백을 '%20'으로 바꿔주는 메서드를 작성하라, 모든 문자를 다 담을 수 있을 만큼 충분한 공간이 이미 확보되어 있으면 문자열의 최종 길이가 함께 주어진다고 가정해도 된다.
4. 회문 순열 : 주어진 문자열이 회문의 순열인지 아닌지 확인하는 함수를 작성하라 (회문이란? 앞으로 읽으나 뒤로 읽으나 같은 단어 혹은 구절을 의미한다.)
5. 하나 빼기 : 문자열을 같게 만들기 위한 편집 횟수가 1회 이내인지 확인하는 함수를 작성하라 (문자열 편집에는 문자삽입, 문자삭제, 문자교체)가 있다.
6. 문자열 압축 : 반복되는 문자의 개수를 세는 방식의 기본적인 문자열 압축 메서드를 작성하라 예)aabccccaaaa -> a2b1c4a4 만약 압축된 문자열의 길이가 기존 문자열의 길이보다 길다면 기존 문자열을 반환해야 한다.
7. 행렬 회전 : 이미지를 표현하는 N X N 행렬이 있다. 이미지의 각 픽셀은 4 바이트로 표현된다. 이때, 이미지를 90도 회전시키는 메서드를 작성하라. 행렬을 추가로 사용하지 않고서도 할 수 있겠는가
8. O 행렬 : M X N 행렬의 한 원소가 0일 경우, 해당 원소가 속한 행과 열의 모든 원소를 0으로 설정하는 알고리즘을 작성하라.
9. 문자열 회전 : 한 단어가 다른 문자열에 포함되어 있는지 판별하는 isSubstring이라는 메서드가 있다고 할 때, s1과 s2의 두 문자열이 주어졌고, s2가 s1을 회전시킨 결과인지 판별하고자 한다. isSubstring을 한 번만 호출해서 판별할 수 있는 코드를 작성하라

## 02. 연결리스트
연결리스트는 차례로 연결된 노드를 표현해주는 자료구조이다. 단방향 연결리스트에서 각 노드는 다음 노드를 가리킨다. 양방향 연결리스트에서 각 노드는 다음 노드와 이전 노드를 함께 가리킨다.

배열과 달리 연결리스트에서는 특정 인덱스를 상수 시간에 접근할 수 없다. 즉 리스트에서 k번째 원소를 찾고 싶다면 처음부터 k번 루프를 돌아야 한다. 리스트의 장점은 리스트의 시작 지점에서 아이템을 추가하거나 삭제하는 연산을 상수 시간에 할 수 있다는 점이다.

### 연결리스트 만들기
```java
//단방향 연결리스트
class Node {
  Node next = null;
  int data;

  public Node(int d) {
    data = d;
  }

  void appendToTail(int d) {
    Node end = new Node(d);
    Node n = this;
    while(n.next != null) {
      n = n.next;
    }
    n.next = end;
  }
}
```
연결리스트에 접근할 때 head 노드의 주소를 참조하는 방법을 사용했다. 이런식으로 구현할 때는 약간 조심해야 하는 부분이 있는데 여러 객체들이 동시에 연결리스트에 참조하는 도중에 head가 바뀌면 어떻게 해야 할지 생각해 봐야 하는 것이다. head가 바뀌었음에도 어떤 객체들은 이전 head를 계속 가리키고 있을 수도 있다.

할 수 있다면, Node 클래스를 포함하는 LinkedList 클래스를 만드는 게 좋다. 그렇게 하면 해당 클래스 안에 head Node 변수를 단 하나만 정의해 놓음으로써 위의 문제점을 완전히 해결할 수 있기 때문이다.

면접에서 연결리스트에 대해 이야기 할 때는 단방향 연결리스트에 대한 이야기인지 양방향 연결리스트에 대한 이야기인지 반드시 인지하고 있어야 한다.

### 단방향 연결리스트에서 노드 삭제
연결리스트에서 노드를 삭제하는 연산은 꽤 직관적이다. 노드 n이 주어지면, 그 이전 노드 prev를 찾아 prev.next를 n.next와 같도록 설정한다. 리스트가 양방향 연결리스트인 경우에는 n.next가 가리키는 노드를 갱신하여 n.next.prev가 n.prev와 같도록 설정해야 한다. 여기서 유의할 점은 1)널 포인터 검사를 반드시 해야한다. 2)필요하면 head와 tail 포인터도 갱신해야 한다.

### Runner 기법
Runner는 부가 포인터라고도 하며, 연결리스트 문제에서 많이 활용되는 기법이다. `연결리스트를 순회할 때 두 개의 포인터를 동시에 사용하는 것`이다. 이때 한 포인터가 다른 포인터보다 앞서도록 한다.

### 재귀 문제
연결리스트 관련 문제 가운데 상당수는 재귀 호출에 의존한다. 연결리스트 문제를 푸는 데 어려움을 겪고 있다면, 재귀적 접근법은 통할지 확인해 봐야 한다.

### 면접 문제
1. 중복 없애기 : 정렬되어 있지 않은 연결리스트가 주어졌을 때 이 리스트에서 중복되는 원소를 제거하는 코드를 작성하라
2. 뒤에서 k번째 원소 구하기 : 단방향 연결리스트가 주어졌을 때 뒤에서 k번째 원소를 찾는 알고리즘을 구하라
3. 중간 노드 삭제 : 단방향 연결리스트가 주어졌을 때 중간에 있는 노드 하나를 삭제하는 알고리즘을 구현하라(단, 삭제할 노드에만 접근할 수 있다.)
4. 분할 값 : x가 주어졌을 때 x보다 작은 노드들을 x보다 크거나 같은 노드들보다 앞에 오도록 하는 코드를 작성하라
5. 리스트의 합 : 표현된 숫자 두 개가 있을 때, 이 두수를 더하여 그 합을 연결리스트로 반환하는 함수를 작성하라. 예)(7->1->6) + (5->9->2) = 617 + 295
6. 회문 : 주어진 연결리스트가 회문인지 검사하는 함수를 작성하라
7. 교집합 : 단방향 연결리스트 두 개가 주어졌을 때 이 두 리스트의 교집합 노드를 찾은 뒤 반환하는 코드를 작성하라 (교집합은 노드의 값이 아닌 주소가 완전히 같은 경우를 말한다.)
8. 루프 발견 : 순환 연결리스트가 주어졌을 때, 순환되는 부분의 첫째 노드를 반환하는 알고리즘을 작성하라
