---
title: 09. 면접문제
date: 2023-04-01 22:14:48 +0900
categories: [BOOK, 코딩 인터뷰 완전분석]
tags: []  # TAG는 반드시 소문자로 이루어져야함!
---

## 01. 배열과 문자열
배열이나 문자열에 대한 문제들은 서로 대체 가능하다.

### 해시 테이블
해시테이블을 효율적인 탐색을 위한 자료구조로서 키(key)를 값에 대응시킨다. 간단한 해시 테이블을 구현하기 위해선 연결리스트와 해시 코드 함수만 있으면 된다. 키와 값을 해시테이블에 넣을때는 다음의 과정을 거친다.
1. 처음에 키의 해시 코드를 계산한다.(키의 자료형은 보통 int, long이 된다. 키의 개수는 무한대지만 int의 개수는 유한하므로 서로 다른 두 개의 키가 같은 해시 코드를 가리킬 수 있다.)
2. hash(key) % array.length와 같은 방식으로 해시 코드를 이용해서 배열의 인덱스를 구한다.(서로 다른 해시코드가 같은 인덱스를 가리킬 수 있다.)
3. 배열의 각 인덱스에는 키와 값으로 이루어진 연결 리스트가 존재한다. 키와 값을 해당 인덱스에 저장한다. (충돌에 대비해서 반드시 연결리스트를 이용해야 한다.)

키에 상응하는 값을 찾기 위해서는 다음과 같은 과정을 반복해야 한다.
1. 주어진 키로부터 해시 코드를 계산한다.
2. 해시 코드를 이용해서 인덱스를 계산한다.
3. 해당 키에 상응하는 값을 연결리스트에서 탐색한다.

충돌이 자주 발생한다면 최악의 경우 수행 시간은 O(N)이 된다. (N은 키의 갯수) 충돌을 최소화하도록 잘 구현된 경우 탐색시간은 O(1)이다.

또 다른 구현법으로는 균형 이진 탐색 트리를 사용하는 방법이 있다. 이 경우 탐색 시간이 O(logN)이 된다. 이 방법은 크기가 큰 배열을 미리 할당해 놓지 않아도 되기 때문에 잠재적으로 적은 공간을 사용한다는 장점이 있다.

### ArrayList와 가변 크기 배열
특정 언어에서 배열의 크기를 자동으로 조절할 수 있다. 자바 같은 언어에서 배열은 길이가 고정되어 있다. 동적 가변 크기 기능이 내재되어 있는 배열과 비슷한 자료구조를 원할 때는 보통 ArrayList를 사용한다. ArrayList는 필요에 따라 크기를 변화시킬 수 있으면서도 O(1)의 접근 시간을 유지한다. 통상적으로 배열이 가득 차는 순간, 배열의 크기를 두 배로 늘린다. 크기를 늘리는 순간은 O(N)이지만, 자주 발생하는 일이 아니라서 상환입력시간으로 계산했을 때 여전히 O(1)이 된다.

### StringBuilder
문자열 리스트가 주어졌을 때 이 문자열을 하나로 이어붙이려는 경우 이때 수행시간은 어떻게 될까?
```java
String joinWord(String[] words) {
  String sentence = "";
  for(String w : words) {
    sentence = sentence + w;
  }
  return sentence;
}
```
문자열을 이어붙일 때마다 두 개의 문자열을 읽어 들인 뒤 문자를 하나하나 새로운 문자열에 복사해야 한다. 따라서 총 수행시간은 O(x+2x+...nx) -> O(xn²)이 된다.

StringBuilder를 사용하면 이 문제를 해결할 수 있다. 이는 단순하게 가변 크기 배열을 이용해서 필요한 경우에만 문자열을 복사하게끔 해준다.
```java
String joinWord(String[] words) {
  StringBuilder sentence = new StringBuilder();
  for(String w : words) {
    sentence.append(w);
  }
  return sentence.toString();
}
```

### 면접 문제
1. 중복이 없는가 : 문자열이 주어졌을 때, 중복되어 등장하는 문자열이 있는지 확인하는 알고리즘을 작성하라
2. 순열 확인 : 문자열 두 개가 주어졌을 때, 이 둘이 서로 순열 관계에 있는지 확인하는 메서드를 작성하라 (순열이란? 문자열을 재배치하는 것을 뜻한다.)
3. URI화 : 문자열에 들어있는 모든 공백을 '%20'으로 바꿔주는 메서드를 작성하라, 모든 문자를 다 담을 수 있을 만큼 충분한 공간이 이미 확보되어 있으면 문자열의 최종 길이가 함께 주어진다고 가정해도 된다.
4. 회문 순열 : 주어진 문자열이 회문의 순열인지 아닌지 확인하는 함수를 작성하라 (회문이란? 앞으로 읽으나 뒤로 읽으나 같은 단어 혹은 구절을 의미한다.)
5. 하나 빼기 : 문자열을 같게 만들기 위한 편집 횟수가 1회 이내인지 확인하는 함수를 작성하라 (문자열 편집에는 문자삽입, 문자삭제, 문자교체)가 있다.
6. 문자열 압축 : 반복되는 문자의 개수를 세는 방식의 기본적인 문자열 압축 메서드를 작성하라 예)aabccccaaaa -> a2b1c4a4 만약 압축된 문자열의 길이가 기존 문자열의 길이보다 길다면 기존 문자열을 반환해야 한다.
7. 행렬 회전 : 이미지를 표현하는 N X N 행렬이 있다. 이미지의 각 픽셀은 4 바이트로 표현된다. 이때, 이미지를 90도 회전시키는 메서드를 작성하라. 행렬을 추가로 사용하지 않고서도 할 수 있겠는가
8. O 행렬 : M X N 행렬의 한 원소가 0일 경우, 해당 원소가 속한 행과 열의 모든 원소를 0으로 설정하는 알고리즘을 작성하라.
9. 문자열 회전 : 한 단어가 다른 문자열에 포함되어 있는지 판별하는 isSubstring이라는 메서드가 있다고 할 때, s1과 s2의 두 문자열이 주어졌고, s2가 s1을 회전시킨 결과인지 판별하고자 한다. isSubstring을 한 번만 호출해서 판별할 수 있는 코드를 작성하라

## 02. 연결리스트
연결리스트는 차례로 연결된 노드를 표현해주는 자료구조이다. 단방향 연결리스트에서 각 노드는 다음 노드를 가리킨다. 양방향 연결리스트에서 각 노드는 다음 노드와 이전 노드를 함께 가리킨다.

배열과 달리 연결리스트에서는 특정 인덱스를 상수 시간에 접근할 수 없다. 즉 리스트에서 k번째 원소를 찾고 싶다면 처음부터 k번 루프를 돌아야 한다. 리스트의 장점은 리스트의 시작 지점에서 아이템을 추가하거나 삭제하는 연산을 상수 시간에 할 수 있다는 점이다.

### 연결리스트 만들기
```java
//단방향 연결리스트
class Node {
  Node next = null;
  int data;

  public Node(int d) {
    data = d;
  }

  void appendToTail(int d) {
    Node end = new Node(d);
    Node n = this;
    while(n.next != null) {
      n = n.next;
    }
    n.next = end;
  }
}
```
연결리스트에 접근할 때 head 노드의 주소를 참조하는 방법을 사용했다. 이런식으로 구현할 때는 약간 조심해야 하는 부분이 있는데 여러 객체들이 동시에 연결리스트에 참조하는 도중에 head가 바뀌면 어떻게 해야 할지 생각해 봐야 하는 것이다. head가 바뀌었음에도 어떤 객체들은 이전 head를 계속 가리키고 있을 수도 있다.

할 수 있다면, Node 클래스를 포함하는 LinkedList 클래스를 만드는 게 좋다. 그렇게 하면 해당 클래스 안에 head Node 변수를 단 하나만 정의해 놓음으로써 위의 문제점을 완전히 해결할 수 있기 때문이다.

면접에서 연결리스트에 대해 이야기 할 때는 단방향 연결리스트에 대한 이야기인지 양방향 연결리스트에 대한 이야기인지 반드시 인지하고 있어야 한다.

### 단방향 연결리스트에서 노드 삭제
연결리스트에서 노드를 삭제하는 연산은 꽤 직관적이다. 노드 n이 주어지면, 그 이전 노드 prev를 찾아 prev.next를 n.next와 같도록 설정한다. 리스트가 양방향 연결리스트인 경우에는 n.next가 가리키는 노드를 갱신하여 n.next.prev가 n.prev와 같도록 설정해야 한다. 여기서 유의할 점은 1)널 포인터 검사를 반드시 해야한다. 2)필요하면 head와 tail 포인터도 갱신해야 한다.

### Runner 기법
Runner는 부가 포인터라고도 하며, 연결리스트 문제에서 많이 활용되는 기법이다. `연결리스트를 순회할 때 두 개의 포인터를 동시에 사용하는 것`이다. 이때 한 포인터가 다른 포인터보다 앞서도록 한다.

### 재귀 문제
연결리스트 관련 문제 가운데 상당수는 재귀 호출에 의존한다. 연결리스트 문제를 푸는 데 어려움을 겪고 있다면, 재귀적 접근법은 통할지 확인해 봐야 한다.

### 면접 문제
1. 중복 없애기 : 정렬되어 있지 않은 연결리스트가 주어졌을 때 이 리스트에서 중복되는 원소를 제거하는 코드를 작성하라
2. 뒤에서 k번째 원소 구하기 : 단방향 연결리스트가 주어졌을 때 뒤에서 k번째 원소를 찾는 알고리즘을 구하라
3. 중간 노드 삭제 : 단방향 연결리스트가 주어졌을 때 중간에 있는 노드 하나를 삭제하는 알고리즘을 구현하라(단, 삭제할 노드에만 접근할 수 있다.)
4. 분할 값 : x가 주어졌을 때 x보다 작은 노드들을 x보다 크거나 같은 노드들보다 앞에 오도록 하는 코드를 작성하라
5. 리스트의 합 : 표현된 숫자 두 개가 있을 때, 이 두수를 더하여 그 합을 연결리스트로 반환하는 함수를 작성하라. 예)(7->1->6) + (5->9->2) = 617 + 295
6. 회문 : 주어진 연결리스트가 회문인지 검사하는 함수를 작성하라
7. 교집합 : 단방향 연결리스트 두 개가 주어졌을 때 이 두 리스트의 교집합 노드를 찾은 뒤 반환하는 코드를 작성하라 (교집합은 노드의 값이 아닌 주소가 완전히 같은 경우를 말한다.)
8. 루프 발견 : 순환 연결리스트가 주어졌을 때, 순환되는 부분의 첫째 노드를 반환하는 알고리즘을 작성하라

## 03. 스택과 큐
### 스택 구현하기
스택 자료구조는 말그대로 데이터를 쌓아 올린다는 의미이다. 문제의 종류에 따라 배열보다 스택에 데이터를 저장하는 것이 더 적합한 방법일 수 있다.

스택은 Last-In-First-Out 에 따라 자료를 배열한다.
* pop() : 스택에서 가장 위에 있는 항목을 제거한다.
* push(item) : item 하나를 스택의 가장 윗 부분에 추가한다.
* peek() : 스택의 가장 위에 있는 항목을 반환한다.
* isEmpty() : 스택이 비어있을 때 true를 반환한다.

배열과 달리 스택은 상수 시간에 i번째 항목에 접근할 수 없다. 하지만 스택에서 데이터를 추가하거나 삭제하는 연산은 상수 시간에 가능하다.

```java
public class MyStack {
  private static class StackNode{
    private T data;
    private StackNode next;
    public StackNode(T data) {
      this.data = data;
    }
  }

    private StackNode top;
    public T pop() {
      if (top = null) throw new EmptyStackException() ;
      T item = top. data;
      top = top.next;
      return item;
    }
라      StackNode t = new StackNode (item);
      t.next = top;
      top = t.
    }
    public T peek(){
      if (top == null) throw new EmptyStackException ();
      return top.data;
    }
    public boolean isEmpty () {
      return top == null;
  }
}
```
스택이 유용한 경우는 재귀 알고리즘을 사용할 때다. 재귀적으로 함수를 호출해야 하는 경우에 임시 데이터를 스택에 넣어 주고, 재귀 함수를 빠져나와 퇴각 검색을 할 때는 스택에 넣어 두었던 임시 데이터를 빼 줘야 한다.

### 큐 구현하기
큐는 First-In-First-Out 순서에 따른다. 큐에 저장되는 항목들은 큐에 추가되는 순서대로 제거된다.
* add(item) : item을 리스트 끝 부분에 추가한다.
* remove() : 리스트의 첫 번째 항목을 제거한다.
* peek() : 큐에서 가장 위에 있는 항목을 반환한다.
* isEmpty() : 큐가 비어 있을 때는 true를 반환한다.

```java
public class MyQueue {
  private static class QueueNode {
    private T data;
    private QueueNode next;
    public QueueNode (T data) {
      this. data = data;
    }
 }
  private QueueNode first;
  private QueueNode last;

  public void add (T item) {
    QueueNode t = new QueueNode(item);
    if (last != null) {
      last.next = t;
    }
    last = t;
    if (first == null) {
      first = last;
    }
  }

  public T remove() {
    if (first == null) throw new NoSuchElementException ();
    T data = first. data;
    first = first. next;
    if (first == null) {
      last = null;
    }
    return data;
  }
  public T peek() {
    if (first == null) throw new NoSuchElementException () ;
    return first.data;
  }
  public boolean isEmpty () {
    return first == null;
  }
```
큐에서 처음과 마지막 노드를 갱신할 때 실수가 나오기 쉽다. 큐는 너비 우선 탐색을 하거나 캐시를 구현하는 경우에 종종 사용된다.

### 면접 문제
1. 한 개로 세 개 : 배열 한 개로 스택 세 개를 어떻게 구현할지 설명하라
2. 스택 Min : 기본적인 push와 pop 기능이 구현된 스택에서 최소값을 반환하는 min 함수를 추가하려고 한다. 어떻게 설계할 수 있겠는가?
3. 접시 무더기 : 접시 무더기를 생각해보면 접시를 너무 높이 쌓으면 무너져 내릴 것이다. 현실에서는 무더기가 어느 정도 높아지면 새로운 무더리를 만든다. 이것을 흉내내는 자료구조 SetOfStack을 구현해보라
4. 스택으로 큐 : 스택 두 개로 큐 하나를 구현한 MyQueue 클래스를 구현하라
5. 스택 정렬 : 가장 작은 값이 위로 오도록 스택을 정렬하는 프로그램을 작성하라
6. 동물 보호소 : 먼저 들어온 동물이 먼저 나가는 동물 보호소가 있을때 사람들은 보호소에서 가장 오래된 동물부터 입양할 수 있는데 개와 고양이중 어떤 동물을 데려갈지 선택할 수 있다. 이 시스템을 자료구조로 구현하

## 04. 트리와 그래프
트리에서 탐색하는 것이 배열이나 연결리스트처럼 선형으로 구성된 자료구조에서 탐색하는 것보다 훨씬 까다롭다. 또 최악의 수행시간과 평균적 수행시간이 매우 크게 바뀔 수 있어서, 알고리즘을 살펴볼 때에는 두 가지 측면 모두를 반드시 따져 봐야 한다.

### 트리의 종류
트리를 이해하기 위한 좋은 방법 중 하나는 재귀적 설명법을 사용하는 것이다.
* 트리는 하나의 루트 노드를 갖는다.
* 루트 노드는 0개 이상의 자시 노드를 갖고 있다.
* 그 자식노드 또한 0개 이상의 자식 노드를 갖고 있다.

트리에는 사이클이 존재할 수 없다. 노드들은 특정 순서로 나열될 수도 있고, 그럴 수 없을 수도 있다. 각 노드는 어떤 자료형으로도 표현 가능하다.

트리 및 그래프 문제들은 대부분 세부사항이 모호하거나 가정 자체가 틀린 경우가 많다. 아래의 이슈들을 유의하고 명확하게 해줄 것을 요구하자.
1. 트리 vs 이진 트리 : 이진 트리는 각 노드가 최대 두 개의 자식을 갖는 트리를 말한다.
2. 이진 트리 vs 이진 탐색 트리 : 이진 탐색 트리는 모든 노드가 특정 순서를 따르는 속성이 있는 이진 트리를 일컫는다. 많은 지원자들이 트리 문제가 주어지면 이진 탐색트리 일 것이라고 가정해 버린다. 이진탐색 트리인지 아닌지 확실하게 묻도록 하자
3. 균형 vs 비균형 : 많은 트리가 균형 잡혀 있긴 하지만, 전부 그런것은 아니다. 면접관에게 어느쪽인지 묻도록 하자.
4. 완전 이진 트리 : 완전 이진 트리는 트리의 모든 높이에서 노드가 꽉 차 있는 이진 트리를 말한다. 마지막 단계는 꽉차있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져야 한다.
5. 전 이진 트리 : 전 이진 트리는 모든 노드의 자식이 없거나 정확히 두 개 있는 경우를 말한다. (자식이 하나만 있는 노드가 존재해서는 안 된다.)
6. 포화 이진 트리 : 포화 이진 트리는 전 이진 트리이면서 완전 이진 트리인 경우를 말한다. 모든 말단 노드는 같은 높이에 있어야 하며, 마지막 단계에서 노드의 개수가 최대가 되어야 한다.

### 이진 트리 순회
1. 중위 순회 : 중위 순회는 왼쪽 가지, 현재 노드, 오른쪽 가지 순서로 노드를 방문하고 출력하는 방법을 말한다. 이진 탐색 트리를 이 방식으로 순회한다면 오름차순으로 방문하게 된다.
2. 전위 순회 : 전위 순회는 자식 노드보다 현재 노드를 먼저 방문하는 방법을 말한다. 전위 순회에서 가장 먼저 방문하게 될 노드는 언제나 루트이다.
3. 후위 순회 : 후위 순회는 모든 자식 노드들을 먼저 방문한 뒤 마지막에 현재 노드를 방문하는 방법을 말한다. 후위 순회에서 가장 마지막에 방문하게 될 노드는 언제나 루트이다.

### 이진 힙(최소힙과 최대힙)
최소힙은 트리의 마지막 단계에서 오른쪽 부분을 뺀 나머지 부분이 가득 채워져 있다는 점에서 완전 이진 트리이며, 각 노드의 원소가 자식들의 원소보다 작다는 특성이 있다. 따라서 루트는 트리 전체에서 가장 작은 원소가 된다. 최대 힙은 원소가 내림차순으로 정렬되어 있다는 점만 다를 뿐 최소힙과 완전히 같다.

1. 삽입 : 최소힙에 원소를 삽입할 때는 언제나 트리의 밑바닥에서부터 삽입을 시작한다. 완전 트리의 속성에 위배되지 않게 새로운 원소는 밑바닥 가장 오른쪽 위치로 삽입된다. 힙에 있는 노드의 개수를 n이라 할 때, 연산은 O(log n)시간이 걸린다.
2. 최소 원소 뽑아내기 : 최소힙에서 최소 원소를 찾기란 가장 쉬운 일이다. 최소 원소는 언제나 가장 위에 놓인다. 최솟값을 어떻게 힙에서 제거하느냐가 까다로운 부분이다.

### 트라이(접두사 트리)
트라이는 n-차 트리의 변종으로 각 노드에 문자를 저장하는 자료구조이다. 따라서 트리를 아래쪽으로 순회하면 단어 하나가 나온다.

널 노드라고도 불리우는 * 노드는 종종 단어의 끝을 나타낸다. * 노드의 실제 구현은 특별한 종류의 자식 노드로 표현될 수도 있다.

트라이에서 각 노드는 1개에서 ALPHABET_SIZE + 1개까지 자식을 갖고 있을 수 있다. 트라이는 길이가 K인 문자열이 주어졌을 때 O(K) 시간에 해당 문자열이 유효한 접두사인지 확인할 수 있다.

### 그래프
트리는 그래프의 한 종류이다. 그렇다고 모든 그래프가 트리는 아니다. 트리는 사이클이 없는 하나의 연결 그래프이다.

그래프는 단순히 노드와 그 노드를 연결하는 간선을 하나로 모아 놓은 것과 같다.

그래프에는 방향성이 있을 수도 있고, 없을 수도 있다. 방향성이 있는 간선은 일방통행, 방향성이 없는 간선은 양방향 통행 도로라고 생각하면 된다. 모든 정점 쌍간에 경로가 존재하는 그래프는 연결 그래프라고 부른다. 그래프에는 사이클이 존재할 수도 있고, 존재하지 않을 수도 있다. 사이클이 없는 그래프는 비순환 그래프라고 부른다.

<img src="/assets/img/posting_img/book/코딩인터뷰/그래프.jpeg" width="500px">

인접 리스트 : 인접 리스트는 그래프를 표현할 때 사용되는 가장 일반적인 방법이다. 모든 정점을 인접 리스트에 저장한다. 그래프는 트리와 달리 특정 노드에서 다른 모든 노드로 접근이 가능하지는 않다.

```java
//그래프 클래스는 트리의 노드 클래스와 같아 보인다.
class Graph {
  public Node[] nodes;
}

class Node {
  public String name;
  public Node[] children;
}
```

인접 행렬 : 인접 행렬은 N x N 불린 행렬로써 `matrix[i][j]`가 true라면 i에서 j로의 간선이 있다는 뜻이다. (???) 무방향 그래프를 인접 행렬로 표현한다면 이 행렬은 대칭행렬이 된다.

그래프 탐색 : 그래프를 탐색하는 방법으로는 깊이 우선 탐색과 너비 우선 탐색이 있다.
1. 깊이 우선 탐색은 루트 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법을 말한다. (넓게 탐색하기 전에 깊에 탐색한다.)
2. 너비 우선 탐색은 루트 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법을 말한다.

<img src="/assets/img/posting_img/book/코딩인터뷰/그래프탐색.jpeg" width="700px">

깊이 우선 탐색(DFS)는 그래프에서 모든 노드를 방문하고자 할 때 더 선호되는 편이다. a노드를 방문한 뒤 a와 인접한 노드들을 차례로 순회한다. a와 인접한 b를 방문했다면, a와 인접한 또 다른 노드를 방문하기 전에 b의 이웃 노드들을 전부 방문해야 한다.

그래프 탐색시 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다. 이를 검사하지 않는다면 무한루프에 빠질 수 있다.

두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때는 너비 우선 탐색(BFS)가 일반적으로 더 낫다.

너비 우선 탐색은 직관적이지 않은 면이 있다. 가장 많은 실수가 BFS가 재귀적으로 동작할 것이라 가정하는데 재귀적으로 동작하지 않는다. `BFS는 큐를 사용`한다. a 노드에서 시작한다고 했을 때 BFS는 a 노드의 이웃 노드를 모두 방문한 다음에 이웃의 이웃들을 방문한다. 즉 a에서 시작해서 거리에 따라 단계별로 탐색한다고 볼 수 있다.

양방향 탐색 : 양방향 탐색은 출발지와 도착지 사이에 최단 경로를 찾을 때 사용되곤 한다. 기본적으로 출발지와 도착지 두 노드에서 동시에 너비 우선 탐색을 수행한 뒤 두 탐색 지점이 충돌하는 경우에 경로를 찾는 방식이다.

<img src="/assets/img/posting_img/book/코딩인터뷰/양방향 탐색.jpeg" width="700px">

### 면접 문제
1. 노드 사이의 경로 : 방향 그래프가 주어졌을 때 두 노드 사이에 경로가 존재하는지 확인하는 알고리즘을 작성하라
2. 최소 트리 : 오름차순으로 정렬된 배열이 있다. 이 배열안에 들어있는 원소는 정수이며 중복된 값이 없다고 했을 때 높이가 최소가 되는 이진탐색트리를 만드는 알고리즘을 작성하라
3. 깊이의 리스트 : 이진 트리가 주어졌을 때 같은 깊이에 있는 노드를 연결리스트로 연결해주는 알고리즘을 설계하라
4. 균형 확인 : 이진 트리가 균형 잡혀있는지 확인하는 함수를 작성하라
5. BST 검증 : 주어진 이진 트리가 이진 탐색 트리인지 확인하는 함수를 작성하라
6. 후속자 : 이진 탐색 트리에서 주어진 노드의 다음 노드를 찾는 알고리즘을 작서앟라
7. 순서 정하기 : 프로젝트의 리스트와 프로젝트들 간의 종속 관계가 주어졌을 때 프로젝트를 수행해 나가는 순서를 찾으라
8. 첫 번째 공통 조상 : 이진 트리에서 노드 두 개가 주어졌을 때 이 두 노드의 첫번째 공통 조상을 찾는 알고리즘을 설계하고 그 코드를 작성하라
9. BST 수열 : 배열의 원소를 왼쪽에서부터 차례로 트리에 삽입함으로써 이진 탐색 트리를 생성할 수 있다. 이진 탐색 트리 안에서 원소가 중복되지 않는 다고 할 때, 해당 트리를 만들어 낼 수 있는 모든 가능한 배열을 출력하라.
10. 하위 트리 확인 : 두 개의 커다란 이진 트리 T1과 T2가 있다고 하자. T1이 T2 보다 훨씬 크다고 했을 때, T2가 T1의 하위 트리(subtree)인지 판별하는 알 고리즘올 만들라.
11. 임의의 노드 : 이진 트리 클래스를 바닥부터 구현하려고 한다. 노드의 삽입, 검색, 삭제뿐만 아니라 임의의 노드를 반환하는 getRandomNode() 메서드도 구현한다. 모든 노드를 같은 확률로 선택해주는 getRandomNode 메서드를 설계하고 구현하라
12. 합의 경로 : 각 노드의 값이 정수인 이진 트리가 있다. 이때 정수의 합이 특정 값이 되도록 하는 경로의 개수를 세려고 한다. 경로는 꼭 위에서 아래로 내려가야 한다. 즉 부모 노드에서 자식 노드로만 움직일 수 있다. 이 알고리즘을 설계하라

## 05. 비트 조작
비트 조작 기법은 다양한 문제에서 활용된다. 명시적으로 요구하는 문제들도 있는 한편, 코드를 최적화할 때 유용하게 사용되는 기법으로 활용되기도 한다. 비트 조작 코드를 작성하는 능력뿐 아니라 손으로도 그릴 수 있도록 익숙해 지는 것이 좋다.

### 손으로 비트 조작 해보기
<img src="/assets/img/posting_img/book/코딩인터뷰/비트조작.jpeg" width="700px">

### 비트 조작을 할 때 알아야 할 사실들과 트릭들
비트 조작 문제를 풀 때 다음의 표현식들을 알아 두면 좋다.

<img src="/assets/img/posting_img/book/코딩인터뷰/비트조작표현식.jpeg" width="700px">

위 표현식들을 이해하기 위해서는 연산들이 비트 단위로 이루어진다는 사실을 명심해야 한다. 한 비트에서 일어나는 일이 다른 비트에 어떤 영향도 미치지 않는다. 그러므로 위 표현식이 한 비트에 대해 참이라면 일련의 비트들에 대해서도 참이 된다.

### 산술 우측 시프트 vs 논리 우측 시프트
산술 우측 시프트는 기본적으로 2로 나눈 결과와 같다. 논리 우측 시프트는 우리가 일반적으로 비트를 옮길 때 보이는 것처럼 움직인다.

논리 우측 시프트는 비트를 옆으로 옮긴 다음에 최상위 비트에 0을 넣는다. 즉, >>> 연산과 같다.

### 기본적인 비트 조작 : 비트값 확인 및 채워넣기
__비트값 확인__

```java
//이 메서드는 1을 i비트만큼 시프트해서 00010000과 같은 값을 만든다.
//그 다음 AND 연산을 통해 num의 i번째 비트를 뺀 나머지 비트를 모두 삭제한 뒤, 이 값을 0과 비교한다.
//만약 이 값이 0이 아니라면 i번째 비트는 1이어야 하고, 0이라면 i번째 비트는 0이어야 한다.
boolean getBit(int num, int i) {
  return((num & (1 << i)) != 0);
}
```

__비트값 채워넣기__

```java
//SetBit는 1 i비트만큼 시프트해서 00010000과 같은 값을 만든다.
//그 다음 OR 연산을 통해 num의 i번째 비트값을 바꾼다.
//i번째를 제외한 나머지 비트들은 0과 OR 연산을 하게 되므로 num에 아무 영향을 끼치지 않는다.
int setBit(int num, int i) {
  return num | (1 << i);
}
```

__비트값 삭제하기__

```java
//이 메서드는 setBit를 거의 반대로 한 것과 같다. NOT 연산자를 이용해 00010000 -> 11101111과 같이 만든 뒤 num과 AND 연산을 수행한다.
//그러면 나머지 비트의 값은 변하지 않은채 i번째 비트값만 삭제된다.
int clearBit(int num, int i) {
  int mask = ~(1 << i);
  return num & mask;
}
```

__비트값 바꾸기__

i번째 비트값을 v로 바꾸고 싶다면 우선 11101111과 같은 값을 이용해 (i=4인 경우) i번째 비트값을 삭제해야 한다. 그 뒤 우리가 바꾸고자 하는 값 v를 왼쪽으로 i번 시프트한다.

### 면접 문제
1. 삽입 : 두 개의 32비트 수 N과 M이 주어지고, 비트 위치 i와 j가 주어졌을 때, M을 N에 삽입하는 메서드를 구현하라.
2. 2진수를 문자열로 : 0.72와 같이 0 과 1 사이의 실수가 double 타입으로 주어 졌을 때, 그 값을 2진수 형태로 출력하는 코드를 작성하라.
3. 비트 뒤집기 : 어떤 정수가 주어졌을 때 여러분은 이 정수의 비트 하나를 0에서 1로 바꿀 수 있다. 이때 1이 연속으로 나올 수 있는 가장 긴 길이를 구하는 코드를 작성하라.
4. 다음 숫자 : 양의 정수가 하나 주어졌다. 이 숫자를 2진수로 표기했을 때 1 비트의 개수가 같은 숫자중에서 가장 작은 수와 가장 큰 수를 구하라.
5. 디버거 : 다음 코드가 하는 일을 설명하라 `((n & (n-1)) == 0)`
6. 변환 : 정수 A와 B를 2진수로 표현했을 때 A를 B로 바꾸기 위해 뒤집어야 하는 비트의 개수를 구하는 함수를 작성하라
7. 쌍끼리 맞바꾸기 : 명령어를 가능한 한 적게 사용해서 주어진 정수의 짝수 번째 비트의 값과 홀수번째 비트의 값을 바꾸는 프로그램을 작성하라
8. 선 그리기 : 흑백 모니터 화면은 하나의 바이트 배열에 저장되는데, 인접한 픽셀 여덟 개를 한 바이트에 묶어서 저장한다. 화면의 폭은 w이며, w는 8로 나누어 떨어진다. 이때 (x1, y)에서 (x2, y)까지 수평선을 그려주는 함수를 작성하라

## 06. 수학 및 논리 퍼즐
많은 문제들이 수학 혹은 컴퓨터 과학에 기초해서 만들어졌기 때문에 대부분 논리적인 추론으로 해법을 찾을 수 있다.

### 소수
모든 자연수는 소수의 곱으로 나타낼 수 있다는 규칙이 있다.

1. 가분성 : 어떤 수 x로 y를 나눌 수 있으려면 x를 소수의 곱으로 분할하였을 때 나열되는 모든 소수는 y를 소수의 곱으로 분할하였을 때 나열되는 모든 소수들의 부분집합이어야 한다.
2. 소수판별 : 어떤 수 n이 소수인지 여부를 판별하는 가장 단순한 방법은 2에서 n-1까지 루프를 돌면서 나누어지는 경우가 있는지 확인해 보는 것이다.
3. 소수 목록 만들기(에라토스테네스의 체) : 에라토스테네스의 체는 소수 목록을 만드는 굉장히 효율적인 방법이다. 이 알고리즘은 소수가 아닌 수들은 반드시 다른 소수로 나누어진다는 사실에 기반해서 동작한다.

```java
boolean [] sieve0fEratosthenes(int max) {
  boolean[] flags = new boolean [max + 1];
  int count = 0;
  init(flags); // 0과 1번 인덱스를 제외한 모든 원소값을 true로 초기화한다.
  int prime = 2;

  while (prime s= Math.sart (max)) {
    /* prime의 배수들을 지워나간다. */
    cross0ff(flags, prime);

    /* 그다음 true로 세팅된 인덱스를 찾는다. */
    prime = getNextPrime (flags, prime);
  }
  return flags;
}
void crossOff (boolean [] flags, int prime) {
  /* prime의 배수들을 제거해나간다. K < prime인 k에 대한 k * prime은
  * 이전 루프에서 이미 제거되었을 것이므로 prime * prime부터 시작한다. */
  for (int i = prime * prime; i < flags.length; i += prime)
    flags [i] = false;
  }
}

int getNextPrime (boolean [] flags, int prime) {
  int next = prime + 1;
  while (next < flags.length && !flags[next]) {
    next++;
  }
  return next;
}
```
