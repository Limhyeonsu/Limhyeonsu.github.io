---
title: 7장 데이터 구조와 처리
date: 2022-06-11 23:40:35 +0900
categories: [BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍]
tags: [computer]  # TAG는 반드시 소문자로 이루어져야함!
---

## 기본 데이터 타입
프로그래밍 언어에는 다양한 기본 데이터 타입을 제공한다. 이런 타입에는 크기(size)와 해석이라는 두 가지 측면이 존재한다.

1964년 포인터를 발명했다. 포인터는 단지 컴퓨터 아키텍처에 따라 결정되는 크기의 부호가 없는 정수에 불과하며 정숫값이 아니라 메모리 주소로 해석된다. 포인터를 통하여 원하는 값이 있는 위치를 알 수 있다.
포인터는 C언어가 인기를 끌면서 유명세를 탔고 일부 언어는 잘못된 포인터 사용으로 인한 오류를 막기 위해 참조라는 더 추상적인 개념을 구현하기도 한다.

## 배열
프로그래밍 언어는 배열을 지원한다. 배열은 마치 아파트와 같다. 아파트 한 동에는 주소가 있고, 동 안의 각 집에는 번호가 있다. 프로그래머는 이 호수를 인덱스라고 부르고 각각의 집을 원소(element)라고 부른다.
일반적인 컴퓨터 개발 규정에는 배열 원소의 타입이 모두 같아야 한다고 정해져 있다.

배열에서 각 원소는 0번째 원소의 주소인 기저 주소로부터 얼마나 멀리 떨어져 있는지를 나타내는 오프셋으로 지정할 수 있다. 프로그래밍 언어는 다차원 배열을 지원하기도 한다. 다차원 배열이 메모리에 어떻게 저장되는지 잘 알아야 한다.

예) 4 X 3 2차원 아파트 건물 집집마다 전단지를 돌린다고 할때 1)[0,0], [0,1], [0,2], [1,0], [1,1], [1,2]....순으로 방문 2)[0,0], [1,0], [2,0], [0,1], [1,1], [2,1]...순으로 방문

두 번째 방식이 첫 번째 방식보다 지역성이 좋고 힘도 덜 든다. 열 인덱스가 1 바뀌면 [0,0] -> [0,1] 인접한 메모리 위치에 있는 원소로 이동하지만 행 인덱스가 1 바뀌면 [0,0] -> [1,0] 인접한 행으로 이동해야 하기 때문에 연속적인 메모리 공간상으로는 배열의 열 개수만큼 떨어져있는 메모리 위치에 있는 원소로 이동해야 한다.
따라서 주소 공간상에서는 열 인덱스가 바뀔 때보다 행 인덱스가 바뀔 때 더 많은 이동이 일어난다.

## 비트맵
기본 데이터 타입을 사용해 배열을 사용하는 경우 원하는 데이터를 표시하기에는 기본 데이터가 너무 클 때도 있다. 그럴때 비트의 배열인 비트맵을 사용할 수 있다.
비트맵에 대해 수행할 수 있는 기본 연산은 1)비트 설정하기(set), 2)비트 지우기(clear), 3)비트가 1인지 검사하기, 4)비트가 0인지 검사하기 네 가지가 있다.

정수 나눗셈을 통해 특정 비트가 들어 있는 바이트를 찾을 수 있다. 필요한 연산은 8로 나누는 것 뿐이다. 다음 단계로 비트 위치에 대한 마스크를 만들어야 한다. 마스크는 들여다볼 수 있는 구멍이 있는 비트 패턴을 말한다.
배열 인덱스와 비트 마스크를 사용하면 비트맵 기본연산을 쉽게 수행할 수 있다. 또 자원이 사용 가능하거나 사용 중인지 여부를 나타낼ㄷ 때도 비트 맵을 유용하게 사용할 수 있다.

## 문자열
여러 문자로 이뤄진 시퀀스를 문자열이라고 한다. 배열과 마찬가지로 문자열을 연산할 때도 그 길이를 알아야 한다. 한 가지 접근 방법은 문자열 안에 길이를 저장하는 것이다. 하지만 이 방법은 잘 작동하지만 문자열 길이가 255자로 제한된다는 단점을 가지고 있다.

C언어에서는 다른 접근 방법을 사용한다. 문자열을 위한 전용 데이터 타입을 제공하지 않고 대신 1차원 바이트 배열을 사용한다.(char) C 문자열은 길이를 저장하지 않고 대신 무자 배열에 들어있는 문자열 데이터의 끝에 바이트를 하나 추가하고 문자열의 끝을 표시하는 문자로 NUL(문자열 터미네이터)을 넣는다.

이런 문자열 터미네이터를 사용하는 방식에는 장단점이 있는데 중요한 장점으로 저장이 쉽다는 점이 있고, 문자열의 끝까지 각 문자를 출력하는 일을 할 때 부가 비용이 들지 않는다는 점이 있다. 단점으로는 문자열의 길이를 알아내려면 문자열 터미네이터를 발견할 때까지 문자열을 스캔하면서 문자 수를 세야한다. 또 문자열 중간에 NUL 문자를 넣고 싶을때는 이 방법을 사용할 수 없다.

## 복합 데이터 타입
현재 대부분의 언어는 우리가 원하는대로 데이터 타입, 즉 suite를 만들 수 있는 방법을 제공한다. 이를 구조체라고 한다. 그리고 구조체 스위트 안에 있는 여러 방을 구조체의 멤버라고 한다.

<img src="/assets/img/posting_img/book/programingStructure/일시구조체.jpeg" width="700px">

스위트 같은 데이터 구조 이외에 움직일 수 있는 파티션으로 구분한 사무실 같은 데이터 구조를 사용할 수도 있다. 이런 데이터 구조를 C에서는 공용체라고 부른다. 공용체를 사용하면 같은 메모리 공간이나 내용을 여러 가지 관점으로 바라볼 수 있다.

구조체와 공용체의 차이점은 구조체 안의 모든 멤버는 각기 다른 메모리를 차지하지만 공용체의 멤버들은 메모리를 공유할 수 있다는 데 있다.

## 단일 연결 리스트
데이터 양이 정해져 있지 않은 경우 배열이 적합하지 않다. 배열을 충분히 크게 만들지 않으면 데이터가 늘어난 경우 새로 더 큰 배열을 만들고 기존 배열의 내용을 새 배멸로 복사해야한다. 반대로 배열의 크기를 크게 잡아놓으면 메모리를 너무 낭비하게 된다.

연결 리스트는 목록에 들어갈 원소 개수를 모르는 경우 배열보다 더 잘 작동한다.

<img src="/assets/img/posting_img/book/programingStructure/단일연결리스트.jpeg" width="700px">

next는 리스트의 다음 원소 주소를 저장하는 포인터고, 리스트에서 맨 앞은 헤드, 마지막은 테일이다. 배열과의 차이점은 배열은 메모리에 연속적으로 위치하지만, 리스트 원소는 메모리에서 아무 위치에나 있을 수 있다는 점이 있다.
따라서 리스트에는 원소를 쉽게 추가할 수 있다. 삭제는 조금 복잡한데 삭제할 원소의 바로 앞 원소의 next 포인터가 삭제할 원소의 next 포인터가 가리키는 원소를 가리키게 해야하기 때문이다.

<img src="/assets/img/posting_img/book/programingStructure/간접주소지정.jpeg" width="700px">
