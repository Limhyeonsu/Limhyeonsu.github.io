---
title: 13장 컴퓨터 보안
date: 2022-06-22 21:02:25 +0900
categories: [BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍]
tags: [computer]  # TAG는 반드시 소문자로 이루어져야함!
---

컴퓨터 네트워크 발달은 작은 아파트 보안 문제에서 큰 성의 보안 문제로 변화시켰다. 큰 성은 지켜야할 출입구가 많고 성이 커질수록 더 많은 쓰레가 쌓이고 버그가 숨을 공간도 많아진다.
보안의 핵심은 우리가 정의한 안전함에 따라 유지하는 것이다. 그리고 안전함의 정의는 다른 사람들이 정한 정의와도 균형을 맞춰야 한다.

## 보안과 프라이버시 개요
### 1) 위협 모델
보안은 위협 모델에 따라 상대적이다. 위협 모델은 보안이 필요한 대상 목록과 각 보안 대상에 가해질 수 있는 공격을 열거해서 이런 공격을 방어하는 방법을 설계할 수 있게 한다.
위협 모델을 이해하는 것이 중요하고 모델에 따라 적합한 방어를 설계해아 한다.

### 2) 신뢰
위협 모델을 정할 때 가장 어려운 부분은 신뢰할 대상을 정하는 것이다. 네트워크로 연결된 컴퓨터 세계에서 신뢰할 대상을 선택하는 것은 아주 제한적이다. 컴퓨터 보안 세계에서 신뢰는 선택할 수 없지만 의존해야 하는 대상을 가리킨다. 즉 보안은 이런 구성요소의 보안에 달려 있다.
컴퓨터를 사용하면 수많은 하드웨어, 소프트웨어에 의존해야 한다. 이들의 소스 코드를 볼 수 없어도 의존할 수밖에 없다.

[신뢰 위반]

1. 의도적 : 예) 소니가 고객 컴퓨터에 설치했던 루트킷(시스템의 보호를 우회시킴), 레노보가 랩톱에 설치한 광고를 표시하는 멀웨어(악의적인 소프트웨어)가 있다.
2. 무능 : 암호화 되지 않은 비밀번호 사용 등
3. 부정직 : 예) 미국 국립 표준 기술 연구소가 미국 국가안보국(NSA)에서 온 전문가의 도움을 받아 만든 암호 표준 -> NSA 전문가들이 의도적으로 표준을 강화하지 않고 악화시켰음이 드러남

투명성이나 개방성에서 더 나은 보안을 얻을 수 있다. 더 많은 사람이 현재 사용 중인 보안 기술에 대해 교육받으면 받을수록 보안 기술의 약점에 대해 더 많이 토의하고 약점을 더 잘 발견하게 된다.

### 3) 물리적 보안
학교 사물함을 예를 들어 생각해 보면 사물함의 문은 공격 표면이다. 사물함 문에 달린 번호 자물쇠는 올바른 번호와 순서로 열어야 열리며 자물쇠의 주인은 이를 알고 있어야 한다.  학교가 이 조합을 알려주는 것은 특정 사물함을 열 수 있는 권한을 부여하는 것이다. 번호 자물쇠 가운데이는 열쇠 구멍이 있고
보안 전문가들은 이를 백도어 라고 부른다. 이 구멍은 내가 제어할 수 없지만 누군가 사물함을 열 수 있는 또 다른 방법이다. 백도어는 학교에서 모든 학생의 사물함을 빠르게 열 수 있도록 편의상 만든 것이고 이로 인해 모두의 보안이 나빠진다.

### 4) 통신 보안
예를 들어 오늘까지 숙제 제출 마감인데 병원 예약 때문에 직접 제출할 수 없어 친구에게 부탁한다고 가정하면 첫 번째 인증 단계를 거친다. 숙제를 부탁할 대상이 진짜 나의 친구인지 성격 나쁜 쌍둥이 동생일 수도 있다.
그리고 내 손을 떠난 순간부터 온갖 일이 벌어질 수 있다. 친구가 숙제 제출을 까먹을 수도 있고 숙제를 고쳐서 답을 틀리게 하던가 나쁜 짓을 할 수도 있다. 이 경우 친구가 나의 숙제를 그대로 제출했음을 증명할 방법이 없다.(진봉성)

만약 숙제를 우편으로 제출해도 되는 경우 불특정 다수가 편지를 다룰 수 있기 때문에 중간자 공격이 가능해진다. 이 경우에는 cryptography를 통해 해결할 수 있다. 메시지를 받을 수신자만 아는 비밀 코드를 사용해 암호화하여 보내면 수신자는 비밀 코드를 사용해 메시지를 복호화 한다.
제대로 설계된 암호 시스템은 당사자 사이에 신뢰하는 요소의 수를 감소시킨다.

### 5) 모던 타임즈
연결된 컴퓨터 시대는 물리적 보안 문제를 통신 보안 문제와 결합시켰다. 컴퓨터와 전화는 전 지구적인 인터넷에 연결되어 있고 인터넷은 너무 큰 공격 표면이기 때문에 적어도 어느 한 곳에서는 신뢰가 깨질 것이라 예상해야 한다. 그리고 인터넷을 통한 공격자는 근본적으로 눈으로 볼 수 없다.
그리고 요즘엔 공격자가 프로그램이기 더이상 사람이 아니다. 예를 들어 초인종을 누르고 도망가는 사람이 있다. 이 사람이 충분히 지속성이 있다면 이들로 인해 다른 사람이 대문의 초인종을 누르지 못할 수도 있다. 정당한 고객들이 서비스를 박지 못하게 방해하기 때문에 이런 형태의 공격을 '서비스 거부 공격(DoS)'이라고 부른다.
오늘날 대부분 '분산 서비스 거부 공격(DDOS)'으로 이뤄진다. 이는 엄청나게 많은 사람이 협력해서 초인종을 누르는 상황과 비슷하다.

공격자의 추적을 어렵게 하는 요인중 하나로 공격자가 proxy를 사용한다는 점이다. 몇몇 기계에 침입해서 자신의 소프트웨어를 설치하고 그 기계로 하여금 더러운 일을 하게 만든다.

공격에는 주로 두 가지 유형이 있다. 1)크립토그래피 시스템 공격은 상대적으로 드물고 잘 설계된 시스템을 공격하기는 어렵다. 2)트릭을 써서 사용자가 자신의 컴퓨터에 소프트웨어를 직접 설치하게 만드는 사회적 공격

현대에 생긴 또 다른 문제로는 비트를 조작하면 물리적인 반향을 일으킬 수 있게 됐다는 점이있다. 예)집에 보일러를 꺼버리거나 진공 청소기를 프로그래밍 해서 집의 고양이에게 테러를 가하거나 침입 경보기를 끄는 경우를 들 수 있다.

### 6) 메타데이터와 감시
암호화가 통신 내용을 비밀로 유지할 수 있다고 해도 단지 통신 패턴을 관찰하는 것만으로도 많은 정보를 얻을 수 있다. 편지를 보낸다고 할 때 편지 봉투의 누구에게 편지를 쓰고 누가 보내는지에 대한 정보를 메타데이터라고 한다. 이 정보는 데이터에 대한 데이터이다.
누군가는 이 정보를 통해 친구의 정보를 얻을 수 있다. 현대에는 SNS를 통해 친구들의 정보를 가져가는 것이 쉬워졌다.

### 7) 사회적 맥락
보안에는 두 가지 축이 있는데 1)튼튼한 보안을 구축하기 위한 기술 2)개인의 보안과 사회 전체의 보안 사이의 트레이드 오프

보안은 사회적 문제일 뿐만 아니라 각기 다른 관습과 법으로 인해 나라마다 다른 문제이기도 하다.

미국 정부는 1998년 데이터 암호화 표준 (DES) 암호를 사용하라고 장려했다. 그러나 DES를 깨기 위한 Deep Crack이라는 기계가 만들어졌고 이는 정부 기관이 무능하거나 알고리즘 안전성에 대해 거짓말을 하고 있다고 증명하려는 의도에서였다.
이들의 노력은 어느정도 효과가 있었다. 정부 기관의 행동을 바꾸지는 못 했지만 향상된 암호화 표준 개발의 기폭제가 되었다.

### 8) 인증과 권한 부여
인증은 어떤 사람이나 대상이 실제로 그 사람이나 대상임을 증명하는 과정이며 권한부여는 제대로 된 자격증명을 제공하지 않는 사람에게 접근을 제한하는 것이다.

## 크립토그래피
크립토그래피를 사용하면 송신자가 통신 내용을 뒤죽박죽으로 만들어서 정해진 수신자만 디코딩하도록 송신할 수 있다. 크립토그래피는 보안과 프라이버시 뿐만 아니라 암호 서명을 사용하면 데이터의 진실성을 증명할 수 있다.

### 1) 스테가노그래피
어떤 내용을 다른 내용 속에 감추는 방식을 스테가노그래피라고 부른다. 스테가노그래피는 송신자와 수신자 사이에 연결의 자취가 남지 않기 때문에 비밀리에 통신하기 좋은 방법이다.

예) 영화 제작사에서 영화 리뷰어에게 개봉전 영화를 보낼 때 누구에게 보낸 영화인지 식별할 수 있는 표시를 비디오에 넣어 이를 통해 영화가 유출되면 어디서 유출됐는지를 파악할 수 있다.

### 2) 치환 암호
각 문자를 다른 문자로 변환하는 표를 만들고 이 표를 보고 메시지에서 원래의 문자를 그에 대응하는 다른 문자로 바꿔치기 하면 메시지를 암호화할 수 있다.
그리고 표를 참조해 역방향으로 참조하면 암호화된 메시지를 복호화할 수 있다.

치환 암호는 통계를 사용해 쉽게 깰 수 있어 좋은 방법이 아니다.

### 3) 전치 암호
메시지를 인코딩하는 또 다른 방법으로 문자 위치를 뒤섞는 것이 있다. 글자를 뒤섞는 암호 시스템을 'scytale'이라고 부르고, 이런 암호법을 '전치 암호'라고 한다.

### 4) 더 복잡한 암호

### 5) 일회용 패드
일회용 패드는 중복되지 않는 유일한 치환 암호들의 모음으로 각 치환 암호 코드를 단 한 번만 사용했다. 일회용 패드는 제대로 사용하면 완전히 안전하지만 몇 가지 문제점이 있다.
1. 양 당사자가 똑같은 패드를 써야 한다.
2. 양 당사자가 서로 동기화 돼야 한다. 어떤 방식을 쓰든 수신자와 송신자는 패드에서 같은 페이지에 있는 암호를 사용해야 한다.
3. 패턴 반복을 피하려면 패드가 메시지만큼 길어야 한다.

### 6) 키 교환 문제점
대칭 암호 시스템에는 통신의 양 당사자가 같은 열쇠를 사용해야 한다는 문제점이 있다. 즉 대칭 암호 시스템은 중간자 공격에 취약하다.

### 7) 공개키 암호
공개키 암호에서는 서로 연관된 키 쌍을 사용한다. 대칭키 암호에서는 암호화와 복호화에 모두 같은 암호를 사용했지만 공개키 암호에서는 누구에게나 알려져 있는 키를 공개키라고 부르고, 나만 알고 있어야 하는 키를 비밀키라고 부른다. 공개키 암호화 방식에서는 암호화와 복호화 키가 다르기 때문에 비대칭키 시스템이다.

### 8) 전방향 안전성
대칭키 암호 세션 키를 실제 통신에 사용할 경우 키를 발견하면 모든 메시지를 읽을 수 있다는 문제가 있다. 이를 피할 방법으로 전방향 안전성이 있다. 이는 각 메시지마다 세션 키를 새로 만들어 키를 알아내게 되도 메시지를 단 하나만 풀 수 있게 된다.

### 9) 암호학적 해시 함수
암호학적 해시 함수도 임의의 입력을 미리 정해진 범위 안의 수로 변환한다. 암호학적 해시 함수의 핵심 특성은 __단방향 함수__ 라는 점이다. 단방향이라는 말은 입력에서 해시값을 만들어내기는 쉬워도 해시에서 입력을 만들어낼 수는 없거나 만들어내려면 비용이나 시간이 많이 들어서 비실용적이라는 뜻이다.

또 암호학적 해시 함수는 도용하기가 어려워야 한다. 해시를 만들어내는 입력 데이터를 알아내기가 아주 어려워야 한다. 다시 말해 해시 충돌을 만들어내기가 아주 어려워야 한다는 뜻이다. 오랫동안 MD5 해시 함수가 널리 쓰였으나 현재는 SHA 알고리즘을 변형한 다른 해시 알고리즘이 대신 쓰이고 있다.

### 10) 디지털 서명
크립토그래피를 사용하면 디지털 서명을 통해 데이터가 진본임을 검증할 수 있다. 디지털 서명은 정합성, 부인방지, 인증을 제공한다.

정합성 검증은 메시지가 변조 됐는지 검증할 수 있다는 뜻이다. 데이터의 암호학적 해시값을 계산해 데이터 뒤에 추가함으로써 이뤄지나 누구나 메시지 뒤에 해시를 붙일 수 있다. 따라서 송신자는 해시를 자신의 비밀키로 암호화해서 메시지 뒤에 덧붙인다. 수신자는 공개키를 통해 해시를 복호화할 수 있다.

부인 방지는 메시지를 보낸 사람이 자기가 그런 메시지를 보낸 적이 없다고 주장할 수 없다는 뜻이다. 비밀키로 메시지에 서명을 하기 때문에 보낸 사람이 자신이 서명했음을 부인하기 어렵다.

### 11) 공개키 인프라
오늘날 HTTPS에서는 공개키를 브라우저에 저송하고 브라우저는 인증된 사용자만 복호화할 수 있도록 데이터를 암호화한다. 이런 인프라에는 신뢰할 수 있는 제 3자인 인증기관이 있어 키가 어떤 당사자의 것임을 인증해준다. 하지만 인증기관이 해킹될 수도 있고, 실수로 비밀키를 공개할 수도 있다는 문제점이 있다.

### 12) 블록체인
블록체인은 복잡한 수학으로 뒷받침된 아주 간단한 아이디어에서 비롯됐다. 블록체인은 은행 계좌와 비슷한 장부를 관리하는 매커니즘으로 생각할 수 있다. 장부의 문제점은 위조하기 쉽다는데 있다.

블록 n의 내용을 변경하면 그 블록의 해시가 바뀌기 때문에 블록 n+1에 저장된 해시와 일치하지 않게 된다. 암호학적 해시의 특성으로 인해 블록이 해시를 유지하면서 쓸모 있게 블록 정보를 변조할 가능성은 거의 없다.

### 13) 패스워드 관리
예전에는 컴퓨터 안에 있는 패스워드 파일에 패스워드가 평문으로 저장됐다. 패스워드가 노출되기 쉬워 보안에 취약했다. 해법은 패스워드를 암호학적 해시와 같은 암호화된 형태로 저장하는 것이다. 로그인 시도시 패스워드를 암호학적 해시로 변환해서 파일에 있는 해시와 비교한다.

오늘날 은행, 학교, 여러 온라인 상점 등에 대해 수없이 많은 패스워드를 기억해야 한다. 대부분의 사람들은 똑같은 패스워드를 모든 곳에 사용해서 이런 문제를 해결한다. 그래서 한 사이트가 공격에 함락당하면 다른 사이트에서도 같은 패스워드를 사용할 수 있게 된다.

## 보안을 위한 소프트웨어 예방 조치
### 1) 올바른 대상을 보호하라
모든 대상을 안전하게 유지하고픈 유횩에 빠지기가 쉽다. 하지만 모든 대상을 안전하게 하는 것은 좋은 생각이 아니다. 예) 안전할 필요가 없는 것을 보는 경우에도 사용자의 로그인이 필요한 경우, 밖에서 로그인하고 자리를 비웠을때 다른 사람이 안전한 정보에도 접근하기 쉬워진다.

### 2) 로직은 세 번 체크하라
로직에 있는 오류를 공격에 활용할 수 있다. 특히 공격자가 소스 코드를 볼 수 있고 내가 찾지 못한 버그를 찾을 수 있다면 공격에 성공할 가능성이 더 커진다.

### 3) 오류를 검사하라
작성한 코드는 시스템 콜이나 라이브러리 함수를 호출한다. 이런 호출이 잘못되면 대부분의 경우 오류 코드를 반환받는다. 이것을 무시하지 말자 조용히 실패하거나 메모리 경계를 넘기는 라이브러리를 피하자

### 4) 공격 표면을 최소화 하라

### 5) 경계 내부에 머물러라

### 6) 좋은 난수를 생성하기는 힘들다
크립토그래피에는 좋은 난수가 중요하다. 가장 흔히 쓰이는 난수 생성기는 실제로는 의사 난수를 생성한다. 의사 난수는 같은 숫자에서 시작하면 같은 순서로 난수가 생성된다.

보안 전문가들은 하드웨어 난수 생성기를 신뢰할 수 없다는 사실을 발견했다. 그래서 프로그램과 무관한 키보드를 누르는 시간의 차이, 디스크 접근 속도, 마우스 움직임 같은 임의의 이벤트에서 엔트로피를 수집한다.

보안이 좋은 난수에 의존해야 한다면 난수를 생성하는 시스템을 반드시 이해해야만 한다.

### 7) 네 코드를 알라
큰 프로젝트에서는 서드파티 코드가 들어가는 경우가 자주 있다. 서드파티 코드는 프로젝트 팀이 아닌 제 3자가 작성한 코드를 말한다. 그리고 이때 서드파티 코드의 소스 코드에 접근할 수 없는 경우가 많다.

서드파티 코드를 사용하면 제품에 쓰이지 않는 코드가 꽤 많이 제품에 포함된다. 이로인해 많은 문제가 발생할 수 있다. 서드파티 코드를 사용해도 안전한 경우는
1. 오픈소스가 나을 수 있다. 누구나 실제 코드를 들여다 볼 수 있어 버그를 발견할 가능성이 더 높다.
2. 제3자 패키지에서 실제로 사용하는 코드의 크기와 전체 패키지 크기 사이의 비율을 주시하자

### 8) 극단적인 영리함은 여러분의 적이다
서드파티 코드를 사용한다면 이상하고 영리한 기능은 피하라 많은 고객이 쓰지 않는 기능을 벤더가 더 이상 지원하지 않을 수도 있다.

### 9) 눈에 보이는 것을 이해하라
민감한 데이터를 다른 프로그램이 접근할 수 있는지 생각해보자 이 부분은 위협 모델을 정의할 때 중요한 부분이다.

코드를 안전하게 하는 일 외에 사이드 채널 공격에 주의를 기울여야 한다. 사이드 채널 공격은 프로그램 구현의 메타데이터나 부작용에 기반을 둔 공격 방법이다. 예) 은행 자동 입출금기에서 키패드를 향하고 있는 카메라가 있는 경우 사이드 채널 공격일 수 있다.

### 10) 과다수집하지 마라
정말 필요한 경우가 아니라면 민감한 정보를 수집하지 마라

### 11) 모아두지 마라
민감한 정보를 수집했다면 가능한한 빨리 민감한 정보를 없애라

### 12) 동적 메모리 할당은 여러분의 친구가 아니다

### 13) 가비지 컬렉션도 여러분의 친구가 아니다

### 14) 코드 역할을 하는 데이터
데이터를 실행할 수 있는 프로그램은 보호 장치가 없기 때문에 직접 이런 보호를 제공해야 한다.

예로 SQL injection 공격이 있다.
