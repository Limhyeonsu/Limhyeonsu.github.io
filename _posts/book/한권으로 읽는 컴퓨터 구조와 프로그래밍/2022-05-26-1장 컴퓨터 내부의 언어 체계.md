---
title: 1장 컴퓨터 내부의 언어체계
date: 2022-05-26 22:28:33 +0900
categories: [BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍]
tags: [computer]  # TAG는 반드시 소문자로 이루어져야함!
---

### 언어란 무엇인가
언어는 편의를 제공하기 위한 지름길이다. 모든 언어의 뜻은 기호의 집합으로 인코딩 된다. 하지만 의미를 기호로 인코딩하는 것으로 충분하지 않다.
언어가 제대로 작동하려면 의사소통하는 당사자들이 모두 같은 문맥을 공유해서 같은 기호에 같은 뜻을 부여할 수 있어야 한다.

### 문자 언어
문자 언어는 기호를 나열한 것이다. 기호를 정해진 순서대로 나열하면 단어를 만들 수 있다. 언어마다 기호와 기호 유형이 달라질 수 있고 순서도 다를 수 있다.

다음의 구성 요소가 문자 언어의 틀을 이루고 컴퓨터 언어에서도 마찬가지이다.
* 기호가 들어갈 상자
* 상자에 들어갈 기호
* 상자의 순서

### 비트
자연어에서 상자는 '문자'라고 부르고 컴퓨터에서는 '비트 bit'라고 부른다. 비트는 binary + digit가 합쳐진 말이다.
비트는 2진법을 사용하고 이는 모스 부호의 점(.)과 선(-)처럼 두 가지 기호 중 하나만 담을 수 있다는 뜻이다. 자연어와 마찬가지로 기호의 순서가 중요하다.

예) A (.-), B(-...), C(-.-.)

### 논리 연산
비트 사용법 중 하나는 날씨가 추운가? 같은 예(true)/아니요(false) 질문에 대한 답을 표현하는 것이다. 자연어에서는 예/아니요 구절을 엮어 한 문장으로 만드는 경우가 자주 있다.
'밖에 비가 내리고 있거나 춥다면 코트를 입어라' 이처럼 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 이런 동작을 '논리 연산'이라고 한다.

#### 불리언 대수
비트에 대해 사용할 수 있는 연산 규칙의 집합으로 기본적으로 NOT, AND, OR 세 가지의 연산자가 있다.
* NOT : 논리적 반대를 의미한다. 거짓인 비트에 NOT을 하면 참이 되고 참인 비트에 NOT을 하면 거짓이 된다.
* AND : 둘 이상의 비트에 작용한다. 모든 비트가 참인 경우 AND 연산의 결과도 참이다.
* OR : 둘 이상의 비트에 작용한다. 어느 한 비트라도 참이라면 OR 연산의 결과도 참이다.
* XOR : 첫 번째 비트와 두 번째 비트가 다른 값인 경우에만 참이 된다.

<img src="/assets/img/posting_img/book/programingStructure/boolean.jpeg" width="700px">

__드로르간의 법칙__

불리언 대수에 적용할 수 있는 법칙으로 a AND b == NOT(NOT a OR NOT b) 이다. 즉 NOT을 충분히 사용하면 AND 연산을 OR 연산으로 대신할 수 있다는 의미이다.
긍정적인 논리에 더해 부정적인 논리를 기술하는 명제를 사용할 때 드모르간 법칙을 활용할 수 있다.

<img src="/assets/img/posting_img/book/programingStructure/드모르간.jpeg" width="700px">

#### 정수를 비트로 표현하는 방법

__양의 정수 표현__

우리는 보통 10진수를 사용한다. 10진수 체계에서는 10가지 기호인 숫자를 상자에 담을 수 있고 이때 오른쪽에서 왼쪽으로 상자가 쌓여진다.
맨 오른쪽에서부터 일의 자리, 십의 자리, 백의 자리 등등의 이름이 붙는다. 각 이름은 10의 거듭제곱에 해당한다.

예) 5028을 계산하면 => 5 * 1000 + 0 * 100 + 2 * 10 8 * 1

비트를 사용할 때도 비슷하게 동작하는데 각 상자에 사용할 수 있는 기호는 1과 0 두가지 밖에 없다. 따라서 각 상자의 자릴수는 2의 거듭제곱이며 2진수 체계는 10을 밑으로 하지 않고 2를 밑으로 하는 수 체계다.

예) <img src="/assets/img/posting_img/book/programingStructure/2진수.jpeg" width="700px">

2진수에서 가장 오른쪽의 비트를 가장 작은 유효비트(LSB)라고 부르고, 가장 왼쪽의 비트를 가장 큰 유효비트(MSB) 라고 부른다. 그래서 LSB를 변경하면 2진수의 값이 가장 작게 변경되고
MSB의 비트를 변경하면 2진수의 값이 가장 크게 변한다.

__2진수 덧셈__

2진수에서도 덧셈 연산을 할 때 10진수 처럼 각 비트를 LSB에서 MSB쪽으로 더하며 결과가 1보다 크면 다음 자리에 1을 올린다.
덧셈 규칙을 논리 연산을 사용해 다음과 같이 표현할 수도 있다.

<img src="/assets/img/posting_img/book/programingStructure/2진덧셈.jpeg" width="700px">

두 비트를 서로 더한 결과는 두 비트를 XOR 한 값과 같고, 올림은 두 비트를 AND한 값과 같다. 덧셈 결과가 비트의 개수로 표현할 수 있는 범위를 벗어나면 '오버플로'가 발생한다.(MSB에서 올림이 발생했다는 뜻)
예) 1001 과 1000을 더한 결과는 10001이다. 하지만 MSB 왼쪽에 사용할 수 있는 비트가 없기 때문에 결과가 0001이 된다.

컴퓨터에는 조건코드 레지스터라는 것이 있어 몇가지 정보 중 오버플로 비트가 있고, 이 비트에는 MSB에서 발생한 올림값이 들어간다. 따라서 이 비트 값을 보면 오버플로가 발생했는지 알 수 있다.
(반대로 MSB 위쪽에서 1을 빌려오는 경우 언더플로라고 한다.)


__음수 표현__
1. 부호와 크기 : 음수와 양수를 구별하기 위해서 흔히 '부호'를 사용한다. 이 부호에는 비트를 하나 사용해서 표현하는데 가장 왼쪽 비트를 부호피트로 사용한다. 부호비트가 0이면 양수로 취급하고, 1이면 음수로 취급한다. 이런한 방법을 `부호와 크기 표현법`이라고 말한다.
부호화 크기 표현법은 널리 쓰이지 못하고 있는데 이는 비트를 구성하는데 비용이 낭비되고, XOR, AND를 통한 덧셈 계산을 사용할 수 없다.
2. 1의 보수 : 양수의 모든 비트를 뒤집는 방법이다. NOT 연산을 통해 보수를 얻는다. 예) 0111(+7) -> 1000(-7) 1의 보수 표현법도 덧셈이 쉽지 않다. MSB쪽에서 올림이 발생한 경우 LSB 쪽으로 올림을 전달한다. 이를 순환 올림이라 부른다.
3. 2의 보수 : 어떤 수의 비트를 뒤집고 1을 추가하면 음수를 얻는다. 예) 0001(+1) 을 뒤집으면 1110이고 여기에 1을 더하면 1111(-1)이 된다.

**우리가 같은 숫자로 이뤄진 수를 보더라도 문맥에 따라 표현하는 값이 달라질 수 있다는 점을 꼭 염두해둬야 한다. 예를 들어 2진수 1111은 2의 보수에서는 -1이고,
부호와 크기 표기로는 -7, 1의 보수에서는 -0이다. 따라서 사용하는 표현법을 반드시 알고 있어야 한다.
