---
title: 3장 메모리와 디스크의 핵심: 순차 논리
date: 2022-06-02 23:48:08 +0900
categories: [BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍]
tags: [computer]  # TAG는 반드시 소문자로 이루어져야함!
---

조합 논리는 입력에 의해서만 출력이 결정된다. 조합 논리만으로는 흐름의 일부분을 떼어내서 기억해둘 수 없기 때문에 현재 처리중인 수가 어떤 수인지 기억할 수 없다.
그래서 조합 논리의 단점을 개선한 순차 논리가 있다. 순차 논리는 입력의 현재 상태와 과거 상태를 함께 고려한다.

## 시간 표현과 상태 기억
우리는 주기 함수를 사용해 시간을 측정할 수 있다. 예를 들면 지구의 자전이 바로 주기적 함수이다. 지구가 한 바퀴를 다 돌면 이는 1일이고, 1일을 더 잘게 나눠서 시간, 분, 초 등으로 구분한다.

컴퓨터의 경우 전자공학을 사용하기 때문에 주기적인 전기 신호가 필요하다. 진자가 스위치를 때리게 하면 이런 신호를 만들 수 있다.

### 1) 발진자
인버터를 사용한 트릭을 보면 인버터의 출력을 입력에 연결할 수 있다. 이런 식의 연결을 '되먹임'이라고 한다. 인버터 출력은 다시 인버터 입력으로 들어가며, 이 입력은 다시 출력에 반영된다. 이로 인해 출력이 0과 1 사이를 진동한다.
그리고 안정적인 주파수로 진동하는 발진자가 있다면 더 정확한 시간을 측정할 수 있는 기준이 될 것이다.

정확한 발진자를 적은 비용으로 효율적으로 만드는 방법은 크리스털을 활용하는 것이다. 전극을 크리스털에 연결하고 크리스털을 압축하면 크리스털이 전기를 만들어 낸다. 그리고 전극에 전기를 가하면 크리스털이 구부러진다. 이런 현상을 '피에조 전기' 효과라고 부른다.
또 크리스털은 음성 진동을 잡아낼 수 있어서 마이크를 만들 때 이를 쓸 수 있다. 그리고 음성 진동을 만들어내서 다양한 경보음도 낼 수 있다.

입력한 전기로부터 크리스털이 전기를 다시 만들어내는 시간은 예측이 가능하며 매우 정확하다.

### 2) 클록
*컴퓨터에서 전자적/기계적 부품에 가까우면 더 저수준, 사용자나 프로그래머에 가까우면 더 고수준이라 한다.

발진자를 사용하면 시간을 더 잘 측정할 수 있다. 발진자는 컴퓨터에 시간을 셀 수 있게 해주는 신호인 '클록'을 제공한다. 클록은 회로의 페이스를 결정한다. 회로의 최대 클록 속도나 가장 빠른 템포는 회로의 전파 지연 시간에 의해 결정된다.

컴퓨터 컴포넌트 제작에는 여러가지 통계가 필요하다. 컴포넌트를 이루는 부품들 사이에 편차가 크기 때문이다. 그래서 비닝 과정에서 부품을 측정하여 특성에 따라 여러 다른 빈이나 무더기로 분류한다.
컴퓨터를 오버클로킹 한다는 말을 들어봤을 것이다. 이는 통계적으로 빈의 중간 정도에 위치하는 부품을 부품이 고장나지 않을 범위 안에서 클록을 빠르게 공급하는 도박을 한다는 뜻이다.

### 3) 래치
OR 게이트의 출력을 입력에 묶는 방식의 되먹임을 사용하면 정보를 기억할 수 있다.

<img src="/assets/img/posting_img/book/programingStructure/AND-OR래치.jpeg" width="700px">

위 사진에서 reset 위에 선을 그어 표현한 것을 유의해라 하드웨어 기호 위에 선을 그으면 반전을 뜻한다. 이 말은 값이 0일 때 참이고, 1일 때 거짓이라는 뜻이다. 이를 액티브 하이에 반대되는 `액티브 로우`라고 부른다.
그리고 이렇게 위에 그은 선을 'bar'라고 읽는다. 따라서 reset 기호를 읽을 때 reset bar라고 읽는다.

<img src="/assets/img/posting_img/book/programingStructure/AND-OR래치.jpeg" width="700px">

위 사진은 S-R 래치를 보여준다. S-R 래치는 set-reset을 뜻하고, 좀 더 똘똘하게 1비트 메모리를 만드는 방법이다. 이들은 액티브 로우를 입력 받고 보수 출력을 제공한다.
보수 출력은 출력의 한쪽은 액티브 하이, 다른 쪽은 액티브 로우라는 뜻이다.

set bar, reset bar가 참인 경우는 두 출력이 모두 참이라서 이상하기 때문에 이런 입력은 사용하면 안 된다.

### 4) 게이트가 있는 래치
<img src="/assets/img/posting_img/book/programingStructure/게이트가있는S-R.jpeg" width="350px">
<img src="/assets/img/posting_img/book/programingStructure/게이트가있는D.jpeg" width="350px">

S-R래치 그림에서 gate bar 입력이 거짓인 경우 set bar, reset bar가 어떤 값이든 아무 관계가 없다. S,R 게이트의 입력이 모두 1이기 때문에 출력이 그대로 유지 된다.

이 회로를 개선하는 방법으로 set bar, reset bar가 같은 입력에 연결하면서 한 쪽 입력에는 인버터를 추가해서 입력을 1비트(D)만 받게 만든다.
이렇게 하면 gate bar가 거짓일 때는 D가 변해도 Q 출력에 아무 변화가 없다.

### 5) 플립플롭
데이터 변경으로 인해 잘못된 결과가 생길 수 있는 가능성을 최소화하기 위해 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는 것이다. 이런 전이를 edge라고 부른다.
그리고 edge에 의해 데이터 변화가 촉발되는 래치를 '플립플롭'이라고 부른다. 플립플롭을 만들 때는 래치를 기본 요소로 사용한다.

### 6) 카운터
플립플롭을 응용한 회로 중에 1, 2, 3 순서대로 수를 세는 카운터가 있다. 개수를 센 결과가 왼쪽에서 오른쪽으로 퍼져나가는 것을 리플 카운터라고 한다.
그리고 각 비트의 상태가 다른 비트의 상태 변화에 약간의 시차를 두고 바뀌기 때문에 이 회로를 '비동기 카운터'라고도 부른다. 따라서 언제 결과를 살펴봐야 맞는지 알기 어렵다는 단점이 있다.
이에 반해 동기적 카운터는 상태 변경이 동시에 일어난다. 이는 모든 플립플롭에 같은 클록을 병렬로 연결한다는 사실을 암시한다.

### 7) 레지스터
D 플립플롭을 사용하면 값을 쉽게 기억할 수 있다. 이를 응용하여 레지스터 회로를 쉽게 구할 수 있다. 레지스터는 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 것이다.
가산기를 예로 들면 가산기 출력을 클록을 사용해 레지스터에 넣고 나면 가산기의 입력을 바꿔도 결과는 바뀌지 않는다.

## 메모리 조직과 주소 지정
훨씬 더 많은 정보를 저장해야 한다면 어떻게 해야 할까? 레지스터를 많이 쌓아두는 것부터 시작할 수 있다. 하지만 어떤 레지스터를 사용해야 하는지 지정할 수 있을까?
이때 각 레지스터에 번호를 부여하는데 이 번호를 '주소'라고 한다. 지정한 주소에 해당하는 레지스터의 출력을 선택할 방법이 필요하다. 그래서 여기에 실렉터를 사용한다.

그리고 시스템에서 여러 메모리 컴포넌트의 출력을 한 출력으로 연결해야 할 수도 있다. 이런 경우 트라이 스테이트 출력이라는 또 다른 기본 요소가 필요하다.
이 모든 요소를 합하면 메모리 컴포넌트가 만들어 진다.

메모리 컴포넌트는 연결지점이 아주 많았다. 32비트 수를 다루고 싶다면 입력과 출력을 32개씩 연결해야 하고, 주소, 제어 신호, 전원도 연결해야 했다. 하지만 메모리를 동시에 읽고 쓸 필요가 있는 경우는 거의 없다는 사실을 활용해 연결을 줄였다.

<img src="/assets/img/posting_img/book/programingStructure/메모리칩.jpeg" width="400px">

그림에서 주소와 데이터는 개별 신호 대신 큰 화살표를 사용한 것을 볼 수 있다. 이런식으로 연관된 신호를 '버스'라고 부른다. 따라서 메모리 칩에는 주소 버스와 데이터 버스가 있다. 버스는 비트를 이동시키는 대량 교통 수단이다.

### 1) 임의 접근 메모리
임의 접근 메모리 즉, RAM은 메모리 위치 중 원하는 곳은 어디든 원하는 순서로 쓰거나 읽을 수 있다. 정적 RAM은 비싸지만 아주 빠르다. 각 비트에 트랜지스터가 6개나 들어간다. 따라서 많은 비트를 저장하기에 좋은 선택은 아니다.
동적 RAM은 커패시터라는 아주 작은 버킷에 전자를 담고, 트랜지스터를 1개만 사용해 뚜껑을 덮는다. 문제는 이 버킷이 새기 때문에 가끔 메모리를 갱신해야 한다는 점이다. 그래서 버킷에 전자를 채우는 시점과 버킷에 정보를 쓰는 시간이 서로 겹치지 않게 조심해야 한다.

정적 RAM이나, 동적 RAM은 모두 휘발성 메모리다. 그래서 전원이 끊어지면 데이터가 사라진다. 반대로 코어 메모리는 오래된 비휘발성 RAM으로 비트를 도넛 모양의 쇳조각에 저장한다.

### 2) 읽기 전용 메모리
읽기 전용 메모리 즉 ROM은 한 번 쓰고 나면 여러 번 읽을 수 있다. 가장 초기 형태의 ROM은 홀러리스 카드로 비트들을 종이에 구멍으로 뚫어 표시한다.

천공 종이 테이프는 ROM 기술과 관련이 있다. 종이 테이프 롤에 뚫린 구멍은 비트를 표현한다. 순서가 뒤섞여 데이터가 꼬일 수 있는 카드에 비해 테이프는 그런 염려가 없다는 것이 장점이다. 반면 테이프가 찢어지면 수리하기가 힘들다.
IBM 카드와 종이 테이프는 순차적인 메모리다. 이는 데이터를 일정한 순서로만 읽을 수 있다는 뜻이다. 그래서 장기적으로 저장해야 하는 데이터를 저장하는 경우에만 유용하다.

이후 최초로 상업적으로 팔리기 시작한 마이크로 프로세서인 인텔 4004로 인해 더 나은 프로그램 저장 기술에 대한 수요가 생겼다.

그리고 프로그래머들이 직접 프로그래밍할 수 있는 ROM인 프로그래머블 읽기 전용 메모리가 만들어졌다. 단 한 번만 ROM에 프로그램을 적어 넣을 수 있었다. 그 다음으로 지울 수 있는 읽기 전용 메모리가 만들어졌다.
그리고 전기로 지울 수 있는 읽기 전용 메모리가 등장하면서 삶이 더 편해졌다.
