---
title: DB
date: 2022-03-17 16:36:44 +0800
categories: [기술면접]
tags: [db, oracle, mysql, mariadb]  # TAG는 반드시 소문자로 이루어져야함!
---

### 데이터베이스 란?
다수의 사람이 공유하여 사용할 목적으로 체계화해 통합 관리하는 데이터의 집합이다.

[특징]
- 실시간 접근성 : 수시적으로 비정형적인 질의에 대하여 실시간 처리에 의한 응답이 가능해야 한다.
- 계속적인 변화 : 데이터의 삽입, 삭제, 수정으로 항상 최신 데이터를 유지해야 한다.
- 동시공용 : 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 한다.
- 내용에 의한 참조 : 데이터베이스에 있는 데이터를 참조할 때 위치가 아닌, 사용자가 요구하는 데이터의 내용으로 찾는다.

### DBMS 란?
DBMS는 데이터베이스 관리 시스템으로 다수의 사용자가 데이터베이스 내의 데이터를 접근할 수 있도록 해주는 소프트웨어 도구의 집합이다.

### RDBMS 란?
관계형 데이터베이스 관리 시스템으로 행과 열로 구성된 2차원 테이블 형식을 이용하여 데이터를 관리하는 소프트웨어이다. (관계형 데이터 모델 : 테이블 형태의 저장구조를 가지고 데이터 사이의 연관관계를 테이블의 키, 열을 통해 표현하는 저장방식)

### *DBMS와 RDBMS의 차이점
DBMS
- 데이터를 파일로 저장한다.
- 계층적 형식 또는 탐색 형식으로 저장된다.
- 표준화 되어있지 않다.
- 데이터 보관시 보안을 제공하지 않는다.
- 데이터 저장시 파일 시스템을 사용하여 테이블간의 관계가 없다.
- 적은 데이터 처리시 좋다.
- 예) XML

RDBMS
- 데이터를 테이블 형식으로 저장한다.
- PK라는 식별자가 존재하고, 데이터의 값들을 테이블 형식으로 저장한다.
- 표준화 되어 있다.
- 보안에 대해 임의의 액세스 제어 또는 강제 액세스 제어를 제공한다.
- 데이터에 접근하기 위해 데이터의 테이블 형식 구조를 지원한다.
- 많은 데이터 처리시 좋다.
- 예) oracle, sql, mysql 등

### *관계형 데이터베이스, 비관계형 데이터베이스
__관계형 데이터베이스__ : 엄격한 데이터 스키마(구조)를 따라 데이터베이스 테이블에 저장되고(데이터 무결성 보장), 데이터는 관계를 통해 연결된 여러 테이블에 분산된다.

__비관계형 데이터베이스__ : 스키마가 없어 다른 구조의 데이터를 같은 컬렉션(table)에 저장할 수 있다.(유연성이 좋다) 필요한 형식으로 저장할 수 있기 때문에 속도가 빠르다. 관계가 없기 때문에 조인이라는 개념이 없다.

### 트랜잭션
트랜잭션은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업 단위이다.

### 트랜잭션의 성질 (ACID)
- 원자성(Atomicity) : 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.
- 일관성(Consistency) : 트랜잭션이 성공적으로 완료되면 일관성 있는 데이터베이스 상태로 변환되어야 한다.(트랜잭션 수행 전과 수행 후의 상태가 같아야 한다.)
- 격리성(Isolation) : 트랜잭션 작업 중 다른 트랜잭션에 영향을 주거나 간섭을 받아서는 안 된다.
- 지속성(Durablility) : 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

### 트랜잭션의 격리 수준(Transaction Isolation Level)
트랜잭션의 격리 수준은 트랜잭션들끼리 얼마나 고립되었는지, 잠금수준을 나타내는 것으로 특정 트랜잭션이 다른 트랜잭션에 의해 변경된 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다. 읽기 일관성을 지키기 위해서 격리 수준이 필요하다.

* READ UNCOMMITTED : 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있다. (트랜잭션의 변경 내용이 commit, rollback 상관없이 다른 트랜잭션에 보여진다)
* READ COMMITTED : 다른 트랜잭션에서 커밋된 내용만 참조할 수 있다. (트랜잭션의 변경 내용이 commit 되어야만 다른 트랜잭션에서 조회할 수 있다.)
* REPETABLE READ : 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있다.
* SERIALIZABLE : 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 한다. (가장 엄격한 수준으로 읽기 작업에서도 공유 잠금을 설정하여 다른 트랜잭션에서 변경작업을 못하게 한다. 성능저하 발생)

[참고1](https://velog.io/@guswns3371/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80)

[참고2](https://dar0m.tistory.com/225)

### 로킹(Locking) 기법
트랜잭션을 병행으로 처리하려고 하면 갱신 내용 손실(동시에 하나의 데이터를 갱신할 때 하나의 갱신이 누락되는 경우), 현황 파악 오류(데이터 갱신이 끝나지 않은 시점에 데이터를 조회하는 경우),
모순성(트랜잭션 동시 실행시 데이터베이스가 일관성이 없는 모순 상태로 남는 문제), 연쇄 복귀 문제(두 트랜잭션이 하나의 레코드 갱신할 때 하나의 트랜잭션이 롤백되면 다른 트랜잭션마저 롤백됨)가 발생할 수 있다.

이 때 로킹 제어 기법을 사용한다. 로킹 제어 기법은 하나의 트랜잭션이 실행되는 동안 데이터 항목에 대해서 데이터를 Lock 시켜서 다른 트랜잭션이 접근하지 못하도록 하고, 트랜잭션이 완료될 때 해당 부분을 Unlock 시키는 방법이다.

로킹 제어 기법에는 공유 로킹(Lock한 부분을 읽기는 가능, 쓰기는 불가능), 배타 로킹(읽기 쓰기 불가능)이 있다.

로킹 단위가 크면 제어 기법이 간단해지고, 병행성이 감소한다. 반대로 로킹 단위가 작으면 제어하기가 까다롭고, 병행성이 증가한다.

로킹기법의 한계로는
1) 직렬 가능한 스케줄이 항상 보장되지 않는다. (2단계 로킹 규약으로 해결 가능)
2) 교착상태(DeadLock)가 발생할 수 있다.

*2단계 로킹 규약 : 확장단계(트랜잭션은 새로운 lock 연산만 실행 가능, unlock 불가), 축소단계(트랜잭션은 새로운 unlock 연산만 실행가능, unlock 연산 실행시 lock 연산은 더이상 실행 불가)

[참고1](https://raisonde.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%A1%9C%ED%82%B9Locking-%EA%B8%B0%EB%B2%95%EA%B3%BC-%EB%A1%9C%ED%82%B9-%EB%8B%A8%EC%9C%84)

### 데드락
둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황이다.
해결 방법으로는 트랜잭션을 자주 커밋, 정해진 순서로 테이블 접근, 읽기 잠금 획득 사용을 피함 등이 있다.

### 회복기법
트랜잭션 수행 중 장애(트랜잭션장애, 시스템장애, 미디어장애)로 인하여 데이터베이스가 손상을 입은 경우 정상적인 상태로 복구 시키는 작업을 가리킨다.

* 로그기반 회복기법
  * 지연갱신 회복기법 : 트랜잭션의 부분 완료 상태에서는 변경 내용을 로그 파일에만 저장하고 커밋 발생 전까지는 데이터베이스에 기록하지 않는다. 회복 과정에서 undo가 필요 없고 트랜잭션의 원자성을 보장할 수 있다.
  * 즉시갱신 회복기법 : 트랜잭션 수행 도중에도 변경 내용을 즉시 데이터베이스와 로그에 기록, 커밋 발생 전 장애 발생시 undo, 커밋 후 장애 발생시 redo
* 체크포인트 회복기법 : 장애 발생시 checkpoint 이전에 처리된 트랜잭션은 회복에서 제외, checkpoint 이후 처리된 트랜잭션은 회복 작업 수행
* 그림자 페이징 회복 기법 : 트랜잭션 실행시 현재 페이지 테이블과 동일한 그림자 페이지 테이블을 생성하여 트랜잭션이 성공하면 그림자 페이지 테이블을 삭제하고, 장애 발생시 그림자 페이지 테이블을 현재 페이지 테이블로 한다.
* 미디어 회복 기법 : 디스크 같은 저장장치가 손상되는 장애에 대비하여 데이터베이스 내용을 별도의 물리적 저장장치에 백업하고, 장애 발생시 가장 최근 백업 데이터로 복구하고 로그파일을 참조하여 백업 이후 작업에 대하여 redo

[참고1](https://raisonde.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%9A%8C%EB%B3%B5-%EA%B8%B0%EB%B2%95-%EC%A0%95%EB%A6%AC)

### 무결성
무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말한다.

* 개체 무결성 : 기본키(PK)로 선택된 필드는 빈 값을 허용하지 않고, 유일한 값이여야 한다.
* 참조 무결성 : 외래키(FK) 값은 Null 이거나 참조할 테이블의 기본키 값과 동일해야 한다. 또 참조할 수 없는 값을 지닐 수 없다.
* 도메인 무결성 : 테이블의 존재하는 필드의 타입, Null 값 허용 등에 대한 사항 정의하여 올바른 데이터가 입력되었는지 확인
* 고유 무결성 : Unique 테이블의 특정 속성에 대해 각 레코드들이 갖는 값들은 서로 달라야한다. -> 유일 해야 한다.
* NULL 무결성 : 특정 속성 값이 Null이 될 수 없게 하는 조건
* 키 무결성 : 하나의 테이블엔 적어도 하나의 키가 존재해야 한다.

### 정규화, 반정규화
__정규화__ 란 무결성을 유지하기 위하여 테이블을 분할하여 중복된 데이터를 제거하는 프로세스이다. 데이터 변경시 이상 현상을 제거하고, 구조 확장시 재디자인을 최소화한다.

[이상현상]
* 삽입이상 : 데이터를 삽입시 원하지 않는 값도 같이 삽입되는 현상
* 삭제이상 : 원하는 데이터만 삭제하고 싶은데 삭제를 원치 않는 속성 값도 같이 지워지는 현상
* 갱신이상 : 속성값을 갱신할 때 일부 정보만 갱신되어 정보의 모순이 발생하는 현상

[정규화 과정]
1. 제1정규형 : 각 컬럼의 값은 원자값을 가져야 한다. (유일한 값, 식별성 o)
2. 제2정규형 : 부분 함수적 종속 제거 (예. {X1, X2} -> Y일 경우, X1와 X2가 Y의 값을 결정할 때 이를 완전 함수적 종속 이라고 하고, X1, X2 중 하나만 Y의 값을 결정할 때 이를 부분 함수적 종속 이라고 한다.)
3. 제3정규형 : 이행적 함수 종속 제거 (예. 이행적 함수 종속이란 A -> B, B -> C가 성립할 때 A -> C가 성립되는 것)
4. 보이스코드 정규형 : 결정자이면서 후보키가 아닌것을 제거해야한다. (예. [학번+과목] => 교수를 결정, 교수는 과목을 결정, 교수도 결정자인데 교수는 학번을 결정지을 수 없으므로 후보키가 아님)
5. 제4정규형 : 다치 종속성 제거
6. 제5정규형 : 조인 종속성 제거

__반정규화__ 란 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 시스템의 성능을 향상시키고 관리의 효율성을 증대시킨다. (단, 과도한 반정규화는 성능을 저하시킴)

[반정규화 방법]
* 테이블 통합 : 두 개의 테이블이 조인되는 경우가 많은 경우에 하나의 테이블로 합치는 것이 성능향상에 도움이 되는 경우 테이블을 통합한다.
* 테이블 분할 : 테이블을 수직(한 테이블에 속성이 너무 많은 경우 속성을 기준으로 분할) 또는 수평(레코드 기준으로 사용빈도의 차이가 큰 경우 분할)으로 분할하는 것
* 중복 테이블 추가 : 여러 테이블에서 데이터를 추출해서 사용하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 중복 테이블을 추가한다.
* 중복 속성 추가 : 조인해서 데이터 처리시 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 추가한다.

**수평분할 예) 고객 테이블에서 성별에 따라 남녀로 나누어 두 개의 테이블로 분할한다.

### 파티셔닝
데이터베이스 분할(partitioning)은 데이터베이스에서 크기가 큰 테이블을 작은 단위로 분할하는 것이다. 데이터가 너무 커져서 조회 시간이 길어지는 경우 또는 관리 용이성, 성능, 가용성 등의 향상을 이유로 행해진다.

[파티셔닝 분할 기준]
* Range Partitioning(범위 분할) : 컬럼 값의 범위를 기준으로 행을 분할하는 형태로 달, 분기 등의 범위의 분산에 주로 사용됨
* List Partitioning(목록 분할) : 특정한 값을 기준으로 데이터를 분할 예) 서울, 경기.. 지역명 등
* Hash Partitioning(해시 분할) : Hash 함수 결과값을 기준으로 데이터 분할한다. hash 함수를 사용하므로 데이터가 어느 파티션으로 들어가는지 알 수 없어 관리 목적에는 맞지 않으나 데이터를 여러 위치에 분산 배치하여 디스크 IO 성능을 개선한다.
* Composite Partitioning(합성 분할) : 파티셔닝 기법을 결합한 것 예) 범위분할 + 해시분할

### 옵티마이저
옵티마이저는 개발자가 작성한 SQL의 실행계획을 수립하고 여러개의 실행계획 중 최적의 처리 경로를 선택하여 SQL을 실행하는 DBMS의 핵심 엔진이다.
동일한 결과가 나오는 SQL이라도 실행계획에 따라 성능이 달라질 수 있다.

[실행순서]
1) SQL문을 작성
2) Parser가 SQL문을 문법검사, 구문분석을 한다.
3) 옵티마이저가 여러 계획을 생성하고 여러 통계정보를 이용하여 최소 비용의 실행계획을 결정
4) SQL 실행엔진이 옵티마이저가 결정한 실행계획대로 데이터를 처리 후 사용자에게 전달

옵티마이저에는 비용기반 옵티마이저(비용이 가장 적은 실행계획을 선택), 규칙기반 옵티마이저(우선순위가 높은 규칙을 가지고 실행계획을 선택)가 있다.

[참고1](https://coding-factory.tistory.com/743)

### 인덱스
인덱스는 데이터베이스 테이블에 대한 검색 속도를 높여주는 자료구조이다. 특정 컬럼에 인덱스를 생성하면 데이터를 `정렬`하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다.

인덱스의 가장 큰 특징은 데이터들이 정렬되어 있다는 것으로 이로 인해 where 절에서 테이블을 full scan하지 않고 조건에 맞는 데이터를 빠르게 찾을 수 있다.
또한 데이터가 정렬되어 있기 때문에 Sort 과정을 피할 수 있어 자원소비를 줄일 수 있다.

단점으로는 정렬된 상태를 계속 유지시켜 주어야하기 때문에 데이터가 추가, 삭제, 수정으로 인해 변경되면 값들을 다시 정렬해한다. 그리고 인덱스를 관리하기 위해
별도의 저장공간이 추가로 필요하기 때문에 무조건 인덱스를 만드는 것이 좋은 것은 아니다.

수정이 빈번하지 않고, where, join, order by, group by, union이 빈번한 컬럼과
테이블의 전체 데이터 중에서 10~15% 이하의 데이터를 처리하는 경우에 인덱스를 사용하면 효율적이다.


[참고1](https://coding-factory.tistory.com/746)

[참고2](https://velog.io/@sem/DB-%EC%9D%B8%EB%8D%B1%EC%8A%A4Index%EB%9E%80)

### View
뷰는 한 개 이상의 기본 테이블이나 다른 뷰를 이용하여 생성되는 `가상` 테이블이다. 뷰에 대한 정의인 SQL문만 저장되어 있어 디스크 저장공간이 할당되지 않는다.
일부 데이터에만 접근할 수 있도록 제한하기 위한 기법이다.

뷰의 장점은 논리적인 독립성을 제공하고, 데이터의 접근을 제어함으로써 보안이 좋다. 복잡한 질의문을 단순화할 수 있다.

단점으로는 뷰의 정의를 변경할 수 없고(변경하려면 삭제후 재 생성해야험), insert, delete, update에 많은 제한이 있다.

### 조인
관계형 데이터베이스에서는 중복 데이터를 피하기 위해 데이터를 쪼개 여러 테이블로 나눠 저장하는데,
원하는 결과를 도출하기 위해 다시 두 개 이상의 테이블을 조합할할필요가 있다. 이때 join 연산자를 사용하여 관련있는 컬럼 기준으로 테이블을 연결해서 데이터를 검색하는 방법이다.

[조인 종류]
* INNER JOIN : 교집합으로 두 테이블의 공통적인 부분만 SELECT 한다.
* LEFT / RIGHT JOIN : 부분집합으로 조인 기준이 LEFT or RIGHT에 따라 SELECT 됨
* OUTER JOIN : 합집합으로 두 테이블이 가지고 있는것 모두 SELECT 한다.

### 트리거
특정 테이블에 insert, delete, update 문이 수행되었을 때, 데이터베이스에 `자동`으로 동작하도록 작성된 프로그램이다.
트리거는 데이터베이스에 의해 자동으로 호출되지만 특정 테이블의 이벤트 발생과 하나의 트랜잭션 안에서 일어나는 일련의 작업으로 이벤트가 ROLLBACK 되면
트리거로 동작한 작업도 취소된다.

[트리거의 종류]
* 행 트리거 : 데이터 변화가 생길 때마다 실행
* 문장 트리거 : 트리거에 의해 단 한 번 실행

**COMMIT, ROLLBACK을 트리거 안에서 사용시 에러 발생함

### 프로시저
자주 사용하는 특정 작업에 대하여 필요할 때 호출하기 위해 절차적인 언어를 이용하여 작성한 프로그램이다.

장점) 하나의 요청으로 여러 SQL을 실행할 수 있으며 그로 인해 네트워크 부하를 줄일 수 있다.
단점) DB 확장이 어렵고 유지보수가 어렵다.

### 함수
절차형 SQL을 활용하여 일련의 SQL 처리를 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 절차형 SQL이다.

### SQL
SQL은 관계형 데이터베이스 시스템에서 사용하는 질의 언어이다. 문법이 다른 언어보다 단순하고, 대소문자를 구별하지 않는다.

[분류]
* DDL - 데이터 정의어, 테이블이나 관계의 구조를 생성하는데 사용한다. 예)CREATE, ALTER, DROP
* DML - 데이터 조작어, 테이블에 있는 데이터를 직접 조작하는데 사용한다. 데이터 입력, 조회, 수정, 삭제 예)INSERT, SELECT, DELETE, UPDATE
* DCL - 데이터에 접근할 수 있는 권한을 관리하는 언어 예)GRANT, REVOKE / 가진 권한을 남에게 주는 경우 'with grant option', 참조 객체에 사용된 참조 무결성 제약 함께 삭제 'casecade constraints'
* TCL - 트랜잭션 제어어 예)COMMIT, ROLLBACK, SAVEPOINT ...

### NoSQL
다양한 의견이 있지만 'Not Only SQL'이 의견의 다수를 차지하고 있다. 단순히 RDBMS가 가진 특성뿐만 아니라 다른 특성들을 부가적으로 지원한다는 것을 의미한다.
테이블간의 관계를 정의하지 않아 일반적으로 테이블간 join도 불가능하다.

장점) 유연성, 확장성, 고성능, 고기능성

[종류]
* Key Value DB : 해시 테이블을 사용하여 키 값의 쌍을 저장하여 사용 예)Redis, Amazon Dynamo DB
* Document DB : JSON, XML과 같은 Collection 데이터 모델 구조를 채택하고 있다. 예)MongoDB
* Graph DB : 개체과 관계를 그래프 형태로 표현 예)Neo4J
* Wide Columnar Store : Key Value에서 발전된 형태의 Column Family 데이터 모델을 사용한다. 예)HBase, Cassandra..

### Oracle, MySQL, MariaDB, PostgreSQL 차이점, 특징
__ORACLE__ : 1)대량의 정보 관리를 할 때 좋은 성능을 보인다. 2)고성능 트랜잭션 처리 지원하여 속도가 빠르다. 3)가격이 비싸다.

[오라클 버전별 특징 참고](https://velog.io/@sezzzini/DB-Oracle-%EB%B2%84%EC%A0%84%EB%B3%84-%ED%8A%B9%EC%A7%95)

__MySQL__ : 오픈소스로 다중 사용자 다중 스레드를 지원한다. 무료로 사용할 수 있고, 표준 SQL형식을 사용한다.

__MariaDB__ : MySQL을 만든 개발자가 만든것으로 따라서 MySQL과 매우 유사하다. MySQL의 단점을 개선하였다 => 어떤??

__PostgreSQL__ : 대용량 데이터 처리를 위한 기능을 구현, 신뢰성과 안전성이 매우 높다. 오픈소스로 무료로 사용가능하다.

[문법차이]
1) 공백치환 : Oracle -> NVL(), MySQL -> IFNULL()
2) 현재날짜 : Oracle -> SYSDATE, MySQL -> NOW()
3) 문자 합치기 : Oracle -> ||, MySQL -> CONCAT()
4) Oracle -> ROWNUM, MySQL -> LIMIT
