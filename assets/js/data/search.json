[ { "title": "16. 계층쿼리", "url": "/posts/16.%EA%B3%84%EC%B8%B5%EC%BF%BC%EB%A6%AC/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2023-05-14 23:15:37 +0900", "snippet": "계층 쿼리를 사용하면 순환 관계를 가진 데이터를 조회할 수 있다. 순환 관계는 노드와 노드의 관계를 통해 만들어진다. 일반적으로 하나의 부모 노드는 다수의 자식 노드를 가질 수 있고, 하나의 자식 노드는 하나의 부모 노드만 가질 수 있다.노드는 부모 노드와 자식 노드의 존재 여부에 따라 루트 노드, 브랜치 노드, 리프 노드로 구분할 수 있다.순환 관계는 계층의 깊이에 따라 레벨이 부여 된다. 루트 노드는 레벨이 1이고, 계층이 전개될수록 레벨이 1씩 증가한다.-- JONES의 자식 노드 조회SELECT b.empno, b.ename, b.mgrFROM emp a, emp bWHERE a.ename = 'JONES'AND b.mgr = a.empno;-- JONES의 자식 노드의 자식 노드 조회SELECT c.empno, c.ename, c.mgrFROM emp a, emp b, emp cWHERE a. ename = 'JONES'AND b.mgr = a.empnoAND c.mgr = b.empno;-- SMITH의 부모 도느 조회SELECT b.empno, b.ename, b.mgrFROM emp a, emp bWHERE a.ename = 'SMITH'AND b.empno = a.mgr;위에서는 깊은 레벨의 노드를 조회하기 위해서 셀프 조인을 반복해야 했다. 오라클에서는 순환 관계를 가진 데이터를 조회할 수 있는 계층 쿼리 절과 재귀 서브 쿼리 팩토링 기능을 제공한다.16.1 계층 쿼리 절계층 쿼리 절은 오라클의 전통적인 계층 쿼리 구문이다.16.1.1 기본 문법계층 쿼리 절은 WHERE 절 다음에 기술하며, FROM 절이 수행된 후 수행된다. START WITH 절과 CONNECT BY 절로 구성되며, START WITH 절은 생략 가능하다. PRIOR : 직전 상위 노드의 값을 반환 CONNECT_BY_ROOT : 루트 노드의 값을 반환 LEVEL : 현재 레벨을 반환 CONNECT_BY_ISLEAF : 리프 노드인 경우 1, 아니면 0을 반환 CONNECT_BY_ISCYCLE : 루프가 발생한 경우 1, 아니면 0을 반환 SYS_CONNECT_BY_PATH : 루트 노드에서 현재 노드까지의 column을 char로 구분하여 연결한 값을 반환 column 값에 char가 포함되어 있으면 에러 발생SELECT LEVEL AS lv, empno, LPAD(' ', LEVEL - 1, ' ') || ename AS ename, mgr, PRIOR empno AS empno_pFROM empSTART WITH mgr IS NULL --mgr가 존재하지 않는 행CONNECT BY mgr = PRIOR empno -- mgr가 부모 노드의 empno인 행SELECT LEVER AS lv, empno, LPAD(' ', LEVEL - 1, ' ') || ename AS ename, mgr , CONNECT_BY_ROOT ename AS rt , CONNECT_BY_ISLEAF AS lf , SYS_CONNECT_BY_PATH(ename, ',') AS ptFROM empSTART WITH mgr IS NULLCONNECT BY mgr = PRIOR empno16.1.2 동작 원리계층 쿼리 절은 START WITH 절로 루트 노드를 생성한 후, 결과가 없을 때까지 CONNECT 절을 반복 수행하여 하위 노드를 생성한다. (LEVEL=1) : START WITH 절을 수행하여 루트 노드를 생성한다. &gt; 1단계 수행 결과를 임시테이블에 저장한다. (LEVEL=2) : CONNECT BY 절로 테이블에 저장된 1단계 결과와 emp 테이블을 조인한다. (LEVEL=3) : CONNECT BY 절로 임시 테이블에 저장된 2단계 결과와 emp 테이블을 조인한다. &gt; 수행 결과를 임시테이블에 저장한다. (LEVEL=4) : CONNECT BY 절로 임시 테이블에 저장된 3단계 결과와 emp 테이블을 조인한다. (LEVEL=5) : CONNECT BY 절로 임시 테이블에 저장된 4단계 결과와 emp 테이블을 조인한다." }, { "title": "15. Top-N 쿼리", "url": "/posts/15.Top-N%EC%BF%BC%EB%A6%AC/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2023-05-13 22:55:37 +0900", "snippet": "Top-N 쿼리는 상위 N개의 행을 조회하는 쿼리이다.15.1 기본 문법오라클에서는 세 가지 방식의 Top-N 쿼리를 사용할 수 있다.15.1.1 ROWNUM 방식ROWNUM 방식은 전통적인 Top-N 쿼리 방식이다. ORDER BY 절로 행을 정렬하고, 정렬된 행을 ROWNUM 슈도 칼럼으로 제한한다. 행이 반환되는 순서대로 순번을 반환하고, 행이 반환될 때마다 순번이 증가한다.-- ROWNUM은 1부터 시작하고 행이 반환될 때마다 순번이 증가하기 때문에 ROWNUM = 2 조건은 항상 FALSE이다.SELECT empno, sal, ROWNUM AS rn FROM emp WHERE ROWNUM = 2;-- ROWNUM 컬럼은 &lt; 조건이나 &lt;= 조건을 사용해야 한다.SELECT empno, sal, ROWNUM AS rn FROM emp WHERE ROWNUM &lt;= 2;-- 정렬을 한 뒤 갯수 제한을 하고 싶은 경우, 인라인 뷰를 사용해야 한다.SELECT empno, sal, EOWNUM AS rnFROM (SELECT empno, sal FROM ORDER BY sal, empno)WHERE ROWNUM &lt;= 5;경품 추첨 등 무작위로 n개의 행을 조회하는 경우 ORDER BY 절에 DBMS_RANDOM.VALUE 함수를 사용할 수 있다. 하지만 문맥 전환에 의한 성능 저하가 발생할 수 있으므로 DBME_RANDOW.VALUE 함수 대신 ORA_HASH 함수를 사용하여 성능개선을 할 수 있다.15.1.2 분석 함수 방식-- ROW_NUMBER를 이용한 Top-N 쿼리SELECT *FROM (SELECT empno, sal, ROW_NUMBER() OVER (ORDER BY sal, empno) AS rn FROM emp)WHERE rn &lt;= 5ORDER BY sal, empno;-- ROW_NUMBER를 이용한 페이징 쿼리SELECT *FROM (SELECT empno, sal, ROW_NUMBER() OVER (ORDER BY sal, empno) AS rn FROM emp)WHERE rn BETWEEN (:v_pr * (:v_pn - 1)) + 1 AND :v_pr * v_pnORDER BY sal, empno;-- PERCENT_RANK 함수를 사용하여 백분율에 의한 Top-N 쿼리SELECT empno, sal, prFROM (SELECT empno, sal, PERCENT_RANK() OVER (ORDER BY sal, empno) AS pr FROM emp)WHERE pr &lt;= 0.25ORDER BY sal, empno;15.1.3 ROW LIMITING 절ROW LIMITING은 ANSI 표준 SQL 문법이다. ROW LIMITING 절은 ORDER BY 절 다음에 기술하고, ORDER BY 절과 함께 수행된다. OFFSET offset : 건너뛸 행의 개수를 지정 FETCH : 반환할 행의 개수나 백분율을 지정 ONLY : 지정된 행의 개수나 백분율만큼 행을 반환 WITH TIES : 마지막 행에 대한 동순위를 포함해서 반환SELECT empno, salFROM empORDER BY sal, empnoFETCH FIRST 5 ROWS ONLY;PERCENT 키워드를 사용하면 반환할 행의 백분율을 지정할 수 있다.15.2 고급 주제15.2.1 Top-N 쿼리와 조인-- 조인 후 Top-N 처리를 수행 emp 테이블의 데이터가 14건이 조회되면 조인도 14번 수행하고, 2건의 결과만 반환한다.SELECT empno, sal, deptno, dnameFROM (SELECT a.empno, a.sal, a.deptno, b.name FROM emp a, dept b WHERE b.deptno(+) = a.deptno ORDER BY a.sal, a.empno)WHERE ROWNUM &lt;= 2;15.2.2 Top-N 쿼리와 UNION ALL 연산자-- UNION ALL 연산자를 사용하여 연결한 결과를 Top-N 처리를 수행한다. 결과 집합을 정렬해야 하므로 소트 부하가 발생할 수 있다.SELECT *FROM (SELECT 1 AS tp, deptno AS no, dname AS name FROM dept UNION ALL SELECT 2 AS tp, empno AS no, ename AS name FROM emp ORDER BY tp, no)WHERE ROWNUM &lt;= 3;" }, { "title": "09. 면접문제", "url": "/posts/09.%EB%A9%B4%EC%A0%91%EB%AC%B8%EC%A0%9C/", "categories": "BOOK, 코딩 인터뷰 완전분석", "tags": "", "date": "2023-04-01 22:14:48 +0900", "snippet": "01. 배열과 문자열배열이나 문자열에 대한 문제들은 서로 대체 가능하다.해시 테이블해시테이블을 효율적인 탐색을 위한 자료구조로서 키(key)를 값에 대응시킨다. 간단한 해시 테이블을 구현하기 위해선 연결리스트와 해시 코드 함수만 있으면 된다. 키와 값을 해시테이블에 넣을때는 다음의 과정을 거친다. 처음에 키의 해시 코드를 계산한다.(키의 자료형은 보통 int, long이 된다. 키의 개수는 무한대지만 int의 개수는 유한하므로 서로 다른 두 개의 키가 같은 해시 코드를 가리킬 수 있다.) hash(key) % array.length와 같은 방식으로 해시 코드를 이용해서 배열의 인덱스를 구한다.(서로 다른 해시코드가 같은 인덱스를 가리킬 수 있다.) 배열의 각 인덱스에는 키와 값으로 이루어진 연결 리스트가 존재한다. 키와 값을 해당 인덱스에 저장한다. (충돌에 대비해서 반드시 연결리스트를 이용해야 한다.)키에 상응하는 값을 찾기 위해서는 다음과 같은 과정을 반복해야 한다. 주어진 키로부터 해시 코드를 계산한다. 해시 코드를 이용해서 인덱스를 계산한다. 해당 키에 상응하는 값을 연결리스트에서 탐색한다.충돌이 자주 발생한다면 최악의 경우 수행 시간은 O(N)이 된다. (N은 키의 갯수) 충돌을 최소화하도록 잘 구현된 경우 탐색시간은 O(1)이다.또 다른 구현법으로는 균형 이진 탐색 트리를 사용하는 방법이 있다. 이 경우 탐색 시간이 O(logN)이 된다. 이 방법은 크기가 큰 배열을 미리 할당해 놓지 않아도 되기 때문에 잠재적으로 적은 공간을 사용한다는 장점이 있다.ArrayList와 가변 크기 배열특정 언어에서 배열의 크기를 자동으로 조절할 수 있다. 자바 같은 언어에서 배열은 길이가 고정되어 있다. 동적 가변 크기 기능이 내재되어 있는 배열과 비슷한 자료구조를 원할 때는 보통 ArrayList를 사용한다. ArrayList는 필요에 따라 크기를 변화시킬 수 있으면서도 O(1)의 접근 시간을 유지한다. 통상적으로 배열이 가득 차는 순간, 배열의 크기를 두 배로 늘린다. 크기를 늘리는 순간은 O(N)이지만, 자주 발생하는 일이 아니라서 상환입력시간으로 계산했을 때 여전히 O(1)이 된다.StringBuilder문자열 리스트가 주어졌을 때 이 문자열을 하나로 이어붙이려는 경우 이때 수행시간은 어떻게 될까?String joinWord(String[] words) { String sentence = \"\"; for(String w : words) { sentence = sentence + w; } return sentence;}문자열을 이어붙일 때마다 두 개의 문자열을 읽어 들인 뒤 문자를 하나하나 새로운 문자열에 복사해야 한다. 따라서 총 수행시간은 O(x+2x+…nx) -&gt; O(xn²)이 된다.StringBuilder를 사용하면 이 문제를 해결할 수 있다. 이는 단순하게 가변 크기 배열을 이용해서 필요한 경우에만 문자열을 복사하게끔 해준다.String joinWord(String[] words) { StringBuilder sentence = new StringBuilder(); for(String w : words) { sentence.append(w); } return sentence.toString();}면접 문제 중복이 없는가 : 문자열이 주어졌을 때, 중복되어 등장하는 문자열이 있는지 확인하는 알고리즘을 작성하라 순열 확인 : 문자열 두 개가 주어졌을 때, 이 둘이 서로 순열 관계에 있는지 확인하는 메서드를 작성하라 (순열이란? 문자열을 재배치하는 것을 뜻한다.) URI화 : 문자열에 들어있는 모든 공백을 ‘%20’으로 바꿔주는 메서드를 작성하라, 모든 문자를 다 담을 수 있을 만큼 충분한 공간이 이미 확보되어 있으면 문자열의 최종 길이가 함께 주어진다고 가정해도 된다. 회문 순열 : 주어진 문자열이 회문의 순열인지 아닌지 확인하는 함수를 작성하라 (회문이란? 앞으로 읽으나 뒤로 읽으나 같은 단어 혹은 구절을 의미한다.) 하나 빼기 : 문자열을 같게 만들기 위한 편집 횟수가 1회 이내인지 확인하는 함수를 작성하라 (문자열 편집에는 문자삽입, 문자삭제, 문자교체)가 있다. 문자열 압축 : 반복되는 문자의 개수를 세는 방식의 기본적인 문자열 압축 메서드를 작성하라 예)aabccccaaaa -&gt; a2b1c4a4 만약 압축된 문자열의 길이가 기존 문자열의 길이보다 길다면 기존 문자열을 반환해야 한다. 행렬 회전 : 이미지를 표현하는 N X N 행렬이 있다. 이미지의 각 픽셀은 4 바이트로 표현된다. 이때, 이미지를 90도 회전시키는 메서드를 작성하라. 행렬을 추가로 사용하지 않고서도 할 수 있겠는가 O 행렬 : M X N 행렬의 한 원소가 0일 경우, 해당 원소가 속한 행과 열의 모든 원소를 0으로 설정하는 알고리즘을 작성하라. 문자열 회전 : 한 단어가 다른 문자열에 포함되어 있는지 판별하는 isSubstring이라는 메서드가 있다고 할 때, s1과 s2의 두 문자열이 주어졌고, s2가 s1을 회전시킨 결과인지 판별하고자 한다. isSubstring을 한 번만 호출해서 판별할 수 있는 코드를 작성하라02. 연결리스트연결리스트는 차례로 연결된 노드를 표현해주는 자료구조이다. 단방향 연결리스트에서 각 노드는 다음 노드를 가리킨다. 양방향 연결리스트에서 각 노드는 다음 노드와 이전 노드를 함께 가리킨다.배열과 달리 연결리스트에서는 특정 인덱스를 상수 시간에 접근할 수 없다. 즉 리스트에서 k번째 원소를 찾고 싶다면 처음부터 k번 루프를 돌아야 한다. 리스트의 장점은 리스트의 시작 지점에서 아이템을 추가하거나 삭제하는 연산을 상수 시간에 할 수 있다는 점이다.연결리스트 만들기//단방향 연결리스트class Node { Node next = null; int data; public Node(int d) { data = d; } void appendToTail(int d) { Node end = new Node(d); Node n = this; while(n.next != null) { n = n.next; } n.next = end; }}연결리스트에 접근할 때 head 노드의 주소를 참조하는 방법을 사용했다. 이런식으로 구현할 때는 약간 조심해야 하는 부분이 있는데 여러 객체들이 동시에 연결리스트에 참조하는 도중에 head가 바뀌면 어떻게 해야 할지 생각해 봐야 하는 것이다. head가 바뀌었음에도 어떤 객체들은 이전 head를 계속 가리키고 있을 수도 있다.할 수 있다면, Node 클래스를 포함하는 LinkedList 클래스를 만드는 게 좋다. 그렇게 하면 해당 클래스 안에 head Node 변수를 단 하나만 정의해 놓음으로써 위의 문제점을 완전히 해결할 수 있기 때문이다.면접에서 연결리스트에 대해 이야기 할 때는 단방향 연결리스트에 대한 이야기인지 양방향 연결리스트에 대한 이야기인지 반드시 인지하고 있어야 한다.단방향 연결리스트에서 노드 삭제연결리스트에서 노드를 삭제하는 연산은 꽤 직관적이다. 노드 n이 주어지면, 그 이전 노드 prev를 찾아 prev.next를 n.next와 같도록 설정한다. 리스트가 양방향 연결리스트인 경우에는 n.next가 가리키는 노드를 갱신하여 n.next.prev가 n.prev와 같도록 설정해야 한다. 여기서 유의할 점은 1)널 포인터 검사를 반드시 해야한다. 2)필요하면 head와 tail 포인터도 갱신해야 한다.Runner 기법Runner는 부가 포인터라고도 하며, 연결리스트 문제에서 많이 활용되는 기법이다. 연결리스트를 순회할 때 두 개의 포인터를 동시에 사용하는 것이다. 이때 한 포인터가 다른 포인터보다 앞서도록 한다.재귀 문제연결리스트 관련 문제 가운데 상당수는 재귀 호출에 의존한다. 연결리스트 문제를 푸는 데 어려움을 겪고 있다면, 재귀적 접근법은 통할지 확인해 봐야 한다.면접 문제 중복 없애기 : 정렬되어 있지 않은 연결리스트가 주어졌을 때 이 리스트에서 중복되는 원소를 제거하는 코드를 작성하라 뒤에서 k번째 원소 구하기 : 단방향 연결리스트가 주어졌을 때 뒤에서 k번째 원소를 찾는 알고리즘을 구하라 중간 노드 삭제 : 단방향 연결리스트가 주어졌을 때 중간에 있는 노드 하나를 삭제하는 알고리즘을 구현하라(단, 삭제할 노드에만 접근할 수 있다.) 분할 값 : x가 주어졌을 때 x보다 작은 노드들을 x보다 크거나 같은 노드들보다 앞에 오도록 하는 코드를 작성하라 리스트의 합 : 표현된 숫자 두 개가 있을 때, 이 두수를 더하여 그 합을 연결리스트로 반환하는 함수를 작성하라. 예)(7-&gt;1-&gt;6) + (5-&gt;9-&gt;2) = 617 + 295 회문 : 주어진 연결리스트가 회문인지 검사하는 함수를 작성하라 교집합 : 단방향 연결리스트 두 개가 주어졌을 때 이 두 리스트의 교집합 노드를 찾은 뒤 반환하는 코드를 작성하라 (교집합은 노드의 값이 아닌 주소가 완전히 같은 경우를 말한다.) 루프 발견 : 순환 연결리스트가 주어졌을 때, 순환되는 부분의 첫째 노드를 반환하는 알고리즘을 작성하라03. 스택과 큐스택 구현하기스택 자료구조는 말그대로 데이터를 쌓아 올린다는 의미이다. 문제의 종류에 따라 배열보다 스택에 데이터를 저장하는 것이 더 적합한 방법일 수 있다.스택은 Last-In-First-Out 에 따라 자료를 배열한다. pop() : 스택에서 가장 위에 있는 항목을 제거한다. push(item) : item 하나를 스택의 가장 윗 부분에 추가한다. peek() : 스택의 가장 위에 있는 항목을 반환한다. isEmpty() : 스택이 비어있을 때 true를 반환한다.배열과 달리 스택은 상수 시간에 i번째 항목에 접근할 수 없다. 하지만 스택에서 데이터를 추가하거나 삭제하는 연산은 상수 시간에 가능하다.public class MyStack { private static class StackNode{ private T data; private StackNode next; public StackNode(T data) { this.data = data; } } private StackNode top; public T pop() { if (top = null) throw new EmptyStackException() ; T item = top. data; top = top.next; return item; }라 StackNode t = new StackNode (item); t.next = top; top = t. } public T peek(){ if (top == null) throw new EmptyStackException (); return top.data; } public boolean isEmpty () { return top == null; }}스택이 유용한 경우는 재귀 알고리즘을 사용할 때다. 재귀적으로 함수를 호출해야 하는 경우에 임시 데이터를 스택에 넣어 주고, 재귀 함수를 빠져나와 퇴각 검색을 할 때는 스택에 넣어 두었던 임시 데이터를 빼 줘야 한다.큐 구현하기큐는 First-In-First-Out 순서에 따른다. 큐에 저장되는 항목들은 큐에 추가되는 순서대로 제거된다. add(item) : item을 리스트 끝 부분에 추가한다. remove() : 리스트의 첫 번째 항목을 제거한다. peek() : 큐에서 가장 위에 있는 항목을 반환한다. isEmpty() : 큐가 비어 있을 때는 true를 반환한다.public class MyQueue { private static class QueueNode { private T data; private QueueNode next; public QueueNode (T data) { this. data = data; } } private QueueNode first; private QueueNode last; public void add (T item) { QueueNode t = new QueueNode(item); if (last != null) { last.next = t; } last = t; if (first == null) { first = last; } } public T remove() { if (first == null) throw new NoSuchElementException (); T data = first. data; first = first. next; if (first == null) { last = null; } return data; } public T peek() { if (first == null) throw new NoSuchElementException () ; return first.data; } public boolean isEmpty () { return first == null; }큐에서 처음과 마지막 노드를 갱신할 때 실수가 나오기 쉽다. 큐는 너비 우선 탐색을 하거나 캐시를 구현하는 경우에 종종 사용된다.면접 문제 한 개로 세 개 : 배열 한 개로 스택 세 개를 어떻게 구현할지 설명하라 스택 Min : 기본적인 push와 pop 기능이 구현된 스택에서 최소값을 반환하는 min 함수를 추가하려고 한다. 어떻게 설계할 수 있겠는가? 접시 무더기 : 접시 무더기를 생각해보면 접시를 너무 높이 쌓으면 무너져 내릴 것이다. 현실에서는 무더기가 어느 정도 높아지면 새로운 무더리를 만든다. 이것을 흉내내는 자료구조 SetOfStack을 구현해보라 스택으로 큐 : 스택 두 개로 큐 하나를 구현한 MyQueue 클래스를 구현하라 스택 정렬 : 가장 작은 값이 위로 오도록 스택을 정렬하는 프로그램을 작성하라 동물 보호소 : 먼저 들어온 동물이 먼저 나가는 동물 보호소가 있을때 사람들은 보호소에서 가장 오래된 동물부터 입양할 수 있는데 개와 고양이중 어떤 동물을 데려갈지 선택할 수 있다. 이 시스템을 자료구조로 구현하04. 트리와 그래프트리에서 탐색하는 것이 배열이나 연결리스트처럼 선형으로 구성된 자료구조에서 탐색하는 것보다 훨씬 까다롭다. 또 최악의 수행시간과 평균적 수행시간이 매우 크게 바뀔 수 있어서, 알고리즘을 살펴볼 때에는 두 가지 측면 모두를 반드시 따져 봐야 한다.트리의 종류트리를 이해하기 위한 좋은 방법 중 하나는 재귀적 설명법을 사용하는 것이다. 트리는 하나의 루트 노드를 갖는다. 루트 노드는 0개 이상의 자시 노드를 갖고 있다. 그 자식노드 또한 0개 이상의 자식 노드를 갖고 있다.트리에는 사이클이 존재할 수 없다. 노드들은 특정 순서로 나열될 수도 있고, 그럴 수 없을 수도 있다. 각 노드는 어떤 자료형으로도 표현 가능하다.트리 및 그래프 문제들은 대부분 세부사항이 모호하거나 가정 자체가 틀린 경우가 많다. 아래의 이슈들을 유의하고 명확하게 해줄 것을 요구하자. 트리 vs 이진 트리 : 이진 트리는 각 노드가 최대 두 개의 자식을 갖는 트리를 말한다. 이진 트리 vs 이진 탐색 트리 : 이진 탐색 트리는 모든 노드가 특정 순서를 따르는 속성이 있는 이진 트리를 일컫는다. 많은 지원자들이 트리 문제가 주어지면 이진 탐색트리 일 것이라고 가정해 버린다. 이진탐색 트리인지 아닌지 확실하게 묻도록 하자 균형 vs 비균형 : 많은 트리가 균형 잡혀 있긴 하지만, 전부 그런것은 아니다. 면접관에게 어느쪽인지 묻도록 하자. 완전 이진 트리 : 완전 이진 트리는 트리의 모든 높이에서 노드가 꽉 차 있는 이진 트리를 말한다. 마지막 단계는 꽉차있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져야 한다. 전 이진 트리 : 전 이진 트리는 모든 노드의 자식이 없거나 정확히 두 개 있는 경우를 말한다. (자식이 하나만 있는 노드가 존재해서는 안 된다.) 포화 이진 트리 : 포화 이진 트리는 전 이진 트리이면서 완전 이진 트리인 경우를 말한다. 모든 말단 노드는 같은 높이에 있어야 하며, 마지막 단계에서 노드의 개수가 최대가 되어야 한다.이진 트리 순회 중위 순회 : 중위 순회는 왼쪽 가지, 현재 노드, 오른쪽 가지 순서로 노드를 방문하고 출력하는 방법을 말한다. 이진 탐색 트리를 이 방식으로 순회한다면 오름차순으로 방문하게 된다. 전위 순회 : 전위 순회는 자식 노드보다 현재 노드를 먼저 방문하는 방법을 말한다. 전위 순회에서 가장 먼저 방문하게 될 노드는 언제나 루트이다. 후위 순회 : 후위 순회는 모든 자식 노드들을 먼저 방문한 뒤 마지막에 현재 노드를 방문하는 방법을 말한다. 후위 순회에서 가장 마지막에 방문하게 될 노드는 언제나 루트이다.이진 힙(최소힙과 최대힙)최소힙은 트리의 마지막 단계에서 오른쪽 부분을 뺀 나머지 부분이 가득 채워져 있다는 점에서 완전 이진 트리이며, 각 노드의 원소가 자식들의 원소보다 작다는 특성이 있다. 따라서 루트는 트리 전체에서 가장 작은 원소가 된다. 최대 힙은 원소가 내림차순으로 정렬되어 있다는 점만 다를 뿐 최소힙과 완전히 같다. 삽입 : 최소힙에 원소를 삽입할 때는 언제나 트리의 밑바닥에서부터 삽입을 시작한다. 완전 트리의 속성에 위배되지 않게 새로운 원소는 밑바닥 가장 오른쪽 위치로 삽입된다. 힙에 있는 노드의 개수를 n이라 할 때, 연산은 O(log n)시간이 걸린다. 최소 원소 뽑아내기 : 최소힙에서 최소 원소를 찾기란 가장 쉬운 일이다. 최소 원소는 언제나 가장 위에 놓인다. 최솟값을 어떻게 힙에서 제거하느냐가 까다로운 부분이다.트라이(접두사 트리)트라이는 n-차 트리의 변종으로 각 노드에 문자를 저장하는 자료구조이다. 따라서 트리를 아래쪽으로 순회하면 단어 하나가 나온다.널 노드라고도 불리우는 * 노드는 종종 단어의 끝을 나타낸다. * 노드의 실제 구현은 특별한 종류의 자식 노드로 표현될 수도 있다.트라이에서 각 노드는 1개에서 ALPHABET_SIZE + 1개까지 자식을 갖고 있을 수 있다. 트라이는 길이가 K인 문자열이 주어졌을 때 O(K) 시간에 해당 문자열이 유효한 접두사인지 확인할 수 있다.그래프트리는 그래프의 한 종류이다. 그렇다고 모든 그래프가 트리는 아니다. 트리는 사이클이 없는 하나의 연결 그래프이다.그래프는 단순히 노드와 그 노드를 연결하는 간선을 하나로 모아 놓은 것과 같다.그래프에는 방향성이 있을 수도 있고, 없을 수도 있다. 방향성이 있는 간선은 일방통행, 방향성이 없는 간선은 양방향 통행 도로라고 생각하면 된다. 모든 정점 쌍간에 경로가 존재하는 그래프는 연결 그래프라고 부른다. 그래프에는 사이클이 존재할 수도 있고, 존재하지 않을 수도 있다. 사이클이 없는 그래프는 비순환 그래프라고 부른다.인접 리스트 : 인접 리스트는 그래프를 표현할 때 사용되는 가장 일반적인 방법이다. 모든 정점을 인접 리스트에 저장한다. 그래프는 트리와 달리 특정 노드에서 다른 모든 노드로 접근이 가능하지는 않다.//그래프 클래스는 트리의 노드 클래스와 같아 보인다.class Graph { public Node[] nodes;}class Node { public String name; public Node[] children;}인접 행렬 : 인접 행렬은 N x N 불린 행렬로써 matrix[i][j]가 true라면 i에서 j로의 간선이 있다는 뜻이다. (???) 무방향 그래프를 인접 행렬로 표현한다면 이 행렬은 대칭행렬이 된다.그래프 탐색 : 그래프를 탐색하는 방법으로는 깊이 우선 탐색과 너비 우선 탐색이 있다. 깊이 우선 탐색은 루트 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법을 말한다. (넓게 탐색하기 전에 깊에 탐색한다.) 너비 우선 탐색은 루트 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법을 말한다.깊이 우선 탐색(DFS)는 그래프에서 모든 노드를 방문하고자 할 때 더 선호되는 편이다. a노드를 방문한 뒤 a와 인접한 노드들을 차례로 순회한다. a와 인접한 b를 방문했다면, a와 인접한 또 다른 노드를 방문하기 전에 b의 이웃 노드들을 전부 방문해야 한다.그래프 탐색시 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다. 이를 검사하지 않는다면 무한루프에 빠질 수 있다.두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때는 너비 우선 탐색(BFS)가 일반적으로 더 낫다.너비 우선 탐색은 직관적이지 않은 면이 있다. 가장 많은 실수가 BFS가 재귀적으로 동작할 것이라 가정하는데 재귀적으로 동작하지 않는다. BFS는 큐를 사용한다. a 노드에서 시작한다고 했을 때 BFS는 a 노드의 이웃 노드를 모두 방문한 다음에 이웃의 이웃들을 방문한다. 즉 a에서 시작해서 거리에 따라 단계별로 탐색한다고 볼 수 있다.양방향 탐색 : 양방향 탐색은 출발지와 도착지 사이에 최단 경로를 찾을 때 사용되곤 한다. 기본적으로 출발지와 도착지 두 노드에서 동시에 너비 우선 탐색을 수행한 뒤 두 탐색 지점이 충돌하는 경우에 경로를 찾는 방식이다.면접 문제 노드 사이의 경로 : 방향 그래프가 주어졌을 때 두 노드 사이에 경로가 존재하는지 확인하는 알고리즘을 작성하라 최소 트리 : 오름차순으로 정렬된 배열이 있다. 이 배열안에 들어있는 원소는 정수이며 중복된 값이 없다고 했을 때 높이가 최소가 되는 이진탐색트리를 만드는 알고리즘을 작성하라 깊이의 리스트 : 이진 트리가 주어졌을 때 같은 깊이에 있는 노드를 연결리스트로 연결해주는 알고리즘을 설계하라 균형 확인 : 이진 트리가 균형 잡혀있는지 확인하는 함수를 작성하라 BST 검증 : 주어진 이진 트리가 이진 탐색 트리인지 확인하는 함수를 작성하라 후속자 : 이진 탐색 트리에서 주어진 노드의 다음 노드를 찾는 알고리즘을 작서앟라 순서 정하기 : 프로젝트의 리스트와 프로젝트들 간의 종속 관계가 주어졌을 때 프로젝트를 수행해 나가는 순서를 찾으라 첫 번째 공통 조상 : 이진 트리에서 노드 두 개가 주어졌을 때 이 두 노드의 첫번째 공통 조상을 찾는 알고리즘을 설계하고 그 코드를 작성하라 BST 수열 : 배열의 원소를 왼쪽에서부터 차례로 트리에 삽입함으로써 이진 탐색 트리를 생성할 수 있다. 이진 탐색 트리 안에서 원소가 중복되지 않는 다고 할 때, 해당 트리를 만들어 낼 수 있는 모든 가능한 배열을 출력하라. 하위 트리 확인 : 두 개의 커다란 이진 트리 T1과 T2가 있다고 하자. T1이 T2 보다 훨씬 크다고 했을 때, T2가 T1의 하위 트리(subtree)인지 판별하는 알 고리즘올 만들라. 임의의 노드 : 이진 트리 클래스를 바닥부터 구현하려고 한다. 노드의 삽입, 검색, 삭제뿐만 아니라 임의의 노드를 반환하는 getRandomNode() 메서드도 구현한다. 모든 노드를 같은 확률로 선택해주는 getRandomNode 메서드를 설계하고 구현하라 합의 경로 : 각 노드의 값이 정수인 이진 트리가 있다. 이때 정수의 합이 특정 값이 되도록 하는 경로의 개수를 세려고 한다. 경로는 꼭 위에서 아래로 내려가야 한다. 즉 부모 노드에서 자식 노드로만 움직일 수 있다. 이 알고리즘을 설계하라05. 비트 조작비트 조작 기법은 다양한 문제에서 활용된다. 명시적으로 요구하는 문제들도 있는 한편, 코드를 최적화할 때 유용하게 사용되는 기법으로 활용되기도 한다. 비트 조작 코드를 작성하는 능력뿐 아니라 손으로도 그릴 수 있도록 익숙해 지는 것이 좋다.손으로 비트 조작 해보기비트 조작을 할 때 알아야 할 사실들과 트릭들비트 조작 문제를 풀 때 다음의 표현식들을 알아 두면 좋다.위 표현식들을 이해하기 위해서는 연산들이 비트 단위로 이루어진다는 사실을 명심해야 한다. 한 비트에서 일어나는 일이 다른 비트에 어떤 영향도 미치지 않는다. 그러므로 위 표현식이 한 비트에 대해 참이라면 일련의 비트들에 대해서도 참이 된다.산술 우측 시프트 vs 논리 우측 시프트산술 우측 시프트는 기본적으로 2로 나눈 결과와 같다. 논리 우측 시프트는 우리가 일반적으로 비트를 옮길 때 보이는 것처럼 움직인다.논리 우측 시프트는 비트를 옆으로 옮긴 다음에 최상위 비트에 0을 넣는다. 즉, »&gt; 연산과 같다.기본적인 비트 조작 : 비트값 확인 및 채워넣기비트값 확인//이 메서드는 1을 i비트만큼 시프트해서 00010000과 같은 값을 만든다.//그 다음 AND 연산을 통해 num의 i번째 비트를 뺀 나머지 비트를 모두 삭제한 뒤, 이 값을 0과 비교한다.//만약 이 값이 0이 아니라면 i번째 비트는 1이어야 하고, 0이라면 i번째 비트는 0이어야 한다.boolean getBit(int num, int i) { return((num &amp; (1 &lt;&lt; i)) != 0);}비트값 채워넣기//SetBit는 1 i비트만큼 시프트해서 00010000과 같은 값을 만든다.//그 다음 OR 연산을 통해 num의 i번째 비트값을 바꾼다.//i번째를 제외한 나머지 비트들은 0과 OR 연산을 하게 되므로 num에 아무 영향을 끼치지 않는다.int setBit(int num, int i) { return num | (1 &lt;&lt; i);}비트값 삭제하기//이 메서드는 setBit를 거의 반대로 한 것과 같다. NOT 연산자를 이용해 00010000 -&gt; 11101111과 같이 만든 뒤 num과 AND 연산을 수행한다.//그러면 나머지 비트의 값은 변하지 않은채 i번째 비트값만 삭제된다.int clearBit(int num, int i) { int mask = ~(1 &lt;&lt; i); return num &amp; mask;}비트값 바꾸기i번째 비트값을 v로 바꾸고 싶다면 우선 11101111과 같은 값을 이용해 (i=4인 경우) i번째 비트값을 삭제해야 한다. 그 뒤 우리가 바꾸고자 하는 값 v를 왼쪽으로 i번 시프트한다.면접 문제 삽입 : 두 개의 32비트 수 N과 M이 주어지고, 비트 위치 i와 j가 주어졌을 때, M을 N에 삽입하는 메서드를 구현하라. 2진수를 문자열로 : 0.72와 같이 0 과 1 사이의 실수가 double 타입으로 주어 졌을 때, 그 값을 2진수 형태로 출력하는 코드를 작성하라. 비트 뒤집기 : 어떤 정수가 주어졌을 때 여러분은 이 정수의 비트 하나를 0에서 1로 바꿀 수 있다. 이때 1이 연속으로 나올 수 있는 가장 긴 길이를 구하는 코드를 작성하라. 다음 숫자 : 양의 정수가 하나 주어졌다. 이 숫자를 2진수로 표기했을 때 1 비트의 개수가 같은 숫자중에서 가장 작은 수와 가장 큰 수를 구하라. 디버거 : 다음 코드가 하는 일을 설명하라 ((n &amp; (n-1)) == 0) 변환 : 정수 A와 B를 2진수로 표현했을 때 A를 B로 바꾸기 위해 뒤집어야 하는 비트의 개수를 구하는 함수를 작성하라 쌍끼리 맞바꾸기 : 명령어를 가능한 한 적게 사용해서 주어진 정수의 짝수 번째 비트의 값과 홀수번째 비트의 값을 바꾸는 프로그램을 작성하라 선 그리기 : 흑백 모니터 화면은 하나의 바이트 배열에 저장되는데, 인접한 픽셀 여덟 개를 한 바이트에 묶어서 저장한다. 화면의 폭은 w이며, w는 8로 나누어 떨어진다. 이때 (x1, y)에서 (x2, y)까지 수평선을 그려주는 함수를 작성하라06. 수학 및 논리 퍼즐많은 문제들이 수학 혹은 컴퓨터 과학에 기초해서 만들어졌기 때문에 대부분 논리적인 추론으로 해법을 찾을 수 있다.소수모든 자연수는 소수의 곱으로 나타낼 수 있다는 규칙이 있다. 가분성 : 어떤 수 x로 y를 나눌 수 있으려면 x를 소수의 곱으로 분할하였을 때 나열되는 모든 소수는 y를 소수의 곱으로 분할하였을 때 나열되는 모든 소수들의 부분집합이어야 한다. 소수판별 : 어떤 수 n이 소수인지 여부를 판별하는 가장 단순한 방법은 2에서 n-1까지 루프를 돌면서 나누어지는 경우가 있는지 확인해 보는 것이다. 소수 목록 만들기(에라토스테네스의 체) : 에라토스테네스의 체는 소수 목록을 만드는 굉장히 효율적인 방법이다. 이 알고리즘은 소수가 아닌 수들은 반드시 다른 소수로 나누어진다는 사실에 기반해서 동작한다.boolean [] sieve0fEratosthenes(int max) { boolean[] flags = new boolean [max + 1]; int count = 0; init(flags); // 0과 1번 인덱스를 제외한 모든 원소값을 true로 초기화한다. int prime = 2; while (prime s= Math.sart (max)) { /* prime의 배수들을 지워나간다. */ cross0ff(flags, prime); /* 그다음 true로 세팅된 인덱스를 찾는다. */ prime = getNextPrime (flags, prime); } return flags;}void crossOff (boolean [] flags, int prime) { /* prime의 배수들을 제거해나간다. K &lt; prime인 k에 대한 k * prime은 * 이전 루프에서 이미 제거되었을 것이므로 prime * prime부터 시작한다. */ for (int i = prime * prime; i &lt; flags.length; i += prime) flags [i] = false; }}int getNextPrime (boolean [] flags, int prime) { int next = prime + 1; while (next &lt; flags.length &amp;&amp; !flags[next]) { next++; } return next;}확률확률은 까다롭게 느껴질 수 있지만 기본적으로는 논리적인 추론이 가능한 몇 가지 법칙에 기반한다.&lt;img src=”/assets/img/posting_img/book/코딩인터뷰/확률.jpeg” width=”700px””&gt;A ∩ B의 확률위 벤다이어그램에 다트를 던진다고 생각했을 때 A와 B의 두 원이 겹치는 부분에 다트가 떨어질 확률은 얼마나 되는가? A에 떨어질 확률과 A와 B가 겹치는 부분의 비율도 알고 있다면, 그 확률은 다음과 같이 표현할 수 있다. P(A∩B) = P(B|A)P(A)예) 1~10까지의 수 중 하나를 뽑는다고 할 때, 5보다 작거나 같으면서 동시에 짝수인 수를 뽑을 확률은 얼마가 되는가? 1-5까지의 수를 뽑을 확률은 50%이고, 1~5 중에서 짝수를 뽑을 확률은 40%다. 따라서 두 경우에 모두 속할 확률은 다음과 같다. P(x=짝수∩x&lt;= 5) = P(x=짝수∩x&lt;=5)P(x&lt;=5)=(2/5)*(1/2)=1/5A ∪ B의 확률다트가 A 또는 B에 떨어질 확률은 각 영역에 떨어질 확률은 알고 있고, 겹치는 부분에 떨어질 확률도 알고 있다면, A 혹은 B에 떨어질 확률은 다음과 같이 표현할 수 있다. P(A∪B)=P(A)+P(B)-P(A∩B)여기서 독립사건과 상호 배타적인 사건의 확률을 구하는 특수 규칙들을 쉽게 얻을 수 있다. 독립성 : A와 B가 독립사건(발생한 사건 사이에 아무런 관계가 없는 경우)이라면, A가 B에 아무런 영향을 끼치지 않으므로 P(B A)=P(B)가 되고 따라서 P(A∩B)=p(A)가 된다. 상호 배타성 : A와 B가 상호 배타적이라면 P(A∩B)=0이 되므로 P(A∪B)를 계산할 때 P(A∩B)항은 제거해도 된다. 따라서 P(A∪B)=P(A)+P(B)가 된다.두 사건의 확률이 전부 0보다 큰 경우에 이 두 사건이 독립적이면서 상호 배타적인 것은 불가능하다. 두 사건중 하나의 확률이 0이라면 두 사건은 독립적이면서 상호 배타적이다.입을 열라수수께끼 같은 문제를 만나게 되면 당황하지 말라, 면접관들이 원하는 것은 여러분이 문제를 어떻게 공략해 나가는지 보는 것이다. 입을 열어 말을 하고, 문제를 어떻게 공략해 나가는지 면접관들에게 보여주라.규칙과 패턴을 찾으라많은 경우에 문제를 풀다가 발견하는 규칙이나 패턴을 따로 적어두면 도움이 된다. (사실 반드시 적어두는 것이 낫다.)예) 끈이 두 개가 있다. 각 끈은 태우는데 정확히 한 시간이 걸린다. 이 두 끈을 사용해 15분을 재려면 어떻게 해야되겠는가? 끈의 밀도는 균일하지 않아서 절반의 길이를 태우는데 드는 시간이 정확히 30분이라는 보장은 없다.[규칙] 태우는 데 x분이 걸리는 끈과 y분이 걸리는 끈이 주어지면, x+y만큼의 시간을 잴 수 있다. 태우는 데 x분이 걸리는 끈이 주어지면, x/2분을 잴 수 있다. 1번 끈을 태우는 데 x분 걸리고 2번 끈을 태우는 데 y분이 걸리면, 2번 끈을 태우는 시간을 (y-x)분이나 (y-x/2)분으로 바꿀 수 있다.이 규칙들을 조합하면 전부 태우는 데 한 시간 걸리는 2번 끈을 30분 걸리는 끈으로 바꿀 수 있다. 그다음 2번 끈의 양쪽에 불을 붙여 버리면 2번 끈은 15분 뒤에 전부 타버린다. 그러니 다음의 순서대로 해보자 1번 끈은 양쪽에 불을 붙이고, 2번 끈은 한쪽에만 불을 붙인다. 1번 끈이 다 타들어가면 30분이 지난 것이다. 따라서 2번 끈이 다 타기 위해 남은 시간은 30분이다. 그 시점에 2번 끈의 다른 쪽에도 불을 붙인다. 그러면 정확히 15분 뒤에 2번 끈도 완전히 다 타버릴 것이다.최악의 경우는?수수께끼 종류의 문제 중 많은 수가 최악의 경우를 최소화하는 것와 연관이 있다. 어떤 행동을 최소화하는 문제일 수도 있고, 지정된 횟수 안에 처리해야 하는 문제일 수도 있다. 그럴 때는 최악의 상황을 균형 맞추도록 하면 도움이 된다.알고리즘적 접근법문제를 풀다가 막혔다면, 알고리즘 문제를 푸는 접근법 가운데 하나를 적용해 보자. 수수께끼처럼 보이는 문제들 중 상당수는 기술적인 측면을 제거한 알고리즘 문제인 경우가 많다.면접 문제 무거운 알약 : 약병 20개가 있다. 이중 19개에는 1.0그램짜리 알약들이 들어있고, 하나에는 1.2그램짜리 알약들이 들어 있다. 저울이 주어졌을때 무거운 약병을 찾으려면 어떻게 해야 할까? 저울은 딱 한 번만 쓸 수 있다. 도미노 : 8X8 크기의 체스판이 있는데 대각선 반대 방향 끝에 있는 셀 두 개가 떨어져 나갔다. 하나의 도미노로 정확히 두 개의 정사각형을 덮을 수 있을 때, 31개 도미노로 보드 전체를 덮을 수 있겠는가? 삼각형 위의 개미 : 개미 세 마리가 삼각형의 각 꼭짓점에 있다. 개미 세 마리가 삼각형 모서리를 따라 걷기 시작했을 때, 두 마리 혹은 세 마리 전부가 충돌할 확률은 얼마인가? 물병 : 5리터짜리 물병과 3리터 짜리 물병이 있다. 물은 무제한으로 주어지지만 계량컵은 주어지지 않는다. 이 물병 두 개를 사용해서 정확히 4리터 물을 계량하려면 어떻게 해야 할까? 계란 떨어뜨리기 문제 : 100층짜리 건물이 있다. N층 혹은 그 위 어딘가에서 계란이 떨어지면 그 계란은 부서진다. 하지만 N층 아래 어딘가에서 떨어지 면 깨지지않는다. 계란 두 개가 주어졌을 때, 최소 횟수로 계란을 떨어뜨려서 N을 찾으라. 100 라커 : 복도에 100개의 라커가 있다. 어떤 남자가 100개의 라커 문을 전부 연다. 그러고 나서 짝수 번호의 라커를 전부 닫는다. 그 다음에는 번호가 3의 배수인 라커를 순서대로 찾아다니며 열려 있으면 닫고, 닫혀 있으면 연다. 이런 식으로 복도를 100번 지나가면(마지막에는 100번째 라커의 문을 열거나 닫을 것이다) 열린 라커문은 몇 개가 되겠는가? 독극물 : 1,000개의 음료수 중 하나에 독극물이 들어 있다. 그리고 독극물을 확인해 볼 수 있는 식별기 10개가 주어졌다. 독극물 한 방울을 식별기에 떨어뜨리면 식별기가 변한다. 만약 식별기에 독극물을 떨어뜨리지 않았다면 몇 번이든 재사용해도 된다. 하지만 이 테스트는 하루에 한 번만 할 수 있으며 결과를 얻기까지 일주일이 걸린다. 독극물이 든 음료수를 가능한 한 빨 리 찾아내려면 어떻게 해야 할까?07. 객체 지향 설계객체 지향 설계에 관한 문제들은 기술적 문제 또는 실제 생활에서 접할 수 있는 객체들을 구현하는 클래스와 메서드를 대략적으로 그려보는 문제다. 이런 문제들을 통해 지원자들이 어떤 코딩 스타일을 갖고 있는지 알아볼 수 있다.접근법객체가 나타내는 것이 물리적 개체이건 기술적 작업이건 간에 객체 지향 설계에 관한 질문들은 거의 비슷한 방식으로 공략 가능하다. 모호성의 해소 : 객체 지향 설계 관련 문제들은 대개 고의적으로 모호성을 띄고 있다. 면접관들은 여러분이 스스로 가정을 만들어내고, 질문을 통해 명확히 해나가는 과정을 살펴보고 싶어하기 때문이다. 객체 지향 설계에 관한 질문을 받으면, 누가 그것을 사용할 것이며 어떻게 사용할 것인지에 대한 질문을 던져야 한다. 핵심 객체의 설계 : 시스템에 넣을 핵심 객체가 무엇인지 생각해 봐야 한다. 관계 분석 : 핵심 객체를 결정했다면, 객체 사이의 관계를 분석해야 한다. 어떤 객체가 어떤 객체에 속해 있는가? 다른 객체로부터 상속받아야 하는 객체는 있나? 관계는 다대다 관계인가 아니면 일대다 관계인가? 행동 분석 : 이제 남은 일은 객체가 수행해야 하는 핵심 행동들에 대해서 생각하고, 이들이 어떻게 상호작용해야 하는지 따져 보는 것이다.디자인 패턴면접관은 지식이 아닌 능력을 평가할 것이므로 디자인 패턴은 보통 면접 범위 외로 친다. 하지만 싱글톤, 팩터리 메서드와 같은 디자인 패턴을 알아두면 면접 볼 때 특히 유용하다.여러분의 소프트웨어 엔지니어링 기술을 향상시키는 가장 좋은 방법은 디자인 패턴에 관한 책을 하나 골라 공부하는 것이다. 싱글톤 클래스 : 싱글톤 패턴은 어떤 클래스가 오직 하나의 객체만을 갖도록 하며, 프로그램 전반에 걸쳐 그 객체 하나만 사용되도록 보장해야 한다. 팩터리 메서드 : 팩터리 메서드는 어떤 클래스의 객체를 생성하기 위한 인터페이스를 제공하되, 하위 클래스에서 어떤 클래스를 생성할지 결정할 수 있도록 도와준다. 한 가지 방법은 Factory 메서드 자체에 대한 구현은 제공하지 않고 객체 생성 클래스를 abstract로 선언하고 놔두는 것이다.면접 문제 카드 한 벌 : 카드 게임에 쓰이는 카드 한 벌을 나타내는 자료구조를 설계하라. 콜 센터 : 고객 응대 담당자, 관리자, 감독관 이렇게 세 부류의 직원들로 구성된 콜 센터가 있다고 할 때, 콜 센터로 오는 전화는 먼저 상담이 가능한 고객 응대 담당자로 연결돼야 한다. 고객 응대 담당자가 처리할 수없는 전화는 관리자로 연결되고, 관리자가 처리할 수 없는 전화는 다시 감독관에게 연결된다. 이 문제를 풀기 위한 자료구조를 설계하라 주크박스 : 객체 지향 원칙에 따라 음악용 주크박스를 설계하라 주차장 : 객체 지향 원칙에 따라 주차장을 설계하라 온라인 북 리더 : 온라인 북 리더 시스템에 대한 자료구조를 설계하라 직소 : N x N 크기의 직소 퍼즐을 구현하라. 자료구조를 설계하고, 퍼즐을 푸는 알고리즘을 설명하라 채팅 서버 : 채팅 서버를 어떻게 구현할 것인지 설명하라 지뢰찾기 : 텍스트 기반의 지뢰찾기 게임을 설계하고 구현하라. 파일 시스템 : 메모리 상주형 파일 시스템을 구현하기 위한 자료구조와 알고리즘에 대해 설명해 보라 해시 테이블 : 체인(연결리스트)를 사용해 충돌을 해결하는 해시테이블을 설계하고 구현하라08. 재귀와 동적 프로그래밍재귀와 관련된 문제들은 아주 많지만 상당수는 패턴이 비슷하다. 주어진 문제가 재귀 문제인지 확인해 보는 좋은 방법은, 해당 문제를 작은 크기의 문제로 만들 수 있는지 보는 것이다.다음과 같은 문장으로 시작하는 문제는 재귀로 풀기 적당한 문제일 가능성이 높다. “n번째…를 계산하는 알고리즘을 설계하라”, “첫 n개를 나열하는 코드를 작성하라”, “모든 …를 계산하는 메서드를 구현하라” 등등접근법재귀적 해법은 부분문제에 대한 해법을 통해 완성된다. 믾은 경우 단순히 f(n-1)에 대한 해답에 무언가를 더하거나, 제거하거나, 아니면 그 해답을 변경하여 f(n)을 계산해낸다. 주어진 문제를 부분문제로 나누는 방법도 여러 가지가 있다. 가장 흔하게 사용되는 세 가지 방법으로는 다음이 있다. 상향식 접근법 : 상향식 접근법은 가장 직관적인 경우가 많다. 우선 간단한 경우들에 대한 풀이법을 발견하는 것으로부터 시작한다. 하향식 접근법 : 하향식 접근법은 덜 명확해서 복잡해 보일 수 있다. 이러한 문제들은 어떻게 하면 N에 대한 문제를 부분 문제로 나눌 수 있을지 생각해 봐야 한다. 반반 : 데이터를 절반으로 나누는 방법도 종종 유용하다. 예) 이진 탐색재귀적 해법 vs 순환적 해법재귀적 알고리즘은 사용하면 공간 효율성이 나빠질 수 있다. 재귀 호출이 한 번 발생할 때마다 스택에 새로운 층을 추가해야 한다. (재귀의 깊이가 n일 때 O(n)만큼의 메모리를 사용하게 된다는 것을 의미한다.) 이런 이유로 재귀적 알고리즘을 순환적으로 구현하는 것이 더 나을 수 있다.동적 계획법 &amp; 메모이제이션동적 프로그래밍은 거의 대부분 재귀적 알고리즘과 반복적으로 호출괴는 부분문제를 찾아내는 것이 관건이다. 이를 찾은 뒤 나중을 위해 현재 결과를 캐시에 저장해 놓으면 된다.동적 프로그래밍을 설명하는 가장 간단한 예시는 n번째 피보나치 수를 찾는 것이다. 이런 문제를 풀 때는 일반적인 재귀로 구현한 뒤 캐시 부분을 나중에 추가하는 것이 좋다.//피보나치 수열//1) 재귀int fibonacci(int i) { if(i==0) return 0; if(i==1) return 1; return fibonacci(i-1) + fibonacci(i-2);}//2) 하향식 동적 프로그래밍(메모이제이션)int fibonacci(int n) { return fibonacci(n, new int[n + 1]);}int fibonacci(int i, int[] memo) { if (i = 0 || i == 1) return i; if (memo[i] == 0) { memo[i] = fibonacci(i - 1, memo) + fibonacci(i - 2, memo); } return memo[i];}//3) 상향식 동적 프로그래밍int fibonacci(int n) { if (n == 0) return 0; else if (n == 1) return 1; int[] memo = new int[n]; memo[0] = 0: memo[1] = 1; for (int i = 2; i &lt; n; i++) { memo[i] = memo [i - 1] + memo [i - 2]; } return memo[n - 1] + memo [n - 2];}면접 문제 트리플 스텝 : 어떤 아이가 n개의 계단을 오른다. 한 번에 1계단 오르기도 하고, 2계단이나 3계단을 오르기도 한다. 계단을 오르는 방법이 몇 가지가 있는지 계산하는 메서드를 구현하라 격자판 상의 로봇 : 행의 개수는 r, 열의 개수는 c인 격자판의 왼쪽 상단 꼭짓점에 로봇이 놓여 있다고 할 때, 이 로봇은 오른쪽 아니면 아래쪽으로만 이동할 수 있다. 마술 인덱스 : 배열 A[0 ... n-1]에서 A[i] = i인 인덱스를 마술 인덱스라 정의한다. 정렬된 상태의 배열이 주어졌을 때, 마술 인덱스가 존재한다면 그 값을 찾는 메서드를 작성하라. 부분 집합 : 어떤 집합의 부분집합을 전부 반환하는 메서드를 작성하라 재귀 곱셈 : * 연산자를 사용하지 않고 양의 정수 두 개를 곱하는 재귀 함수를 작성하라 괄호 : n쌍의 괄호로 만들 수 있는 모든 합당한 조합을 출력하는 알고리즘을 구현하라 영역 칠하기 : 이미지 편집 프로그램에서 흔히 쓰이는 영역 칠하기 함수를 구현하라09. 시스템 설계 및 규모 확장성규모 확장성은 가장 쉬운 종류의 문제이다. 이런류의 문제들은 단순히 여러분이 실제 세계에서 어떻게 행동할지를 보기 위해 설계된 문제들이다.문제를 다루는 방법 소통하라 : 시스템 설계 문제를 출제하는 가장 큰 목적은 의사소통 능력을 평가하기 위함이다. 면접관과 끊임없이 의사소통하라, 질문을 던지고 시스템에 발생할 수 있는 문제점을 열린 마음으로 받아들여라 처음에는 포괄적으로 접근하라 : 알고리즘으로 바로 뛰어들지 말고, 특정 부분을 과도하게 파고들지 말라 화이트보드를 사용하라 면접관이 우려하는 부분을 인정하라 가정을 할 때 주의하라 여러분이 생각하는 가정을 명확히 언급하라 : 가정을 할 때는 그것을 면접관에게 알려 줘야 한다. 필요하다면 어림잡아 보라 뛰어들라 : 지원자로서 문제를 책임져야 한다. 그렇다고 조용히 있으면 안 된다. 반드시 면접관과 이야기를 해야 한다.시스템 설계 : 단계별 접근법 문제의 범위를 한정하라 : 설계해야 할 시스템에 대해 잘 모르고 있다면 시스템을 설계할 수 없다. 만들고자 하는 시스템과 면접관이 원하는 것이 같은지 확실히 할 수 있다는 점에서 문제의 범위를 한정하는 작업은 중요하다. 합리적인 가정을 만들라 : 필요하다면 가정을 세우는 것도 괜찮지만 합당해야한다. 중요한 부분을 먼저 그리라 : 시스템의 주요한 부분을 다이어그램으로 그려라. 시스템의 처음부터 마지막까지 어떻게 동작하는지 그 흐름을 보이라. 핵심 문제점을 찾으라 : 기본적인 설계를 마친 뒤에는 발생할 수 있는 핵심 문제에 집중해야 한다. 어느 부분이 병목지점일까? 이 시스템이 풀어야할 주된 문제는 무엇인가? 핵심 문제점을 해결할 수 있도록 다시 설계하라 : 핵심 문제가 무엇인지 알아냈다면 그에 맞게 설계를 수정해야 한다. 또 알고있는 제약사항들을 면접관과 이야기하는 것 또한 중요하다.규모 확장을 위한 알고리즘: 단계별 접근법단순히 시스템의 한부분 혹은 알고리즘을 설계해 보라는 요청을 받을 수도 있는데 이때도 반드시 규모 확장성을 신경써야 한다. 질문하라 : 초반에는 문제를 제대로 이해했는지 확인하기 위한 질문 시간이 필요하다. 문제가 무엇인지 확실하게 이해하지 못한 상태에서는 문제 자체를 풀 수가 없다. 현실적 제약을 무시하라 : 메모리 제약이 없고, 컴퓨터 한 대에서 모든 데이터를 다 처리할 수 있다고 가정해보라 현실로 돌아오라 : 원래 문제로 돌아와서 컴퓨터 한 대에 저장할 수 있는 데이터의 크기는 얼마나 되고, 데이터를 여러 조각으로 쪼갰을 때 어떤 문제가 발생할지 생각해 보라 문제를 풀어라 : 발견된 문제점들을 어떻게 해결할지 생각해 봐야 한다.시스템 설계의 핵심 개념특정 개념을 알고 있으면 문제를 더 쉽게 풀 수 있다.수평적 vs 수직적 규모 확장 수직적 규모 확장 : 특정 노드의 자원의 양을 늘리는 방법을 말한다. 예) 서버의 메모리를 추가해서 서버의 처리 능력을 향상시킬 수 있다. 수평적 규모 확장 : 노드의 개수를 늘리는 방법을 말한다. 예) 서버를 추가함으로써 서버 한 대가 다뤄야 하는 부하를 줄일 수 있다.서버 부하 분산 장치일반적으로 규모 확장성이 있는 웹사이트의 프론트엔드 부분은 서버 부하 분산 장치를 통해서 제공된다. 이렇게 해야 서버에 걸리는 부하를 여러 대의 서버에 균일하게 분산시킬 수 있고, 서버 한 대 때문에 전체 시스템이 죽거나 다운되는 상황을 방지할 수 있다.데이터베이스 역정규화와 NoSQLSQL 같은 관계형 데이터베이스의 조인 연산은 시스템이 커질수록 굉장히 느려진다. 따라서 조인 연산은 가능하면 피해야 한다. 역정규화를 사용하면 데이터베이스의 정보를 추가해서 읽기 연산의 속도를 향상시킬 수 있다. 또는 NoSQL 데이터베이스를 사용할 수도 있다. NoSQL은 조인 연산 자체를 지원하지 않는다. 따라서 자료를 저장할 때 조금 다른 방식으로 구성해 놓는데, 이 방식이 규모 확장성에 좋도록 설계되어 있다.데이터 베이스 분할(샤딩)샤딩은 데이터를 여러 컴퓨터에 나눠서 저장하는 동시에 어떤 데이터가 어떤 컴퓨터에 저장되어 있는지 알 수 있는 방식을 말한다. 수직적 분할 : 자료의 특성별로 분할하는 방식, 단점으로는 특정 테이블의 크기가 일정 수준이상으로 커지면, 데이터베이스를 재분할해야 할 수도 있다. 키 혹은 해시 기반 분할 : 간단하게 구현하자면 mod(key, n)의 값을 이용해서 N개의 서버에 분할 저장하면 된다. 문제는 서버를 새로 추가할 때마다 모든 데이터를 다시 재분배해야 하는데, 굉장히 비용이 큰 작업이다. 디렉터리 기반 분할 : 데이터를 찾을 때 사용되는 조회 테이블을 유지하는 방법이다. 이 방법은 상대적으로 서버를 추가하기 쉽지만 심각한 단점으로는 조회 테이블이 단일 장애지점이 될 수 있고, 지속적으로 테이블을 읽는 행위가 전체 성능에 영향을 미칠 수 있다.캐싱인메모리 캐시를 사용하면 결과를 굉장히 빠르게 가져올 수 있다. 인메모리 캐시는 키-값을 쌍으로 갖는 간단한 구조로써 일반적으로 애플리케이션과 데이터 저장소 사이에 자리잡고 있다.비동기식 처리 &amp; 큐이상적인 경우 속도가 느린 연산은 비동기식으로 처리해야 한다. 그렇지 않으면 해당 연산이 끝나기까지 하염없이 기다려야 할 수도 있기 때문이다. 어떤경우에는 연산을 미리 해 놓을 수 있다.네트워크 성능 척도네트워크의 성능을 측정할 때 사용되는 몇 가지 중요한 척도는 다음과 같다. 대역폭 : 단위 시간에 전송할 수 있는 데이터의 최대치를 말한다. 보통 초당 몇 비트를 보낼 수 있는지로 계산한다. 처리량 : 처리량은 단위 시간에 실제로 전송된 데이터의 양을 의미한다. 지연 속도 : 데이터를 전송하는 데 걸리는 시간을 말한다.예) 공장의 컨베이어 벨트에서 물품이 이동할때, 지연 속도는 물품 하나가 한 지점에서 다른 지점까지 옮겨지는 데 걸린 시간을 말하고, 처리량은 단위 시간에 옮겨진 물품의 개수를 의미한다. 컨베이어 벨트의 폭을 넓힌다고 지연속도가 달라지지는 않는다. 하지만 처리량과 대역폭을 바꾼다면 달라질 수 있다. 벨트의 길이를 줄이면 각 물품이 벨트 위에서 보내는 시간이 줄어들기 때문에 지연 속도 또한 줄어들 것이다. 컨베이어 벨트의 속도를 빠르게 만든다면 위의 세 가지 척도를 모두 바꿀 수 있다. 대역폭은 최상의 조건에서 단위 시간에 전송할 수 있는 물품의 개수를 뜻한다. 처리량은 실제 상황에서 단위 시간에 전송된 물품의 개수를 말한다.지연 시간은 무시되기 쉽지만 특정 상황에선 굉장히 중요한 역할을 한다.MapReduceMapReduce 프로그램은 보통 굉장히 커다란 데이터를 처리하는 데 사용된다. MapReduce 프로그램을 사용하려면 Map 단계와 Reduce 단계를 구현해야 한다. 나머지 부분은 시스템이 알아서 처리할 것이다. Map 은 데이터를 입력으로 받은 뒤 key, value 쌍을 반환한다. Reduce는 키와 값들을 입력으로 받은 뒤 처리과정을 거쳐 새로운 키와 값을 반환한다. 경우에 따라 이 결과를 또 다른 Reduce 프로그램에 넘길 수도 있다.MapReduce는 많은 과정을 병렬로 처리할 수 있게 도와주기 때문에 굉장히 커다란 데이터에 대해서도 규모 확장이 쉬워진다.시스템 설계시 고려할 점 실패 : 시스템의 어떤 부분이든 실패 가능성이 존재한다. 따라서 각 부분이 실패했을 때를 대비한 대비책을 준비해야 한다. 가용성 및 신뢰성 : 가용성은 사용 가능한 시스템의 시간을 백분율로 나타낸 것을 말한다. 신뢰성은 특정 단위 시간에 시스템이 사용 가능할 확률을 나타낸 것을 말한다. 읽기 중심 vs 쓰기 중심 : 쓰는 연산이 많다면 큐를 사용하는 방법을 생각해보고, 읽는 연산이 많다면 캐시를 사용하는 것이 좋을 수 있다. 보안 : 해당 시스템이 직면할 수 있는 문제점에 대해 생각해 보고 그를 해결하기 위해 어떻게 시스템을 설계할지 생각해보라완벽한 시스템은 없다어떤 시스템에 대해서도 완벽하게 동작하는 시스템 설계란 존재하지 않는다. 이런 종류의 문제를 받았을 때 여러분이 해야 할 일은 사례를 잘 이해하고, 문제의 범위를 설정하고, 합리적인 가정을 세운뒤, 명확하게 설계한 시스템을 만드는 것이다.연습 문제수백 만 개의 문서가 주어졌을 때, 특정 단어 리스트가 포함된 문서를 찾으려고 한다. 어떻게 할 수 있을까? 단어가 등장하는 순서는 중요하지 않지만, 해당 단어가 완벽하게 나타나야 한다. 처음에는 문서가 겨우 수십 개 있을 때를 가정하고 문제를 풀어 본다. 한 가지 방법은 전처리 과정을 통해 모든 문서에 대한 해시테이블을 만드는 것이다. 문서의 개수가 수백만 개로 늘어나면 어떻게 해야 할까? 일단 문서를 여러 대의 컴퓨터로 나눠서 보내야 할 것이다. 데이터를 나누려면 다음과 같은 사항들을 고민해야 한다. 해시테이블은 어떻게 분할할 것인가? 키워드에 따라 나눌 수 있다. 어떤 단어에 대한 문서 목록은 컴퓨터 한 대에 온전히 저장될 것이다. 즉 전체 문서 집합 가운데 특정한 부분집합에 대한 해시 테이블만 한 컴퓨터에 두는 것이다. 데이터를 분할하기로 결정하면, 어떤 컴퓨터에서는 문서를 처리하고 그 처리 결과를 다른 컴퓨터로 옮겨야 할 수 있다. 어떤 컴퓨터에 어떤 데이터가 보관되어 있는지 알 수 있어야 한다. 각 문제점들에 대한 해법을 찾아야 한다. 한 가지 방법은 키워드를 알파벳 순서에 따라 분할하는 것이다. 즉 한 컴퓨터가 특정한 범위의 단어들만 통제하게 하는 것이다.면접 문제 주식 데이터 소셜 네트워크 : 페이스북, 링크드인과 같은 대규모 소셜 네트워크를 위한 자료구조는 어떻게 설계하겠는가? 웹 크롤러 : 웹에 있는 데이터를 긁어오는 크롤러를 설계할 때 무한루프에 빠지는 일을 방지하려면 어떻게 해야 하는가? 중복 URL : 100억 개의 URL이 있다. 중복된 문서를 찾으려면 어떻게 해야 하는가? 캐시 : 최근 검색 요청을 캐시에 저장하는 메커니즘을 설계하라, 또 데이터가 바뀌었을 때 어떻게 캐시를 갱신할 것인지 반드시 설명하라 판매 순위 : 전자상거래 회사에서 가장 잘 팔리는 각 목록별 리스트를 알고 싶어할 때, 이 시스템을 어떻게 설계할지 설명하라 개인 재정 관리자 Pastebin : 텍스트를 입력하면 접속 가능한 임의의 URL을 생상한 뒤 반환해주는 시스템을 설계하라10. 정렬과 탐색많은 정렬 및 탐색 문제는 잘 알려진 알고리즘들을 변용하여 출제된다. 그러므로 여러 가지 정렬 알고리즘의 차이점을 잘 이해하고, 해당 상황에서 어떤 알고리즘이 어울릴지 살펴두는 것이 좋다.예) Person 객체로 이루어진 아주 크기가 큰 배열이 있을 때, 이 배열에 담긴 객체들을 나이순으로 정렬하라. 배열의 크기가 크므로 효율성이 매우 중요하다. 나이순으로 정렬하는 것이므로, 그 값의 범위가 좁다는 것을 알 수 있다.위 예에서 버킷 정렬 또는 기수 정렬이 가장 적합하다. 버킷의 크기를 1년으로 설정하면 O(n)에 정렬할 수 있다.널리 사용되는 정렬 알고리즘 버블 정렬 : 평균 및 최악 실행시간 O(n²), 메모리 O(1) 버블 정렬은 배열의 첫 원소부터 순차적으로 진행하며, 현재 원소가 그 다음 원소의 값보다 크면 두 원소를 바꾸는 작업을 반복한다. 선택 정렬 : 평균 및 최악 실행시간 O(n²), 메모리 O(1) 선택 정렬은 심플한 알고리즘이다.(하지만 비효율적) 배열을 선형 탐색하며 가장 작은 원소를 배열 맨 앞으로 보낸다. 그 다음 두 번째로 작은 원소를 찾은 뒤 앞으로 보내 준다. 병합 정렬 : 평균 및 최악 실행 시간 O(nlogn), 메모리-상황에 따라 다름, 병합 정렬은 배열을 절반씩 나누어 각각을 정렬한 다음 이 둘을 합하여 다시 정렬하는 방법이다. 이 알고리즘에서는 병합 처리하는 것이 가장 복잡하다. 병합 작업을 수행하는 메서드는 병합 대상이 되는 배열의 두 부분을 임시 배열에 복사하고, 왼쪽 절반의 시작 지점과 오른쪽 절반의 시작 지점을 추적한다. 그 다음 임시 배열을 순회하면서 두 배열에서 더 작은 값의 원소를 꺼내어 원래 배열에 복사해 넣는다. 두 배열중 한 배열에 대한 순회가 끝난 경우 다른 배열의 남은 부분을 원래 배열에 남김없이 복사해 넣고 작업을 마친다. 퀵 정렬 : 평균 O(nlogn), 최악O(n²), 메모리 O(logn) 퀵 정렬은 무작위로 선정된 한 원소를 사용하여 배열을 분할하는데, 선정된 원소보다 작은 원소들은 앞에, 큰 원소들은 뒤로 보낸다. 배열 분할 작업은 연속된 스왑 연산을 통해 효율적으로 수행된다. 하지만 배열 분할에 사용되는 원소가 중간값에 가까운 값이 되리라는 보장이 없기 때문에, 정렬 알고리즘이 느리게 동작할 수도 있다. 기수 정렬 : 실행시간 O(kn) 기수 정렬 알고리즘은 데이터가 정수처럼 유한한 비트로 구성되어 있는 경우에 사용된다. 기수 정렬은 각 자릿수를 순회해 나가면서 각 자리의 값에 따라 그룹을 나눈다. 탐색 알고리즘 : 탐색 알고리즘에서 일반적인 것은 이진 탐색이다. 이진 탐색은 정렬된 배열의 원소 x를 찾고자 할 때 사용된다. x를 중간에 위치한 원소와 비교한 뒤 x가 중간에 위치한 값보다 작다면 배열의 왼쪽 절반을 재탐색 하고, 크다면 배열의 오른쪽 절반을 재탐색한다. 이 과정을 x를 찾거나 부분배열의 크기가 0이 될 때까지 반복한다.면접 문제 정렬된 병합 : 정렬된 배열 A와 B가 주어진다. A의 끝에는 B를 전부 넣을 수 있을 만큼 충분한 여유 공간이 있다. B와 A를 정렬된 상태로 병합하는 메서드를 작성하라 Anagram 묶기 : 철자 순서만 바꾼 문자열이 서로 인접하도록 문자열 배열을 정렬하는 메서드를 작성하라 회전된 배열에서 검색 : n개의 정수로 구성된 정렬 상태의 배열을 임의의 횟수만큼 회전시켜 얻은 배열이 입력으로 주어졌을 때, 이 배열에서 특정한 원소를 찾는 코드를 작성하라 크기를 모르는 정렬된 원소 탐색 드문드문 탐색 : 빈 문자열이 섞여 있는 정렬된 문자열 배열이 주어졌을 때, 특정 문자열의 위치를 찾는 메서드를 작성하라 큰 파일 정렬 : 한 줄에 문자열 하나가 쓰여있는 20GB짜리 파일이 있다고 할 때, 이 파일을 정렬하려면 어떻게 해야할지 설명하라 빠트린 정수 : 음이 아닌 정수 40억개로 이루어진 입력 파일이 있다. 이 파일에 없는 정수를 생성하는 알고리즘을 작성하라(단 메모리는 1GB만 사용할 수 있다.) 중복 찾기 : 1부터 N까지의 숫자로 이루어진 배열이 있다. 배열엔 중복된 숫자가 나타날 수 있고, N이 무엇인지는 알 수 없다. 사용 가능한 메모리가 4KB일 때, 중복된 원소를 모두 출력하려면 어떻게 할 수 있을까? 정렬된 행렬 탐색 : 각 행과 열이 오름차순으로 정렬된 M X N 행렬이 주어졌을 때 특정한 원소를 찾는 메서드를 구현하라 스트림에서의 순위 : 정수 스트림을 읽는다고 하자. 주기적으로 어떤 수 x의 랭킹을 확인하고 싶을 때 해당 연산을 지원하는 자료구조와 알고리즘을 구현하라 Peak과 Valley11. 테스팅테스팅과 관련된 질문들은 보통 다음 네 가지 범주 중 하나에 속한다. 실생활에서 접하는 객체를 테스트하라 소프트웨어 하나를 테스트하라 주어진 함수에 대한 테스트 코드를 작성하라 발생한 이슈에 대한 해결책을 찾아내라면접관이 평가하는 것 큰 그림을 이해하고 있는가 : 소프트웨어가 지향하는 바가 무엇인지 정말로 이해하고 있는 사람인가? 테스트 케이스간의 우선순위를 적절히 매길 수 있는가? 퍼즐 조각을 제대로 맞추는 방법을 아는가 : 소프트웨어가 어떻게 동작하는지, 그리고 각 소프트웨어가 보다 더 큰 생태계의 일부로 어떻게 귀속되는지 이해하고 있는가? 조직화 : 문제에 구조적으로 접근하고 있는가, 아니면 생각나는 대로 아무 방법이나 질러보고 있는가? 실용성 : 실제로 적용 가능한 합리적인 테스트 계획을 세울 수 있나?실제 세계에서 객체 테스트하기클립을 테스트하려면 어떻게 하겠나? 라는 질문을 통해 살펴보자 사용자는 누구인가? 클립의 사용 목적은 무엇인가? 문제를 풀기전 해당 제품을 어떤 사용자가 어떤 목적으로 사용하게 될지 면접관과 의논해 봐야 한다. 어떤 use case가 있나? 유스케이스의 목록을 만들어두면 도움이 될 것이다. 이번 예에서는 “종이 다발을 망가뜨리지 않고 함께 묶어 놓는다”가 될 것이다. 한계 조건은? 한 번에 30장을 영구적 손상 없이 묶을 수 있다거나 30장에서 50장 정도는 약간의 손상이 있다거나 하는 것을 의미한다. 스트레스 조건과 장애 조건은? 문제가 없는 제품은 없다. 따라서 장애가 발생하는 조건을 분석하는 것도 여러분이 해야 하는 일이다. 어떤 종류의 문제를 심각하게 간주해야 하는지 등을 면접관과 이야기 해봐야 한다. 테스트는 어떻게 수행할 것인가? 테스트를 어떻게 수행할지 토론하는 것은 테스트와 관련된 세부사항을 이야기하는 것과 관련이 있다.소프트웨어 테스팅하나의 소프트웨어를 테스트하는 것은 실제 세계의 객체를 테스트하는 것과 아주 유사하다. 가장 큰 차이점은 소프트웨어의 경우 성능 테스트의 세부사항을 더 많이 강조한다는 것이다. 소프트웨어 테스팅의 두 가지 핵심적 측면은 다음과 같다. 수작업 테스트 vs 자동화된 테스트 : 이상적으로는 모든 것을 자동화하면 좋겠지만 불가능한 일이다. 컴퓨터는 일반적으로 살펴보라고 언급한 문제들만 인지하는 반면, 인간의 인지 능력은 특별히 검토된적이 없는 새로운 문제들을 밝혀낼 수도 있다. 블랙박스 테스트 vs 화이트박스 테스트 : 블랙박스 테스트의 경우 소프트웨어를 주어진 그대로 테스트해야 한다. 반면 화이트박스 테스트의 경우 그 내부의 개별 함수들을 프로그램적으로 접근하여 테스트할 수 있다.소프트웨어 테스트에 적용할 수 있는 접근법을 처음부터 끝까지 하나씩 살펴보자 블랙박스 테스트를 하고 있는가 아니면 화이트박스 테스트를 하고 있는가? 면접관에게 어떤 테스트를 해야하는지 확인하라 누가 사용할 것인가? 왜 사용하는가? 어떤 유스케이스들이 있나? 한계 조건은? 유스케이스가 모호하게 정의되어 있다면 그게 무엇을 의미하는지 정확히 알아 낼 필요가 있다. 스트레스 조건과 장애 조건은? 소프트웨어에 장애가 발생한다면 그 장애는 어떤 모습이어야 하는가? 테스트 케이스는? 테스트 실행은 어떻게? 정확히 어떤 상황을 테스트하려고 하는가? 어떤 단계를 자동화할 수 있나? 사람이 개입해야 하는 부분은 어디인가? 자동화는 강력한 테스트를 가능하게 해주지만, 큰 문제를 일으킬 수도 있다. 따라서 수작업 테스트 또한 테스트 절차에 포함되어야 한다.함수 테스트함수 테스트는 가장 쉬운 종류의 테스트다. 보통 입력과 출력을 확인하는 테스트만 하면 되기 때문에 면접관과 길게 얘기할 것도 없고 모호한 부분도 적다. 그렇다고 대화의 중요성을 간과해서는 안 된다. 어떤 가정을 하건, 면접관과 그에 대해 대화를 해야 한다.예) sort(int[] array)를 테스트하라는 문제를 받은 경우. 테스트 케이스 정의 : 정상적인 케이스 : 전형적인 입력에 대해 정확한 출력을 내는가? 여기서 발생할 수 있는 잠재적인 문제들에 대해 꼭 생각해보자. 극단적인 케이스 : 빈 배열을 인자로 넘기면 어떻게 되는가? 널 입력, 잘못된 입력 : 입력이 잘못 주어졌을 때 코드가 어떻게 동작해야 하는지 고려해 봐야 한다. 특수한 입력 : 특수한 패턴의 입력도 때로 주어질 수 있다. 이미 정렬된 배열이 입력으로 주어지면 어떻게 되나? 혹은 아예 역순으로 정렬된 배열이 주어진다면? 예상되는 결과를 정의하라 테스트 코드를 작성하라문제 해결에 관한 문제이미 있는 장애를 어떻게 디버깅하고 해결할 것인지를 설명하라는 문제도 출제된다. 이런 경우도 다른 문제와 마찬가지로 구조적으로 접근해서 해결할 수 있다. 시나리오를 이해하라 : 상황을 가능한 한 정확하게 이해할 수 있도록 많은 질문을 던져라 문제를 쪼개라 : 문제를 테스트 가능한 단위로 분할할 순서다. 구체적이고 관리 가능한 테스트들을 생성하라 : 고객에게 뭘 해달라는 지시를 내릴 순 없을 것이다. 그러므로 여러분이 본인 컴퓨터에서 반복 검증할 수 있는 테스트를 생성해야 한다.면접 문제 오류 : 다음 코드에서 오류를 찾아내라 무작위 고장 : 실행하면 죽어버리는 프로그램의 소스코드가 있다. 디버거에서 열 번 실행해 본 결과, 같은 지점에서 죽는 일은 없었다. 단일 스레드 프로그램이고, C의 표준 라이브러리만 사용한다. 오류들을 각각 어떻게 테스트해 볼 수 있겠는가? 체스 테스트 No 테스트 도구 : 테스트 도구를 사용하지 않고 웹 페이지에 부하 테스트를 실행하려면 어떻게 할 수 있겠는가? 펜 테스트 : 펜을 어떻게 테스트하겠는가? ATM 테스트 : 분산 은행 업무 시스템을 구성하는 ATM을 어떻게 테스트하겠는가?12. C와 C++13. 자바언어 자체 질문에 대한 접근법 예제 시나리오를 만들어 보고 어떻게 전개되어야 하는지 자문해 보라 다른 언어에선 이 시나리오를 어떻게 처리할 것인지 자문해 보라 프로그래밍 언어를 설계하는 사람이라면 이 상황을 어떻게 설계할 것인지 생각해 보라 어떤 선택이 어떤 결과로 이어지는가?면접관들은 반사적으로 답을 내놓는 지원자만큼이나 답을 유도해 낼 수 있는 지원자에게 좋은 인상을 갖는다.오버로딩 vs 오버라이딩오버로딩은 두 메서드가 같은 이름을 갖고 있으나 인자의 수나 자료형이 다른 경우를 지칭한다.오버라이딩은 상위 클래스의 메서드와 이름과 용례가 같은 함수를 하위 클래스에 재정의하는 것을 말한다.컬렉션 프레임워크자바의 컬렉션 프레임워크는 아주 유용하다. ArrayList : ArrayList는 동적으로 크기가 조절되는 배열이다. 새 원소를 삽입하면 크기가 늘어난다. Vector : ArrayList와 비슷하지만 동기화되어 있다는 차이가 있다. LinkedList HashMap : HashMap 컬렉션은 면접이나 실제 상황 가릴 것 없이 광범위하게 사용된다.면접 문제 Private 생성자 : 상속 관점에서 생성자를 private로 선언하면 어떤 효과가 있나? finally에서의 반환 : try-catch-finally 의 try 블록에서 return 문을 넣어도 실행되는가? final과 그 외 : final, finally, finalize의 차이는? 제네릭 vs 템플릿 : 자바 제네릭과 C++ 템플릿의 차이를 설명하라 TreeMap, HashMap, LinkedHashMap : 각 차이를 설명하고 언제 무엇을 사용하는 것이 좋은지 예를 들어 사용하라 객체 리플렉션 : 자바의 객체 리플렉션을 설명하고, 이것이 유용한 이유를 설명하라 람다 표현식 : Country라는 클래스의 getContinent()와 getPopulation()이 라는 메서드가 있다. 대륙의 이름과 국가의 리스트가 주어졌을 때 주어진 대륙의 총 인구수를 계산하는 메서드를 작성하라 람다 랜덤 : 람다 표현식을 사용해서 임의의 부분집합을 반환하는 함수를 작성하라14. 데이터베이스SQL 문법과 그 변종들묵시적 JOIN과 명시적 JOIN비정규화 vs 정규화 데이터베이스정규화 데이터베이스는 중복을 최소화하도록 설계된 데이터베이스를 말한다. 비정규화 데이터베이스는 읽는 시간을 최적화하도록 설계된 데이터베이스를 말한다.전형적인 정규화 데이터베이스의 경우 외래키를 갖는 컬럼이 있을 것이다. 이 설계의 장점은 데이터베이스에 데이터를 한 번만 저장해도 된다는 점이다. 하지만 상당수 일상적 질의를 처리하기 위해 JOIN을 많이 하게된다는 단점이 있다.대신 비정규화 데이터베이스에서는 데이터를 중복해서 저장할 수 있다. 같은 질의를 자주 반복해서 한다는 사실을 미리 알고 있으면, 정보를 중복해서 다른 테이블에 저장할 수도 있다. 비정규화는 높은 규모의 확장성을 실현하기 위해 자주 사용되는 기법이다.SQL 문249~251p소규모 데이터베이스 설계 모호성 처리 : 데이터베이스에 관계된 문제에는 의도적이든 아니든 모호한 부분이 내포되어 있다. 설계를 시작하기 전에 무엇을 설계해야 하는지 이해해야 한다. 따라서 모호한 부분이 있다면 면접관과 논의해야 한다. 핵심 객체 정의 : 이 시스템의 핵심 객체가 무엇인지 살펴봐야 한다. 보통 핵심 객체 하나 당 테이블을 사용한다. 관계 분석 : 핵심 객체의 윤곽을 잡고 나면 어떻게 테이블을 설계해야 할지 감을 잡을 수 있을 것이다. 테이블끼리의 관계가 어떻게 되는지 분석해야한다. 행위 조사 : 세부적인 부분을 채워 넣는다. 흔하게 수정될 작업들을 살펴보고 관련된 데이터를 어떻게 저장하고 가져올 것인지 이해해야 한다.대규모 데이터베이스 설계대규모의 규모 확장성이 높은 데이터베이스를 설계할 때에 JOIN 연산은 일반적으로 아주 느리다고 간주해야 한다. 따라서 데이터를 비정규화해야 한다.면접 문제 하나 이상의 집 : 하나 이상의 집을 대여한 모든 거주자의 목록을 구하는 SQL 질의문을 작성하라 Open 상태인 Request : 모든 건물 목록과 Status가 Open인 모든 Request의 개수를 구하라 Request를 Close로 바꾸기 JOIN : 서로 다른 종류의 JOIN은 어떤 것들이 있는가? 어떻게 다르고, 어떤 상황에서 어떤 JOIN과 어울리는지 설명하라 비정규화 : 비정규화란 무엇인가? 장단점을 설명하라 객체-관계 다이어그램 : 회사, 사람, 직원으로 구성된 데이터베이스의 ERD를 그려라 성적 데이터베이스 설계 : 학생들의 성적을 저장하는 간단한 데이터베이스를 생각해보고 설계하라, 그리고 성적이 우수한 학생 목록을 반환하는 SQL 질의문을 작성하라.15. 스레드와 락대기업 회사에서 스레드로 알고리즘을 구현하라는 문제를 출제하는 일이 흔하지는 않지만 스레드, 특히 교착상태에 대한 일반적인 이해도를 평가하기 위한 문제는 어떤 회사든 상대적으로 자주 출제하는 편이다.자바의 스레드자바의 모든 스레드는 java.lang.Thread 클래스의 객체에 의해 생성되고 제어된다. 자바에서 스레드를 구현하는 방법은 다음과 같다. java.lang.Runnable 인터페이스를 구현하기 : Runnable 인터페이스를 구현하는 클래스를 만들고, Thread 타입의 객체를 만들때 Thread 생성자에 Runnable 객체를 인자로 넘긴다. 그리고 Thread 객체의 start() 메서드를 호출한다. java.lang.Thread 클래스를 상속받기 : Thread 클래스를 상속받아서 스레드를 만들게 되면 항상 run() 메서드를 오버라이드해야 하며, 하위 클래스의 생성자는 상위 클래스의 생성자를 명시적으로 호출해야 한다.스레드를 생성할 때 Runnable 인터페이스를 구현하는 것이 더 선호된다. 이유는 자바는 다중 상속을 지원하지 않아 Thread 클래스를 상속하게 되면 다른 클래스를 상속받을 수 없기 때문이다.동기화와 락어떤 프로세스 안에서 생성된 스레드들은 같은 메모리 공간을 공유하게 된다. 이것은 장점일 수 있으나 두 스레드가 같은 자원을 동시에 변경하는 경우에 문제가 된다. 자바는 공유 자원에 대한 접근을 제어하기 위한 동기화 방법을 제공한다.동기화된 메서드통상적으로 synchronized 키워드를 사용할 때는 공유 자원에 대한 접근을 제어한다. 이 키워드는 메서드에 적용할 수도 있고, 특정한 코드 블록에 적용할 수도 있다.public class MyObject { public synchronized void foo (String name) { try { System.out.printin(\"Thread \" + name + \", foo(): starting\"); Thread. sleep (3000); System. out.println(\"Thread ' + name + \". foo (): ending\"); } catch (InterruptedException exc) { System.out.println(\"Thread \" + name + \": interrupted.\"); }}동기화된 블록public class MyObiect { public void foo(String name) { synchronized (this) { //... } }}락좀 더 세밀하게 동기화를 제어하고 싶을 때는 락을 사용한다. Lock을 공유 자원에 붙이면 해당 자원에 대한 접근을 동기화할 수 있다. 스레드가 해당 자원에 접근하려면 그 자원에 붙어있는 락을 획득해야 한다. 특정 시점에 락을 쥐고 있을 수 있는 스레드는 하나뿐이다.교착상태와 교착상태 방지교착상태란 첫 번째 스레드는 두 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리고 있고, 두 번째 스레드 역시 첫 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리는 상황을 일컫는다. 모든 스레드가 락이 풀리고 있길 기다리는 ‘무한대기 상태’에 빠지게 된다. 교착상태가 발생하기 위해서는 다음의 조건을 모두 충족해야 한다. 상호 배제 : 한 번에 한 프로세스만 공유 자원을 사용할 수 있다. 들고 기다리기 : 공유 자원에 대한 접근 권한을 갖고 있는 프로세스가, 그 접근 권한을 양보하지 않은 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있다. 선취 불가능 : 한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 있다. 대기 상태의 사이클 : 두 개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재한다.교착상태를 방지하기 위해선 이 조건들 가운데 하나를 제거하면 된다. 대부분 교착상태 방지 알고리즘은 4번 조건을 막는데 초점이 맞춰져 있다.면접 문제 프로세스 vs 스레드 : 두개의 차이는? 문맥 전환 : 문맥 전환에 소요되는 시간을 측정하려면? 철학자의 만찬 교착상태 없는 클래스 : 교착상태에 빠지지 않는 경우에만 락을 제공해주는 클래스를 설계해보라 순서대로 호출 동기화된 메서드 : 동기화된 A 메서드, 일반 B 메서드가 구현된 클래스가 있을 때, 같은 프로그램에서 실행되는 스레드가 두 개 존재할 때 A를 동시에 실행할 수 있는가? A와 B는 동시에 실행될 수 있는가? FizzBuzz16. 중간 난이도 연습문제 숫자 교환 : 임시 변수를 사용하지 않고 숫자를 교환하는 함수를 작성하라 단어 출현 빈도 : 어떤 책에서 나타난 단어의 출현 빈도를 계산하는 메서드를 설계하라 교차점 : 시작점과 끝점으로 이루어진 선분 두 개가 주어질 때, 이 둘의 교차점을 찾는 프로그램을 작성하라 틱-택-토의 승자 : 승자를 알아내는 알고리즘을 설계하라 계승의 0 : n!의 계산 결과에서 마지막에 붙은 연속된 0의 개수를 계산하는 알고리즘을 작성하라 최소의 차이 : 두 개의 정수 배열이 주어져 있다. 각 배열에서 숫자를 하나씩 선택했을 때 두 숫자의 차이가 최소인 값을 출력하라 최대 숫자 : 주어진 두 수의 최댓값을 찾는 메서드를 작성하라 (if-else나 비교 연산자는 사용할 수 없다.) 정수를 영어로 : 정수가 주어졌을 때 이 숫자를 영어 구문으로 표현해주는 프로그램을 작성하라 연산자 : 덧셈 연산자만을 사용하여 정수에 대한 곱셈, 뺄셈, 나눗셈 연산을 수행하는 메서드를 작성하라 살아 있는 사람 : 사람의 태어난 연도와 사망한 연도가 리스트로 주어졌을 때 가장 많은 사람이 동시에 살았던 연도를 찾는 메서드를 작성하라 다이빙 보드 : 다량의 널빤지를 이어 붙여서 다이빙 보드를 만들려고 한다. 널빤지는 길이가 긴 것과 짧은 것 두 가지 종류가 있는데, 정확히 K개의 널빤지를 사용해서 다이빙 보드를 만들어야 한다. 가능한 다이빙 보드의 길이를 모두 구하는 메서드를 작성하라. XML 인코딩 : XML 요소가 주어졌을 때, 해당 요소를 인코딩한 문자열을 출력하는 메서드를 작성하라. 정사각형 절반으로 나누기 : 2차원 평면 위에 정사각형 두 개가 주어졌을 때, 이들을 절반으로 가르는 직선 하나를 찾으라 최고의 직선 : 2차원 평면 위에서 점이 여러 개 찍혀 있을 때 가장 많은 수의 점을 동시에 지나는 직선을 구하라 Master Mind 부분 정렬 : 정수 배열이 주어졌을 때, m부터 n까지의 원소를 정렬하기만 하면 배열 전체가 정렬되는 인덱스 m과 n을 찾으라. 연속 수열 : 정수 배열이 주어졌을 때 연속한 합이 가장 큰 수열을 찾고 그 합을 반환하라 패턴 매칭 : 패턴 문자열과 일반 문자열 두 개가 주어져있다. a와 b로 이루어진 패턴 문자열은 일반 문자열을 표현하는 역할을 한다. 일반 문자열이 패턴 문자열 과 일치하는지 판단하는 메서드를 작성하라. 연못 크기 : 대륙의 해발고도를 표현한 정수형 배열이 주어졌다. 여기서 0은 수면을 나타내고, 연못은 수직, 수평, 대각선으로 연결된 수면의 영역을 나타낸다. 연못의 크기는 연결된 수면의 개수라고 했을 때, 모든 연못의 크기를 계산하는 메서드를 작성하라 T9 합의 교환 : 정수형 배열 두 개가 주어졌을 때, 각 배열에서 원소를 하나씩 교환해서 두 배열의 합이 같아지게 만들라 랭턴 개미 Rand5로부터 Rand7 : rand5()를 사용해서 rand7() 메서드를 구현하라. 즉, 0 부터 4까지 숫자 중에서 임의의 숫자를 반환하는 메서드를 이용해서 0부터 6까지의 숫자 중에서 임의의 숫자를 반환하는 메서드를 작성하라. 합이 되는 쌍 : 정수형 배열이 주어졌을 때, 두 원소의 합이 특정 값이 되는 모든 원소 쌍을 출력하는 알고리즘을 설계하라 LRU 캐시 : 가장 오래된 아이템을 제거하는 최저 사용 빈도 캐시를 설계하고 구현하라 계산기 : 양의 정수 +, -, *, / 로 구성된 수식을 계산하는 프로그램을 작성하라17. 어려운 연습문제 덧셈 없이 더하기 : 두 수를 더하는 함수를 작성하라. 단, +를 비롯한 어떤 연산자도 사용할 수 없다. 섞기 : 카드 한 벌을 완벽히 섞는 메서드를 작성하라 (완벽의 의미는 카드 한 벌을 섞는 방법이 52가지가 있는데 이 각각이 전부 같은 확률로 나타날 수 있어야 한다는 뜻이다.) 임의의 집합 : 길이가 n인 배열에서 m개의 원소를 무작위로 추출하는 메서드를 작성하라. 단, 각 원소가 선택될 확률은 동일해야 한다. 빠진 숫자 : 배열 A에는 0부터 n까지의 숫자 중 하나를 뺀 나머지가 모두 들어 있다. 배열 A에서 빠진 숫자가 무엇인지 확인하는 코드를 작성하라. O(n)시간에 할 수 있겠는가? 문자와 숫자 : 문자와 숫자로 채워진 배열이 주어졌을 때 문자와 숫자의 개수가 같으면서 가장 긴 부분 배열을 구하라 숫자 2세기 : 0부터 n까지의 수를 나열했을 때 2가 몇 번이나 등장했는지 세는 메서드를 작성하라 아기 이름 : 정부는 매년 가장 흔한 아기 이름 10,000명과 그 이름의 빈도수를 발표한다. 하지만 아기 이름의 철자가 다르면 빈도수를 세는 데 문제가 될 수 있다. 예를 들어 John과 Jon은 실제로는 같은 이름이지만 다르게 분류되는 것이다. 이름/빈도수 리스트와 같은 이름의 쌍이 리스트로 주어졌을 때 실제 빈도수의 리스트를 출력하는 알고리즘을 작성하라. 서커스 타워 : 단원의 키와 몸무게가 주어졌을 때 최대로 쌓을 수 있는 인원수를 계산하는 메서드를 작성하라.(어깨 위에 올라서는 사람은 아래에 있는 사람보다 가벼우면서 키도 작아야 한다.) k번째 배수 : 소인수가 3,5,7로만 구성된 숫자 중 k번째 숫자를 찾는 알고리즘을 설계하라 다수 원소 : 다수 원소란 배열에서 그 개수가 절반 이상인 원소를 말한다. 양의 정수로 이루어진 배열이 주어졌을 때 다수 원소를 찾으라. 다수 원소가 없다면 -1을 반환하라. 알고리즘은 O(N) 시간과 O(1) 공간 안에 수행되어야 한다. 단어 간의 거리 : 단어가 적혀 있는 아주 큰 텍스트 파일이 있다. 단어 두 개가 입력으로 주어졌을 때, 해당 파일 안에서 그 두 단어 사이의 최단거리를 구하는 코드를 작성하라. 같은 파일에서 단어간 최단 거리를 구하는 연산을 여러 번 반복한다고 했을 때 어떤 최적화 기법을 사용할 수 있겠는가? 공백 입력하기 : 긴 문서를 편집하다가 실수로 공백과 구두점을 지우고, 대문자를 전부 소문자로 바꿔 버렸다. 예) “I reset the computer. It still didn’t boot!”과 같은 문장이 “iresetthecomputeritstilldidntboot!” 로 바뀐 것이다. 사전과 문서가 주어졌을 때 단어들을 원래대로 분리하는 최적의 알고리즘을 설계하라 가장 작은 숫자 K개 : 배열에서 가장 작은 숫자 K개를 찾는 알고리즘을 설계하라 가장 긴 단어 : 주어진 단어 리스트에서 다른 단어들을 조합하여 만들 수 있는 가장 긴 단어를 찾는 프로그램을 작성하라 마사지사 : 인기 있는 마사지사가 있다. 마사지 사이에 15분간 휴식이 필요하므로 마사지 예약이 연달아 들어온다면 그 중에서 어떤 예약을 받을지 선택해야 한다. 연달아 들어온 마사지 예약 리스트가 주어졌을 때(모든 예약 시 간은 15분의 배수이며 서로 겹치지는 않고 한번 예약이 되면 변경이 불가능 하다), 총 예약 시간이 가장 긴 최적의 마사지 예약 순서를 찾으라. 다중 검색 : 문자열 s와 s보다 짧은 길이를 갖는 문자열로 이루어진 배열 T가 주어졌을 때, T에 있는 각 문자열을 s에서 찾는 메서드를 작성하라 가장 짧은 초수열 : 작은 길이의 배열과 그보다 긴 길이의 배열 두 개가 주어졌다. 길이가 긴 배열에서 길이가 작은 배열의 원소를 모두 포함하면서 길이가 가장 짧은 부분배열을 찾으라 빠진 숫자 찾기 : 1부터 N까지 숫자 중에서 하나를 뺀 나머지가 정확히 한 번 씩 등장하는 배열이 있다. 빠진 숫자를 O(N) 시간과 O(1) 공간에 찾을 수 있겠는가? 만약 숫자 두 개가 빠져 있다면 어떻게 찾겠는가? 연속된 중간 값 : 임의의 수열이 끊임없이 생성되고 이 값이 어떤 메서드로 전달된다고 할 때, 새로운 값이 생성될 때마다 현재까지의 중간값을 찾고 그 값을 유지하는 프로그램을 작성하라 막대 그래프의 부피 : 누군가가 히스토그램 위에서 물을 부었을 때, 이 그래프가 저장할 수 있는 물의 양을 계산하는 알고리즘을 설계하라 단어 변환 : 사전에 등장하는 길이가 같은 단어 두 개가 주어졌을 때, 한 번에 글자 하나만 바꾸어 한 단어를 다른 단어로 변환하는 메서드를 작성하라 최대 검은색 정방행렬 : 정방형의 행렬이 있다. 이 행렬의 각 셀은 검은색이거나 흰색이다. 네 가장자리가 전부 검은색인 최대 부분 정방행렬을 찾는 알고리즘을 설계하라 최대 부분 행렬 : 양의 정수와 음의 정수로 이루어진 N X N 행렬이 주어졌을 때 모든 원소의 합이 최대가 되는 부분 행렬을 찾는 코드를 작성하라 단어 직사각형 : 백만 개의 단어 목록이 주어졌을 때, 각 단어의 글자들을 사용하여 만들 수 있는 최대 크기 직사각형을 구하는 알고리즘을 설계하라 드문드문 유사도" }, { "title": "08. 합격한뒤에", "url": "/posts/08.%ED%95%A9%EA%B2%A9%ED%95%9C%EB%92%A4%EC%97%90/", "categories": "BOOK, 코딩 인터뷰 완전분석", "tags": "", "date": "2023-03-27 22:44:37 +0900", "snippet": "면접이 끝나고 입사 제안을 받으면 그 제안을 어떻게 검토할 것인지, 그리고 협상은 어떻게 해야하는지 살펴보자합격 또는 거절 통지에 대처하는 요령 입사 결정 기한과 연장 : 회사가 입사 제안을 하는 경우 보통 정해진 경우가 있다.(1~4주) 입사 제안 거절 : 공손한 어투로 입사 제안을 거절하자, 공격적이지 않고 명백한 이유를 대는 것이 좋다. 탈락 통보 대처 : 탈락 통보를 받게 되면 이를 재지원하는 기회로 만드는 것이 좋다. 또 구인 담당자에게 피드백을 공유해달라고 요청해볼 수도 있다.입사 제안 평가입사 제안을 검토할 때 고려해야 할 것들은 다음과 같다.재정 관련 사항입사 제안 검토시 가장 큰 실수는 연봉에만 지나치게 연연하는 것일 것이다. 연봉 외에 고려해야할 사항은 계약 보너스, 이직 보너스 : 많은 회사들은 계약 보너스나 이직 보너스를 지급한다. 이런 경우 해당 보너스를 3년간 지급받을 급여에 합산하여 입사 제안을 평가하는 것이 현명하다. 생활 비용 차이 : 세금 및 기타 생활 비용에서 오는 차이는 실제 통장에 적히는 급여에 큰 차이를 만들어낸다. 연간 보너스 스톡옵션과 증여 : 지분 보상은 매해 받는 금전적 보상의 큰 부분을 차지한다.길게 봤을 때 입사 후 무엇을 배울 수 있는지와 회사가 어떻게 경력 발전에 도움이 되는지가 더 중요할 수도 있다.경력 개발지금 받은 입사 제안이 여러분의 경력에 어떤 영향을 미칠지 생각해 보는 것은 중요하다. 이 회사의 이름이 이력서에 얼마나 보기 좋게 만들어 줄 것인가? 얼마나 많이 배우게 될 것인가? 관련된 다른 것들도 배우게 될 것인가? 승진 계획은 어떤가? 개발자의 경력을 어떻게 발전시키는 회사인가? 관리직으로 옮기고자 할 경우, 회사가 현실적 계획을 마련해 주는가? 회사나 팀 규모가 확대되고 있는 중인가? 회사를 떠나고 싶을 경우, 옮길 만한 회사가 가까이 있는가? 아니면 이사를 해야 하나?회사의 안정성안정적인 회사일수록 느리게 성잘할 수 있다. 회사의 안정성을 얼마나 중요하게 생각하는지는 실제로 여러분의 가치관에 달려 있다.행복의 척도 제품 관리자와 동료 회사 문화 근무 시간연봉 협상 그냥 해 보라 : 대부분 협상을 좋아하지 않는다. 하지만 그렇기에 해볼만한 가치가 있다. 실질적인 대안을 가져라 구체적으로 요구하라 : 그냥 더 주세요 하는 것보다는 연봉이 0000정도 더 많았으면 한다. 라고 요구하는 것이 효과적이다. 많이 부를 것 : 협상이라는 것은 주고 받는 대화 과정이다. 정말로 받고자 하는 것보다 좀 더 많이 불러라 연봉 이외의 것도 고려하라 : 지분을 더 달라고 하거나, 계약 보너스를 더 많이 달라고 해 보라 가장 좋은 협상 매체를 고르라 : 대부분의 사람들은 전화로 협상하는 게 낫다고 말한다. 자신에게 맞는 협상 매체를 사용하자입사 후일정 수립하는 일을 즐기다 보면, 거기에 빠진 나머지 여러분의 경력이 발전하지 않고 있다는 사실을 미처 깨닫지 못한다. 이것이 바로 새로운 직업을 시작하기 전에 나아갈 길을 미리 그려보아야 하는 이유다.여러분의 진로를 미리 설계하고 정기적으로 점검함으로써 현실에 안주해버리는 일을 피할 수 있다.튼튼한 관계 수립무엇인가 새롭게 시작하고 싶다면, 네트워크를 형성하는 것이 중요하다. 개인적으로 추천 받는 편이 훨씬 낫다.일터에서 관리자나 팀원들과 끈끈한 관계를 수립히라. 퇴사하는 직원들과도 계속 연락을 유지하라.원하는 것을 요구하라어떤 관리자는 여러분의 경력을 성장시키려 애쓰지만, 어떤 사람은 방관한다. 여러분의 경력에 도움되는 도전을 찾아나서는 것은 전적으로 여러분의 본인에게 달려있다.꾸준히 면접을 보라적극적으로 새로운 직장을 찾고 있지 않더라도 적어도 일 년에 한 번 정도는 면접을 보기 바란다. 최신 면접 기술을 유지할 수 있고, 현재 어떤 종류의 기회가 있는지 알아볼 수도 있다." }, { "title": "07. 기술적 문제", "url": "/posts/07.%EA%B8%B0%EC%88%A0%EC%A0%81-%EB%AC%B8%EC%A0%9C/", "categories": "BOOK, 코딩 인터뷰 완전분석", "tags": "", "date": "2023-03-21 21:01:37 +0900", "snippet": "준비하기많은 지원자들이 공부를 한답시고 문제와 답을 읽기만 하곤 한다. 문제는 직접 푸는 훈련을 해야한다. 답을 외우는 것은 도움이 되지 않는다. 문제를 만날때마다 다음과 같이 행동하자 직접 풀도록 노력하라 : 문제에 힌트가 주어지긴 하지만 직접 답을 찾으려고 노력하자. 문제를 풀 때는 공간과 시간 효율에 대해서도 반드시 생각하자 코드를 종이에 적으라 : IDE를 이용하면 코드 문법 강조, 자동완성, 디버거가 갖춰진 편리한 환경에서 코딩할 수 있다. 종이에 코딩하게 되면 그런 도움을 받을 수 없다. 실제 면접에서도 마찬가지다. 코드를 테스트하라 : 물론 종이에서, 기본 조건, 오류 발생 조건 등을 전부 테스트 하라 종이에 적은 코드를 그대로 컴퓨터로 옮긴 뒤 실제로 실행해 보라 : 종이에 적는 과정에서 많은 실수를 저질렀을 것이다. 실수 목록들을 만들고 실제 면접장에서 같은 실수를 저지르지 않도록 유의하라.그리고 가상 면접을 가능한 한 많이 해보길 바란다.알고 있어야 할 것들많은 회사에서 자료구조, 알고리즘 같은 종류의 문제에 집중하는데 이어한 문제를 내는 이유는 단순히 지식 확인을 위해서가 아니다.핵심 자료구조, 알고리즘, 기본 개념면접관이 우리에게 기대하는 것은 기본기다. 반드시 알아야할 것들로 다음과 같이 있다. 자료구조 알고리즘 개념 연결리스트 너비 우선 탐색 비트 조작 트리, 트라이, 그래프 깊이 우선 탐색 메모리(스택vs힙) 스택, 큐 이진 탐색 재귀 힙 병합 정렬 동적 프로그래밍 Vector, ArrayList 퀵 정렬 big-O시간&amp;공간 해시 테이블     위 주제에 대하여 사용법, 구현법, 애플리케이션, 가능하다면 공간과 시간 복잡도에 대해서 알아두자. 특히 해시테이블은 매우 중요한 주제다 이 자료구조를 능숙하게 다룰 수 있도록 연습하자2의 승수 표위 표는 규모 확장성 및 메모리 제한과 관련된 문제를 풀 때 유용하다.실제 문제 살펴보기 듣기 : 문제 설명과 관련된 것이라면 어떤 정보든지 집중해서 들어야 한다. 예제 : 직접 예제를 만들어서 디버깅하라 무식하게 풀기 : 알고리즘 효율을 높이려고 미리 애쓰지 말라, 먼저 무식한 방법으로 풀어보자 최적화 간과한 부분이 있는지 생각해보자 예제를 손으로 풀어보고 사고 과정을 되짚어 보자 잘못된 방법으로 문제를 풀어 본 뒤 왜 알고리즘이 틀렸는지 생각해보자 시간과 공간의 비용-이익 관계를 고려하라. (해시테이블이 특히 유용하다.) 검토하기 : 해법을 찾았다면 다시 한 번 검토하라 구현하기 : 시작부터 코드를 모듈화시키고 리팩토링해서 깔끔하게 만들어라 테스트 개념적 테스트 - 마치 코드리뷰를 하듯이 자세하게 코드를 훑어보며 테스트 특이하거나 표준적이지 않은 코드 산술연산 혹은 널 노드와 같이 실수가 날 만한 부분 작은 크기의 테스트들 특이하거나 극단적인 입력 경청하기반드시 문제를 잘 듣고 정확히 이해했는지 확인해야 한다. 확실하지 않은 부분은 질문을 통해 반드시 짚고 넘어가야 한다.문제를 주의 깊게 듣고 문제와 관련된 모든 독특한 정보를 머릿속에 기억해 둬야 한다. 대부분 문제를 푸는데 아무 영향도 끼치지 않는 정보를 제공하는 경우는 많지 않다.예제를 직접 그려보기많은 지원자들이 머릿속에서 생각한 후 바로 문제를 풀려고 시도하는데, 예제를 직접 그려 보면 차원이 다른 문제 풀이 능력을 발휘할 수 있을 것이다.예제를 만들 때는 다음을 유의해야 한다. 명확한 예제를 쓰라 - 문제에 맞는 실제 숫자와 문자열을 사용하라 충분히 큰 예제를 쓰라 특별한 예제를 지양하라무식한 방법으로 일단 해보기예제가 완성되면 일단 무식한 방법으로 먼저 시도해보자 첫 알고리즘이 형편 없어도 알고리즘의 시간 및 공간복잡도를 설명한 뒤 알고리즘을 개선해 나가면 된다. 무식한 방법 알고리즘은 느릴 수 있어도 토론할 가치가 있다.최적화 간과한 정보가 있는지 찾아보자 새로운 예제를 만들어 보자 잘못된 방식으로 문제를 풀어보자 - 틀린 해법을 통해 올바른 해법을 찾아낼 수도 있다. 시간과 공간의 실익을 따져보고 균형을 맞추어라 정보를 미리 계산해 두라 해시 테이블을 사용하라 (면접 문제에 널리 사용되는 개념으로 반드시 알고 있어야 한다.) 가능한 최선의 수행시간이 무엇인지 생각하라검토하기최적 알고리즘을 완성했다고 바로 코딩에 뛰어들지 말라 잠시 생각하며 알고리즘에 대한 이해를 확실히 할 시간을 가지자코딩을 시작하기 전에 가능하면 완벽에 가까운 상태로 만든 뒤에 실제 코딩에 들어가야 한다.코드작성하기아름다운 코드를 작성하려면 다음을 유의하라 모듈화된 코드를 사용하라 - 모듈화는 좋은 코딩 방식이다. 모듈화는 무엇인가를 쉽게 만들게 해준다. 에러를 검증하라 필요한 경우에 다른 클래스나 구조체를 사용하라 - 어떤 동작을 하는 함수가 필요한 경우 그 함수객체가 있다고 가정하고 사용한다. 그리고 나중에 시간이 남으면 그때 세부적인 부분을 처리하면 된다. 좋은 변수명을 사용하라 - 한 글자 변수명을 여기저기 사용하다 보면 코드를 읽기 어려워진다. 되도록 의미 있는 변수명을 쓰되 변수명이 너무 길어지고 반복되는 경우 처음에는 긴 변수명을 쓰고 이를 줄여서 약자로 쓰겠다고 면접관에게 설명하면 된다.나중에 리팩터링해야 할 부분을 발견한다면 바로 뛰어들지 말고 면접관에게 우선 설명한 후 시간을 들일 필요가 있는지 판단하여 리팩터링 여부를 결정한다.테스트면접에서 테스트 없이 코드를 제출하지 말아야 한다. 테스트는 다음과 같은 방법을 사용하자 개념적 테스트부터 시작하라 - 개념적 테스트는 코드를 한줄 한줄 읽어 내려가며 어떤 일을 수행하는지 분석하는, 즉 머릿속에서 돌려보는 테스트를 의미한다. 코드에서 평소와는 다르게 돌아가는 부분을 유심히 살펴보라 - 예) x=length-2, i=1부터 시작하는 for문 등을 눈여겨 보자 버그가 자주 발생하는 부분을 유심히 살펴보라 - 예)재귀함수의 기본, 정수 나눗셈, 이진트리의 널 노드, 연결리스트를 순회할 때 시작과 끝점 같은 곳 등을 잘 확인하자 작은 규모의 테스트를 돌려보라 - 실제 입력데이터를 이용해서 테스트해보자, 알고리즘 테스트시 원소의 개수가 많은 배열은 되도록 사용하지 말자 3~4개 정도가 적당하다. 크기가 작아야 버그를 더 빨리 찾을 수 있다.버그를 찾으면 바로 고치치 말고 왜 그런 버그가 발생했는지 주의 깊게 분석한 뒤 고치는 것이 최선의 방법이다.최적화 및 문제풀이 기술 1 : BUD를 찾으라B(병목현상), U(불필요한 작업), D(중복되는 작업)알고리즘이 비효율적으로 동작하는 가장 흔한 이유가 위 세가지다.병목현상병목현상은 알고리즘에서 전체 수행 시간을 잡아먹는 부분을 의미한다. 일반적으로 다음의 두 가지 이유 때문에 병목 현상이 발생한다. 어떤 부분 때문에 알고리즘이 느려지는 경우 : 예) 두 단계로 이루어진 알고리즘이 있을 때, 이 알고리즘은 먼저 배열을 정렬한 뒤 특정 속성을 가진 원소를 찾는 알고리즘이다. 첫 번째 단계에서는 O(N logN)이 소요되고 두 번째 단계에선 O(N)이 소요된다. 두 번째 단계를 줄일 수 있지만 별 의미가 없을 것이다. 왜냐하면 O(N logN)이 이 알고리즘의 병목점이기 때문이다. 첫 단계를 최적화하지 않는 이상 이 알고리즘의 전체 수행시간은 O(N logN)으로 남게 된다. 검색을 여러 번 하는 것처럼 반복적으로 수행하는 부분이 여러 개 있는 경우 : 이 경우에는 O(N)을 O(log N) 혹은 O(1)로 줄이는 것이 의미가 있을 것이다. 이런 경우 전반적인 수행 시간에 엄청난 속도 향상을 이룰 수 있기 때문이다.병목현상을 해결하는 것은 전체 수행 시간에 커다란 차이를 만들어낸다.예제: 서로 다른 정수로 이루어진 배열이 있을 때 두 정수의 차이가 k인 쌍의 개수를 세라. 예를 들어 주어진 배열이 (1, 7, 5, 9,2, 12, 31이고 k= 2면, 두 정 수의 차이가 2인 쌍은 다음과 같이 네 개가 존재한다.(1,3), (3,5), (5,7), (7,9)여기서 병목점은 원소 쌍의 두 번째 원소를 반복적으로 찾을 때 있다. 따라서 여기가 최적화를 해야 할 부분이다. 만약 배열이 정렬되어 있다면 이진 탐색을 이용해 O(logN)에 찾을 수 있고, 이를 모든 N개의 원소에 적용해 보면 시간 복잡도는 O(N logN)이 된다.이 알고리즘에선 배열을 정렬하는 부분이 새로운 병목점이 된다. 정렬 단계 때문에 두 번째 단계를 아무리 최적화해도 시간 복잡도 개선에 도움이 되지 않는다.정렬되지 않은 배열에서 원소를 빠르게 찾을 수 있는 방법이 무엇일까? 바로 해시테이블을 이용하면 된다. 배열의 모든 월소를 해시테이블에 넣은 뒤 이 해시테이블을 통해 x + k 또는 x - k가 배열에 존재하는지 확인하면 된다. 이렇게 하면 O(N) 시간에 문제를 풀 수 있다.불필요한 작업예제: a, D, C, d가 1에서 1000사이에 있는 정수 값 중 하나일 때 2'+6% C+d?을 만족하는 모든 자연수를 출력하시오.//무식한 방법 : 모든 가능한 값을 d에 대입해보는 과정은 불필요하다. 왜냐하면 가능한 d의 값은 딱 하나뿐이기 때문이다.n = 1000for a from 1 to n for b from 1 to n for c from 1 to n for d from 1 to n if a³ + b³ == c³ + d³ print a, b, c, d //정답을 찾은 뒤에는 d를 찾는 루프를 빠져나와야 한다. break이 방법의 시간복잡도는 여전히 O(N²)이라서 전체 시간 복잡도 개선에 별다른 영향을 주지 않는다.n = 1000for a from 1 to n for b from 1 to n for c from 1 to n d = pow(a³ + b³ - c³, 1/3) //정수로 반올림한다. if a³ + b³ == c³ + d³ //실제 이값이 수식을 만족하는지 확인한다. print a, b, c, d중복되는 작업 (103p)최적화 및 문제풀이 기술 2 : 스스로 풀어보라 DIY여러분이 컴퓨터 과학에 관한 지식이 없는 누군가에게 알파벳순으로 정렬된 학생 수첩 더미를 주면서 Peter Smith의 학생 수첩을 찾아보라고 한다면 그들은 이진 탐색 비슷한 방식을 이용할 것이다. 이진 탐색에 대한 사전 지식이 없더라도 직관적으로 어떻게 접근해야 할지는 알고있다.‘알고리즘을 설계하라’ 라는 문구를 던지면 사람들은 종종 혼란에 빠진다. 하지만 수첩더미와 같은 실제 예제를 쥐어주면 인간은 굉장히 훌륭한 알고리즘을 직관적으로 찾는다. 그러므로 실제 예제를 통해 직관적으로 문제를 풀어나가려는 노력을 하자.예제: 길이가 작은 문자열 s와 길이가 긴 문자열 b가 주어졌을 때, 문자열 b 안에 존재하는 문자열 s의 모든 순열을 찾는 알고리즘을 설계하라. 각 순열의 위치를 출력하면 된다.s : abbcb : cbabadcbbabbcbabaabccbabc나쁜 풀이 ) s에서 가능한 모든 순열을 나열한 뒤 b에서 찾는다. 이경우 순열의 개수가 S!이므로 O(S!*B)가 될 것이다.이렇게 하면 극단적으로 느린 알고리즘이 된다.좋은 풀이 ) s의 길이가 4이므로 b를 4개씩 끊어서 차례로 살펴본 뒤 s의 순열을 만족하는지 확인한다. b의 문자를 앞에서부터 차례로 살펴보면서 s에 속한 문자가 보일 때마다 그다음 문자를 포함한 4개의 문자열이 s의 순열을 만족하는지 확인한다.이렇게 하면 아마 수행시간은 O(BS), O(BSlogS), O(B*S²) 중 하나가 될 것이다.이처럼 문제를 풀때 문제에 적합하고, 크기가 크며, 구체적인 예제를 바탕으로 직관적으로 (손으로 직접) 문제를 풀어보길 바란다.최적화 및 문제풀이 기술 3 : 단순화, 일반화하라 자료형과 같은 제약조건을 단순화하거나 변형시킨다. 단순화된 버전의 문제를 푼다. 단순화된 문제의 알고리즘이 완성되면 해당 알고리즘을 보다 복잡한 형태로 다듬어 간다.예제: 랜섬 노트(ransom note)는 잡지에서 오린 단어를 이용해서 만들어 낸 새로운 문장을 의미한다. 잡지(문자열)가 주어졌을 때, 그 잡지에서 문자열로 표현된 특정 랜섬 노트를 만들 수 있는지 어떻게 확인할까?이런 형태의 문제는 배열을 하나 만들어서 글자의 출현 빈도를 세기만 하면 풀 수 있다. 배열의 각 원소는 글자 하나에 대응된다. 우선 랜섬 노트 내에서 각 문자가 출현한 횟수를 센 다음, 잡지를 훑어 가며 각 문자의 횟수가 랜섬 노트에 출현한 문자의 횟수보다 같거나 많은지 확인한다.==&gt; 결과 값(랜섬노트)가 주어지고, 입력 값(잡지)가 주어졌을때 입력 값으로 결과 값을 만들 수 있느냐에 대한 문제 같음.최적화 및 문제풀이 기술 4 : 초기 사례로부터 확장하기이 접근법은 우선 초기 사례 예) n=1 과 같은 문제를 푼 뒤, 거기서부터 해법을 확장해 나간다.106~107p최적화 및 문제풀이 기술 5 : 자료구조 브레인스토밍단순하게 일련의 자료구조를 차례 차례 살펴보면서 하나씩 적용해보면 된다. (107~108p)가능한 최선의 수행 시간(BCR)가능한 최선의 수행 시간이 무엇일까 생각해 보는 것 자체로도 문제를 푸는 유용한 힌트를 발견해낼 수 있다.예) 길이가 A와 B인 배열 두 개가 주어졌을 때 두 배열에 공통으로 들어있는 원소의 개수가 몇 개인지 세는 경우이 문제의 경우 각 배열의 원소를 적어도 한 번씩은 건드려봐야 하기 때문에 어떤 알고리즘이든 O(A+B)보다 빠를 수 없다. 따라서 이 문제에 BCR은 O(A+B)이다.오답에 대한 대처법면접에서 흔히하는 오해는 모든 문제를 맞춰야 한다는 생각이다. 면접에서 답을 평가할 때 맞냐 틀렸냐로 보지 않는다. 최종 답안이 최적 해법에 근접한가, 최종 답안을 내는데 시간이 얼마나 걸렸나 얼마나 힌트를 필요로 했는가 얼마나 코드가 깔끔한가를 더 중요하게 여긴다. 면접관은 지원자들을 상대적으로 평가한다. 대부분의 문제가 아주 어렵기 때문에 굉장히 실력있는 지원자라 하더라도 단번에 최적에 해법을 말하긴 어려울 수 있다.알고 있던 문제가 면접에 나왔을 때이전에 알고있던 문제가 면접에 나왔다면 면접관에게 사실대로 말하길 바란다. 면접관이 문제를 출제한 이유는 여러분의 문제풀이 능력을 평가하기 위함이다. 여러분이 이미 문제를 알고있다면 면접관은 여러분을 제대로 평가할 수 없다.면접용으로 완벽한 언어수많은 최고의 회사들은 언어 선택에 깐깐하게 굴지 않는다. 특정 언어에대한 내용을 알고있는지보다 얼마나 문제를 잘 풀었는지에 더 관심이 있다.언어를 선택할 때는 여러분이 가장 편하게 코딩할 수 있는 언어를 선택하는 게 가장 좋다. 만약 그런 언어가 많다면 다음을 염두해두고 선택하자 널리 사용되는 언어 : 면접관도 알고 있는 언어로 코딩하는 것이 바람직하다. 언어 가독성 : 면접관에게 익숙하지 않은 언어라도 기본적인 내용은 이해할 수 있을 것이다. 어떤 언어들은 다른 언어들과 전반적으로 유사해서 자연스럽게 쉽게 읽히는 경향이 있다. 잠재적인 문제점 : 어떤 언어들은 그 언어를 사용한다는 이유만으로 안고 가야하는 잠재적인 문제점들이 있다. 언어가 얼마나 장황한지 : 예를 들어 자바는 파이썬과 비교했을 때 상당히 장황한 언어다. 사용하기 쉬운 언어 : 어떤 언어는 다른 언어보다 특정 기능을 사용하기 쉽다.어떤 코드가 좋아 보이나모든 회사가 좋고 깔끔한 코드를 작성하는 지원자를 원한다는 사실을 알고 있을 것이다. 알반적으로 얘기해서 좋은 코드란 다음과 같은 속성을 가진다. 정확도 : 예상 가능한 혹은 불가한 입력에 대해서 코드는 정확히 동작해야 한다. 효율성 : 시간과 공간 두 가지 측면에서 모두 효율성이 좋은 코드여야 한다. 효율성 개념은 O 표기법과 같은 점근적 효율성과 실생활에서 만나게 되는 실용적 효율성의 개념을 모두 포괄한다. 간략화 : 코드 100줄짜리를 10줄로 작성할 수 있다면 그렇게 해야 한다. 가독성 : 다른 개발자들도 여러분의 코드를 읽고 어떻게 동작하는지 이해할 수 있어야 한다. 필요한 곳에 주석이 달려 있어야 하며 쉽게 이해할 수 있는 방식으로 구현되어야 한다. 관리 가능성 : 코드는 제품의 수명주기 동안에 적절히 수정 가능해야 하고, 최초로 작성한 개발자뿐 아니라 다른 개발자도 쉽게 관리 가능한 코드여야 한다." }, { "title": "06. big-O", "url": "/posts/06.bigO/", "categories": "BOOK, 코딩 인터뷰 완전분석", "tags": "", "date": "2023-03-12 22:00:37 +0900", "snippet": "big-O 시간은 알고리즘의 효율성을 나타내는 지표 혹은 언어다. 이를 제대로 이해하지 못하면 알고리즘을 개발하는 데 큰 고비를 겪을 수 있다.비유하기디스크에 있는 파일을 다른 지역에 살고 있는 친구에게 가능하면 빨리 보내려고 한다고 가정할 때, 파일의 크기가 작다면 온라인을 통한 전송이 빠를 것이다. 하지만 파일이 1TB라면 하루이상 걸릴 수 있다. 그럴땐 직접 차를 타고 가는 것이 빠를지도 모른다.시간 복잡도위 내용이 바로 점근적 실행 시간, 또는 big-O 시간에 대한 개념이다. 위의 데이터 전송 예시의 알고리즘 실행 시간을 다음과 같이 설명할 수 있다. 온라인 전송 : O(s), s는 파일의 크기가 된다. 따라서 파일의 크기가 증가함에 따라 전송 시간 또한 선형적으로 증가한다. 직접 전송 : 파일의 크기와 관계없이 O(1), 상수 시간만큼 소요된다.상수가 얼마나 큰지 또는 선형식이 얼마나 천천히 증가하는지에 관계없이 숫자가 커지다 보면 선형식은 언젠가 상수를 뛰어 넘게 된다.big-O, big-ϴ, big-Ω O(big-O) : 학계에서 big-O는 시간의 상한을 나타낸다. 배열의 모든 값을 출력하는 알고리즘은 O(N)으로 표현할 수 있지만, 이외에 N보다 큰 big-O 시간으로 표현할 수도 있다. Ω(big-Omega) : 학계에서 Ω는 등가 개념 혹은 하한을 나타낸다. 알고리즘은 Ω 수행시간보다 빠를 수 없게 된다. ϴ(big-theta) : 학계에서는 ϴ는 O와 Ω 둘 다를 의미한다. 어떤 알고리즘의 수행 시간이 O(N)이면서 Ω(N)이라면, 이 알고리즘의 수행 시간을 ϴ(N)로 표현할 수 있다.최선의 경우, 최악의 경우, 평균적인 경우 : 알고리즘의 수행시간을 세 가지 다른 방법으로 나타낼 수 있다. 퀵 정렬의 관점에서 보면 퀵 정렬은 축이 되는 원소 하나를 무작위로 뽑은 뒤 이보다 작은 원소들은 앞에, 큰 원소들은 뒤에 놓이도록 원소의 위치를 바꾼다. 그 결과 부분 정렬이 완성되고, 그 뒤 왼쪽과 오른쪽 부분을 이와 비슷한 방식으로 재귀적으로 정렬해 나간다. 최선의 경우 : 만약 모든 원소가 동일하다면 퀵 정렬은 평균적으로 단순히 배열을 한 차례 순회하고 끝날 것이다. 즉 수행시간이 O(N)이 된다. 최악의 경우 : 운이 없게 배열에서 가장 큰 원소가 계속해서 축이 된다면 이런 경우에 수행시간은 O(N²)으로 악화된다. 평균적인 경우 : 보통 최선의 경우와 최악의 경우가 반복적으로 일어나는 일은 많지 않다. 따라서 수행시간은 평균적으로 O(N log N)이라고 말할 수 있다.공간 복잡도알고리즘에서는 시간뿐 아니라 메모리 또한 신경 써야 한다. 공간 복잡도는 시간 복잡도와 평행선을 달리는 개념이다. 크기가 n인 배열을 만들고자 한다면 O(n)의 공간이 필요하다. n * n 크기의 2차원 배열을 만들고자 한다면 O(n²)의 공간이 필요하다.상수항은 무시하라big-O는 단순히 증가하는 비율을 나타내는 개념이므로 특수한 입력에 한해 O(N)코드가 O(1) 코드보다 빠르게 동작하는 것은 매우 가능성 있는 얘기다. 이런 이유로 우리는 수행시간에서 상수항을 무시해 버린다. 즉 O(2N)으로 표기되어야 할 알고리즘을 실제로는 O(N)으로 표기한다.big-O 표기법은 수행 시간이 어떻게 변화하는지를 표현해주는 도구이다. 따라서 O(N)이 언제나 O(2N)보다 나은 것은 아니라는 사실만 받아드리자지배적이지 않은 항은 무시하라수식에서 지배적이지 않은 항은 무시해도 된다. O(N² + N)은 O(N²) O(N + logN)은 O(N) O(5 * 2ᴺ + 1000N¹⁰⁰)은 O(2ᴺ)여러 부분으로 이루어진 알고리즘 : 덧셈 vs 곱셈//덧셈 수행 시간 O(A+B)for(int a: arrA) { print(a);}for(int b: arrB) { print(b);}//곱셈 수행 시간 O(A*B)for(int a: arrA) { for(int b: arrB) { print(a + \", \" + b); }}만약 알고리즘이 A 일을 모두 끝마친 후에 B 일을 수행하라의 형태라면 A와 B의 수행 시간을 더해야 한다.만약 알고리즘이 A 일을 할 때마다 B 일을 수행하라의 형태라면 A와 B의 수행 시간을 곱해야 한다.상환 시간ArrayList는 배열의 역할을 함과 동시에 크기가 자유롭게 조절되는 자료구조이다. ArrayList는 배열로 구현되어 있다. 배열의 용량이 꽉 찼을 때 ArrayList 클래스는 기존보다 크기가 두 배 더 큰 배열을 만든 뒤, 이전 배열의 모든 원소를 새 배열로 복사한다.배열이 가득 차 있는 경우, 배열에 N개의 원소가 들어 있을 때 새로운 원소를 삽입하려면 O(N)이 걸린다. 왜냐하면 크기가 2N인 배열을 새로 만들고 기존의 모든 원소를 새 배열로 복사해야 하기 때문이다. 따라서 이 경우에 삽입 연산은 O(N) 시간이 소요된다.대다수의 경우, 배열에 가용 공간이 존재하고 이때의 삽입 연산은 O(1)이 걸린다.상환 시간이라는 개념은 최악의 경우는 가끔 발생하지만 한 번 발생하면 그 후로 꽤 오랫동안 나타나지 않으므로 비용을 분할 상환한다는 개념이다.배열의 크기가 2의 승수가 되었을 때 원소를 삽입하면 용량이 두 배로 증가한다. 배열의 크기가 1, 2, 4, 8, 16, 32, ….X 일 때, 새로운 원소를 삽입하면 배열의 용량이 두 배로 증가하고, 이때 기존의 1, 2, 4, 8, 16, 32, …X개의 원소 또한 새로운 배열로 복사해줘야 한다. X개의 원소를 삽입할 때 필요한 시간은 O(2X)이고, 이를 분할 상환해보면 삽입 한 번에 필요한 시간은 O(1)이다.log N 수행 시간이진 탐색의 경우 N개의 정렬된 원소가 들어있는 배열에서 원소 X를 찾을 때 사용한다. 먼저 원소 x와 배열의 중간 값을 비교하고, x == 중간값 을 만족하면 이를 반한한다. x &lt; 중간값일 때는 배열의 왼쪽 부분을 재탐색하고, x &gt; 중간값일 경우에는 배열의 오른쪽 부분을 재탐색한다.처음에 원소 N개가 들어있는 배열에서 시작해서 한 단계가 지나면 탐색해야 할 원소의 개수가 N /2로 줄어들고, 한 단계가 더 지나면 N /4 개로 줄어든다. 그러다 원소를 찾았거나 탐색해야할 원소가 하나만 남으면 탐색을 중지한다. 총 수행시간은 N을 절반씩 나누는 과정에서 몇 단계 만에 1이 되는지에 따라 결정된다. 이 때 사용되는 것이 log이다.재귀적으로 수행시간 구하기int f(int n) { if(n &lt;= 1) return 1; return f(n-1) + f(n-1);}f 함수가 두 번 수행된다고 해서 O(N²)라고 생각할 수 있다. 코드를 하나씩 읽어보면 f(4)는 f(3)을 두 번 호출하고, f(3)은 f(2)를 거쳐서 f(1)까지 호출한다.트리의 깊이가 N이고 각 노드는 두 개의 자식 노드를 갖고 있다. 따라서 깊이가 한 단계 깊어질 때마다 이전보다 두 배 더 많이 호출하게 된다. (2ᴺ⁺¹ -1 이 됨) 이처럼 재귀함수에서 수행시간은 보통 O(깊이)로 표현되고는 한다. 위 예제의 경우 수행시간은 O(2ᴺ)이 된다.예제 및 연습문제//1) O(N)void foo(int[] array) { int sum = 0; int product = 1; for(int i = 0; i &lt; array.lengh; i++) { product *= array[i]; } System.out.println(sum + \", \" + product);}//2) 안쪽 루프의 반복 횟수는 O(N)이고, 루프가 N번 반복되기 때문에 수행시간은 O(N²)이 된다.void printPairs(int[] array) { for(int i = 0; i &lt; array.length; i++) { for(int j = 0; j &lt; array.length; j++) { System.out.println(array[i] + \", \" + array[j]); } }}//3) 2번 예제와 비슷하나 j가 i+1로 시작한다는 것이 차이가 있다. ==&gt; O(N²) 걸린다. 72~73pvoid printUnorderedPairs(int[] array) { for(int i = 0; i &lt; array.length; i++) { for(int j = i+1; j &lt; array.length; j++) { System.out.println(array[i] + \", \" + array[j]); } }}//4)void printUnorderedPairs(int[] arrayA, int[] arrayB) { for(int i = 0; i &lt; arrayA.length; i++) { for(int j = 0; j &lt; arrayB.length; j++) { //O(1) 시간이 걸리는 작업 } }}arrayA의 원소 하나당 안쪽에 for 루프는 b(arrayB.length)회 반복된다. 따라서 arrayA.length일 때 수행시간은 O(ab)가 된다. O(N²)이라 생각할 수 있겠지만 서로 다른 두 개의 입력이 주어지므로 O(N²)이 아니다.//5)void printUnorderedPairs(int[] arrayA, int[] arrayB) { for(int i = 0; i &lt; arrayA.length; i++) { for(int j = 0; j &lt; arrayB.length; j++) { for(int k = 0; k &lt; 100000; k++) { System.out.println(arrayA[i] + \", \" + arrayB[j]); } } }}위 경우에도 크게 달라질거 없다. 100,000은 상수항으로 간주되므로 수행 시간은 O(ab)가 된다.//6)void reverse(int[] array) { for(int i = 0; i &lt;array.length / 2; i++) { int other = array.length - i - 1; int temp = array[i]; array[i] = array[other]; array[other] = temp; }}위 예제는 O(N) 시간에 동작한다. 배열의 절반만 살펴본다고 해서 big-O 시간에 영향을 끼치는 것은 아니다.7)다음 중 O(N)과 같은 것은? O(N+P), P &lt; N/2 -&gt; O O(2N) -&gt; O O(N + logN) -&gt; O O(N+M) -&gt; X8)여러 개의 문자열로 구성된 배열이 주어졌을 때 각각의 문자열을 먼저 정렬하고 그 다음에 전체 문자열을 사전순으로 다시 정렬하는 알고리즘이 있을때 이 알고리즘의 수행 시간은?틀린답변)대부분 각 문자열을 정렬하는데 O(NlogN)이 소요되므로 모든 문자열을 정렬하는데 O(N * NlogN)이 소요되고, 그 다음 전체 문자열을 다시 사전순으로 정렬해야 하므로 O(NlogN)이 추가로 필요할 것이다. 따라서 전체 수행시간은 O(N²logN + NlogN)이 되고, 이를 정리하면 O(N²logN)이 될 것이라 생각한다.위 답이 틀린 이유는 N을 서로 다른 두 가지 경우에 혼용(문자열의 길이를 나타낼 때, 배열의 길이를 나타낼 때)해서 사용했다는 점이다. 이와 같은 실수를 방지하기 위해서 변수 N을 아예 사용하지 않거나 N이 가리키는 것이 명백한 경우에만 사용하는 것이 좋다.[정리] 각 문자열을 정리하는데 O(slogs) 소요 a개의 문자열을 모두 정렬해야 하므로 총 O(a * slogs) 소요 전체 문자를 사전순으로 정렬, 문자열 두개를 비교하는데 O(s) 시간 소요, 총(aloga)번을 비교해야 하므로 결론적으로 O(a * sloga)가 소요된다.위 두부분을 더해주면 전체 시간복잡도는 O(a * s(loga + logs))가 된다.//9) 균형 이진 탐색 트리에서 모든 노드의 값을 더하는 코드int sum(Node node) { if(node == null) { return 0; } return sum(node.left) + node.value + sum(node.right);}위 코드는 트리의 각 노드를 한 번씩 방문한 뒤 각 노드에서(재귀호출 제외) 상수 시간에 해당하는 일을 수행한다. 따라서 수행 시간은 노드의 개수와 선형 관계에 있다. 즉 N개의 노드가 있을 때 수행시간은 O(N)이 된다.재귀 함수에 분기가 여러 개 존재하는 경우 수행 시간은 일반적으로 O(분기^깊이)가 된다. 만약 분기가 두 개 존재하면 O(2^깊이)가 될 것이다. 지수 시간 알고리즘으로 표현되기는 했지만 결과적으로 보면 생각보다 나쁜 알고리즘은 아니다.위 예제에서 나온 트리는 균형 이진 탐색 트리로 총 N개의 노드가 있다면 깊이는 대략 logN이 된다.위의 수식에 따르면 수행시간은 O(2^logN)이 된다.//10) 현재의 값보다 작은 수들로 나누어 떨어지는지 확인함으로써 현재 값이 소수인지 아닌지를 판별하는 코드boolean isPrime(int n) { for(int x =2; x * x &lt;= n; x++;) { if(n % x == 0) { return false; } } return true;}for 루프의 내부 코드는 상수 시간에 동작한다. 최악의 경우에 for 루프가 몇 번 반복하는지만 세어 보면 시간 복잡도를 구할 수 있다.위 코드에서 루프는 x=2부터 x*x=n까지 반복한다. 즉 X=√n까지 반복한다는 뜻이다. 시간복잡도는 O(√n)//11) n의 계승(factorial)을 구하는 코드int factorial(int n) { if(n &lt; 0) { return -1; }else if(n == 0) { return 1 }else { return n * factorial(n-1); }}단순히 n부터 1까지 반복하는 재귀함수이므로 O(n)이 된다.//12) 문자열로 나타낼 수 있는 순열의 개수를 구하는 코드void permutation(String str) { permutation(str, \"\");}void permutation(String str, String prefix) { if(str.length() == 0) { System.out.println(prefix); }else { for(int i = 0; i &lt; str.length; i++) { String rem = str.substring(0, i) + str.substring(i + 1) ; permutation(rem.prefix + str.charAt(i)); } }}permutation 함수가 얼마나 많이 호출되는지, 각 호출마다 걸리는 시간이 얼마나 되는지 살펴보면 알 수 있다. 순열이 완성되는 시점에 permutation 함수가 몇 번이나 호출되는가 : 길이가 7인 문자열이 주어졌을 때 첫번째 자리는 7개의 선택권이 있다. 문자 하나를 선택했다면 그다음 자리는 6개의 선택권, 그 다음은 5개의 선택권…이 있다. 즉 7!(7의 계승)이 된다. =&gt; permutation 함수는 n!번 호출 순열 생성이 완성되기 전에 permutation 함수는 몇 번이나 호출되는가 : 1에서 말한대로 말단 노드는 n!이 되고 루트에서 말단 노드까지의 거리는 n이 될 것이다. 따라서 전체 노드의 개수는 n*n!개를 넘지 못한다. 각 함수 호출을 처리하는 데 얼마나 오래 걸리나 : 문자열을 연결해주는 연산을 수행하므로 O(n) 시간이 걸릴 것이다. 또 rem, prefix, str.charAt(i)의 길이의 합은 항상 n이 되는 것을 알 수 있다. 따라서 호출 트리의 각 노드가 처리하는 일은 O(n)이 된다. 총 수행 시간은 어떻게 되는가? : permutation 함수는 O(n*n)번(상한) 호출되고 한 번 호출될 때마다 O(N) 시간이 걸리므로 총 수행 시간은 O(nen)을 넘지 않을 것이다.//13) n번째 피보나치 수를 구하는 코드int fib(int n) { if(n &lt;= 0) return 1; return fib(n-1) + fib(n-2);}재귀 호출의 패턴을 이용하면 O(분기^깊이)가 된다. 각 호출마다 분기가 2개 존재하므로 깊이가 N일 떼 수행 시간은 O(2ᴺ)이 된다.//14) 0부터 n까지의 피보나치 수열 전부를 출력하는 코드void allFib(int n) { for(int i = 0; i &lt; n; i++) { System.out.println(i + \":\" + fib(i)); }}int fib(int n) { if(n &lt;= 0) return 0; else if(n == 0) return 1; return fib(n-1) + fib(n-2);}여기서는 n이 변한다는 점이 중요하다. fib(n)은 O(2ᴺ)이 걸리지만 n번의 호출이 모두 다른 n을 사용하므로 이를 반영해서 계산하는 것이 중요하다. fib(1) : 2¹번 호출 fib(2) : 2²번 호출 fib(3) : 2³번 호출 fib(4) : 2⁴번 호출81~88p" }, { "title": "05. 행동문제", "url": "/posts/05.-%ED%96%89%EB%8F%99-%EB%AC%B8%EC%A0%9C/", "categories": "BOOK, 코딩 인터뷰 완전분석", "tags": "", "date": "2023-03-11 22:00:37 +0900", "snippet": "대비 요령 흔히 나오는 문제 프로젝트1 프로젝트2 프로젝트3 가장 도전적이었던 것       실수 혹은 실패담       즐거웠던 것       리더십       팀원과의 갈등       남들과 다르게 행동했던 것       각 행의 첫 칸에는 흔히 나오는 질문들을 둔다. 면접 전에 위 표를 활용하여 공부하자. 세개 정도의 프로젝트에 대해서는 자세히 말할 수 있어야 하고, 기술적인 부분에 대해서는 깊이 있게 논의할 수 있어야 한다.여러분의 단점은 무엇인가 : 면접관이 단점을 물어보면 진짜 단점을 이야기 해라, 실존하면서도 인정할 수밖에 없는 단점을 이야기 하되, 그 단점을 극복하기 위해 어떻게 하고 있는지 강조하라.면접관에게는 어떤 질문을 해야하나 : 대부분의 면접관은 지원자에게 질문할 기회를 준다. 얼마나 양질의 질문을 던지느냐가 무의식적이든 의식적이든 면접관의 결정에 영향을 끼친다. 순수한 질문 : 예) 테스터, 개발자, 관리자의 비율은? 어떤식으로 협조하는가, 프로젝트 계획은 어떤식으로 수립하는가? 통찰력을 보여줄 수 있는 질문 : 예) X라는 기술을 사용하는 것을 봤는데 Y 문제는 어떻게 해결하시나? 열정을 보여줄 수 있는 질문 : 예) 규모 확장성 문제에 관심이 많고, 배우고 싶은데 회사 내에 그에 관해 배울 수 있는 기회가 있는가?기술적 프로젝트에 대한 이해두세 개의 프로젝트를 집중적으로 깊이 있게 알고 있어야 한다. 다음의 기준에 맞는 프로젝트를 선택한다면 더할 나위 없다. 단순히 많이 배웠던 것을 넘어서 도전적인 요소가 있었던 프로젝트 중심 역할을 했던 프로젝트 기술적으로 깊이 있는 이야기를 할 수 있는 프로젝트선택한 프로젝트에 대해서 도전적인 면, 실수, 기술적 결정, 기술의 선택, 남들과는 다르게 할 수 있었던 것들에 대해 이야기할 수 있어야 한다. 또 애플리케이션의 규모를 어떻게 확장할 수 있겠는가와 같은 질문에 대해서도 대비해야 한다.행동 질문에 대한 대처 요령52~56p면접관은 행동 질문을 통해 여러분의 과거 경험에 대해 더 잘 이해할 수 있다. 질문에 답할 때는 다음 사항들에 유의하자. 구체적으로 답하고, 오만한 태도를 보이지 말라 세부사항은 최소한만 언급하라 팀이 아닌 여러분 자신에 초점을 맞춰라 구조적인 답변을 내놓으라 : 행위 문제에 구조적으로 대답을 할 때 널리 쓰이는 두 가지 방법이 있다. 유용한 정보 우선 : 답변 서두에 내용을 간결히 요약하는 방식 S.A.R : 상황을 요약하고, 어떤 행동을 했는지 설명하고, 그 결과를 기술하는 접근법이다. 취했던 행동에 대해 논하라그러니까, 당신에 대해 말해보세요56~57p이야기를 구성하는 법 : 대표적으로 사람들에게 잘 먹히는 구조는 시간순 구조다. 현재 일에 대해 설명하는 문장으로 시작해서 업무 외에 관련 있거나 흥미로운 취미에 대한 이야기로 끝맺는다. 현재 직업(서두에서만) 학교 졸업 후 지금까지 현재 역할(자세하게) 업무 외에 마무리취미 : 대개 취미는 사소한 것에 불과하다. 취미가 일반적인 활동이라면 말하지 않고 건너 뛰어도 될 것이다. 취미가 유용한 경우로는 취미가 굉장히 독특한 경우 취미에 기술적인 면이 있는 경우 취미가 긍정적인 성격적 특성을 보여주는 경우성공 사례를 간간이 보여주라" }, { "title": "01. 알아두어야 할 시스템, 인프라 지식", "url": "/posts/01.-%EC%95%8C%EC%95%84%EB%91%90%EC%96%B4%EC%95%BC-%ED%95%A0-%EC%8B%9C%EC%8A%A4%ED%85%9C,-%EC%9D%B8%ED%94%84%EB%9D%BC-%EC%A7%80%EC%8B%9D/", "categories": "BOOK, 완벽한 IT 인프라구축을 위한 Docker", "tags": "infra, docker", "date": "2023-03-03 23:32:37 +0900", "snippet": "1-1. 인프라에 대한 기초 지식이전에 개발에 폭포수 모델에 따르면, 애플리케이션 엔지니어, 인프라 엔지니어의 역할이 나뉘어 있었는데 클라우드에 등장으로 애플리케이션 엔지니어에게도 OS와 네트워크 같은 인프라 기초 지식이 필요하게 되었다.인프라의 구성 요소인프라는 애플리케이션 동작에 필요한 하드웨어와 OS 및 미들웨어 등을 의미한다. 기능 요건 : 필요한 시스템 기능을 정의한 것을 의미 비기능 요건 : 시스템 성능과 신뢰성, 확장성, 운영성, 보안 등과 관련된 요건[인프라의 구성요소] 하드웨어 네트워크 OS 미들웨어인프라의 종류(클라우드와 온프레미스 환경) 온프레미스 : 시스템 구축에서부터 운영까지 자사에 데이터센터를 두고 수행하는 형태를 온프레미스라고 한다. 온프레미스 환경에서는 인프라 구성 요소인 서버와 네트워크 기기를 자사에서 조달하여 시스템 요건에 맞는 인프라를 구축한 뒤 자사에서 직접 운영한다. 퍼블릭 클라우드 : 인터넷을 통해 불특정 다수에게 제공하는 클라우드 서비스를 의미한다. 인프라 관련 초기 투자가 필요 없다. 프라이빗 클라우드 : 특정 기업 그룹에만 제공하는 클라우드 서비스를 의미한다. 보안을 확보하기 쉽고 독자적인 기능과 서비스를 추가하기에 용이하다.[클라우드에 적합한 케이스] 트래픽 변화가 많은 시스템 : 시스템에는 직원용 시스템과 고객용 시스템이 있다. 상대적으로 트래픽을 예측하기 힘든 고객용 시스템의 경우 트래픽 양에 따라 쉽게 증설할 수 있는 클라우드에서 구성하는 것이 좋다. 재해에 대비하기 위해 해외에 백업을 구축하고자 하는 시스템 되도록 빨리 동작해야 하는 시스템[온프레미스에 적합한 케이스] 높은 가용성이 요구되는 시스템 높은 기밀성이 요구되는 데이터를 다루는 시스템 특수 요건의 시스템 총 비용이 높은 시스템인프라 구축 및 운영 프로세스인프라의 경우 운영 단계에서 리소스 모니터링, 보안 대책을 위한 버전 업그레이드, 시스템 장애 발생시 복구 작업등의 많은 업무가 존재한다. Docker는 시스템 구축과 운영에 있어서 지금까지 사람이 수행해왔던 업무 중 많은 부분을 자동화하기 위한 플랫폼이다.1-2. 네트워크 및 하드웨어에 대한 기초인프라의 최하단 레이어를 구성하는 요소는 바로 네트워크와 하드웨어이다.네트워크네트워크에서는 각종 네트워크 장비등을 식별하기 위해 네트워크 Address를 사용한다. MAC Address : 네트워크 인터페이스 카드와 무선 LAN 칩 등 네트워크 부품에 물리적으로 할당되어 있는 48bit 주소다. IP Address : 인터넷과 인트라넷 등 네트워크에 접속하는 컴퓨터와 네트워크 장비를 구분하는 식별번호다.OSI 7 Layer와 통신 프로토콜서로 어떻게 통신할 것인가에 대해 정의한 규약을 통신 프로토콜이라 한다. OSI 7 Layer는 국제표준화기구(ISO)에서 정한 것으로 컴퓨터 통신를 계층 구조로 나눈 것이다. Application Layer : 웹의 HTTP와 메일을 전송하는 SMTP 등 애플리케이션에 특화된 프로토콜이다. Presentation Layer : 데이터 저장 방식과 압축, 문자 코드 등 데이터 표현 형식을 정의한다. Session Layer : 커넥션이 이루어지는 타이밍과 데이터 전송 타이밍을 정의한다. Transport Layer : 데이터 전송을 제어하는 계층으로 전송 중 오류를 감지하거나 재전송을 담당한다. 대표적으로 TCP, UDP가 있다. Network Layer : 서로 다른 네트워크 사이에서 이루어지는 통신을 위한 계층이다. 다른 네트워크에 데이터 패킷을 전송하는 것을 라우팅이라고 한다. Data Link Layer : 같은 네트워크 내에 있는 노드 사이의 통신을 위한 계층이다. Physical Layer : 통신 장비의 물리적, 전기적인 특성에 대한 계층으로 데이터에 어느정도의 전압과 전류를 줄 것인가와 케이블과 커넥터 형태 등을 정한다.방화벽시스템이 동작할 때 가장 중요한 것은 보안이며 이를 확보하기 위해 불필요한 통신을 차단해야 한다. 방화벽은 내부 네트워크와 외부와의 통신을 제어하고 내부 네트워크를 안전하게 지키기 위한 기술이다. 패킷 필터링 방식 : 통신하는 패킷을 포트 번호와 IP Address 기반으로 필터링하는 방법이다. 애플리케이션 게이트웨이 방식 : 패킷 대신 애플리케이션 프로토콜 레벨에서 외부와 통신하며 제어하는 방법이다. (프록시 서버)라우터와 L3 스위치라우터는 서로 다른 네트워크를 연결하기 위한 통신 장비이다. Network Layer에서 동작하며 어떤 루트로 데이터를 전송할지를 판단하기 위한 경로 선택 기능을 가지고 있다.L3 스위치는 라우터와 거의 같은 기능을 가지고 있고 라우팅을 하드웨어에서 처리하기 때문에 빠르게 동작한다는 특징이 있다.서버온프레미스에서는 여러 대의 서버로 인프라를 구성하고, 클라우드 서버에서는 온프레미스 서버 사양과 동급인 인스턴스를 선택해야 한다. CPU : 프로그램 연산과 처리등을 수행하는 전자 회로 부품을 말한다. CPU의 주요 연산 회로를 Core라고 부르며 Core 수가 크면 클수록 동시에 처리할 수 있는 연산 처리 수가 증가한다. 또 CPU의 빠른 처리를 위하여 메모리와의 처리 속도 차를 줄이기 위한 동적 캐시를 사용한다. 메모리 : CPU가 직접 액세스할 수 있는 기억장치를 메모리라 한다. 기억 영역이기 때문에 데이터 용량이 크고 데이터 전송 속도가 빠를수록 성능이 높다. 스토리지 : 데이터베이스에 데이터를 저장하는 디바이스로 보조기억장치라고 불린다. 예) 하드디스크, SSD, 하드디스크에 장애가 발생한 경우 중요한 데이터가 분실될 수 있으므로 대부분 RAID 구성을 해야한다.클라우드를 사용하는 경우 하드웨어 선택이 곧 서비스 선택이다. 안정적이고 효율적인 인프라를 구축하기 위해서는 클라우드 서비스의 조합이 포인트다." }, { "title": "14. 분석함수", "url": "/posts/14.%EB%B6%84%EC%84%9D%ED%95%A8%EC%88%98/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2023-02-17 21:55:37 +0900", "snippet": "분석함수는 집계 함수의 확장 기능으로 생각할 수 있다. 집계 함수는 행 그룹으로 값을 집계하고, 분석 함수는 파티션과 윈도우로 값을 집계한다.집계 함수는 행 그룹 별로 단일 행을 반환하기 때문에 데이터 집합이 변경되지만, 분석 함수는 데이터 집합을 변경하지 않고 값을 집계한다. 데이터 집합이 변경되지 않기 때문에 원본 값과 집계 값을 함께 분석할 수 있는 장점이 있다.# 집계 함수를 사용한 버전SELECT a.empno, a.sal, b.sal AS c1, a.sal / b.sal AS c2FROM emp a, (SELECT deptno, SUM(sal) AS sal FROM emp GROUP BY deptno) bWHERE a.deptno = 10AND b.deptno = a.deptnoORDER BY 1;# 분석 함수를 사용한 버전SELECT empno, sal, SUM(sal) OVER () AS c1, RETIO_TO_REPORT(sal) OVER () AS c2FROM empWHERE deptno = 10ORDER BY 1;14.1 기본 문법분석 함수는 OVER 키워드를 사용한다. 집계 함수에 OVER 키워드를 기술하면 분석 함수로 동작한다.OVER 키워드에는 ANALYTIC 절을 기술할 수 있고, 이 절은 QUERY PARTITION 절, ORDER BY 절, WINDOWING 절로 구성된다.14.1.1 QUERY PARTITION 절QUERY PARTITION 절은 GROUP BY 절과 유사하게 동작한다. QUERY PARTITION 절을 생략하면 전체 행이 하나의 파티션으로 동작한다.SELECT empno, job, sal , SUM(sal) OVER (PARTITION BY job) AS c1 -- job별 합계 , SUM(sal) OVER () AS c2 -- 총 합계FROM empWHERE deptno = 30ORDER BY 2, 1;14.1.2 ORDER BY 절SELECT empno, sal, SUM(sal) OVER (ORDER BY sa1, empno) AS c1FROM empWHERE deptno = 30ORDER BY 2, 1;14.1.3 WINDOWING 절WINDOWING 절로 파티션의 윈도우를 지정할 수 있다. 윈도우는 ROWS 방식이나 RANGE 방식으로 지정할 수 있다.[윈도우 범위를 지정하는 키워드] BETWEEN … AND … : 윈도우의 시작과 끝 UNBOUNDED PRECEDING : 앞쪽 끝 UNBOUNDED FOLLOWING : 뒤쪽 끝 CURRENT ROW : 현재 행 value_expr PRECEDING : ROWS - 현재 행에서 앞쪽으로 value_expr 만큼 이동, RANGE - 현재 값에서 value_expr 을 가감 value_exp FOLLOWING : ROWS - 현재 행에서 뒤쪽으로 value_expr 만큼 이동, RANGE - 현재 값에서 value_expr 을 가감341~350p14.1.4 KEEP 키워드KEEP 키워드를 사용하면 ANALYTIC 절에 QUERY PARTITION 절만 사용할 수 있다.# job 파티션 별 sal가 최소인 행을 대상으로 comm의 최고값을 조회SELECT ename, job, sal, comm, MAX(comm) KEEP(DENSE_RANK FIRST ORDER BY sal) OVER (PARTITION BY job) AS c1FROM empWHERE deptno = 30ORDER BY 2,3,4;14.1.5 주의사항 RANGE 방식에 value_expr을 지정하면 ORDER BY 절에 숫자 값이나 날짜 값을 사용해야 한다 RANGE 방식에 value_expr을 지정하면 정렬 표현식을 1개만 사용할 수 있다 분석함수는 SELECT 절과 ORDET BY 절에 사용할 수 있다# 1번 주읫사항SELECT job, sal, sum(sal) OVER (ORDER BY job RANGE 1 PRECEDING) as c1FROM empWHERE deptno = 30;# 2번 주의사항SELECT job, sal, SUM(sal) OVER (ORDER BY sal, comm RANGE 1 PRECEDING) as c1FROM empWHERE deptno = 30;# 3번 주의 사항SELECT deptno, ename, salFROM empWHERE SUM(sal) OVER (PARTITION BY deptno) &gt;= 1000;14.2 분석 함수분석 함수의 대부분은 집계 함수에 OVER 키워드를 기술하는 방식으로 사용한다.14.2.1 기본 함수 COUNT 함수 : 전체 행의 개수나 expr의 개수를 반환 MIN 함수 : expr의 최저 값을 반환 MAX 함수 : expr의 최고 값을 반환 SUM 함수 : expr의 합계 값을 반환 AVG 함수 : expr의 평균 값을 반환 (358~361p)14.2.2 통계 함수 STDDEV 함수 : expr의 표준 편차를 반환 VARIANCE 함수 : expr의 분산을 반환이외에도 다음의 통계 함수를 분석 함수로 사용할 수 있다.14.2.3 순위 함수순위 함수는 정렬 조건에 따른 순위를 반환한다. 순위 집계함수는 가상의 행을 생성하지만 순위 분석 함수는 실제의 행으로 값을 계산한다. RANK 함수 : expr이 동일하면 동순위를 부여하고 다음 순위는 동순위의 개수만큼 건너뛴다. DENSE_RANK 함수 : 동순위가 존재하더라도 다음 순위를 이어서 부여한다. ROW_NUMBER 함수 : 고유한 순번을 반환, 정렬 값이 동일하더라도 다른 순번을 부여하기 때문에 결과 값이 변경될 수 있다. NTILE 함수 : order_by_clause에 따라 행을 정렬하고, expr의 개수만큼 버킷을 생성한 후 행에 해당하는 버킷 번호를 할당한다. NTILE 함수로 생성한 버킷으로 행을 집계할 수 있다. 367~369p# 950~1250 1번 버킷, 1500~2850 2번 버킷...SELECT sal , NTILE(1) OVER (ORDER BY sal) AS c1, NTILE(2) OVER (ORDER BY sal) AS c2 , NTILE(3) OVER (ORDER BY sal) AS c3, NTILE(4) OVER (ORDER BY sal) AS c4 , NTILE(5) OVER (ORDER BY sal) AS c5, NTILE(6) OVER (ORDER BY sal) AS c6 , NTILE(7) OVER (ORDER BY sal) AS c7FROM empWHERE deptno = 30ORDER BY 1; CUME_DIST 함수 : 누적 분포 값을 반환한다. (0 &lt; y &lt;= 1) PERCENT_RANK 함수 : 백분위 순위 값을 반환한다. (0 &lt;= y &lt;= 1) RATIO_TO_REPORT 함수 : expr의 합계에 대한 현재 expr의 비율을 반환한다.14.2.4 분포 함수분포 함수는 분포 모형에 따른 분포 값을 반환한다. PERCENTILE_COUNT 함수 : 연속 분포 모델에서 expr에 지정한 백분위 값에 해당하는 값을 반환한다. PERCENTILE_DISC 함수 : 이산 분포 모델에서 expr에 지정한 백분위 값에 해당하는 값을 반환한다. MEDIAN 함수 : 연속 분포 모형을 가진 중앙값을 반환한다.14.2.5 순차 함수순차에 해당하는 값을 가져오는 함수다. FIRST_VALUE 함수 : 윈도우 첫 행의 expr을 반환한다. LAST_VALUE 함수 : 윈도우 끝 행의 expr을 반환한다. NTH_VALUE 함수 : 윈도우 n번째 행의 measure_expr을 반환한다.14.2.6 기타 함수 LAG 함수 : 현재 행에서 offset 이전 행의 value_expr을 반환한다. LEAD 함수 : 현재 행에서 offset 이후 행의 value_expr을 반환한다.LAG 함수와 LEAD 함수는 행 기준으로 동작하므로 분석 함수의 정렬 값이 고유하지 않으면 값이 무작위로 변경될 수 있다. LISTAGG 함수 : measure_expr을 order_By_clause로 정렬한 후 delimiter로 구분하여 연결한 값을 반환한다.14.3 활용 예제선분 이력 전환 1점 이력을 선분 이력으로 전환해보자-- LEAD 함수를 사용하면 점 이력을 선분 이력으로 변환할 수 있다.SELECT cd, dt AS bg_dt , LEAD(dt - 1, 1, DATE, '9999-12-31') OVER (ORDER BY dt) AS ed_dt, v1FROM t1ORDER BY 1, 2;선분 이력 전환 2월별 이력을 선분 이력으로 전환해보자-- ROW_NUMBER 함수로 생성한 순번의 차를 이용하여 행 그룹을 생성SELECT cd, MIN(ym) AS bg_ym , CASE WHEN MAX(r1) = MAX(cn) THEN '999912' ELSE MAX(ym) END AS ed_ym, v1FROM (SELECT a.* , COUNT(*) OVER (PARTITION BY a.cd) AS cn , ROW_NUMBER() OVER (PARTITION BY a.cd ORDER BY a.ym) AS r1 , ROW_NUMBER() OVER (PARTITION BY a.cd, a.v1 ORDER BY a.ym) AS r2 FROM t1 a)GROUP BY cd, v1, r1 - r2ORDER BY 1, 2;선분 이력 병합SELECT cd, MIN(bg) AS bg, MAX(ed) AS ed, ynFROM(SELECT a.* , ROW_NUMBER() OVER (PARTITION BY cd ORDER BY bg) AS r1 , ROW_NUMBER() OVER (PARTITION BY cd, yn ORDER BY bg) AS r2 FROM t1 a)GROUP BY cd, yn, CASE WHEN yn = 'N' THEN r1 - r2 ELSE r1 ENDORDER BY 1, 2;행 패턴 검색WITH w1 AS ( SELECT a.* , NVL (SIGN (v1 - LAG(v1) OVER (PARTITION BY cd ORDER BY dt)), 0) AS df FROM t1 a) SELECT a.* , ROw_NUMBER() OVER (PARTITION BY cd ORDER BY dt) AS r1 , ROw_NUMBER() OVER (PARTITION BY cd, df ORDER BY dt) AS r2 FROM w1 aORDER BY 1m 2;선형 보간행 복제 기법을 사용하여 데이터가 존재하지 않는 구간의 행을 생성하고, LEAD 함수를 사용하여 보간 값을 계산한다.SELECT a.dt + b.lv - 1 AS dt, ROUND (a.v1 + (a.v1_df / a.dn) * (b.lv - 1), 2) AS v1FROM (SELECT a.*, NVL(LEAD(a.v1) OVER (ORDER BY a.dt) - a.v1, 0) AS v1_df, NVL(LEAD(a.dt) OVER (ORDER BY a.dt) - a.dt, 0) AS dn FROM t1 a) a, (SELECT LEVEL AS 1v FROM DUAL CONNECT BY LEVEL &lt;=10)bWHERE b.1v &lt;= a.dnORDER BY 1," }, { "title": "13. 집합 연산자", "url": "/posts/13.%EC%A7%91%ED%95%A9-%EC%97%B0%EC%82%B0%EC%9E%90/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2023-02-14 22:43:37 +0900", "snippet": "집합 연산자는 데이터 집합을 연결한다는 점에서 조인과 유사하게 동작한다. 조인은 데이터 집합을 수직으로 연결하고, 집합 연산자는 데이터 집합을 수평으로 연결한다.13.1 기본 문법13.1.1 UNION ALL 연산자UNION ALL 연산자는 데이터 집합을 수평으로 연결한다. 기술 순서대로 데이터 집합이 반환된다.# t1 테이블이 반환된 후, t2 테이블이 반환된다.SELECT c1 FROM t1UNION ALLSELECT c2 FROM t2;13.1.2 UNION 연산자중복 값이 제거된 합집합을 생성한다. 중복 값을 제거하기 위해 sort가 발생한다.SELECT c1 FROM t1UNIONSELECT c2 FROM t2;# 아래 쿼리는 데이터 집합이 중복되지 않기 때문에 UNION ALL을 사용해도 결과가 동일하다. 불필요한 sort가 발생하지 않도록 UNION ALL을 사용하자SELECT '1' AS tp, empno, ename FROM emp WHERE job = 'ANALYST'UNIONSELECT '2' AS tp, empno, ename FROM emp WHERE sal = 3000;13.1.3 INTERSECT 연산자중복 값이 제거된 교집합을 생성한다.SELECT c1 FROM t1INTERSECTSELECT c1 FROM t2;13.1.4 MINUS 연산자중복 값이 제거된 차집합을 생성한다.# t1 - t2SELECT c1 FROM t1MINUSSELECT c1 FROM t2;13.2 주의사항 연결되는 열의 개수가 동일해야 한다. 연결되는 열의 데이터 타입이 동일해야 한다. 집합 연산자를 사용한 쿼리는 ORDER BY 절을 쿼리의 마지막에 1번만 기술해야 한다.(UNION ALL 연산자의 경우 인라인 뷰에서 데이터를 정렬한 후 데이터 집합을 연결할 수 있다.) 집합 연산자는 우선순위가 동일하기 때문에 기술 순서대로 연산이 수행된다. (괄호를 사용하여 연산 순서를 조정할 수 있다.)13.3 활용 예제OR 조건 성능 개선 : OR 조건을 사용한 쿼리는 다수의 조건으로 인해 쿼리의 성능이 저하될 수 있다. UNION ALL 연산자로 데이터 집합을 분리함으로써 쿼리의 성능을 개선할 수 있다.SELECT ename, sal, deptnoFROM empWHERE((deptno = 10 AND sal &gt;= 2000) OR (deptno = 20 AND sal &gt;= 3000));SELECT ename, sal, detnp FROM emp WHERE deptno = 10 AND sal &gt;= 2000UNION ALLSELECT ename, sal, detnp FROM emp WHERE deptno = 20 AND sal &gt;= 3000;동적 조건 성능 개선 : UNION ALL 연산자로 동적 조건의 성능을 개선할 수 있다. 328~329pFULL OUTER JOIN 성능 개선 : FULL OUTER JOIN을 수행하면 조인이 여러 번 수행되어 쿼리의 성능이 저하되었다. 성능 개선을 위해 UNION ALL 연산자로 변경하는 기법을 사용할 수 있다. 그렇다고 모든 FULL OUTER JOIN을 UNION ALL 연산자로 변경할 수 있는 것은 아니다. FULL OUTER JOIN의 조인 차수가 1:1인 경우만 FULL OUTER JOIN을 UNION ALL 연산자로 변경할 수 있다. 330~334pINTERSECT, MINUS 연산자 성능 개선 : UNION, INTERSECT, MINUS 연산자는 중복 값을 제거하기 위해 데이터 집합을 정렬한다. 대량 데이터에 소트가 발생하면 쿼리 성능이 저하될 수 있다. INTERSECT, MINUS 연산자는 서브 쿼리로의 변경을 통해 소트 발생량을 감소시킬 수 있다." }, { "title": "12. 서브 쿼리", "url": "/posts/12.%EC%84%9C%EB%B8%8C-%EC%BF%BC%EB%A6%AC/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2023-02-10 00:05:37 +0900", "snippet": "쿼리 블록은 다른 쿼리 블록을 포함할 수 있다. 다른 쿼리 블록에 포함된 쿼리 블록을 서브 쿼리, 다른 쿼리 블록을 포함한 쿼리 블록을 메인 쿼리라고 한다.# 예) 급여가 평균 이상인 사원 조회SELECT ename, salFROM empWHERE sal &gt;= (SELECT AVG(sal) FROM emp);서브 쿼리는 사용 위치에 따라 분류된다. 중첩 서브쿼리 (nested subquery) : WHERE 절, HAVING절 스칼라 서브 쿼리 (scalar subquery) : SELECT 절 인라인 뷰 (inline view) : FROM 절12.1 중첩 서브 쿼리중첩 서브쿼리는 메인 쿼리와의 상관 관계가 없으면 비상관 서브쿼리, 상관 관계가 있으면 상관 서브쿼리로 구분할 수 있다. 그리고 서브 쿼리가 반환하는 행의 개수에 따라 단일 행 서브 쿼리와 다중 행 서브쿼리로도 구분할 수 있다.12.1.1 비상관 서브 쿼리서브 쿼리의 WHERE 절에 메인 쿼리와의 조인 조건이 존재하지 않는다. 서브 쿼리가 반환하는 행의 개수에 따라 단일 행 비상관 서브 쿼리와 다중 행 비상관 서브 쿼리로 구분할 수 있다.단일 행 비상관 서브 쿼리# 단일 행SELECT *FROM t1WHERE c1 = (SELECT MAX(c1) AS c1 FROM t2);# 다중 열 서브쿼리SELECT *FROM t1WHERE (c1, c2) = (SELECT MAX(c1), MAX(c2) FROM t2);다중 행 비상관 서브 쿼리# IN 조건SELECT *FROM t1WHERE c1 IN (SELECT c1 FROM t2);# NOT IN 조건SELECT *FROM t1WHERE c1 NOT IN (SELECT c1 FROM t2); -- 열의 값에 null이 있는 경우 결과가 반환되지 않는다. AND NULL은 항상 UNKNOWN이기 때문에 결과가 반환되지 않는다.# ANY(일부), ALL(전체)SELECT *FROM t1WHERE c1 &gt; ANY(SELECT c1 FROM t2);12.1.2 상관 서브 쿼리메인 쿼리와 관계가 있는 서브 쿼리로 서브 쿼리의 WHERE 절에 메인 쿼리와의 조인 조건이 존재한다.단일 행 상관 서브 쿼리SELECT a.*FROM t1 aWHERE a.c2 = (SELECT MAX(x.c2) FROM t2 x WHERE x.c1 = a.c1); -- 메인 쿼리와 조인 조건다중 행 상관 서브 쿼리# EXISTS 조건 : 서브 쿼리에 존재하는 행 반환SELECT a.*FROM t1 aWHERE EXISTS (SELECT 1 FROM t2 x WHERE x.c1 = a.c1);# NOT EXISTS 조건 : 서브 쿼리에 존재하지 않는 행 반환SELECT a.*FROM t1 aWHERE NOT EXISTS (SELECT 1 FROM t2 x WHERE x.c1 = a.c1);12.1.3 사용 기준 행 비상관 서브 쿼리 상관 서브 쿼리 단일 행 비교 조건 비교 조건 다중 행 IN, NOT IN EXISTS, NOT EXISTS # 단일 행 비상관 서브 쿼리 : 메인 쿼리에 단일 값을 입력할 때 사용 예) MAX(), = 등호조회SELECT 고객번호, 고객명FROM 고객WHERE 고객번호 = (SELECT MAX(주문고객번호) KEEP (DENSE_RANK FIRST ORDER BY 주문일자 DESC) FROM 주문);# 단일 행 상관 서브 쿼리 : 메인 쿼리의 열을 서브 쿼리의 결과와 비교할 때 사용SELECT a.고객번호, b.주문번호, b.주문일자FROM 개인고객 a, 주문 bWHERE b.주문고객번호 = a.고객번호AND b.주문일자 = (SELECT MAX(x.주문일자) FROM 주문 x WHERE x.주문고객번호 = a.고객번호);# 다중행 서브쿼리 : IN 조건(서브쿼리 먼저조회 -&gt; 메인쿼리에 값 공급), EXISTS 조건(메인쿼리 먼저 조회 -&gt; 서브쿼리로 존재여부 확인)12.2 스칼라 서브 쿼리스칼라 서브쿼리는 SELECT 절에 사용하는 서브 쿼리다. 스칼라는 단일 값을 의미한다. 따라서 다중 행이 반환되며 에러가 발생한다.SELECT a.c1, (SELECT MAX(x.c2) FROM t2 x WHERE x.c1 = a.c1) AS c2FROM t1 a;12.3 인라인 뷰인라인 뷰는 FROM 절에서 사용하는 서브 쿼리이다. 인라인 뷰는 쿼리에서 즉시 처리되는 뷰를 의미한다.SELECT a.dname, b.enameFROM (SELECT * FROM dept WHERE loc = 'DALLAS') a , (SELECT * FROM emp WHERE job = 'CLERK') bWHERE b.detno = a.deptno;12.4 사용 기준조인조인은 테이블을 연결하는 기본 방식이다. 조인 기준의 행이 줄어들거나 늘어날 수 있다.중첩 서브 쿼리중첩 서브 쿼리는 서브 쿼리로 메인 쿼리의 결과 집합을 제한할 때 사용한다. EXISTS 조건은 조인되는 값의 종류가 적고, 서브 쿼리 테이블의 크기가 클 때 유용하다. 메인 쿼리와 서브 쿼리의 조인 차수가 1:M일 때 사용하는 것이 일반적이다.NOT EXISTS 조건은 메인 쿼리와 서브 쿼리의 조인 차수에 관계 없이 모두 사용할 수 있다. 아우터 조인으로도 작성 가능하다 가독성 측면에서는 NOT EXISTS 조건을 사용하는 편이 바람직 하다.스칼라 서브 쿼리스칼라 서브쿼리는 서브 쿼리로 단일 값을 조회할 때 사용한다. 스칼라 서브 쿼리는 조인되는 값의 종류가 적고, 서브 쿼리 테이블의 크기가 클 때 유용하다. (1:M일때 사용)그렇지 않다면 인라인 뷰로 변경하는 편이 성능 측면에서 유용하다.인라인 뷰복합 뷰는 인라인 뷰로 새로운 결과 집합을 만들거나 조인 차수를 1:1 관계로 만들 때 사용한다. 단순 뷰는 조인 순서를 제어하거나 반복되는 표현식을 제거할 때 사용할 수 있다.12.5 WITH 절WITH 절을 사용하면 서브 쿼리를 별도의 절(SUBQUERY FACTORING 절)에 기술할 수 있다.12.5.1 SUBQUERY FACTORING 절이 절을 사용하면 서브 쿼리에 이름을 부여하고, 이름이 부여된 서브 쿼리를 메인 쿼리에서 반복 사용할 수 있다. WITH query_name AS (subquery) ... SELECT ...WITH w1 AS (SELECT deptno, SUM(sal) AS sal FROM emp GROUP BY deptno)SELECT a.deptno, b.dname, a.salFROM w1 a, dept bWHERE b.deptno = a.deptno;WITH w1 AS (SELECT deptno, SUM(sal) AS sal FROM emp GROUP BY deptno) , w2 AS (SELECT SUM(sal) AS sal FROM w1)SELECT a.deptno, a.dname, b.sal, (b.sal / c.sal) * 100 AS rtFROM dept a, w1 b, w2 cWHERE b.deptno = a.deptno;12.5.2 PL/SQL 선언12.1 버전부터 WITH 절애 PL/SQL 함수와 프로시저를 선언할 수 있다.12.6 신규 기능12.6.1 LATERAL 인라인 뷰LATERAL 인라인 뷰를 사용하면 인라인 뷰에 메인 쿼리의 열을 기술할 수 있다. LATERAL 인라인 뷰 뒤에 (+) 기호를 사용하면 아우터 조인으로 조인된다.12.6.2 CROSS APPLY 절CROSS APPLY 절을 사용하면 LATERAL 인라인 뷰의 이너 조인과 결과가 동일하다.12.6.3 OUTER APPLY 절을 사용할 수 있다.OUTER APPLY 절은 LEFT OUTER JOIN의 변형이다.12.6.4 기존 동작 변화12.1 버전 이전에 서브 쿼리에 메인 쿼리의 조건을 기술하면 에러가 발생했으나 이후 버전부터는 에러가 발생하지 않는다. 스칼라 서브쿼리도 서브쿼리에 메인 쿼리의 조건을 기술할 수 있다." }, { "title": "11. 조인", "url": "/posts/11.%EC%A1%B0%EC%9D%B8/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2023-02-07 23:02:37 +0900", "snippet": "조인을 사용하면 하나의 쿼리로 다수의 테이블을 조회할 수 있다. 조인은 열 값으로 테이블 행을 연결한다.SELECT a.deptno, a.dname, b.empno, b.enameFROM dept a, emp bWHERE b.deptno = a.deptnoORDER BY 1, 3;11.1 기본 원리11.1.1 조인 조건일반 조건이 열과 값을 평가하는 반면, 조인 조건은 열과 열을 평가한다. 조인은 조인 조건에 따라 카티션 곱, 등가 조인, 비등가 조인으로 구분할 수 있다.카티션 곱카티션 곱은 조인 조건이 없는 조인 이다. 카티션 곱이 발생하면 조인되는 테이블 행의 곱만큼 행이 반환된다.카티션 곱은 조인 조건이 없으므로 평가 결과가 항상 TRUE 이다.등가 조인등가 조인은 조인 조건이 모두 등호(=)인 조인이다. 값이 동일한 경우에만 행이 반환된다. (inner join) 조인되는 테이블의 갯수가 n개라면, 테이블 간의 조인 조건은 최소 n-1개가 되어야 한다.SELECT a.c1, b.c1FROM t1 a, t2 bWHERE b.c1 = a.c1;비등가 조인비등가 조인은 등호 외에 다른 조인 조건이 있는 조인이다.SELECT a.c1, b.c1FROM t1 a, t2 bWHERE b.c1 &gt;= a.c1;11.1.2 조인 범위조인 범위는 inner, outer로 구분할 수 있다.inner join이너 조인은 조인이 성공한 범위를 반환한다. NVL을 사용해서 널을 포함한 조인을 수행할 수 있고, IS NULL 조건을 사용할 수도 있다.SELECT ...FROM t1 a, t2 bWHERE b.c1 = a.c1AND b.c2 = a.c2AND b.c3 = a.c3;outer join아우터 조인은 이너와 아우터를 함께 반환한다.# 아우터 기준 반대쪽에 (+) 기호를 기술한다.SELECT ...FROM t1 a, t2 bWHERE b.c1(+) = a.c1;232~240p11.1.3 조인 차수조인 차수는 조인되는 테이블의 차수를 의미한다.예) t1, t2가 1:M 관계라면 조인 차수는 1:M이다.등가 조인시 관계 차수가 1:M이고 M쪽의 PK가 모두 등호로 입력되면 조인 차수는 1:1이 된다.11.2 기술 순서11.2.1 FROM 절FROM 절의 테이블은 데이터의 논리적인 흐름에 따라 기술해야 한다. 데이터 모델과 업무 요건을 이해해야 테이블의 기술 순서를 결정할 수 있는 것이다.# t1 -&gt; t2 -&gt; t3 순서로 조인 수행SELECT *FROM t1 a, t2, b, t3 cWHERE b.c1 = a.c1AND c.c1 = b.c1;# t1 -&gt; t3 -&gt; t2SELECT *FROM t1 a, t3, c, t2 bWHERE d.c1 = a.c1AND b.c1 = c.c1;# t2 -&gt; t3 -&gt; t1SELECT *FROM t2 b, t3, c, t1 aWHERE c.c1 = b.c1AND a.c1 = c.c1조인은 행이 가장 적게 늘어나는 순서로 수행해야 하며, FROM 절의 테이블도 동일한 순서로 기술하는 편이 바람직하다. 그리고 조인 조건에 일반 조건이 존재하는 경우 실제 행의 증감까지 고려할 필요가 있다.FROM 절의 기술 순서는 조인의 기본 원리와도 관련이 있다.# 1)SELECT *FROM t1 a, t2 bWHERE b.c1(+) = a.c1;# 2)SELECT *FROM t1 a, t2 bWHERE b.c1 = a.c1(+)1번은 t1을 기준으로 t2를 아우터 조인하고, 2번은 t2를 기준으로 t1을 아우터 조인한다. 1번이 데이터의 논리적 흐름에 부합한다. 아우터 조인의 경우 아우터 기준을 FROM 절에 먼저 기술하는 편이 바람직하다.11.2.2 WHERE 절WHERE 절도 데이터의 논리적 흐름에 따라 작성해야 한다. FROM 절에 첫 번째로 기술된 테이블의 일반 조건을 기술한다. FROM 절에 기술된 테이블의 순서에 따라 조인 조건과 일반 조건의 순서로 조건을 기술한다. 조인 조건은 가능한 PK와 FK 순서대로 기술하고, 먼저 조회된 테이블의 값이 입력되는 형태로 작성한다.SELECT a.ename, b.dnameFROM emp a, dept bWHERE a.job = 'CLERK' -- 일반(a) AND a.sal &gt;= 1000 -- 일반(a) AND b.deptno = a.deptno -- 조인(b = a) AND b.loc = 'DALLAS' -- 일반(b)# WHERE 조건이 데이터의 논리적 흐름에 부합SELECT *FROM t1 a, t2 b, t3 cWHERE b.c1 = a.c1AND c.c2 = b.c1;# 논리적 흐름에 부합하지 않음SELECT *FROM t1 a, t2 b, t3 cWHERE b.c1 = a.c1AND c.c2 = a.c1; -- 이부분11.3 ANSI 조인 문법11.3.1 NATURAL JOIN 절이름이 같은 열로 테이블을 등가 조인한다. SELECT * FROM t1 NATURAL JOIN t2;11.3.2 USING 절지정한 열로 테이블을 등가 조인한다. SELECT * FROM t1 JOIN t2 USING(c1);11.3.3 CROSS JOIN 절카티션 곱을 생성한다. SELECT * FROM t1 a CROSS JOIN t2 b11.3.4 INNER JOIN 절이너 조인을 수행한다. ON 절에 조인 조건을 기술한다. SELECT * FROM t1 a INNER JOIN t2 b ON b.c1 = a.c1; INNER 키워드는 생략할 수 있다.11.3.5 OUTER JOIN 절아우터 조인을 수행한다. 아우터 기준에 따라 LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN을 사용할 수 있다. ON절에 아우터 기준의 일반 조건을 기술하면 일반 조건과 무관하게 아우터를 반환하고, 일반 조건에 해당하는 행만 아우터 조인한다.WHERE 절에 아우터 기준이 아닌 테이블의 일반 조건을 기술하면 아우터 조인이 이너 조인으로 변경된다.ANSI 조인 문법과 오라클 조인문법 : 256p11.4 파티션 아우터 조인파티션 아우터 조인은 QUERY PARTITION 절을 사용한다.SELECT *FROM t1 aLEFT OUTER JOIN t2 b PARTITION BY (b.c1)ON b.c1 = a.c1;11.5 활용 예제259~282p 조인 조건 : 조인 조건은 관계의 속성과 관련이 있다. 주로 비교 조건과 BETWEEN 조건을 사용하지만 다른 유형의 조건을 사용할 수도 있다. 조인 범위 : 조인 범위는 관계의 옵셔널리티와 관련이 있다. 조인 기준이 아닌 테이블에 대해 필수 관계면 이너 조인, 선택 관계면 아우터 조인으로 조인해야 조인 기준이 모두 반환된다. 조인 차수 : 조인 차수는 관계의 카디널리티와 관련이 있다. 테이블의 관계 차수가 1:1이면, 조인 차수도 1:1이다. 기술 순서 : 조인조건, 조인 범위, 조인 차수 모두와 관련이 있다. 카티션 곱 : 카티션 곱이 발생하면 행이 M * N개로 늘러나기 때문에 행 복제로 부르기도 한다. 셀프 조인 : 셀프 조인은 동일한 테이블을 조인하는 것을 말한다. 예) 순환관계, 누적합 등 범위 조인 : 범위 조인은 범위 속성을 가진 테이블의 조인이다. 선택 조인 : 선택 조인은 서브타입이나 다중 관계를 가진 테이블을 조인할 때 사용할 수 있다. 파티션 아우터 조인 : 누락된 기간 값을 채울 수 있다." }, { "title": "10. GROUP BY 절과 HAVING 절", "url": "/posts/10.Group-by-%EC%A0%88%EA%B3%BC-having-%EC%A0%88/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2023-02-02 23:09:07 +0900", "snippet": "GROUP BY 절은 행 그룹을 생성하고, HAVING 절은 조회할 행 그룹을 선택한다. GROUP BY 절은 WHERE 절 다음에 기술하며, WHERE 절이 수행된 후 수행된다.10.1 GROUP BY 절SELECT SUM(sal) AS c1FROM empWHERE sal &gt; 2000GROUP BY ();GROUP BY 절을 기술하지 않거나, GROUP BY 절에 NULL이나 ()을 기술하면 전체 행이 하나의 행 그룹으로 처리된다.SELECT deptno, SUM(sal) AS salFROM empWHERE sal &gt; 2000GROUP BY deptno;SELECT deptno, SUM(sal) AS salFROM empWHERE sal &gt; 2000GROUP BY deptno, job;SELECT deptnoFROM empWHERE sal &gt; 2000GROUP BY deptnoORDER BY SUM(sal);GROUP BY 절을 사용한 쿼리는 SELECT 절과 ORDER BY 절에 GROUP BY 절의 표현식이나 집계 함수를 사용한 표현식만 기술할 수 있다.# deptno별 sal의 합계에 대한 평균값 집계SELECT AVG(SUM(sal) AS c1FROM empWHERE sal &gt; 2000GROUP BY deptno;# deptno가 10이나 20인 행을 1020행 그룹, 나머지 행을 3040 행 그룹으로 sal의 합계 값을 집계SELECT CASE WHEN deptno IN (10, 20) THEN 1020 ELSE 3040 END AS deptno, SUM(sal) AS salFROM empGROUP BY CASE WHEN deptno IN (10, 20) THEN 1020 ELSE 3040 END;10.2 GROUP BY 절의 확장 기능10.2.1 ROLLUPROLLUP은 지정한 표현식의 계층별 소계와 총계를 집계한다. ROLLUP(a) ==&gt; (a),() ROLLUP(a, b) ==&gt; (a, b), (a), () ROLLUP(a, b, c) ==&gt; (a,b,c), (a,b), (a), ()SELECT deptno, COUNT(*) AS c1FROM empWHERE sal &gt; 2000GROUP BY ROLLUP (deptno)ORDER BY 1;DEPTNO C1______ __ 10 2 20 3 30 1 610.2.2 CUBECUBE는 지정한 표현식의 모든 조합을 집계한다. CUBE(a) ==&gt; (a), () CUBE(a, b) ==&gt; (a, b), (a), (b), () CUBE(a, b, c) ==&gt; (a, b, c), (a, b), (a, c), (b, c), (a), (b), (c), ()SELECT deptno, COUNT(*) AS c1FROM empWHERE sal &gt; 2000GROUP BY CUBE(deptno)ORDER BY 1;DEPTNO C1______ __ 10 2 20 3 30 1 610.2.3 GROUPING SETSGROUPING SETS은 지정한 행 그룹으로 행을 집계한다. 행 그룹으로 ROLLUP과 CUBE를 사용할 수도 있다. GROUPING SET(a, b) ==&gt; (a), (b) GROUPING SET((a, b), a, ()) ==&gt; (a, b), (a), () GROUPING SET(a, ROLLUP, (b)) ==&gt; (a), (b), () GROUPING SET(a, ROLLUP, (b, c)) ==&gt; (a), (b, c), (b), () GROUPING SET(a, b, ROLLUP, (c)) ==&gt; (a), (b), (c), ()SELECT deptno, job, COUNT(*) AS c1FROM empWHERE sal &gt; 2000GROUP BY GROUPING SETs (deptno, job)ORDER BY 1, 2;DEPTNO JOB C1______ _________ __ 10 2 20 3 30 1 ANALYST 2 MANAGER 2 PERSIDENT 1SELECT deptno, job, COUNT(*) AS c1FROM empWHERE sal &gt; 2000GROUP BY GROUPING SETs (deptno, ROLLUP, job)ORDER BY 1, 2;DEPTNO JOB C1______ _________ __ 10 2 20 3 30 1 ANALYST 2 MANAGER 2 PERSIDENT 1 610.2.4 조합 열조합 열은 하나의 단위로 처리되는 열의 조합이다. ROLLUP((a, b)) ==&gt; (a, b), () ROLLUP(a,(b, c)) ==&gt; (a, b, c), (a), () ROLLUP((a,b), c) ==&gt; (a, b, c), (a, b), ()10.2.5 연결 그룹연결 그룹을 사용하면 행 그룹을 간결하게 작성할 수 있다. a, ROLLUP, (b) ==&gt; (a, b), (a) a, ROLLUP, (b, c) ==&gt; (a, b, c), (a, b), (a) a, ROLLUP, (b), ROLLUP (c) ==&gt; (a, b, c), (a, b), (a, c), (a) GROUPING SETS(a, b), GROUPING SETS(c, d) ==&gt; (a, c), (a, d), (b, c), (b, d)10.2.6 관련 함수GROUPING 함수GROUPING은 expr이 행 그룹에 포함되면 0, 포함되지 않으면 1을 반환한다.SELECT deptno, job, COUNT(*) AS c1 , GROUPING(deptno) AS g1, GROUPING(job) AS g2FROM empWHERE sal &gt; 2000GROUP BY ROLLUP (deptno, job)ORDER BY 1, 2;GROUPING_ID 함수GROUPING_ID는 GROUPING 함수의 결과 값을 연결한 값의 비트 벡터에 해당하는 숫자 값을 반환한다.GROUP_ID 함수GROUP_ID는 중복되지 않은 행 그룹은 0, 중복된 행 그룹은 1을 반환한다.10.3 HAVING 절HAVING 절을 사용하면 조회할 행 그룹을 선택할 수 있다. (WHERE 절과 유사하게 동작한다.) WHERE 절은 GROUP BY 절보다 먼저 수행되기 때문에 집계 함수를 사용하면 에러가 발생한다. 이때 HAVING 절을 사용하면 에러가 발생하지 않는다. (GROUP BY 절 없이도 사용가능하다.)SELECT SUM(sal) AS sal FROM emp HAVING SUM(sal) &gt; 2000;HAVING 절은 SELECT 절보다 먼저 수행되고, SELECT 절에 기술되지 않는 집계 함수를 사용해도 무방하다.# 집계 후 HAVING 절에서 행 그룹 전체를 제외(비효율적임)SELECT deptno, SUM(sal) AS salFROM empGROUP BY deptnoHAVING deptno &lt;&gt; 30ORDER BY 1;# WHERE 절에서 집계 대상이 아닌 행 제외(바람직)SELECT deptno, SUM(sal) AS salFROM empWHERE deptno &lt;&gt; 30GROUP BY deptnoORDER BY 1;HAVING절에서 GROUP_ID 함수를 사용하면 중복된 행 그룹을 제외할 수 있다." }, { "title": "19. JPA 잠금 기법", "url": "/posts/19.JPA-%EC%9E%A0%EA%B8%88-%EA%B8%B0%EB%B2%95/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2023-01-30 21:08:21 +0900", "snippet": "01. 동시 접근과 잠금[동시 접근을 올바르게 처리하지 않을 대 발생하는 데이터 불일치 문제]위 그림을 보면 인출과 입금 이후에 실제 잔고는 800원이어야 하는데 남은 잔고는 500원이 된다.이렇게 동시성 접근 문제를 막기 위한 가장 쉬운 방법은 DB 트랜잭션 격리 수준을 높이는 것이다. 단, 트랜잭션 격리 수준을 높이면 동시 사용자가 많은 온라인 서비스에서는 전체 성능을 떨어뜨리기 때문에 동시 접근을 처리하기 위한 올바른 방법이 아니다.트랜잭션 격리 수준을 높이는 대신 동시 접근을 처리할 수 있는 다른 방법으로는 잠금 기법 을 사용하는 것이다. 잠금 기법에는 먼저 데이터에 접근한 트랜잭션이 우선순위를 갖는 선점 잠금 방식과 먼저 데이터를 수정한 트랜잭션이 우선순위를 갖는 비선점 잠금 방식이 존재한다.02. 선점 잠금(pessimistic lock)선점 잠금은 먼저 데이터에 접근한 트랜잭션이 우선순위를 갖는 잠금 방식이다.선점 잠금을 사용하면 서로 다른 두 트랜잭션이 동시에 동일 데이터에 접근하여 수정하는 것을 방지할 수 있고, 동시 접근으로 데이터 일관성이 깨지는 것을 막아준다. JPA에서 선점 잠금을 사용하려면 find() 메서드의 세 번째 인자로 LockModeType.PESSIMISTIC_WRITE를 값으로 전달하면 된다.public class DepositService { public int deposit(String accountNum, int value) { EntityManager em = EMF.currentEntityManager(); try { em.getTransaction().begin(); //LockModeType.PESSIMISTIC_WRITE를 사용하면 하이버네이트는 DBMS의 잠금 쿼리를 사용해서 행 단위 잠금을 사용한다. Account account = em.find(Account.class, accountNum, LockModeType.PESSIMISTIC_WRITE); if(account == null) { throw new AccountNotFoundException(); } account.deposit(value); em.getTransacion().commit(); return account.Balance(); }catch(Exception ex) { em.getTransacion().rollback(); throw ex; }finally { em.close(); } }}한 트랜잭션이 식별자가 “02-001”인 Account 엔티티를 LockModeType.PESSIMISTIC_WRITE를 이용해서 구현했다면, 이 트랜잭션의 잠금이 해제될 때까지 “02-001” Account 엔티티에 대한 선점 잠금을 구하지 못하고 블록킹 된다.선점 잠금을 사용할 때 주의사항으로는 교착 상태 에 빠질 수 있다는 것이다. 선점 잠금으로 인해 트랜잭션이 교착상태에 빠지는 상황을 방지하려면 짐금 대기 시간을 힌트로 설정하면 된다.Map&lt;String, Object&gt; hints = new HashMap&lt;&gt;();//DBMS에 따라 잠금 대기시간지 적용되지 않을 수 있다.hints.put(\"javax.persistence.lock.timeout\", 1000);Account account = em.find(Account.class, accountNum, LockModeType.PESSIMISTIC_WRITE, hints);03. 비선점 잠금(optimistic lock)비선점 잠금 방식은 먼저 데이터를 수정한 트랜잭션이 우선순위를 갖는다.비선점 잠금 방식을 사용하려면 버전 값을 저장할 컬럼이 필요하다. JPA는 엔티티를 조회할 때 버전 값을 함께 조회한다. 그리고 엔티티의 데이터가 바뀌면 update 쿼리의 비교 조건으로 식별자뿐만 아니라 데이터를 조회한 시점의 버전 값도 함께 사용한다. 그리고 update 쿼리에서 버전을 1 증가 시킨다. 만약 다른 트랜잭션에서 먼저 데이터를 수정하게 되면 버전 값이 일치하지 않아 데이터 수정에 실패한다.[JPA에서 비선점 잠금을 사용하기 위한 방법] 버전 값을 저장할 컬럼 추가(컬럼 타입은 숫자나 시간 타입) 버전 컬럼과 매핑할 속성에 @Version 애노테이션을 설정@Entitypublic class Customer { @Id private String id; @Version private Integer ver; @Column(name=\"secret_code\") private String secretCode;}@Version으로 설정할 수 있는 타입으로는 int, Integer, short, Short, long, Long, Timestamp이다.em.getTransaction().begin();//select c.id, c.secret_cpde, c.ver from Customer c where c.id=?Customer customer = em.find(Customer.class, id);customer.changeSecretCode(newSecCode);//update Customer set secret_code=?, ver=?, where id=? and ver=?em.getTransacion().commit();만약 update 쿼리 실행 결과로 변경된 행의 개수가 0이면, 트랜잭션을 롤백하고 익셉션을 발생한다.객체를 생성할 때 버전을 지정하지 않아 ver가 null이면 하이버네이트는 버전 값으로 0을 사용한다." }, { "title": "18. 기타 매핑 설정", "url": "/posts/18.-%EA%B8%B0%ED%83%80-%EB%A7%A4%ED%95%91-%EC%84%A4%EC%A0%95/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2023-01-26 22:42:21 +0900", "snippet": "01. 상속 매핑예) 시스템에 일반 이슈, 방문 예약, 민원의 세 가지 이슈 종류가 있다고 할 때 이 이슈 타입을 상속을 이용해서 설계할 수 있다.JPA에서는 같은 클래스 계층을 테이블과 매핑하는 다음과 같은 방식을 지원한다.1-1. 클래스 계층을 한 개 테이블로 매핑상속 관계의 엔티티를 매핑하는 가장 쉬운 방법은 클래스 계층을 한 테이블에 매핑하는 것이다. 한 테이블에 계층의 전체 클래스를 매핑하려면 매핑 대상 클래스를 식별할 수 있어야 한다. 대상 클래스를 구분하기 위해 타입 식별 컬럼을 추가로 필요로 한다.@Entity@Table(name=\"issue\")@Inheritance(strategy = InheritanceType.SINGLE_TABLE) //상속 매핑 방식 설정, SINGLE_TABLE : 한 테이블로 상속 계층을 매핑한다.@DiscriminatorColumn(name=\"issue_type\") //타입 식별값을 저장할 컬럼 지정@DiscriminatorValue(\"IS\") //Issue 타입을 위한 식별 값을 지정public class Issue { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; @Temporal(TemporalType.TIMESTAMP) @Column(name=\"issue_date\") private Date issueDate; @Column(name=\"customer_name\") private String customerName; @Column(name=\"customer_cp\") private String customerCp; private String content; private boolean closed;}@Entity@DiscriminatorValue(\"VR\")public class VisitReservation extends Issue { @Column(name=\"assignee_emp_id\") private String assigneeEngineerId; @Temporal(TemporalType.TIMESTAMP) @Column(name=\"schedule_date\") private Date scheduleDate;}@Entity@DiscriminatorValue(\"AP\")public class Appeal extends Issue { private String response;}위 엔티티를 저장하는 save()를 사용하면 @DiscriminatorValue로 지정한 값을 issue_type 컬럼의 값으로 사용한다.단일 객체를 조회할 때는 상속 계층에 있는 타입중 알맞은 타입을 지정해서 조회하면 된다. em.find(Appeal.class, id); 로 하면 where 조건절에 issue_type = ‘AP’가 자동으로 들어간다.1-2. 계층의 클래스마다 테이블로 매핑예) 첨부 파일 정보를 표현하는 모델이 있을 때 처음 요구사항은 고정된 폴더에 파일을 저장하는 방식이였다가 시간이 지나 폴더를 고정하지 않고 파일을 저장할 경로를 지정하는 방식이 추가되었다. 그리고 클라우드에 올린 파일 정보를 추가할 수 있는 방식도 추가되었다.눈여겨볼 점은 하위 클래스에 해당하는 테이블은 상위 클래스에 해당하는 테이블의 주요키를 공유한다는 점이다.@Entity@Table(name=\"attach_file\")@Inheritance(strategy=InheritanceType.JOINED) //JOINED : 계층 클래스마다 테이블을 사용하면 각 테이블을 조인해서 필요한 데이터를 조회public class AttachFile { @Id private String id; private String name; @Column(name=\"upload_date\") @Temporal(TemporalType.TIMESTAMP) private Date uploadDate;}@Entity@Table(name=\"local_file\")public class LocalFile extends AttachFile { private String path;}@Entity@Table(name=\"cloud_file\")public class CloudFile extends AttachFile { private String provider; private String url;}계층마다 테이블을 매핑하기 때문에 엔티티를 저장하면, 엔티티 타입에 따라 매핑된 모든 테이블에 데이터를 나눠서 저장한다. 엔티티를 조회할 때에는 엔티티 타입에 따라 사용하는 쿼리가 달라진다. em.find(Attach.class, \"F001\");로 실행해 보면 attach_file 테이블 뿐만 아니라 local_file 테이블과 cloud_file 테이블을 외부 조인을 이용해서 함께 조회한다.1-3. 객체 생성 가능한 클래스마다 테이블로 매핑이 방법은 계층에서 추상이 아닌 콘크리트 클래스를 별도 테이블로 매핑하는 방식이다. 이 방식의 경우 매핑된 테이블이 상위 타입을 포함한 모든 속성을 포함한다.위 그림에서 최상위의 Member 클래스가 추상 클래스일 때, Member 클래스를 제외한 나머지 클래스는 객체 생성이 가능하다. 나머지 객체 생성한 클래스들은 상속 계층에 속한 모든 속성을 정의하고 있다.@Entity//TABLE_PER_CLASS : 이 설정을 사용하면 클래스 계층에서 객체 생성 가능 클래스마다 테이블을 별도로 매핑한다.@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)public abstract class Memberber { @Id private String id; private String name;}Member 클래스는 추상 클래스이므로 특정 테이블과 매핑되지 않는다.@Entity@Table(name=\"ent_member\")public class EntMember extends Member { @Column(name=\"comp_id\") private String companyId;}이런 방식으로 매핑했을 때 TempMember를 하위 타입으로 갖는 PersonalMember 클래스를 이용해서 조회하면 이 두 테이블을 조회한 결과를 union 연산으로 합한 뒤에 검색 조건을 설정하는 것을 알 수 있다. TempMember 객체는 PersonalMember 타입에 속하기 때문에 두 타입에 매핑된 테이블을 모두 조회하는 것이다.1-4. 상속 계층과 다형 쿼리@Inheritance 애노테이션을 이용해서 상속 계층을 매핑하면 다형 쿼리를 사용할 수 있다. 다형 쿼리란 상위 타입을 사용해서 엔티티를 조회하는 기능이다.상위 타입으로 조회하면 클래스 계층 매핑 방식에 따라 데이터 조회에 필요한 모든 테이블을 조회한다. 또 해당 타입에 필요한 모든 데이터를 조회하므로 상위 타입으로 조회한 객체를 실제 타입으로 변환할 수 있다.1-5. 세 방식의 장단점 한 테이블로 매핑 : 매핑이 간단하고, 한 테이블만 조회하므로 성능이 좋다는 장점이 있다. 단점으로는 하위 클래스에 매핑된 칼럼은 not null일 수 없고, 하위 클래스를 추가하면 테이블을 변경해야 한다. 클래스마다 테이블로 매핑 : 테이블마다 필요한 데이터만 보관하므로 데이터가 정규화된다는 장점이 있고, 외부 조인을 사용하므로 계층도가 복잡해질수록 조회 성능이 떨어진다는 단점이 있다. 객체 생성 가능 클래스마다 별도 테이블 매핑 : 최하위 타입으로 조회하면 조인이 발생하지 않는다는 장점이 있고, 식별자 중복 여부를 테이블 단위로 막을 수 없고, 상위 타입의 속성이 바뀌면 모든 테이블을 변경해야 한다는 단점이 있다.02. AttributeConverter 를 이용한 속성 변환AttributeConverter는 다음과 같은 경우 유용하게 사용할 수 있다. JPA가 지원하지 않는 타입을 매핑할 때 두 개 이상 속성을 갖는 밸류 타입을 한 개 컬럼에 매핑할 때예) JPA 표준에 따르면 InetAddress 타입과 VARCHAR 사이의 매핑은 지원하지 않는다. 이때 사용할 수 있는 것이 AttributeConverter 이다.AttributeConverter은 자바 타입과 DB 타입간의 변환을 처리 해주어 이를 사용하면 지원하지 않는 자바 타입을 매핑할 수 있다.[메서드] public Y convertToDatabaseColumn(X attribute) : 엔티티의 X 타입 속성을 Y 타입의 DB 데이터로 변환 public X convertToEntityAttribute(Y dbData) : Y 타입으로 읽은 DB 데이터를 엔티티의 X 타입 속성으로 변환@Converter //해당 클래스가 AttributeConverter를 구현한 클래스임을 지정public class InetAddressConverter implements AttributeConverter&lt;InetAddress, String&gt; { //...}@Entity@Table(name=\"auth_log\")public class AuthLog { //... //변환에 사용할 AttributeConverter 구현 클래스를 지정 @Convert(converter=InetAddressConverter.class) private InetAddress ipAddress; //...}410~412p03. @MappedSuperclass와 매핑 설정 공유업무 시스템을 만들다 보면 데이터 생성 시점, 생성자, 접근 IP정보를 저장하기 위한 용도로 각 도메인의 이같은 속성을 공통으로 추가해야할 때가 있다. @MappedSuperclass를 이용해서 공통 설정을 위한 상위 클래스를 생성할 수 있다.@MappedSuperclasspublic class DomainModel { @Id private String id; @Column(name=\"crt_dtm\") private Date CreationDate; @Column(name=\"crt_empid\") private String creationEmpId; @Column(name=\"crt_ip\") private String creationIp; //...}@MappedSuperclass로 설정한 클래스는 테이블과 매핑할 대상은 아니다. 매핑 대상은 하위 클래스 이다. 하위클래스에서 상위 클래스에 설정한 매핑 정보를 그대로 물려 받아 사용한다.@Entitypublic class Category extends DomainModel { private String name; //...}그리고 @MappedSuperclass로 설정한 클래스의 설정 값을 재정의하고 싶은 경우 @AttributeOverride를 클래스에 설정한다.@Entity//name 속성으로 재정의할 속성을 지정, column 속성으로 매핑할 컬럼 지정@AttributeOverride(name=\"creationIp\", column=@Column(name=\"creation_ip\"))public class Category extends DomianModel { //...}" }, { "title": "17. 스프링데이터 JPA 소개", "url": "/posts/17.%EC%8A%A4%ED%94%84%EB%A7%81%EB%8D%B0%EC%9D%B4%ED%84%B0-JPA-%EC%86%8C%EA%B0%9C/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2023-01-22 21:58:21 +0900", "snippet": "01. 중복 코드@Repositorypublic class UserRepository{ @PersistenceContext private EntityManager; public User find(String email) { return em.find(User.class, email); } public void save(User user) { em.persist(user); } //...}@Repositorypublic class HotelRepository{ @PersistenceContext private EntityManager; public Hotel find(String id) { return em.find(Hotel.class, id); } public void save(Hotel hotel) { em.persist(hotel); } //...}UserRepository와 HotelRepository는 다루는 엔티티만 다를 뿐 EntityManager를 이용해서 엔티티를 찾고, 저장하는 코드는 온전히 동일한 구조를 갖는다.이런 중복 코드 작업을 없앨 수 있는 좋은 방법이 있는데, 그것이 바로 스프링 데이터 JPA를 사용하는 것이다.02. 스프링 데이터 JPA 소개스프링 데이터 JPA를 이용해서 많은 중복 코드 작성을 줄일 수 있다.public interface UserRepositoty extends Repository&lt;User, String&gt; { User findOne(String email); User save(User user); void delete(User user); @Query(\"select u from User u order by u.name\") List&lt;User&gt; findAll();}Repository는 스프링 데이터 JPA가 제공하는 인터페이스이다. 이 인터페이스만 상속받아 정해진 규칙에 맞게 메서드를 작성하면 된다. 따라서 EntityManager를 이용한 코드를 중복해서 구현할 필요가 없다.스프링 데이터 JPA는 Repository를 상속한 인터페이스를 검색하고, 그 인터페이스를 알맞게 구현한 객체를 스프링 빈으로 등록한다.//UserRepositoty를 사용할 코드는 다음 처럼 의존성 주입을 통해 UserRepositoty 빈을 주입받아 사용한다.@Servicepublic class UserService { @Autowired public void setUserRepositoty(UserRepositoty userRepositoty) { this.userRepositoty = userRepositoty; }}03. 스프링 데이터 JPA 설정스프링 데이터 JPA를 사용하려면 프로젝트에 spring-data-jpa 모듈에 대한 의존을 추가하면 된다. (369~372p)04. 리포지토리 인터페이스 메서드 작성 규칙4-1. 리포지토리 인터페이스 작성스프링 데이터 JPA를 위한 리포지토리 인터페이스를 작성하는 것이 첫 번째다. 스프링 데이터 JPA는 spring-data-jpa, spring-data-common 모듈을 사용하는데 이 두 모듈이 제공하는 리포지토리 타입 중 하나를 상속받은 인터페이스를 작성하면 된다.//T는 엔티티 타입을 의미하고, ID는 식별자 타입을 의미한다.public interface Repository&lt;T, ID extends Serializable&gt; {}public interface UserRepositoty extends Repository&lt;User, String&gt; {...}//Repository 인터페이스를 상속 받는 대신 애노테이션을 사용해도 된다.@RepositoryDefinition(domainClass=Hotel.class, idClass = String.class)public interface HotelRepository {...}4-2. 기본 메서드public interface UserRepository extends Repository&lt;User, String&gt; { //식별자를 인자로 받는다. User findOne(String email); //save 메서드는 해당 엔티티의 상태에 따라 persist()나 merge()를 사용해서 엔티티를 저장한다. User save(User user); void delete(User user);}스프링 데이터 JPA는 새로운 엔티티인지 여부를 판단할 때 다음과 같은 규칙을 사용한다. 해당 엔티티 클래스가 Persistable 인터페이스를 구현했다면 isNew() 메서드로 새로운 엔티티인지 검사한다. 엔티티에 @Version 속성이 있다면 버전 속성이 null인 경우 새 엔티티로 간주한다. 식별자가 기본 데이터 타입이 아니면 식별자가 null인 경우 새 엔티티로 간주한다. 숫자 타입이면 값이 0인 경우 새 엔티티로 간주힌디.4-3. 조회 메서드 기본 규칙public interface UserRepository { // 모든 엔티티 조회 - List, Iterator, Collection 타입을 사용해도 된다. List&lt;User&gt; findAll(); // 특정 속성을 이용해서 엔티티 검색 - findBy속성 List&lt;User&gt; findByEmail(String email); // And 조건을 이용해서 두 개 이상의 속성에 대한 비교 연산을 조합할 수 있다. List&lt;User&gt; findByEmailAndName(String email, String name); // 속성명 뒤에 비교 연산자를 위한 키워드 추가도 가능하다. 예) 지정한 날짜 이후인지 비교 List&lt;User&gt; findByCreateDateAfter(Date date);}public interface HotelRepository { // 중첩 프로퍼티를 지정할 수도 있다. where h.address.zipcode = ? List&lt;Hotle&gt; findByAddressZipcode(String zipcode);}스프링 데이터 JPA는 메서드 이름을 대문자 기준으로 구성 요소를 판단한다. find(select), By 절은 where 조건이 시작됨을 뜻함, By 키워드 뒤에 오는 속성은 엔티티의 속성을 뜻한다.4-4. 힌 개 결과 조회단일 결과를 조회하고 싶다면 콜렉션 대신 조회 타입을 리턴 타입으로 사용하면 된다.User findByName(String name);4-5. 정렬 지원 메서드정렬을 하기 위한 방버으로는 메서드 이름에 OrderBy 키워드 사용 Sort 타입을 파라미터로 전달하기List&lt;User&gt; findByNameStartingWithOrderByNameAsc(String name);List&lt;User&gt; findAll(Sort sort);Sort sort = new Sort( new Sort.Order(Sort.Direction.ASC, \"name\"), new Sort.Order(Sort.Direction.DESC, \"createDate\"));List&lt;User&gt; users = userRepository.findAll(sort);4-6 페이징 처리Pageable 인터페이스를 사용하면 범위를 지정해서 일부만 조회할 수 있다.List&lt;User&gt; findByNameStartingWith(String name, Pageable pageable);PageRequest pageRequest = new PageRequest(0, 10);List&lt;User&gt; user = userRepository.findByNameStartingWith(\"최\", pageRequest);Sort sort = new Sort(\"name\");PageRequest pageRequest = new PageRequest(1, 10, sort);List&lt;User&gt; users = userRepository.findByNameStartingWith(\"최\", pageRequest);리턴타입으로 Page를 사용할 수도 있다. Page 인터페이스는 다음과 같은 메서드를 제공한다. int getTotalPages() - 전체 페이지 개수 long getTotalElements() - 전체 개수 int getNumber() - 현재 페이지 번호 int getSize() - 한 페이지의 크기 int getNumberOfElements() - 현재 페이지의 항목 개수 List&lt;T&gt; getContent() - 현재 페이지의 조회 결과 boolean hasContent - 조회 결과가 존재하면 true boolean isFirst() - 현재 페이지가 첫 번째이면 true boolean isLast() - 현재 페이지가 마지막이면 true boolean hasNext() - 다음 페이지가 존재하면 true boolean hasPrevious() - 이전 페이지가 존재하면 true Sort getSort() - 현재 결과를 구할때 사용한 Sort 객체 Pageable nextPageable() - 다음 페이지를 구하기 위한 Pageable 객체를 리턴 Pageable previousPageable() - 이전 페이지를 구하기 위한 Pageable 객체를 리턴4-7 결과 개수 제한단순히 첫 번째 결과나 처음 몇 개 결과만 조회하고 싶다면 First 키워드나 Top 키워드를 사용한 메서드를 사용할 수 있다. findFirst / findTop findFirstN / findTopN4-8. JPQL 사용하기메서드 이름이 다소 복잡하거나 길다면 실행할 JPQL을 직접 지정할 수도 있다. @Query 애노테이션을 메서드에 적용하고 실행할 JPQL을 지정하면 된다.05. Specification을 이용한 검색 조건 조합크리테리아를 사용하면 검색 조건인 Predicate를 조합할 수 있다. 검색 조건을 생성하고, 조합하기 위해서 CriteriaBuilder가 필요한데 이는 EntityManager가 필요하다.스프링 데이터 JPA는 EntityManager 없이 검색 조건을 조합할 수 있는 기능을 제공하는데 이 기능이 바로 Specification이다. 이것을 사용하기 위한 방법으로는 리포지토리 인터페이스에 Specification을 입력받는 메서드를 정의 검색 조건을 생성하는 Specification을 구현하기 검색 조건을 조합한 Specification을 객체로 검색하기Paga&lt;Hotel&gt; findAll(Specification&lt;Hotel&gt; spec, Pageable pageable);public class HotelSpecs{ public static Specification&lt;Hotel&gt; bestGrade() { return new Specification&lt;Hotel&gt;(){ @Override public Predicate toPredicate( Root&lt;Hotel&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) { return cb.equal(root.get(\"grade\"), Grade.STAR7); } }; } public static Specification&lt;Hotel&gt; nameLike(String name) { return(root, query, cb) -&gt; cb.like(root.get(\"name\"), \"%\" + name + \"%\"); }}Sort sort = new Sort(new Sort.Order(Sort.Direction.DESC, \"name\"));Pageable pageable = new PageRequest(0,3,sort);//grade 속성이 STAR7dls Hotel을 name 기준으로 내림차순으로 정렬한 결과를 구한다.Specification&lt;Hotel&gt; bestGradeSpec = HotelSprecs.bestGrade();Page&lt;Hotel&gt; hotels = hotelRepository.findAll(bestGradeSpec, pageable);두 조건을 조합하고 싶다면 Specifications (이름 뒤에 s가 붙은)를 사용한다.Specifications&lt;Hotel&gt; specs = Specifications.where(HotelSpecs.bestGrade());specs = specs.and(HotelSpecs.nameLike(\"구로\"));Page&lt;Hotel&gt; hotels = hotelRepository.findAll(specs, pageable);Specifications 타입은 Specification 타입을 상속받고 있어서 and(), or(), not() 메서드에 Specifications 객체도 전달할 수 있다. and(), or(), not() 메서드는 항상 새로운 Specifications 객체를 생성한다.검색 조건이 없는 경우에는 빈 Specification을 전달하면 된다.06. 스프링 데이터가 제공하는 인터페이스 상속받기findOne, save, findAll과 같은 메서드는 다수의 리포지토리에서 제공하는 메서드이다. 이것은 각 리포지토리 인터페이스에서 동일한 형태의 메서드를 갖게 된다. 스프링 데이터 JPA를 사용하면 구현 코드뿐만 아니라 중복된 메서드마저 작성하지 않아도 된다.387~390ppublic interface HotelRepository extends CrudRepository&lt;Hotel, String&gt; { //CrudRepository가 이름처럼 저장, 조회, 삭제와 관련된 기본 기능을 제공하므로 필요한 메서드만 정의하면 된다.}//PagingAndSortingRepository 인터페이스는 페이징과 정렬 기능을 추가한 메서드를 제공한다.public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt; extends CrudRepository&lt;T, ID&gt; { //...}//JPA와 관련된 추가 기능을 제공한다.public interface JpaRepository&lt;T, ID extends Serializable&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; { //... //파라미터로 전달받은 엔티티 객체를 한 쿼리로 삭제 void deleteInBatch(Iterable&lt;T&gt; entities); //모든 엔티티를 조회한 뒤 deleteInBatch()로 삭제하는 방식으로 동작 (잘못 사용하면 성능에 심각한 문제가 발생한다.) void deleteAllInBatch();}//Specification을 사용하는 메서드가 필요하다면 JpaSpecificationExecutor 인터페이스를 사용한다.public interace JpaSpecificationExecutor&lt;T&gt; { //...}JpaRepository와 JpaSpecificationExecutor의 두 인터페이스를 상속하면 리포지토리에 필요한 대부분의 메서드를 제공하고 있어 findBy와 같이 추가로 필요한 메서드만 작성하면 된다." }, { "title": "15. 추가 쿼리 기능", "url": "/posts/15.%EC%B6%94%EA%B0%80-%EC%BF%BC%EB%A6%AC-%EA%B8%B0%EB%8A%A5/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2023-01-19 21:33:21 +0900", "snippet": "01. 수정 쿼리와 삭제 쿼리1-1. 수정 쿼리Query query = em.createQuery(\"update Hotel h set h.name = :newName where h.name = :oldName\");JPQL의 update 쿼리를 사용하려면 트랜잭션 범위 안에서 실행해야 한다. 트랜잭션 범위 안에서 실행하지 않을 경우 exception이 발생한다.그리고 update 쿼리를 생성할 때는 결과 타입을 받지 않는 createQuery()를 사용한다. 따라서 TypedQuery가 아닌 Query 타입을 사용한다.//크리테리아를 이용한 수정 쿼리CriteriaUpdate&lt;Hotel&gt; cu = cb.createCriteriaUpdate(Hotel.class);Root&lt;Hotel&gt; h = cu.from(Hotel.class);cu.set(h.get(\"name\"), \"베스트웨스턴 구로\");cu.where(cb.equal(h.get(\"name\"), \"베스트웨스턴 구로호텔\"));Query query = em.createQuery(cu);query.executeUpdate(); //실제 쿼리 실행em.getTransacion().commit();1-2. 삭제 쿼리//SQL에는 from 절이 있지만 JPQL은 from 절이 없다.Query query = em.createQuery(\"delete Hotel h set h.name = :name\");//크리테리아를 사용한 삭제 쿼리CriteriaDelete&lt;Hotel&gt; cd = cb.createCriteriaDelete(Hotel.class);Root&lt;Hotel&gt; h = cd.from(Hotel.class);cd.where(cb.equal(h.get(\"name\"), \"베스트웨스턴 구로호텔\"));Query query = em.createQuery(cd);query.executeUpdate();1-3. 수정/삭제 쿼리와 영속 컨텍스트수정, 삭제 쿼리를 실행할 때 주의할 점은 영속 컨텍스트에 보관된 객체는 이 쿼리에 영향을 받지 않는다는 점이다.Query query = em.createQuery( \"update Hotel h set h.name = :newName where h.id = :id\");query.setParameter(\"newName\", \"베스트웨스턴 구로\");query.setParameter(\"id\", \"H100-01\");query.executeUpdate();hotel.getName(); //베스트웨스턴 구로호텔(변경전)위 코드를 보면 hotel.getName()시에 update 쿼리로 수정한 “베스트웨스턴 구로”가 아닌 수정전 결과 값이 나온다. 즉 update 쿼리를 이용해서 수정한 결과는 영속 컨텍스트에 반영되지 않는 것이다. 영속 컨텍스트에 보관된 엔티티에 수정 쿼리의 결과를 반영하고 싶다면, refresh()메서드를 사용해서 DB에서 데이터를 읽어와 엔티티에 반영하면 된다. (단, delete 쿼리로 삭제한 엔티티에 대해 refresh()를 실행하면 exception이 발생한다.)02. 네이티브 쿼리모든 DB 작업을 JPA 쿼리로 처리할 수는 없다. DBMS에 특화된 기능이 필요하면 SQL을 사용해야 한다. 이럴 때 필요한 것이 네이티브 쿼리이다.2-1. Object 배열로 결과를 조회하는 네이티브 쿼리Query query = em.createNativeQuery( \"select id, name, grade from hotel\" + \"where grade = :grade order by id asc limit :first, :max\");query.setParameter(\"grade\", \"STAR4\");query.setParameter(\"first\", 0);query.setParameter(\"max\", 1);List&lt;Objet[]&gt; resultList = query.getResultList();for(Object[] row: resultList) { String id = (String) row[0]; String name = (String) row[2]; String grade = (String) row[3];}2-2. 엔티티 매핑으로 결과 조회Query query = em.createNativeQuery( \"select id, name, grade, zipcode, address1, address2\" + \"from hote where grade = :grade orderby id asc\", Hotel.class);query.setParameter(\"grade\", \"STAR4\");List&lt;Hotel&gt; resultList = query.getResultList();for(Hotel hotel : resultList) { System.out.printf(\"%s %s %s \\n\", hotel.getId(), hotel.getName(), hotel.getGrade());}if(resultList.size() &gt; 0){ Hotel hotel = resultList.get(0); hotel.changeAddress(new Address(\"12345\", \"서울\", \"구로\");}2-3. 네임드 네이티브 쿼리 사용xml을 이용한 설정 346~348p03. 하이버네이트 @Subselect@Subselect는 쿼리 결과를 @Entity로 매핑할 수 있는 유용한 기능이다.@Entity@Immutable@Subselect(\"select s.id, s.name, d.hours_op as hoursOperation\" + \"from sight s, sight_detail d\" + \"where s.id = d.sight_id\")@Synchronize({\"Sight\", \"sight_detail\"})public class BestSughtSummary { @Id private Long id; private String name; private String hoursOperation; //...}@Immutable, @Subselect, @Synchronize는 하이버네이트 전용 애노테이션으로 이 태그를 사용하면 테이블이 아닌 쿼리 결과를 @Entity로 매핑할 수 있다. @Subselect - 조회(select) 쿼리를 값으로 갖는다. 이 쿼리의 결과를 매핑할 테이블처럼 사용한다. @Immutable - 엔티티의 변경 내역을 DB에 반영하지 않고 무시한다. @Synchronize - 하이버네이트는 쿼리를 실행하기 전에 지정한 테이블과 관련된 변경이 있다면 엔티티 변경 내역을 플러시 한다." }, { "title": "14. 크리테리아 API를 이용한 쿼리", "url": "/posts/14.%ED%81%AC%EB%A6%AC%ED%85%8C%EB%A6%AC%EC%95%84-API%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%BF%BC%EB%A6%AC/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2023-01-14 23:20:50 +0900", "snippet": "01. 크리테리아 API크리테리아 API는 자바 코드를 이용해서 작성하는 쿼리이다.CritetiaBuilder cb = em.getCriteriaBuilder();CriteriaQuery&lt;User&gt; cq = cb.createQuery(User.class);Root&lt;User&gt; root = cq.from(User.class);cq.select(root);cq.where(cb.equal(root.get(\"name\"), \"고길동\");TypedQuert&lt;User&gt; query = em.createQuery(cq);List&lt;User&gt; users = query.getResultLiat();JPQL보다 복잡하지만 사용하는 이유는 크리테리아가 가진 장점이 있기 때문이다. 다양한 조건을 조합하기 쉽다. 문자열과 달리 자바 코드를 사용하기 때문에 타입에 안전한 쿼리를 만들 수 있다. 자바 코드이기 때문에 IDE의 코드 자동 완성 기능을 활용할 수 있다.02. 크리테리아 기본 코드//1) EntityManager에서 CritetiaBuilder 구한다.CritetiaBuilder cb = em.getCriteriaBuilder();//2) User 타입의 CriteriaQuery 생성 =&gt; createQuery 메서드의 인자는 조회 결과 타입을 지정CriteriaQuery&lt;User&gt; cq = cb.createQuery(User.class);//3) from UserRoot&lt;User&gt; root = cq.from(User.class);//4) root를 조회 결과로 사용 =&gt; select root from User rootcq.select(root);//5) CriteriaQuery로부터 Query 생성TypedQuert&lt;User&gt; query = em.createQuery(cq);03. 검색 조건 지정//CritetiaBuilder는 Predicate를 생성하는 메서드를 제공한다. =&gt; cb.equal(비교할 대상, 비교할 값)Predicate namePredicate = cb.equal(root.get(\"name\").\"고길동\");cq.where(namePredicate);04. 속성 경로 구하기root.get(“name”)은 User 엔티티의 name 속성에 해당하는 Path 객체를 구한다. Path 인터페이스는 엔티티나 밸류, 콜렉션 등의 속성의 경로를 표현한다.public interface Path&lt;X&gt; extends Expression&lt;X&gt; {...}//타입 파라미터 X는 Path 인터페이스가 나타내는 대상 속성의 타입이다. 따라서 다음과 같이 속성 타입을 지정해서 Path를 수할 수 있다.Path&lt;Stirng&gt; name = root.get(\"name\");이름 대신에 정적 메타모델을 사용해서 속성을 지정할 수도 있다. 정적 메타모델은 엔티티의 속성에 대한 메타 정보를 담고 있는 클래스로서 다음과 같이 생겼다.@StaticMetamodel(User.class)public class User_ { public static SingularAttribute&lt;User, String&gt; email; public static SingularAttribute&lt;User, String&gt; name; //...}//정적 메타모델을 사용하면 속성 경ㅇ로를 구할 때 정적 메타모델의 필드를 사용할 수 있다.Predicate namePredicate = cb.equal(root.get(User_.name), \"고길동\");정적 메타모델을 사용하면 타입이나 이름을 오류 없이 알맞은 Path 타입으로 구할 수 있기 때문에 컴파일 시점에 타입에 안전한 코드를 작성할 수 있다는 장점이 있다.4-1. 중첩 속성 경로 구하기1:1 연관관계를 맺고 있는 경우 연관된 엔티티의 속성을 검색조건으로 사용해서 검색하고 싶은 경우 중첩해서 속성을 구하면 된다.Predicate namePredicate = cb.equal(root.get(\"user\").get(\"name\"), \"고길동\");05. CriteriaQuery와 CriteriaBuilder 구분 CriteriaQuery - select, from, where, groupBy, having, order by 등 쿼리의 절을 생성 CriteriaBuilder - 각 절의 구성 요소를 생성CriteriaBuilder는 where 절에서 사용할 Preidcate 구성 요소를 생성하거나, 정렬 순서를 표현하는 Order 구성요소를 생성할 때 등에 사용할 수 있다.06. Expression과 하위 타입Path 등 크리테리아를 이용해서 쿼리를 구성할 때 사용하는 타입은 Expression 인터페이스를 상속하고 있다.CriteriaQuery와 CriteriaBuilder의 많은 메서드가 Expression 타입의 파라미터를 갖는다. 따라서 Expression이 올 수 있는 곳에는 이들 타입을 알맞게 사용할 수 있다.07. 비교 연산자7-1. 기본 비교 연산자각 메서드의 첫 번째 파라미터는 비교 대상을 지정한다. 주요 비교 대상은 엔티티의 속성이므로 주로 Root.get()을 이용해서 비교할 대상을 구한다.Predicate namePredicate = cb.equal(root.get(\"name\"), \"고길동\");Predicate nameEmaileq = cb.equal(root.get(\"name\"), root.get(\"email\"));7-2. in 비교 연산자비교 대상이 특정 값 중 하나인지 비교할 때에는 in() 메서드를 사용한다. 이 메서드는 CriteriaBuilder.In 타입 객체를 리턴한다.CriteriaBuilder.In&lt;Object&gt; nameIn = cb.in(root.get(\"name\"));// value() 메서드를 이용해서 in 연산자로 비교할 값 목록을 지정한다.nameIn.value(\"고길동\").value(\"홍길동\");cq.where(nameIn);// where root.name in ('고길동', '홍길동');In을 Object로 받으면 String 타입뿐 아니라 Integer, Double과 같이 모든 타입의 값을 전달받을 수 있다. 자바는 타입 추론을 지원하므로 In&lt;String&gt; 타입 변수를 사용해서 String 타입으로 제한할 수 있다.//get() 메서드에 타입 파라미터를 지정할 수도 있다.CriteriaBuilder&lt;Object&gt; nameIn = cb.in(root.&lt;String&gt;get(\"name\")) .value(\"고길동\") .value(0); //error7-3. 콜렉션 비교JPQL의 member of에 해당하는 Predicate를 생성할 때는 isMember() 메서드를 사용한다. isMember(E elem, Expression&lt;C&gt; collection) isMember(Expression&lt;E&gt; elem, Expression&lt;C&gt; collection)Player player = em.find(Player.class, \"P1\");CriteriaBuilder cb = em.getCriteriaBuilder();CriteriaQuery&lt;Team&gt; cq = cb.createQuery(Team.class);Root&lt;Team&gt; t = cq.from(Team.class);cq.where( cb.isMember(player, t.get(\"players\")));cq.select(t)select t from Team t where :player member of t.players특정 콜렉션에 속해 있지 않은지 비교할 때에는 isNotMember() 메서드를 사용한다. 콜렉션이 비어있는지 확인할 때는 isEmpty()를 그와 반대는 isNotEmpty()를 사용한다.7-4. exists, all, anyexists, all, any 쿼리는 서브쿼리를 사용하기 때문에 다소 복잡하다.JPQL은 exists를 위해 서브쿼리를 사용하고있다. 크리테리아도 동일하게 서브쿼리를 사용해서 exists 비교 조건을 생성한다.CriteriaQuery&lt;Hotel&gt; cq = cb.createQuery(Hotel.class);//select h from Hotel hRoot&lt;Hotel&gt; h = cq.from(Hotel.class);cq.select(h);//exists()에 사용할 서브쿼리 생성Subquery&lt;Review&gt; subquery = cq.subquery(Review.class);Root&lt;Review&gt; r = subquery.from(Review.class);subquery.select(r).where(cb.equal(r.get(\"hotel\"), h);//exists(서브쿼리) 조건Predicate existsPredicate = cb.exists(subquery);//not(existsPredicate), 즉 not exists(서브쿼리)cq.where(cb.not(existsPredicate));7-5. and와 or로 조건 조합JPQL처럼 and와 or처럼 크리테리아도 여러 조건을 조합할 수 있다.Predicate emailPredicate = cb.equal(ubs.get(\"email\"), \"aaa@aaa.com\");Predicate titlePredicate = cb.equal(ubs.get(\"title\"), \"%랜드\");Predicate andPredicate = cb.and(emailPredicate, titlePredicate);cq.where(andPredicate);크리테리아를 사용해서 쿼리를 구성하게 되면 문자열로 작성할 때 발생할 수 있는 쿼리 오류 문제가 거의 발생하지 않는다.또 conjunction() 메서드를 사용하면 if문도 줄일 수 있다. 이 메서드는 조건이 존재하지 않으면 무조건 true인 조건을 생성한다. 예) 조건이 null이라면 전체 목록을 조회하는 쿼리인 1=1 쿼리를 생성한다.복잡한 if-else 블록을 줄이는 또 다른 방법으로는 Predicate 리스트를 만들어 AND로 연결할 조건을 추가하는 방법이다.List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();if(email != null) predicates.add(cb.equal(ubs.get(\"email\"), email);if(keyword != null) predicates.add(cb.like(ubs.get(\"title\"), \"%\"+keyword));cq.where(predicates.toArray(new Predicate[predicates.size()]));위 코드처럼 Predicate 배열을 where() 메서드에 전달하면 각 조건을 AND로 조합한다.08. 정렬 순서 지정하기정렬순서는 CriteriaBuilder의 asc() 또는 desc()로 Order를 생성한뒤 CriteriaQuery orderBy()에 Order를 전달해서 정렬 순서를 지정한다.CriteriaQuery&lt;Player&gt; cq = cb.createQuery(Player.class);Root&lt;Player&gt; p = cq.from(Player.class);cq.select(p);Order teamIdOrder = cb.asc(p.get(\"team\").get(\"id\"));Order nameOrder = cb.asc(p.get(\"name\"));cq.orderBy(teamIdOrder, nameOrder);09. 지정 칼럼 조회9-1. 한 개 속성 조회하기크리테리아에 엔티티가 아닌 특정 컬럼을 조회하고 싶다면 select()에 해당 경로를 전달하면 된다.CriteriaQuery&lt;String&gt; cq = cb.createQuery(String.class);Root&lt;Player&gt; p = cq.from(Player.class);cq.select(p.get(\"id\")); // select 메서드로 단일 속성 선택TypedQuery&lt;String&gt; query = em.createQuery(cq);List&lt;String&gt; rows = query.getResultList();9-2. 배열로 조회하기엔티티가 아닌 두 개 이상의 속성을 배열로 조회하는 방법은 select() 메서드 대신 multiselect() 메서드를 사용하고 선택 타입으로 Object[]을 사용한다는 것이다.CriteriaQuery&lt;Object[]&gt; cq = cb.createQuery(Object[].class);Root&lt;Player&gt; p = cq.from(Player.class);cq.multiselect(p.get(\"id\"), p.get(\"name\"), p.get(\"salary\"));TypedQuery&lt;Object[]&gt; query = em.createQuery(cq);List&lt;Object[]&gt; rows = query.getResultList();for(Object[] row: rows) { String id = (String) row[0]; String name = (String) row[1]; int salary = (int)row[2]; //...}9-3. 특정 객체로 조회하기select new jpastart.common.IdName(p.id, p.name) from Player p 처럼 특정 객체로 조회하고 싶다면 construct() 메서드를 사용해서 클래스 생성자와 전달할 대상을 지정한다.CriteriaBuilder cb = em.getCriteriaBuilder();CriteriaQuery&lt;IdName&gt; cq = cb.createQuery(IdName.class);Root&lt;Player&gt; p = cq.from(Player.class);//클래스 타입과 생성자에 전달할 대상 목록을 지정한다.cq.select(cb.construct(IdName.class, p.get(\"id\"), p.get(\"name\")));TypedQuery&lt;IdName&gt; query = em.createQuery(cq);List&lt;IdName&gt; rows = query.getResultList();public class IdName{ private String id; private String name; public IdName(String id, String name) { this.id = id; this.name = name; } //...}10. 조인크리테리아도 JPQL과 마찬가지로 다음과 같은 방식을 이용해서 조인을 처리할 수 있다. 자동 조인 - 연관된 엔티티의 속성에 접근할 때 발생,CriteriaQuery&lt;Player&gt; cq = cb.createQuery(Player.class);Root&lt;Player&gt; p = cq.from(Player.class);cq.select(p);Predicate teamNamePredicate = cb.equal(p.get(\"team\").get(\"name\"), \"팀\");cq.where(teamNamePredicate);cq.orderBy(p.get(\"name\"))); 명시적 조인CriteriaBuilder cb = em.getCriteriaBuilder();CriteriaQuery&lt;Player&gt; cq = cb.createQuery(Player.class);Root&lt;Player&gt; p = cq.from(Player.class);cq.select(p);Join&lt;Player, Team&gt; t = p.join(\"team\"); //Player의 \"team\" 속성에 대한 조인을 표현하는 Join 객체를 리턴한다.cq.where(cb.equal(t.get(\"name\"), \"팀\"));cq.orderBy(cb.asc(p.get(\"name\")));//외부조인Team team = em.find(Team.class, \"T1\");//....Join&lt;Player, Team&gt; t = p.join(\"team\", JoinType.LEFT);t.on(cb.equal(t, team)); where 절에서 조인CriteriaBuilder cb = em.getCriteriaBuilder();CriteriaQuery&lt;Object[]&gt; cq = cb.createQuery(Object[].class);//조인할 Root 객체를 두개 생성Root&lt;User&gt; u = cq.from(User.class);Root&lt;UserBestSight&gt; s = cq.from(UserBestSight.class);//조인할 속성끼리 값이 같은지 비교cq.where(cb.equal(u.get(\"email\"), s.get(\"email\")));cq.multiselect(u, s);cq.orderBy(cb.asc(u.get(\"name\")));11. 집합 함수CriteriaBulider는 집합 함수에 대응하는 메서드를 제공한다.Expression&lt;N&gt;의 N은 Number 또는 그 하위 타입이다.CriteriaQuery&lt;Object[]&gt; cq = cb.createQuery(Object[].class);Root&lt;Player&gt; p = cq.from(Player.class);cq.multiselect( cb.count(p), cb.sum(p.get(\"salary\")). cb.avg(p.get(\"salary\")), cb.max(p.get(\"salary\")), cb.min(p.get(\"salary\")));TypedQuery&lt;Object[]&gt; query = em.createQuery(cq);Object[] aggvalues = query.getSingleReuslt();12. group by와 havingCriteriaQuery&lt;Object[]&gt; cq = cb.createQuery(Object[].class);Root&lt;Player&gt; p = cq.from(Player.class);cq.groupBy(p.get(\"team\").get(\"id\"));cq.multiselct(p.get(\"team\").get(\"id\"), cb.count(p), cb.avg(p.get(\"salary\")), cb.max(p.get(\"salary\")), cb.min(p.get(\"salary\")));TypedQuery&lt;Object[]&gt; query = em.createQuery(cq);// select t count(p), avg(p.salary) from Player p left join p.team t group by tCriteriaQuery&lt;Object[]&gt; cq = cb.createQuery(Object[].class);Root&lt;Player&gt; p = cq.from(Player.class);Join&lt;Player, Team&gt; t = p.join(\"team\", joinType.LEFT);cq.groupBy(t);cq.multiselct(cb.count(p), cb.avg(p.get(\"salary\")));TypedQuery&lt;Object[]&gt; query = em.createQuery(cq);// select t, count(p), avg(p.salary) from Team t left join t.player p group by t having count(p) &gt; 1CriteriaQuery&lt;Object[]&gt; cq = cb.createQuery(Object[].class);Root&lt;Team&gt; t = cq.from(Team.class);Join&lt;Team, Player&gt; p = t.join(\"players\", joinType.LEFT);cq.groupBy(t);cq.having(cb.gt(cb.count(p), 1)); //count(p) &gt; 1cq.multiselct(cb.count(p), cb.avg(p.get(\"salary\")));groupBy() 메서드는 두 개가 있다. 1)가변인자를 사용하는 메서드, 2)List를 사용하는 메서드이다. 따라서 두 개 이상의 기준을 사용해서 그룹을 나누고 싶다면 groupBy() 메서드에 인자를 두 개 이상 전달하거나 그룹 대상을 담고있는 List를 인자로 주면 된다.13. 함수와 연산자13-1. 문자열 함수 concat() - 두 개 문자열을 연결한다. substring() - 문자열의 시작위치에서 지정한 길이에 해당하는 문자열을 구한다. trim() - 문자열의 공백 문자를 제거한다. lower() - 문자열을 소문자로 변경한다. upper() - 문자열을 대문자로 변경한다. length() - 문자열의 길이를 구한다. locate() - 문자열이 포함된 위치를 구한다.13-2. 수학 함수 abs() - 절대 값을 구한다. sqr() - 제곱근을 구한다. mod() - x를 y로 나눈 나머지를 구한다. neg() - 수식의 부호를 바꾼다. sum() - x에 y를 더한다. diff() - x에서 y를 뺀다. prod() - x와 y를 곱한다. quot() - x를 y로 나눈다.13-3. 날짜 함수 currentDate() - 현재 시간을 Date 타입으로 구한다. currentTimestamp() - 현재 시간을 Timestamp 타입으로 구한다. currentTime() - 현재 시간을 Time 타입으로 구한다.13-4. 콜렉션 관련 함수 size() - 콜렉션의 크기를 구한다.14. fetch 조인1:1이나 N+1 연관에 대해 fetch 조인을 사용하고 싶다면 join() 메서드 대신 fetch() 메서드를 사용하면 된다.CriteriaBuilder cb = em.getCriteriaBuilder();CriteriaQuery&lt;MembershipCard&gt; cq = cb.createQuery(MembershipCard.class);Root&lt;MembershipCard&gt; mc = cq.from(MembershipCard.class);Fetch&lt;MembershipCard, User&gt; u = mc.fetch(\"owner\", JoinType.LEFT);cq.select(mc);//select mc from MembershipCard mc left join fetch mc.owner u15. 정적 메타모델@Entity@Table(name=\"hotel_review\")public class Review{ //... @Temporal(TemporalType.TIMESTAMP) @Column(name=\"rating_data\") private Date ratingDate;}//특정 기간에 작성한 Review를 검색하고자 할 때,CriteriaQuery&lt;Review&gt; cq = cb.createQuery(Review.class);Root&lt;Review&gt; r = cq.from(Review.class);cq.select(r);Date fromDate = ...Date roDate = ....Predicate betweenPredicate = cb.between(r.get(\"ratingDate\"), fromDate, toDate);//파라미터로 Date 타입만 들어올 수 있게 다음과 같이 할 수 있다.//Predicate betweenPredicate = cb.between(r.&lt;Date&gt;get(\"ratingDate\"), fromDate, toDate);cq.where(betweenPredicate);타입 파라미터를 통해 값 타입을 제한하면 컴파일러를 통해 타입을 검사할 수 있어 잘못된 값 타입으로 인해 발생하는 오류를 줄일 수 있다. 하지만 다소 코드가 길어지고 보기 어려워진다.이때 정적 메타모델을 사용하면 타입도 안전하고, 코드도 덜 복잡해진다.@StaticMetamodel(Review.class)public class Review_{ public static SingulerAttribute&lt;Review, String&gt; id; public static SingulerAttribute&lt;Review, Date&gt; ratingDate;}Predicate betweenPredicate = cb.between(r.get(Review_.ratingDate), fromDate, toDate);15-1. 정적 메타모델 클래스 구성336~337p" }, { "title": "13. JPQL", "url": "/posts/13.JPQL/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2023-01-10 20:39:44 +0900", "snippet": "01. JPQLJPQL은 JPA에서 사용하는 쿼리 언어이다. SQL의 쿼리 언어와 매우 유사하나 테이블과 칼럼 이름 대신 매핑한 엔티티 이름과 속성 이름을 사용한다는 점이 차이가 있다.//엔티티 이름과 엔티티 속성을 사용한다.selectfrom Review rwhere r.hotel =:hotelorder by r.id desc02. JPQL 기본 코드select 별칭 from 엔티티이름 as 별칭 엔티티 이름 뒤에는 별칭이 오는데 이 별칭은 엔티티를 참조할 때 사용한다. 별칭은 필수이며 as는 생략할 수 있다.TypedQuery&lt;User&gt; query = em.createQuery(\"select u from User u\", User.class);List&lt;User&gt; users = query.getResultList(); // SQL을 실행하고 그 결과를 리턴for(User u : users) { //...}//TypedQuery와 달리 타입을 지정하지 않는다.Query query = em.createQuery(\"select u from User u\");List users = query.getResultList();for(Object o : users) { User user = (User)o;}2.1 order by를 이용한 정렬select p from Player p order by p.name ascselect p from Player p order by p.name descselect p from Player p order by p.team.id, p.name03. 검색 조건 지정TypedQuery&lt;Player&gt; query = em.createQuery( \"select p from Player p where p.team.id = \"T1\", Player.class);List&lt;Player&gt; players = query.getResultList();//인텍스 기반 파라미터를 이용해 입력 파라미터를 지정TypedQuery&lt;Player&gt; query2 = em.createQuery( \"select p from Player p where p.team.id = ? and p.salary = ? , Player.class);query2.setParameter(0, \"T1\");query2.setParameter(1, 1000);List&lt;Player&gt; players2 = query2.getResultList();//파라미터 값으로 엔티티 지정//엔티티를 이용하면 연관에 대한 직접 비교를 할 수 있다.Team team = em.find(Team.class, \"T1\");TypedQuery&lt;Player&gt; query3 = em.createQuery( \"select p from Player p where p.team.id = :team and p.salary &gt; :minSalary , Player.class);query3.setParameter(\"team\", team);query3.setParameter(\"minSalary\", 1000);List&lt;Player&gt; players3 = query3.getResultList();3-1. 비교 연산자 = :값이 같은지 비교 &lt;&gt; : 값이 다른지 비교 &lt;, &gt;,&gt;=,&lt;,&lt;= : 값의 크기 비교 between : 값이 사이에 포함되는지 비교 in, not in : 지정한 목록에 값이 존재하는지 또는 존재하지 않는지 비교 like, not like : 지정한 문자열을 포함하는지 검사 is null, is not null : 값이 null인지 또는 null이 아닌지3-2. 콜렉션 비교특정 엔티티나 값이 콜렉션에 속해있는지 검사하고 싶다면 member of 연산자나 not member of 연산자를 사용하면 된다.Player player = em.find(Player.class, \"P1\");TypedQuery&lt;Team&gt; query = em.createQuery( \"select t from Team t where :player member of t.players order by t.name\", Team.class);query.setParameter(\"player\", player);List&lt;Team&gt; teams = query.getResultList();# 실제 query 실행select t.id, t.namefrom Teamwhere ? in (select p.player_id from Player p where t.id = p.team.id)order by t.nameis empty, is not empty를 사용하면 엔티티 콜렉션에 대해 콜렉션이 비어있는지 비교할 수 있다.3-3. exists, all, any특정 값이 존재하는지 검사하고 싶을 때 exists, all, any 중 하나를 사용한다. exists : 특정 값이 존재 할 때 not exists : 특정 값이 존재하지 않을 때 all : 서브 쿼리 결과가 조건을 모두 충족하는지 검사 any : 서브 쿼리 결과가 조건을 충족하는 대상중 하나 이상 충족하는지 검사04. 페이징 처리Query, TypedQuery를 사용하면 간단하게 페이징 처리를 할 수 있다.TypedQuery&lt;Review&gt; query = em.createQuery(\"select r from Review r where r.hotel.id = :hotelId order by r.id desc\", Review.class);query.setParameter(\"hotelId\", \"H-001\");query.setFirstResult(10); //조회할 첫 번째 결과의 위치 지정query.setMaxResults(5); //조회할 최대 갯수List&lt;Review&gt; reivews = query.getResultLiat();05. 지정 속성 조회5-1. 배열로 조회하기TypedQuery&lt;Object[]&gt; query = em.createQuery(\"select p.id, p.name, p.salary from Player p\", Object[].class);List&lt;Object[]&gt; rows = query.getResultList();for(Object[] row: rows) { String id = (String)row[0]; String name = (String)row[1]; int salary = (int)row[2]; //...}select 절에서 선택한 대상이 두 개 이상일 때 결과 타입은 Object 배열이다. Object 배열은 순서대로 값을 보관하기 때문에 배열의 각 데이터를 사용할 때는 위 코드처럼 해당 타입으로 알맞게 변환해주어야 한다.5-2. 특정 객체로 조회하기public class IdName{ private String id; private String name; public IdName(String id, String name) { this.id = id; this.name = name; } public String getId() { return id; } public String getName() { return name; }}//생성자를 이용해서 결과 객체를 생성한다.TypedQuery&lt;IdName&gt; query = em.createQuery(\"select new com.common.IdName(p.id, p.name) from Player p\", IdName.class);List&lt;IdName&gt; rows = query.getResultList();06. 한 개 행 조회결과가 여러개인 경우 getResultList() 메서드를 이용했다. 결과가 정확하게 한 행인 경우에는 getResultList() 대신에 getSingleResult() 메서드를 사용할 수 있다.TypedQuery&lt;Long&gt; query = em.createQuery(\"select count(p) from Player p\", Long.class);Long count = query.getSingleResult();getSingleResult() 사용시 주의할 점은 결과가 반드시 1개여야 한다는 것이다. 결과가 없거나 두 개 이상일 경우 exception이 발생한다.07. 조인JPQL에서는 다음의 세 가지 방식으로 조인을 수행할 수 있다. 자동 조인 명시적 조인 where 절에서 조인//1. 자동 조인 : Player와 Team은 서로 다른 테이블에 매핑되어 있어 하이버네이트는 두 테이블을 조인한 쿼리를 실행한다.select pfrom Player pwhere p.team.name = :teamName//2. 명시적 조인select pfrom Player pjoin p.team twhere t.name = :teamName//3. where 절에서 조인select u, sfrom User u, UserBestSight swhere u.email = s.emailorder by u.name08. 집합 함수 함수 리턴타입 설명 count long 갯수 max, min 해당 속성 타입 최대값/최소값 avg Double 평균 sum 속성타입에 따라 다름 합계 09. group by 와 havingSQL의 group by와 동일하게 JPQL의 group by는 지정항 속성을 기준으로 그룹을 나눈다. group by에 having을 사용해서 조건을 지정할 수 있다.//소속 선수가 1명보다 많은 Team의 선수 수와 평균 연봉을 구하는 JPQLselect t, count(p), avg(p.salary)from Team t left join t.players pgroup by thaving count(p) &gt; 110. 함수와 연산자10.1 문자열 함수 CONCAT - 두 개 이상의 문자열을 연결 SUBSTRING - 문자열에서 시작 위치부터 지정한 길의에 해당하는 문자열을 구함 TRIM - 문자열의 공백을 제거 LOWER - 문자열을 소문자로 변환 UPPER - 문자열을 대문자로 변환 LENGTH - 문자열의 길이를 구함 LOCATE - 식1 문자열에 식2가 포함된 위치를 구함10.2 수학 함수와 연산자 ABS - 절대값 SQRT - 제곱근 MOD - 수식1을 수식2로 나눈 나머지 그외 - 덧셈, 뺄셈, 곱셈, 나눗셈 등10.3 날짜 시간 함수 CURRENT_DATE - 현재 시간을 DATE 타입으로 구함 CURRENT_TIME - 현재 시간을 TIME 타입으로 구함 CURRENT_TIMESTAMP - 현재 시간을 TIMESTAMP 타입으로 구함10.4 콜렉션 관련 함수 SIZE - 콜렉션의 크기를 구함 INDEX - 해당 리스트의 인덱스 값 비교시 사용11. 네임드 쿼리JPQL이 길어지면 문저열을 위한 큰따옴표와 문자열 연결을 위한 + 연산자 때문에 코드가 복잡해진다. 이럴때 필요한 것이 네임드 쿼리로 XML 파일에 네임드 쿼리를 등록하여 사용한다.&lt;!-- ....... --&gt;&lt;named-query name=\"Hotel.noReview\"&gt; &lt;query&gt; select h from Hotel h where not exists (select r from Review r where r.hotel = h) order by h.name &lt;/query&gt;&lt;/named-query&gt;xml 파일로 네임드 쿼리를 등록했다면 persistence.xml 파일에 해당 파일을 등록해야 한다.Player player = em.find(Player.class, \"P1\");TypedQuery&lt;Hotel&gt; query = em.createNamedQuery(\"Hotel.noReview, Hotel.class);//...네임드 쿼리를 작성하는 또 다른 방법으로는 @NamedQuery 애노테이션을 이용하는 것이다. 이 애너테이션은 엔티티에 설정할 수 있으며 @Embeddedable과 같이 엔티티 이외의 타입에는 설정할 수 없다.@Entity@NamedQueries({ @NamedQuery(name=\"Hotel.all\", query=\"select h from Hotel h\"), @NamedQuery(name=\"Hotel.findById\", query=\"select h from Hotel h where h.id=:id)})public class Hotel { //....}12. N+1 쿼리와 조회 전략N+1 쿼리는 연관이나 콜렉션과 관련되어 있다.@Entity@Table(name=\"membership_card\")public class MembershipCard { @Id @Column(name=\"card_number\") private String number; @OneToOne @JoinColumn(name=\"user_email\") private User owner;}@OneToOne 애노테이션의 fetch 속성의 기본값은 EAGER이다. 따라서 MembershipCard를 검색하면 조인 쿼리를 이용해서 연관된 엔티티의 데이터도 함께 조회한다.하지만 JQPL에서는 즉시 로딩 설정을 해도 조인을 사용하지 않는다.TypedQuery&lt;MembershipCard&gt; query = em.createQuery( \"select mc from MembershipCard mc\", MembershipCard.class);List&lt;MembershipCard&gt; cards = query.getResultList();query.getResultList()를 실행하면 MembershipCard 엔티티를 조회하기 위한 select 쿼리를 실행한 뒤 User 엔티티 로딩을 위한 쿼리를 N번 실행한다. 이유는 User와 연관을 갖는 MembershipCard 엔티티가 N개이기 때문이다. 그리고 getResultList() 메서드 실행시에도 User 엔티티 쿼리를 실행하는데 즉시로딩으로 설정되어있기 때문이다.이렇게 N개의 연관된 객체를 로딩하기 위한 N번의 쿼리를 더 실행하는 것을 N+1 쿼리 문제라고 한다.12-1 1:1, N:1 연관에 대한 fetch 조인N+1 쿼리 문제를 처리하는 가장 쉬운 방법은 JPQL에서 fetch 조인을 사용하는 것이다.//join 뒤에 fetch 키워드를 사용하면 조인한 대상을 함께 로딩해서 생성한다.(즉 N번 실행하지 않는다.)TypedQuery&lt;MembershipCard&gt; query = em.createQuery( \"select mc from MembershipCard me left join fetch mc.owner u\", MembershipCard.class);List&lt;MembershipCard&gt; cards = query.getResultList();fetch를 사용하지 않고 join만 사용하는 경우에도 조인 쿼리를 사용하지만 연관된 엔티티를 생성하지는 않는다. 그렇게 되면 연관된 데이터를 함께 로딩했음에도 연관 엔티티를 로딩하기 위한 쿼리를 추가로 실행한다.12-2 콜렉션 연관에 대한 fetch 조인TypedQuery&lt;Team&gt; query = em.createQuery( \"select t from Team t join fetch t.players p\", Team.class);List&lt;Team&gt; teams = query.getResultList();# 실행되는 쿼리는 다음과 같다.select t.id, p.player_id, t.name, p.name, p.salary, p.team_idfrom Team tinner join Player p on t.id = p.team_id위 그림과 같은 결과가 나온다고 했을 때 쿼리 결과의 행 수는 5개이다. 그런데 JPQL에서 select 로 조회한 대상은 Team이므로 getResultList()로 구한 List는 5개의 Team 객체를 리턴한다.TypedQuery&lt;Team&gt; query = em.createQuery( \"select t from Team t join fetch t.players p\", Team.class);List&lt;Team&gt; teams = query.getResultList();Team tema1 = teams.get(0);Team team1b = teams.get(1);Set&lt;Player&gt; players = team1.getPlayers(); //fetch 조인으로 이미 로딩fetcj 조인으로 연관된 players 콜렉션을 로딩했으므로 players에 대한 연관 설정이 지연 로딩이여도 team1.getPlayers()를 처음 실행하는 시점에 Player를 로딩하기 위한 쿼리를 실행하지 않는다.//인덱스가 1인 결과로부터 1개의 결과로 한정query.setFirstResult(1);query.setMaxResults(1);setFirstResult나 setMaxResults를 설정하면 메모리에서 연산을 처리한다. 따라서 결과가 인덱스의 1번인 [T1]이 나와야할 것 같지만 [T2]가 나온다.콜렉션에 대해 fetch 조인을 사용하게 되면 일단 쿼리를 실행해서 엔티티를 메모리에 모두 로딩한다. 그런 뒤 중복을 제거한다. 즉 [T1, T1, T2, T2, T2]를 메모리에 로딩한 뒤에 같은 식별자를 갖는 엔티티의 중복을 제거해서 [T1, T2]로 만든다.이들을 함께 사용하게 되면 쿼리에 해당하는 데이터를 모두 로딩해서 메모리에서 페이징 처리를 하기 때문에 대량 데이터에는 사용하면 안된다. (OutOfMemory가 발생할 수 있음)" }, { "title": "12. 연관 잘 쓰기", "url": "/posts/12.%EC%97%B0%EA%B4%80-%EC%9E%98-%EC%93%B0%EA%B8%B0/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2023-01-05 20:24:23 +0900", "snippet": "01. 연관의 복잡성1.1 로딩 설정의 어려움Order order = em.find(Order.class, orderId);List&lt;OrderLine&gt; orderLines = order.getOrderLines();for(OrderLine ol: orderLines) { Content content = ol.getProduct().getContent(); System.out.println(content.getTitle() + \"\" + content.getCast());}위 코드는 Order 엔티티에서 시작해서 OrderLine, Product, Content를 접근하고 있다. 모든 연관을 즉시 로딩으로 설정했다면 Order를 로딩하는 시점에 OrderLine, Product, Content를 로딩하기 위한 쿼리도 함께 실행할 것이다. 그렇다고 해서 지연 로딩과 즉시 로딩을 적절하게 섞어 쓰기도 쉽지 않다. 상황에 따라 필요한 연관 객체가 다를 수 있어 특정 연관을 지연 로딩이나 즉시 로딩으로 한정할 수 없다.1.2 편리한 객체 탐색과 높은 결합도모든 엔티티를 연관으로 연결하면 객체 탐색을 통해 쉽게 원하는 객체에 접근할 수 있다.//객체들이 연관으로 연결되어 있으면 연관된 객체의 데이터를 쉽게 변경할 수 있다.public class Order { private User orderer; public void changeShippingAddress(Address newShippingAddress, boolean useUserAddress) { this.shippingAddress = newShippingAddress; if(useUserAddress) { //연관된 User 데이터를 변경 orderer.setAddress(newShippingAddress); } }}이렇게 한 엔티티에서 다른 엔티티의 상태를 변경하는 기능을 실행하면 엔티티가 서로 강하게 엮이게 되면서 서로 수정을 어렵게 만드는 원인이 될 수 있다.02. 연관 범위 한정과 식별자를 통한 간접 참조엔티티 간의 참조가 많아질수록 한 엔티티의 기능을 변경할 때 여러 엔티티를 함께 수정해야 할 가능성이 커진다. 이는 코드 변경을 어렵게 만드는 원인이 될 수 있다. 그러기 위해 다음의 방법을 적용한다. 연관 범위를 도메인을 기준으로 한정 도메인을 넘어서는 엔티티 간에는 식별자를 이용한 간접 참조위 그림을 보면 특정 영역 안에서는 연관을 이용해 직접 참조를 유지했지만, 영역을 벗어나는 관계에 대해서는 식별자를 이용해서 간접적으로 참조했다.식별자를 통한 간접 참조 방식을 사용하면 식별자로 연관된 엔티티를 검색하는 과정이 추가되기 때문에 다소 코드가 길어진다. 하지만 앞선 로딩 설정의 어려움과 엔티티 간의 결합도 증가를 완화할 수 있다.03. 상태 변경 관련 기능과 조회 관련 기능연관을 한정해서 사용하면 설정이나 코드 복잡도가 줄어드는 장점이 있다. 하지만 데이터 조회시 여러 엔티티를 직접 조회해야 하는 불편함도 있다. 이런 불편함을 해결하는 방법으로 상태를 변경하는 기능과 조회하는 기능을 분래해서 생각하는 것이다.데이터를 새로 생성하거나 수정하거나 삭제하는 상태 변경 기능은 한두 개의 엔티티만 로딩하기 때문에 식별자로 연관된 엔티티를 직접 로딩해야하는 불편함이 크지 않다.조회 관련 기느은 한 개 이상의 엔티티를 함께 조회하는 경우가 많다. 이렇게 여러 엔티티의 데이터를 조합해야 하는 조회 기능은 조회 기능애 맞는 모델을 따로 구현하는 것을 고려해보자//예) 주문 목록 &gt; Order + OrderLine + Productpublic class OrderSummary { private String id; private String ordererName; private Timestamp orderDate; private int totalAmounts; private String firstProductName; private String firstProductId; //...}도메인이 커질수록 한 개의 모델로 상태 변경 기능과 조회 기능을 구현하기 어려워진다. 로딩 방식의 문제뿐 아니라 상태 변경 시점과 조회 시점에 필요한 데이터가 다르기 때문이다.조회 시점에 필요한 데이터와 변경 시점에 다루는 데이터의 차이가 클수록 조회 전용 모델을 별도로 만들 것을 고려해 봐야 한다.04. 식별자를 공유하는 1:1 연관이 엔티티와 밸류 관계인지 확인모든 테이블을 엔티티로 매핑하는 것은 모델의 의미를 약화시킬 수 있다. 한 도메인 영역세 속하면서 식별자 공유 방식으로 1:1 연관을 맺는 두 엔티티가 동일한 라이프사이클을 갖게 된다. 그렇게 되면 이 관계는 두 엔티티의 1:1 연관이 아닌 엔티티와 밸류 관계일 가능성이 크다.//1:1 연관@Entitypublic class Appeal { @Id private String id; @OneToOne(mapperdBy=\"appeal\") private AppealStatus status;}@Entity@Table(name=\"appeal_atatus\")public class AppealStatus { @Id priavate String id; @OneToOne @primaryKeyColumn priavate Appeal appeal; //...}//엔티티-밸류 관계@EntitySecondaryTable( name=\"appeal_status\", pkJoinColumns=@PrimaryKeyJoinColumn( name=\"id\", referencedColumnName=\"id\"))public class Appeal{ @Id private String id; @Embedded private AppealStatus status; //...}@Embeddedablepublic class AppealStatus{ //...}05. 엔티티 콜렉션 연관과 주의 사항5-1. 1:N 연관보다 N:1 연관 우선1:N 연관을 사용할 때 주의할 점은 N에 해당하는 부분을 실제 기능에서 어떤 식으로 사용하는지 알아야 한다는 점이다.@Entitypublic class Hotel { //... public List&lt;Review&gt; getLatestReview(int cnt) { return reviews.stream().limit(cnt).collect(Collectors.toList()); }}위 예에서 최근 리뷰 n개를 제공하는 메서드를 제공한다. 그런데 이 코드에서 호텔과 관련된 리뷰의 개수가 만 개면 reviews는 만 개의 review 객체를 갖게 된다. 필요한 것은 최근에 등록한 n개지만, 만 개를 로딩하게 된다. 따라서 Hotel과 연관된 Review가 많을수록 이 기능은 실행 속도가 느려져서 성능에 문제를 일으킨다.1:N연관에서 콜렉션에 보관된 엔티티를 일부만 사용하는 기능이 있다면 1:N 연관을 사용하면 안 된다. 대신 N:1 연관을 사용해야 한다. N:1 연관을 사용하면 코드는 다소 길어지지만 1:N 연관을 사용할 때 발생하는 성능 관련 문제를 해결할 수 있다.5-2. 엔티티 간 1:N 연관과 밸류 콜렉션엔티티간 1:N 연관으로 보이는 것 중에 실제로는 밸류에 대한 콜렉션 연관인 경우도 있다. 처음 JPA를 사용할 때 자주 접하는 실수는 모든 테이블에 대해 엔티티 클래스를 작성하는 것이다.대표적인 예가 주문과 개별 주문 항목이다. 이 때 주문과 개별 주문 항목은 각각 별도 테이블과 매핑되나 개별 주문 항목은 자신만의 식별자를 갖는 엔티티라기 보다는 주문에 포함된 밸류이다. 따라고 이 둘은 1:N 관계가 아니다.@Entitypublic class Order{ @ElementCollection @CollectionTable( name=\"order_line\", joinColumns=@JoinColumn(name=\"order_id\") @OrderColumn(name=\"idx\")) private List&lt;OrderLine&gt; orderLines = new ArrayList&lt;&gt;(); //...}@Embeddedablepublic class OrderLine { //...}단순히 테이블이 따로 존재한다고 해서 엔티티 간의 1:N 연관으로 매핑하는 것은 옳지 않다. 1:N 연관이 필요하다면 해당 연관이 엔티티 간의 연관인지 밸류 콜렉션인지 검토 해야 한다. 한 도메인 영역에 속하면서 1:N 연관을 맺는 엔티티가 동일한 라이프 사이클을 갖는다면 엔티티 콜렉션이 아닌 밸류 콜렉션이 더 적합하지 않은지 확인하도록 하자5-3. M:N 연관 대체하기 : 연관 엔티티 사용단방향 연관이든 양방향 연관이든 M:N 연관은 구현을 복잡하게 만들기 때문에 최대한 피하는 게 좋다. M:N 연관 엔티티를 사용하는 방법은 조인 테이블을 엔티티로 매핑하는 것이다. 이 방법은 코드가 복잡해지는 것보다 나은 선택이다.//CastMap 클래스의 식별자로 사용하기 위한 castMapId 클래스@Embeddedablepublic class CastMapId implements Serializable { @Column(name=\"performace_id\") private String performanceId; @Column(name=\"person_id\") private String personId; //생성자, getter, equals, hashCode()...}@Entity@Table(name=\"perf_person\")public class CastMap { @Id private CastMapId id; @ManyToOne @JoinColumn(name=\"performance_id\", insetable=false, updatable=false) private Performance performance; @ManyToOne @JoinColumn(name=\"person_id\", insertable=false, updatable=false) private Person person; //생성자, getter...}em.getTransaction().begin();Performance perf = em.find(Performance.class, \"PF002\");Person person = em.find(Person.class, \"P05\");CastMap castMap = new CastMap(perf, person);em.persist(castMap);em.getTransaction().commit();" }, { "title": "11. 영속성 전이", "url": "/posts/11.%EC%98%81%EC%86%8D%EC%84%B1-%EC%A0%84%EC%9D%B4/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2023-01-05 20:24:23 +0900", "snippet": "01. 영속성 전이1:1 단방향 연관의 예를 들면 두 엔티티를 새로 생성한 뒤 저장하려면 EntityManager.persist()를 이용해서 두 엔티티를 모두 저장해야 한다. 이럴 때 영속성 전이를 사용하면 연관된 객체를 손쉽게 함께 저장할 수 있다.영속성 전이는 엔티티의 영속성 상태 변화를 연관된 엔티티에도 함께 적용하는 것이다. 예) 엔티티를 저장할 때 연관된 엔티티도 함께 저장하고, 엔티티를 삭제할 때 연관된 엔티티도 함께 삭제하는 것@Entity@Table(name=\"membership_card\")public class MembershipCard { @Id @Column(name=\"card_number\") private String number; @OneToOne(cascade=CascadeType.PERSIST) //MembershipCard 엔티티를 저장할 때 연관된 owner도 함께 저장한다. @JoinColumn(name=\"user_email\") private User owner; //…..}User owner = new User(\"jvm@asda.com\", \"JVM\", new Date());MembershipCard memberCard = new MembershipCard(\"1234\", owner, new Date());em.persist(memberCard); //연관된 owner도 영속 객체로 추가함[CascadeType] PERSIST - persist() 실행시 연관된 엔티티를 함께 영속 객체로 추가 REMOVE - remove() 실행시 연관된 엔티티를 함께 삭제 DETACH - detach() 실행시 연관된 엔티티를 함께 분리 상태로 만듬 REFRESH - refresh() 실행시 연관된 엔티티를 함께 다시 읽어옴 MERGE - merge() 실행시 연관된 엔티티도 함께 관리 상태로 바꿈 ALL - 모든 상태 변화에 대해 연관된 엔티티에 함께 적용cascade 속성은 배열을 값으로 갖기 때문에 필요한 전이 대상을 배열로 전달할 수 있다.02. 영속성 전이 주의 사항엔티티는 독립적인 라이프사이클을 갖기 때문에 엔티티를 삭제한다고 해서 연관된 엔티티를 함께 삭제하는 경우는 드물다. 보통 엔티티 삭제시 연관된 엔티티는 null로 할당하거나 콜렉션 연관에서 삭제하는 것이 더 일반적인 방법이다." }, { "title": "10. 엔티티 콜렉션 매핑", "url": "/posts/10.-%EC%97%94%ED%8B%B0%ED%8B%B0-%EC%BD%9C%EB%A0%89%EC%85%98-%EB%A7%A4%ED%95%91/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2023-01-02 20:33:23 +0900", "snippet": "01. 엔티티 콜렉션 매핑과 연관 관리엔티티 콜렉션 매핑은 코드를 복잡하게 만들고, 얻을 수 있는 장점은 크지 않다. 게다가 잘못 사용하면 성능에 영향까지 줄 수 있다. 하지만 콜렉션 매핑이 필요한 순간이 있기 때문에 어떻게 설정해야하는지 알 필요가 있다.예) 스포츠 팀과 소속 선수와의 관계public class Team{ private Set&lt;Player&gt; players = new HashSet&lt;&gt;(); public void addPlayer(player p){ this.players.add(p); }}//Team에서 Player로의 1:N 연관이 단방향인 경우 Player의 팀을 옮기는 코드Team team1 = new Team(\"팀1\");Team team2 = new Team(\"팀2\");Player player1 = new Player(\"선수1\");team1.removePlayer(player1);team2.addPlayer(player1);//Player에서 Team으로의 연관이 필요한 경우public class Player{ private Team team; //...}Team team1 = findTeam(\"팀1\");Team team2 = findTeam(\"팀2\");Player player1 = findPlayer(\"선수1\");team1.removePlayer(player1);//양방향인 경우 관련된 엔티티의 연관을 알맞게 처리해야 한다.player1.setTeam(team2);team2.addPlayer(player1);//양방향 연관을 addPlayer()에서 관리하도록 구현할 수 있다.public class Team{ private Set&lt;Player&gt; players = new HashSet&lt;&gt;(); public void addPlayer(Player player) { Team current = player.getTeam(); if(current == this) return; //player가 속한 현재 팀에서 제거 if(current != null) { current.remove(player); } //새로운 팀으로 변경 this.players.add(player); player.setTeam(this); }}Team team2 = new Team(\"탐2\");Player player1 = new Player(\"선수1\");team2.addPlayer(player1);M:N 연관은 1:N 연관과 유사하지만 조금 더 복잡하다. 대표적인 예로 상품과 카테고리가 있다.public class Product { private Set&lt;Category&gt; categories; //... public void changeCategory(Set&lt;Category&gt; newCategories) { for(Category cat : this.categories) { if(!newCategories.contains(cat)) { //기존 카테고리가 변경할 카테고리에 속하지 않으면 기존 카테고리에서 상품으로의 연관 제거 cat.removeProduct(this); } } //변경할 카테고리에 제품 연관 추가 for(category nawCat : newCategories) { newCat.add(this); } //카테고리에 대한 연관 변경 this.categories = newCategories; }}public class Category { private Set&lt;Product&gt; products; //...}02. 1:N 단방향 엔티티 Set 매핑//Team 엔티티에서 Player 엔티티로의 1:N 단방향 연관설정@Entitypublic class Team { @Id private String id; private String name; @OneToMany @JoinColumn(name=\"team_id\") priavate Set&lt;Player&gt; players = new HashSet&lt;&gt;(); //….}@Entitypublic class Player{ @Id @Column(name=\"player_id\") private String id; private String name; //…. //equals, hashcode}Player 엔티티는 Set에 저장되므로 equals() 메서드와 hashCode() 메서드를 구현했다.2.1 1:N 연관의 저장과 변경//엔티티간에 연관을 맺는 코드em.getTransaction().begin();Player p3 = em.find(Player.class, \"P3\");Player p4 = new Player(\"P4\", \"선수4\");Player p5 = new Player(\"P5\", \"선수5\");em.persist(p4);em.persist(p5);Team t3 = new Team(\"T3\", \"팀3\");t3.addPlayer(p4);t3.addPlayer(p5);t3.addPlayer(p3);em.persist(t3);em.getTransaction().commit();//Player의 팀을 변경하는 코드em.getTransaction().begin();Team t1 = em.find(Team.class, \"T1\");Team t2 = em.find(Team.class, \"T2\");Player p2 = null;for(Player p : t1.getPlayers()) { if(p.getId().equlas(\"P2\")) { p2 = p; break; }}t1.removePlayer(p2);t2.addPlayer(p2);중요한 것은 @OneToMany 연관에 저장되는 대상이 관리 상태의 엔티티여야 한다는 것이다.2.2 1:N 연관의 조회@OneToMany의 기본 로딩 방식은 지연 로딩이므로 연관 콜렉션을 실제로 사용하는 시점에 연관 엔티티를 조회한다.2.3 연관에서 제외하기Team 엔티티에 속한 Player 엔티티를 Team에서 제외하고 싶다면 단순히 콜렉션에서 삭제하면 된다.2.4 콜렉션 지우기Team 엔티티의 players 콜렉션을 모두 삭제하면 연된된 Player 엔티티와의 연관이 끊긴다. 콜렉션을 삭제한다는 것은 콜렉션을 통한 연관을 삭제하는 것이지 콜렉션에 포함된 엔티티를 삭제하는 것은 아니다.03. 1:N 양방향 Set 매핑1:N 단방향 연관을 1:N 양방향 연관으로 바꾸면 1:N 단방향 연관과 N:1 연관을 함께 설정하면 된다. 단방향 연관과 차이점이 있다면 @JoinColumn 대신에 @OneToMany의 mapperedBy 속성을 사용한다는 것이다.@Entitypublic class Player{ //... @ManyToOne @JoinColumn(name=\"team_id\") private Team team; //...}1:1 연광에서 양방향 연관은 DB 테이블에서 참조키를 갖는 쪽이 연관을 소유한다고 했다. 그리고 연관을 소유한 엔티티의 속성을 지정하기 위해 mappedBy 속성을 사용했었다. 1:N 양방향 연관도 마찬가지다. 위 예에서는 참조키를 들고있는 엔티티는 Player이다.@Entitypublic class Team { //... //mappedBy는 연관의 소유의 주체가 Player team 속성이라고 지정한다. @OneToMany(mappedBy=\"team\") private Set&lt;Player&gt; players = new HashSet&lt;&gt;(); //...}em.getTransaction().begin();Team t3 = new Team(\"T3\", \"팀3\");Player p3 = em.find(Player.class, \"P3\");//연관을 소유한 쪽은 Player이기 때문에 실제로 Player의 연관만 맞게 지정해도 DB테이블에는 연관을 위한 데이터가 반영된다.t3.addPlayer(p3);p3.setTeam(t3);em.persist(t3);em.getTransacion().commit();양방향 연관의 소유를 Player가 갖고 있으므로 Team과 Player의 연관을 제거하려면 다음과 같은 콜렉션에 속한 모든 Player에서 Team으로의 연관을 제거해야 한다.em.getTransaction().begin();Team t1 = em.find(Team.class, \"T1\");for(Player p : t1.getPlayer()){ p.setTeam(null);}t1.getPlayer().clear();em.getTransacion().commit();04. 조인 테이블을 이용한 1:N 단방향 엔티티 List 매핑예) 전국을 대상으로 가전 기기 수리를 제공하는 서비스의 경우 지역별로 여러 명의 서비스 수리 담당자가 존재하고 순번이 있다고 하는 경우@Entitypublic class Location { @Id private String id; private String name; @OneToMany @JoinTable(name=\"loc_eng\", //조인 테이블 이름 joinColumns=@JoinColumn(name=\"location_id\"), //조인 테이블에서 Location 엔티티를 참조할 때 사용할 컬럼 inverseJoinColumns=@JoinColumn(name=\"engineer_id\") //조인 테이블에서 콜렉션에 포함될 Engineer 엔티티를 참조할 때 사용할 컬럼 ) @OrderColumn(name=\"list_idx\") private List&lt;Engineer&gt; engineers = new ArrayList&lt;&gt;();}05. 조인 테이블을 이용한 1:N 단방향 엔티티 Map 매핑@Entitypublic class Location{ @Id private String id; private String name; @OneToMany @JoinTable(name=\"loc_eng\", //조인 테이블 이름 joinColumns=@JoinColumn(name=\"location_id\"), //조인 테이블에서 Location 엔티티를 참조할 때 사용할 컬럼 inverseJoinColumns=@JoinColumn(name=\"engineer_id\") //조인 테이블에서 콜렉션에 포함될 Engineer 엔티티를 참조할 때 사용할 컬럼 ) @MapKeyColumn(name = \"map_key\") private Map&lt;String, Engineer&gt; engineers = new HashMap&lt;&gt;();}06. M:N 단방향 연관M:N 연관은 많은 부분에서 객체 모델을 복잡하게 만들기 때문에 가능하면 사용하지 말자.//예) 공연과 캐스팅된 사람과의 관게@Entitypublic class Performance{ @Id private String id; private String name; @ManyToMany @JoinTable(name=\"perf_person\", joinColumns=@JoinColumn(name=\"performance_id\"), inverseJoinColumns=@JoinColumn(name=\"person_id\") ) private Set&lt;Person&gt; cast = new HashSet&lt;&gt;();07. M:N 양방향 연관양방향 연관은 연관의 소유를 누가할지 결정하고 연관을 소유한 쪽에 @JoinTable을 설정해주면 된다." }, { "title": "9. 값의 콜렉션 매핑", "url": "/posts/09.%EA%B0%92%EC%9D%98-%EC%BD%9C%EB%A0%89%EC%85%98-%EB%A7%A4%ED%95%91/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2022-12-30 00:01:12 +0900", "snippet": "01. 값 콜렉션JPA는 String, Int와 같은 단순 값에 대한 콜렉션을 지원한다.또 @Embeddable로 설정한 밸류 값에 대한 콜렉션도 매핑할 수 있다. (List, Set, Map, Collection)02. 단순 값 List 매핑유적지 관광객을 위한 하루 이동 경로 목록을 제공하기 위한 모델을 예로 들면 관광 경로 정보를 담기 위한 클래스 Itinerary 클래스로 표현할 수 있다. 이 클래스에는 차례대로 이동할 관광지 목록을 저장하기 위해 List&lt;String&gt; 타입인 sites 속성을 정의하고 있다.그리고 위 클래스를 DB에 매핑하려면 다음과 같이 두 개의 테이블을 사용한다.Itinerary 클래스와 두 테이블 사이의 매핑은 @ElementCollection 애노테이션을 사용한다.@Entitypublic class Itinerary { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; private String name; private String description; @ElementCollection //값 콜렉션임을 지정 @CollectionTable( name=\"itinerary_site\", //콜렉션의 값은 itinerary_site 테이블에 저장 joinColumns=@joinColumn(name=\"itinerary_id\")) //컬렉션이 속할 엔티티 식별자 컬럼 지정 @OrderColumn(name=\"list_idx\") //리스트의 인덱스 값 컬럼 지정 @Column(name=\"site\") private List&lt;String&gt; sites; //... public void changeSites(List&lt;String&gt; sites) { this.sites = sites; } public void clearSites() { sites.clear(); }}2.1 List의 저장과 조회em.getTransaction().begin();List&lt;String&gt; sites = Arrays.asList(\"경복궁\", \"청계천\", \"명동\", \"인사동\");Itinerary itinerary = new Itinerary(\"광화문-종로 인근\", \"설명\", sites);em.persist(itinerary);em.getTransaction().commit();위 코드를 실행한 쿼리 결과를 보면 sites 속성에 저장된 각 값의 인덱스 값을 list_idx 컬럼에 저장하는 것을 볼 수 있다.@ElementCollection 애노테이션의 fetch 속성은 기본값이 LAZY라서 sites.get(0) 코드를 실행하는 시점에 데이터를 읽어온다.2.2 List 변경Itinerary 클래스는 다음의 두 가지 방법으로 sites 콜렉션의 값을 변경할 수 있다. changeSites() 메서드를 이용해서 sites 속성에 새로운 컬렉션을 할당 &gt; 실행한 쿼리를 보면 delete 쿼리를 이용해 기존 컬렉션 데이터를 삭제한 후 insert 쿼리를 이용해서 새로운 컬렉션의 데이터를 추가한다. getSites() 메서드로 구한 컬렉션을 수정 &gt; 기존 항목을 변경하면 update, 새로 추가하면 insert 쿼리를 실행한다.2.3 List 전체 삭제em.getTransaction().begin();Itinerary itinerary = em.find(Itinerary.class, 1L);itinerary.cleatSites(); //sites.clear()em.getTransaction().commit();컬렉션의 데이터를 삭제하려면 clear() 메서드를 사용하거나 null을 할당하는 방법이 있다.03. 밸류 객체 List 매핑Itinerary 클래스의 이동경로 저장시 단순 장소 이름뿐만 아니라 관광 시간도 포함하려할때 String 대신 다음의 밸류 타입을 사용해야 한다.public class SiteInfo { private String site; private int time; //...}public class itinerary { //... @ElementCollection @CollectionTable( name=\"itinerary_site\", joinColumns=@joinColumn(name=\"itinerary_id\")) @OrderColumn(name=\"list_idx\") //@Column이 없어진거 말고는 설정이 똑같다 private List&lt;SiteInfo&gt; sites;}동작 방식은 단순 값 리스트의 매핑과 동일하다.그리고 @ElementCollection로 매핑한 클래스의 컬럼 이름 대신 다른 컬럼 이름을 사용하고 싶다면 @AttrubuteOverride 애노테이션이나 @AttributeOverrides 애노테이션을 사용하면 된다.04 List 요소와 nullem.getTransaction().begin();Itinerary itinerary = em.find(Itinerary.class, 1L);itinerary.getSites().set(1, null);em.getTransaction().commit();List의 전체 길이가 4라고 할 때 중간에 인덱스 1을 삭제하면 테이블에 인텍스 1에 해당하는 데이터가 null로 할당된다.Itinerary itinerary = em.find(Itinerary.class, 1L);List&lt;String&gt; sites = itinerary.getSites();sites.size() == 4; //truesites.get(1) == null; //true05. 단순 값 Set 매핑집합은 중복을 허용하지 않는 컬렉션이다. 예) 사용자마다 관심사를 위한 키워드를 등록하는 경우public class User { private String email; //... private Set&lt;String&gt; keywords = new HashSet&lt;&gt;(); //getter, setter}Set&lt;String&gt; keywords = new HashSet&lt;&gt;();keywords.add(\"역사\");keywords.add(\"유적\");keywords.add(\"전통음식\");user.setKeywords(keywords) user_email keyword user@email.com 역사 user@email.com 유적 user@email.com 전통음식 @Entity@Table(name=\"user\")public class User { @Id@Basic private String email; @Basic private String name; @Basic @Temporal(TemporalType.TIMESTAMP) @Column(name=\"create_date\") private Date createDate; @ElemtentCollection @CollectionTable( name=\"user_keyword\", joinColumns=@JoinColumn(name=\"user_email\")) @Column(name=\"keyword\") private Set&lt;String&gt; keywords = new HashSet&lt;&gt;(); //…}@OrderColumn 애노테이션을 사용하지 않는 것을 제외하면 List 타입의 단순 값을 매핑할 때와 같다5.1 Set의 저장과 조회em.getTransaction().begin();User user = new User(\"user@email.com\",\"사용자\", new Date());Set&lt;String&gt; keywords = new HashSet&lt;&gt;();keywords.add(\"역사\");keywords.add(\"유적\");keywords.add(\"전통음식\");//Set을 생성하여 보관된 값을 user의 keywords로 전달한다.user.setKeywords(keywords);//User 객체만 저장하면 @CollectionTable로 지정한 테이블에 Set에 보관된 값을 함께 저장한다.em.persist(user);em.getTransaction().commit();User user = em.find(User.class, email);Set&lt;String&gt; keywords = user.getKeywords();//@ElementCollection 애노테이션은 기본 값이 LAZY라 실제 데이터에 접근시 user_keyword 테이블을 조회한다.for(String keyword: keywords) { //keyword 사용}5.2 Set의 변경//기존 값 중 \"서울\"을 삭제하고, 새로운 값인 \"한성\"을 추가한다.em.getTransaction().begin();User user = em.find(User.class, email);Set&lt;String&gt; keywords = user.getKeywords();keywords.remove(\"서울\");keywords.add(\"한성\");em.getTransaction().commit();//새로운 Set 객체를 할당하면 delete 수행 후 insert 한다.em.getTransaction().begin();User user = em.find(User.class, email);Set&lt;String&gt; keywords = new HashSet&lt;&gt;();keywords.add(\"부여\");keywords.add(\"한성\");user.setKeywords(keywords); //새로운 set 할당em.getTransaction().commit();//Set clear()를 사용하는 경우 전체 Set을 삭제하기 위한 delete 쿼리를 수행하지 않는다.//기존 Set 값과 비교하여 삭제된 요소만 delete 쿼리로 삭제하고 새로 추가된 요소만 insert 쿼리로 추가한다.em.getTransaction().begin();User user = em.find(User.class, email);Set&lt;String&gt; keywords = user.getKeywords();keywords.clear(); //기존 Set의 데이터를 삭제keywords.add(\"부여\");keywords.add(\"한성\");em.getTransaction().commit();5.3 Set 전체 삭제Set의 데이터를 삭제하고 싶다면 clear() 메서드를 실행하거나 빈 Set을 할당하거나 null을 할당하면 된다.06. 밸류 객체 Set 매핑예) 관광지 정보에 이름과 타입을 함께 표현하려는 경우 기존처럼 String 타입이 아닌 다음과 같이 해야한다.@Embeddablepublic class RecItem { private String name; private String type; //... @Override public boolean equals(Object o) { if(this == o) return true; if(o == null || getClass() != o.getClass()) return false; RecItem recItem = (RecItem)0; return Objects.equals(name, recItem.name) &amp;&amp; Objects.eqauls(type, recItem.type); } @Override public int hashCode(){ return Objects.hash(name, type); }}public class Sight { //… private Set&lt;RecItem&gt; recItems;}6.1 Set에 저장할 밸류 클래스의 equals() 메서드와 hashCode() 메서드RecItem 클래스에서 눈여겨 봐야할 점은 equals() 메서드와 hashCode() 메서드이다. 이 메서드들을 재정의한 이유는 Set의 특성 때문이다. Set은 중복을 허용하지 않기 때문에 두 값이 같은지 여부를 비교하기 위해 equals() 메서드를 사용한다. hashCode()를 재정의한 이유는 하이버네이트가 Set 타입에 대해 HashSet을 사용하기 때문이다. HashSet은 해시 코드를 사용해서 데이터를 분류해서 저장하는데, 이 해시코드를 구할 때 hashCode() 메서드를 이용한다. 같은 값을 갖는 객체는 같은 해시코드를 리턴해야 올바르게 동작하므로 Set에 보관할 객체는 equals(), hashCode()를 알맞게 구현해야 한다.07. 단순 값 Map 매핑Map은 (키, 값) 쌍을 저장하기 위한 컬렉션 타입이다. 엔티티의 정해진 속성이 아니라 자유롭게 엔티티의 값을 설정하고 싶을 때 유용하게 사용할 수 있다.public class Hotel { @Id private String id; //... @ElementCollection @CollectionTable ( name=\"hotel_property\", joinColumns = @JoinColumn(name=\"hotel_id\") ) @MapKeyColumn(name=\"prop_name\") //컬렉션 테이블에서 Map의 키로 사용할 컬럼을 지정한다. @Column(name=\"prop_value\") private Map&lt;String, String&gt; properties; //... public void addProperties(String name, String value){ this.properties.put(name, value); } public Map&lt;String, String&gt; getProperties() { return properties; }}7.1 Map의 저장과 조회em.getTransaction().begin();Hotel hotel = new Hotel(\"H-GURO\", \"구로 호텔\", Grade.STAR4, new Address(\"12345\", \"addr1\", \"addr2\"));hotel.addProperty(\"추가1\", \"추가정보1\");hotel.addProperty(\"추가2\", \"추가정보2\");em.persist(hotel);em.getTransaction().commit();Hotel hotel = em.find(Hotel.class, \"H100-01\");Map&lt;String, String&gt; properties = hotel.getProperties();String viewValue = properties.get(\"VIEW\"); //지연로딩이 기본값이므로 실제 엔티티에 접근할 때 select 쿼리 실행7.2 Map의 변경 put(k, v) : 키에 대해 값을 추가하거나 기존 값을 변경 remove(k) : 키에 대한 값을 삭제7.3 Map의 전체 삭제Map 데이터 삭제는 clear() 메서드로 삭제하거나 데이터가 없는 빈 Map을 할당하거나 null을 할당하면 된다.08. 밸류 객체 Map 매핑@Embeddablepublic class PropValue{ @Column(name=\"prop_value\") private String value; private String type; //생성자, get, equals..}@Entitypublic class Hotel { //... @ElementCollection @CollectionTable( neme=\"hotel_property\", joinColumn=@JoinColumn(name=\"hotel_id\") ) @MapKeyColumn(name=\"prop_name\") private Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();}09. 콜렉션 타입별 구현 클래스엔티티를 로딩할 때 하이버네이트는 다음 클래스를 이용해서 각 콜렉션 타입의 인스턴스를 생성한다. List -&gt; ArrayList Set -&gt; HashSet Map -&gt; HashMap타입을 다르게 초기화 하더라도 하이버네이트는 엔티티 로딩시 위의 타입으로 객체를 보관한다.10. 조회할 때 정렬 Set과 정렬 Map 사용하기하이버네이트는 컬렉션 데이터를 조회해서 생성하는 시점에 정렬해서 읽어오는 방법을 제공하고 있다. 메모리상에서 정렬 SQL 실행시 order by를 사용//Set의 경우 SoredSet과 자바의 Comparator를 사용해서 데이터 정럴할 수 있다.@Entitypublic class User { @ElementCollection @CollectionTable( name=\"user_keyword\", joinColumns=@JoinColumn(name=\"user_email\")) @Column(name=\"keyword\") @org.hibernate.annotation.SortNatural private SortedSet&lt;String&gt; keywords = new TreeSet&lt;&gt;();}SortNatural를 사용하면 Set에 보관된 객체가 Comparable 인터페이스를 구현했다고 가정하고 compareTo() 메서드를 이용하여 정렬한다.컬렉션에 사용한 타입이 Comparable를 구현하지 않았다면 @SortComparator 사용해서 정렬할 때 사용할 Comparator 클래스를 지정할 수도 있다.//SQL의 order by를 사용한 정렬@ElementCollection@CollectionTable( name=\"sight_rec_item\", joinColumns=@JoinColumn(name=\"sight_id\"))//이 방법은 SQL 쿼리를 입력하는 것이다. 즉 테이블의 namd 컬럼을 정렬 대상으로 하는 것@org.hibernate.annotation.OrderBy(clause=\"name asc\")private Set&lt;RecItem&gt; recItem = new LinkedHashSet&lt;&gt;();//JPA가 제공하는 @OrderBy를 사용한 정렬@ElementCollection@CollectionTable( name=\"sight_rec_item\", joinColumns=@JoinColumn(name=\"sight_id\"))//이 방법은 JPA의 정렬 대상 객체의 속성을 사용한다, 즉 RecItem 객체의 name속성을 정렬한다고 설정@javax.persistence.OrderBy(\"name asc\")private Set&lt;RecItem&gt; recItem = new LinkedHashSet&lt;&gt;();Map의 경우도 Set과 동일하게 사용하여 정렬할 수 있다." }, { "title": "8. 엔티티간 N:1 단방향 연관", "url": "/posts/08.%EC%97%94%ED%8B%B0%ED%8B%B0%EA%B0%84-N%EB%8C%801-%EB%8B%A8%EB%B0%A9%ED%96%A5-%EC%97%B0%EA%B4%80/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2022-12-29 21:38:12 +0900", "snippet": "01. 엔티티의 N:1 연관엔티티를 구현하다보면 같은 타입의 여러 엔티티 객체가 다른 타입의 한 엔티티를 참조해야 할 때가 있다.예) 호텔에 대한 리뷰처럼 한 개의 호텔에 대해 다수의 리뷰를 달 수 있는 경우이때 리뷰 입장에서 보면 한개 이상의 리뷰가 한 개의 호텔을 참조하게 된다. 즉 리뷰와 호텔은 N:1 관계를 갖는다.02. 참조키를 이용한 N:1 연관 설정@Entity@Table(name=\"hotel_review\")public class Review { @Id @GeneratedValue(strategy=GenerationType.IENTITY) private Long id; //Review 입장에서 다수의 Review 엔티티가 한 개의 Hotel 엔티티를 참조하는 N:1 연관임을 설정 @ManyToOne @JoinColumn(name=\"hotel_id\") private Hotel hotel; private int rate; private String comment; @Temporal(TemporalType.TIMESTAMP) @Column(name=\"rating_date\") private Date ratingDate; protected Review() {} public Review(Hotel hotel, int rate, String Comment, Date ratingDate) { this.hotel = hotel; this.rate = rate; this.comment = commnet; this.ratingDate = ratingDate; }}03. N:1의 연관 엔티티 로딩@ManyToOne 애노테이션의 fetch 속성도 기본 값이 EAGER를 사용한다. 여기에도 지연 로딩을 사용하고 싶다면 fetch 속성의 값으로 FetchType.LAZY를 사용하면 된다.Review review1 = em.find(Review.class, 1L);Review review2 = em.find(Review.class, 2L);Hotel hotel1 = review1.getHotel();Hotel hotel2 = review2.getHotel();//hotel1 == hotel2 truereview1과 review2가 참조하는 Hotel의 식별자가 같다면 hotel1, hotel2는 동일 객체다 영속 컨텍스트에서는 식별자를 기준으로 엔티티를 저장하고, 추적하기 때문에 동일한 Hotel 데이터를 두 번 읽어와도 영속 컨텍스트에는 먼저 로딩한 Hotel 엔티티만 존재한다.04. 특정 엔티티와 N:1 연관을 맺은 엔티티 목록 구하기N:1 연관을 갖는 엔티티에 대해 가장 많이 사용하는 기능 중 하나는 특정 엔티티와 N:1 연관을 맺은 엔티티 목록 구하기이다. 예) 호텔의 리뷰를 보기 위해 특정 Hotel 엔티티와 관련된 Review 목록을 구하는 기능JPA는 JPQL이라는 쿼리 언어를 이용해서 특정 엔티티 목록을 조회하는 방법을 제공한다.Hotel hotel = em.find(Hotel.class, \"H100-01\");TypedQuery&lt;Review&gt; query = em.createQuery( \"select f from Review r where r.Hotel = :hotel\" + \"order by r.id desc\". Review.class);query.setParameter(\"hotel\", hotel);//모든 엔티티를 조회하지 않고 일부만 조회하기 위한 세팅query.setFirstResult(3);query.setMaxResults(3);List&lt;Review&gt; reviews = query.getResultList();05. 호텔과 최신 리뷰 조회하는 기능 만들기public class HotelRepository{ EntityManager em = EMF.currentEntityManager(); return em.find(Hotel.class, id);}public class ReviewRepository { public List&lt;Review&gt; findByHotel(Hotel hotel, int startRow, int maxResults) { TypedQuery&lt;Review&gt; query = EMF.CurrentEntityManager() .createQuery(\"select f from Review r where r.Hotel = :hotel\" + \"order by r.id desc\". Review.class); query.setParameter(\"hotel\", hotel); query.setFirstResult(startRow); query.setMaxResults(maxResults); return query.getResultList(); }}public class HotleSummary { private Hotel hotel; private List&lt;Review&gt; latestReviews; public HotleSummary(Hotel hotel, List&lt;Review&gt; latestReviews){ this.hotel = hotel; this.latestReviews = latestReviews; } //getter..}public class GetHotelSummaryServiece { private HotelRepository hotelRepository = new HotelRepository(); private ReviewRepository hotelRepository = new ReviewRepository(); public HotelSummary getHotelSummary(String hotelId) { try{ Hotel hotel = hotelRepository.find(hotelId); List&lt;Review&gt; latestReviews = reviewRepository.findByHotel(hotel, 0, 3); return new HotelSummary(hotel, latestReviews); }finally { EMF.closeCurrentEntityManager(); } }}public class HotelNotFoundException extends RuntimeException{}public class HotelMain { private static GetHotelSummaryServiece hotelSummaryServiece = new GetHotelSummaryServiece(); public static void main(String[] args) throw IOException { EMF.init(); BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); try{ while(true) { System.out.println(\"명령어를 입력하세요.\"); String line = readerLine(); String[] commands = line.split(\" \"); if(commands[0].equalsIgnoreCase(\"exit\")) { System.out.println(\"종료합니다.\"); break; }else if(commands[0].equalsIgnoreCase(\"view\")){ handleViewCommand(commands); }else{ System.out.println(\"올바른 명령어를 입력하세요\"); } System.out.println(\"----\"); } }finally { EMF.close(); } } private static void handleViewCommand(String[] commands) { if(commands.length == 1) { printJHelp(); }else { String hotelId = commands[1]; try{ HotelSummary hotelSummary = hotelSummaryService.getHotelSummary(hotelId); Hotel hotel = hotelSummary.getHotel(); System.out.printf(\"ID: %s\\n 이름: %s\\n 등급: %s\\n\", hotel.getId(), hotel.getName(), hotel.getGrade().name()); List&lt;Review&gt; reviews = hotelSummary.getLatestReviews(); if(reviews.isEmpty()) { System.out.println(\"*리뷰 없음\"); }else { reviews.forEach(review -&gt; System.out.printlf(\"리뷰 점수: %d, 내용: %s\\n\", review.getRate(), review.getCommand())); } }catch(HotelNotFoundException e) { System.out.printf(\"호텔[%s] 정보가 없습니다.\\n\", hotelId); } } } private static void printHelp() { System.out.println(\"사용법: view 호텔ID\"); }}" }, { "title": "7. 엔티티간 1:1 연관 그리고 즉시 로딩과 지연 로딩", "url": "/posts/07.%EC%97%94%ED%8B%B0%ED%8B%B0%EA%B0%84-1%EB%8C%801-%EC%97%B0%EA%B4%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%A6%89%EC%8B%9C-%EB%A1%9C%EB%94%A9%EA%B3%BC-%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2022-12-27 23:24:38 +0900", "snippet": "01. 키를 참조하는 1:1 연관 매핑예) 서비스에서 사용자에게 멤버십 카드를 발급해 준다고 하면 시스템은 사용자를 표현하기 위한 User 엔티티와 멤버십 카드를 표현하기 위한 MembershipCard 엔티티를 갖게 된다. 한 명의 사용자는 한 장의 멤버십 카드를 소유할 수 있다고 가정했을 때 User 엔티티와 MembershipCard는 1:1 관계를 갖는다.User와 MembershipCard는 각자 자신의 식별자를 가지며 MembershipCard는 1:1 연관을 맺는 User 객체를 속성(참조키)으로 갖고 있다.테이블에서는 membership_card 테이블의 user 테이블의 PK를 참조하지만 엔티티 클래스에서는 User 객체를 참조하고 있다.MembershipCard 객체를 생성하려면 membership_card 테이블과 user 테이블을 함께 조회한 뒤에 MembershipCard 객체와 User 객체를 알맞게 생성해야한다. 이를 쿼리를 이용해 개발자가 직접 처리한다면 복잡하지만 JPA를 이용하면 간단한 설정으로 두 엔티티 객체 간의 1:1 연관을 처리할 수 있다.02. 참조키를 이용한 1:1 단방향 연관@Entity@Table(name=\"membership_card\")public class MembershipCard { @Id @Column(name=\"card_number\") private String number; @OneToOne //User 엔티티와 1:1 연관을 가짐을 설정 @JoinColumn(name=\"user_email\") //User 객체의 식별자에 해당하는 참조키로 user_email을 지정 private User owner; //User 엔티티에 대한 참조 @Temporal(TemporalType.DATE) @Column(name=\"expirt_date\") private Date expiryDate; private boolean enabled; //....}em.getTransaction().begin();User owner = em.find(User.class, \"asds@asd.com\");MembershipCard memCard = new MembershipCard(\"1234\", owner, new Date());em.persist(memCard);em.getTransaction().commit();만약 영속 객체가 아닌 User 객체를 MembershipCard의 owner 필드에 할당하면 어떻게 될까?em.getTransaction().begin();User notPersistenceUser = new User(\"jvm@asd.com\", \"JVM\", new Date());MembershipCard memCard = new MembershipCard(\"1234\", notPersistenceUser, new Date());em.persist(memCard);em.getTransaction().commit();영속 컨텍스트에 저장되지 않은 User 객체를 MembershipCard에 할당하게 되면 에러가 발생한다. 즉 연관에 사용할 엔티티 객체는 반드시 영속 상태로 존재해야 한다.03. 1:1 연관의 즉시 로딩과 지연 로딩EntityManager.find()를 이용해서 MembershipCard 객체를 구하면 외부 조인을 이용해서 연관된 User 객체를 한 쿼리로 함께 로딩한다.이렇게 연관된 객체를 함께 로딩하는 것을 즉시 로딩이라고 한다. 즉시 로딩은 연관된 객체를 함께 불러오는데 이는 연관된 객체를 함께 사용하지 않으면 필요 없는 객체를 로딩하게 된다는 것을 뜻한다.연관 객체가 필요없는 기능이 더 많다면 지연 로딩을 사용해서 연관된 객체가 필요할 때만 로딩하도록 구현할 수 있다. 지연 로딩은 연관 객체를 실제 사용하는 시점에 로딩하는 방식이다. 지연 로딩을 설정하는 방식은 @OneToOne(fetch=FetchType.LAZY)//지연 로딩을 설정하면 이때 membership_card만 조회한다.MembershipCard memCard = em.find(MembershipCard.class, \"5678\");//실제 User 객체가 필요할 때 user 테이블을 조회한다.System.out.println(memCard.getOwner().getName());fetch 속성은 즉시 로딩을 기본 값으로 갖기 때문에 지연 로딩이 필요한 경우 설정해주자04. 참조키를 이용한 1:1 양방향 연관JPA는 두 엔티티 간의 양방향 연관을 지원한다. 테이블 구조는 단방향 구조이지만 MembershipCard 클래스, User 클래스를 서로 참조하는 연관을 가질 수 있다.참조키를 이용한 1:1 연관을 양방향으로 설정하기 위해서 다음과 같이 한다.@Entity@Table(name=\"user\")public class User { @Id@Basic private String email; //... //MembershipCard의 user 객체의 변수명인 \"owner\"로 설정한다. @OneToOne(mappedBy=\"owner\") priavate MembershipCard membershipCard;}DB 테이블에서 두 엔티티 간의 연관은 참조키를 통해서 이루어진다. JPA의 1:1 연관도 내부적으로 DB 테이블의 참조를 기반으로 구현하기 때문에 본질적으로 참조의 방향은 단방향이다. 위 예에서 MembershipCard 엔티티에서 User 엔티티로의 단방향 참조를 갖게 된다. 즉 DB 데이터를 기준으로 User에서 MembershipCard로의 연관은 존재하지 않는다.JPA는 1:1 연관에서 물리적으로 존재하지 않는 연관을 처리하기 위해 mappedBy를 사용한다. 위 예에서 mappedBy의 속성값은 owner인데 이는 양방향 연관에서 연관을 소유한 쪽이 상대방 엔티티의 owner 속성이라는 것을 의미한다.05. 주요키를 공유하는 1:1 연관 매핑두 엔티티가 키를 공유하는 경우도 있다.public class UserBestSight { private String email; private User user; private String name; private String description; public UserBestSight(User user, String name, String description) { this.email = user.getEmail(); //식별자 공유 this.user = user; this.name = name; this.description = description; }}위 예처럼 UserBestSight 객체가 User 객체의 식별자를 공유하므로 주요키를 공유하는 1:1 연관에서는 User 객체 없이 UserBestSight 객체는 존재할 수 없다.06. 주요키를 공유하는 1:1 단방향 연관@Entity@Table(name=\"user_best_sight\")public class UserBestSight{ @Id @Column(name=\"email\") private String email; @OneToOne @PrimaryKeyJoinColumn private User user; private Strig title; private String description; public UserBestSight(User user, String name, String description) { this.email = user.getEmail(); //식별자 공유 this.user = user; this.name = name; this.description = description; }}@PrimaryKeyJoinColumn은 User 타입을 참조할 때 주요키를 이용한다. 이때 주요키는 UserBestSight의 @Id와 매핑되는 컬럼이다. 즉 1:1 연관을 맺는 UserBestSight의 식별자와 User의 식별자는 같은 값을 갖는다.//UserBestSight 객체를 생성하려면 User 객체도 필요하다.User user = new User(\"asd@rret.com\", \"홍길동\", new Date());UserBestSight bestSight = new UserBestSight(user, \"김둘리\", \"이상사회\");em.persist(user);em.persist(bestSight);이렇게 하면 트랜잭션을 커밋할 때 두 개의 insert 쿼리가 실행된다.07. 주요키를 공유하는 1:1 양방향 연관@Entity@Table(name=\"user\")public class user { @Id private String email; @OneToOne(mappedBy=\"user\") private UserBestSight bestSight; //... //객체의 생성과 양방향 연관을 함께 처리하고 있다. public UserBestSight createBestSight(String title, String desc) { this.bestSight = new UserBestSight(this, title, desc); return bestSight; } public UserBestSight getBestSight() { return bestSight; }}User user = new User(\"asd@rret.com\", \"홍길동\", new Date());UserBestSight bestSight = user.createBestSight(\"김둘리\", \"이상사회\");em.persist(user);em.persist(bestSight);08. 1:1 연관 끊기연관 객체와의 관계를 제거하려면 단순히 null을 할당하면 된다. 양방향 연관을 사용하면 양쪽 연관에 모두 null을 할당하면 된다.09. 자동 생성키와 1:1 연관 저장JPA는 persist() 실행 시점에 식별자를 생성하는 방식을 제공하고 있다. 자동 증가 컬럼이나 테이블을 이용한 식별자 생성기가 해당한다.//자동 증가 컬럼을 식별자 생성기로 사용한 예@Entity@Table(name=\"hotel_review\")public class Review { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; //....}@Entity@Table(name=\"real_user_log\")public class RealUserLog{ @Id @GeneratedValue(strategy=GenerationType.IDENTITY) priavate Long id; @OneToOne @JoinColumn(name=\"review_id\") priavate Review review; @Temporal(TemporalType.TIMESTAMP) @Column(name=\"used_date\") priavate Date realUsingDate; public RealUserLog(Review review, Date realUsingDate) { this.review = review; this.realUsingDate = realUsingDate; }}참조키 방식을 사용하므로 RealUserLog 객체를 생성하는 시점에 Review 객체의 식별자가 필요한 것은 아니다. 실제 Review 객체의 식별자가 필요한 시점은 DB에 저장하기 위해 insert 쿼리를 실행하는 시점이다.//Review 객체를 저장하기 전에 RealUserLog 객체를 생성해도 문제가 되지 않는다.Review review = new Review(\"H001\", 5, \"최고에요\", new Date());RealUserLog realUserLog = new RealUserLog(review, new Date());em.persist(review);em.persist(realUserLog);반면 주요키를 공유하는 1:1 연관은 연관관계를 맺기 전에 식별자가 필요하다.@Entity@Table(name=\"real_user_log\")public class RealUserLog{ @Id @Column(name=\"review_id\") priavate Long reviewId; @OneToOne @PrimaryKeyJoinColumn priavate Review review; //주요키를 공유하는 1:1 단방향 @Temporal(TemporalType.TIMESTAMP) @Column(name=\"used_date\") priavate Date realUsingDate; public RealUserLog(Review review, Date realUsingDate) { this.reviewId = review.getId(); this.review = review; this.realUsingDate = realUsingDate; }}Review review = new Review(\"H001\", 5, \"최고에요\", new Date());em.persist(review); //review의 식별자 생성RealUserLog realUserLog = new RealUserLog(review, new Date()); //review 식별자 공유em.persist(realUserLog);자동 증가 컬럼, 시퀀스 같은 식별자 생성기를 이용하는 엔티티와 주요키를 공유하는 1:1 연관을 갖는 경우 식별자를 생성한 뒤 연관을 맺어야 함에 주의하자10. 지연 로딩, 프록시, EntityManager 범위하이버네이트는 연관 객체의 지연 로딩을 구현하기 위해 프록시 객체를 사용한다.MembershipCard card = em.find(MembershipCard.class, \"5678\");//출력되는 클래스는 하이버네이트가 생성한 프록시 클래스이다.System.out.println(card.getOwner().getClass().gatName());프록시가 한 번 실제 엔티티를 로딩하면 이후 접근에 대해서는 데이터 조회 쿼리를 실행하지 않는다.프록시를 통해 실제 연관 객체의 값에 접근하는 시점에 DB에서 select 쿼리를 실행한다. 그러므로 DB와의 연결이 끊기면 연관 객체를 로딩할 수 없다. 따라서 지연 로딩을 설정한 객체를 사용해야 하는 경우 EntityManager를 종료하기 전에 연관된 객체에 접근해야 한다." }, { "title": "6. 영속 객체의 라이프사이클", "url": "/posts/06.%EC%98%81%EC%86%8D-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2022-12-26 23:04:38 +0900", "snippet": "01. 영속 객체의 라이프사이클 개요영속 객체는 영속 컨텍스트와의 연관 상태에 따라 관리됨, 분리됨, 삭제됨 상태를 갖는다.JPA는 영속 컨텍스트에 보관된 객체의 변경 내역을 추적한다. JPA의 영속 컨텍스트를 통해서 관리되는 상태의 영속 객체는 관리됨 상태를 갖는다. 이 시점에 트랜잭션 범위 안에서 변경하면 커밋 시점에 변경 내역을 DB에 반영한다.EntityManager가 종료되면 영속 컨텍스트가 사라지고 이 시점에 영속 객체는 영속 컨텍스트와의 관계가 끊어진다. 이때 분리됨 상태가 된다.remove() 메서드에 관리 상태의 객체를 전달하면 삭제됨 상태가 되고, 영속 객체가 삭제되면 트랜잭션 커밋 시점에 해당 데이터를 DB에서 삭제한다.02. EntityManager#persist()와 관리 상태 객체persist()를 이용해서 영속 컨텍스트에 엔티티 객체를 추가하면 해당 엔티티 객체는 관리 상태가 된다. 영속 컨텍스트는 엔티티 객체를 관리할 때 식별자를 기준으로 각 엔티티를 구분한다.엔티티 객체 추가시 식별자 생성 방식에 따라 insert 쿼리가 실행되는 시점이 달라진다. 엔티티 클래스의 id 필드가 MySQL의 auto_increment 칼럼에 매핑되어 있는 경우 auto_increment는 데이터를 삽입할 때 자동으로 값이 증가하므로 persist() 메서드에 객체를 전달하면 그 시점에 insert 쿼리를 실행한다.테이블을 이용해서 식별자를 생성하는 경우에는 persist()에 엔티티를 추가할 때 식별자를 구하기 위한 쿼리가 실행된다. (엔티티 객체를 DB에 insert X) 그리고 실제 엔티티 객체를 DB에 저장하기 위한 insert 쿼리는 트랜잭션을 커밋하는 시점에 실행된다.엔티티 객체를 추가할 때 주의할 점은 트랜잭션 범위에서 실행하지 않으면 엔티티를 DB에 추가하는 insert 쿼리를 실행하지 않는다는 점이다.em.transaction().begin();User user = new User(\"asd@asd.com\", \"user\", new Date());em.persist(user);user.changeName(\"user02\"); //user 객체는 관리 상태이므로 변경 내역을 추적한다.em.getTransaction().commit(); // user의 변경 내역도 함께 반영됨EntityManager.persist()로 엔티티 객체를 영속 컨텍스트에 추가하는데 이는 캐시에 엔티티 객체가 보관된다는 것을 뜻한다. persist()로 저장한 엔티티 객체의 식별자를 이용해서 find()로 엔티티 객체를 구하면 persist()로 저장한 객체를 리턴한다.03. EntityManager#find()와 관리 상태 객체find()로 구한 객체도 영속 컨텍스트에 보관되어 관리 상태가 된다. 관리 상태의 영속 객체는 트랜잭션 범위에서 상태가 바뀌면 트랜잭션을 커밋하는 시점에 변경 내역을 반영하기 위한 update 쿼리를 실행한다.find()로 로딩한 객체는 영속 컨텍스트에 보관되므로 동일 식별자를 갖는 엔티티를 다시 find()로 구하면 select 쿼리를 다시 실행하지 않고 영속 컨텍스트에 보관된 엔티티 객체를 리턴한다.04. 분리 상태 객체영속 컨텍스트에 보관된 영속 객체는 EntityManager가 종료되면 분리 상태가 된다. 분리 상태가 되면 객체의 상태를 변경해도 DB에 반영되지 않는다.05. EntityManager#merge()로 분리 상태를 관리 상태로 바꾸기merge()를 사용하면 분리 상태의 엔티티를 다시 관리 상태로 만들 수 있다.EntityManager em = EMF.createEntityManager();User user = null;try{ user = em.find(User.class, \"madvirus@madvirus.net\");}finally{ em.close();}//이 시점엔 분리 상태user.changeName(\"Choi, Beom Kyun\");EntityManager em2 = EMF.createEntityManager(0;try{ em2.getTransactin().begin(); em2.merge(user); //user는 다시 관리 상태가 됨 em2.getTransaction().commit(); //변경내역 반영}catch(Exception e) { em2.getTransaction().rollback(); throw e;}finally{ em2.clos()l}06. 삭제 상태 객체remove() 메서드에 관리 상태 영속 객체를 전달하면 삭제 상태로 바뀐다. 그리고 트랜잭션 커밋 시점에 delete 쿼리를 실행해서 삭제 상태에 해당하는 해당 데이터를 DB에서 삭제한다.remove()로 삭제 상태로 바뀐 엔티티를 다시 merge()에 전달하면 Exception이 발생한다." }, { "title": "5. EntityManager, 영속 컨텍스트, 트랜잭션", "url": "/posts/05.EntityManager,%EC%98%81%EC%86%8D%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8,%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2022-12-24 20:08:38 +0900", "snippet": "01. EntityManager와 영속 컨텍스트EntityManager entityManager = emf.createEntityManager();EntityTransaction transaction = entityManager.getTransaction();try{ transaction.begin(); Sight sight = entityManager.find(Sight.class, 1L); sight.setDetail(new SightDetail(\"오전9시~오후5시\", \"연중무휴\", \"10대 주차가능\")); transaction.commit();}catch(Exception ex) { transaction.rollback(); throw ex;}finally{ entityManager.close();}위 코드에서 entityManager.find()로 얻어온 객체는 영속 객체이다. 영속 객체는 DB에 보관된 데이터에 매핑되는 메모리상의 객체 를 의미한다. find() 메서드를 통해 읽어온 엔티티 객체는 DB에서 읽어온 객체이므로 영속 객체에 해당한다.save()를 통해 새로운 객체를 추가하면 해당 객체는 영속 객체가 되고 EntityManager가 관리한다. 그리고 트랜잭션 커밋 시점에 영속 객체를 DB에 반영한다.EntityManager는 영속 객체를 관리할 때 영속 컨텍스트라는 집합을 사용한다. 일종의 메모리 저장소로 EntityManager가 관리하는 엔티티 객체를 보관한다. DB에서 읽어온 엔티티 객체를 영속 컨텍스트에 보관하고 save()로 저장한 엔티티 객체 역시 영속 컨텍스트에 보관한다.EntityManager는 트랜잭션 커밋 시점에 영속 컨텍스트에 보관된 영속 객체의 변경 내용을 추적해서 DB에 반영한다. 데이터가 변경된 객체는 update 쿼리를 이용해서 변경하고, 새롭게 추가된 객체는 insert 쿼리를 이용해 삽입, 삭제된 객체는 delete 쿼리를 이용해서 삭제한다.JPA는 영속 컨텍스트에 보관한 엔티티를 구분할 때 식별자를 이용한다. 즉 영속 컨텍스트는 엔티티 타입+식별자를 키로 사용하고 엔티티를 값으로 사용하는 데이터 구조를 갖는다.1.1 영속 컨텍스트와 캐시EntityManager 입장에서 영속 컨텍스트는 동일 식별자를 갖는 엔티티에 대한 캐시 역할을 한다.예를 들어 한 EntityManager에서 객체에 대해 동일한 식별자를 갖는 엔티티를 두 번 이상 조회하면 첫 번째 find()에서는 select 쿼리를 실행하지만 두 번째 find()에서는 select 쿼리를 실행하지 않는다.(영속 컨텍스트에 보관된 객체를 리턴)이 캐시는 영속 컨텍스트와 관련되어 있으므로 EntityManager 객체를 종료하기 전까지만 유효하다.02. EntityManager의 종류1)애플리케이션 관리 EntityManager애플리케이션 관리 EntityManager는 EntityManagerFactory 생성과 종료, 이를 이용하여 EntityManager를 생성하고 종료를 처리한다. 애플리케이션 코드에서 EntityManager의 생성과 종료를 책임지므로 EntityManager를 사용한 뒤에는 close()를 호출해서 EntityManager를 반드시 종료시켜야 한다.2)컨테이너 관리 EntityManager컨테이너 관리 EntityManager는 JEE 컨테이너에서 EntityManagerFactory와 EntityManager의 라이프사이클을 관리한다. JEE 컨테이너가 EntityManager를 생성하고 종료하는 과정을 처리하기 때문에 애플리케이션 코드는 컨테이너가 제공하는 EntityManager를 사용해서 필요한 기능만 구현하면 된다. EntityManager는 @PersistenceContext 애노테이션을 사용하면 된다.public class WithdrawService { //JEE 컨테이너는 @PersistenceContext 애노테이션이 적용된 필드에 컨테이너가 관리하는 EntityManager 객체를 주입한다. @PersistenceContext EntityManager em; //EntityManager가 트랜잭션에 참여하기 때문에 애플리케이션 코드에서는 트랜잭션을 직접 관리하지 않는다. @Transactional public void withdraw(String email) { User user = em.find(User.class, email); if(user == null) { throw new UserNotFoundException(); } em.remove(user); }}//컨테이너 관리 EntityManager에 대해 close()를 실행하면 에러가 발생한다.03. 트랜잭션 타입3.1 자원 로컬 트랜잭션 타입JPA가 제공하는 EntityTransaction을 이용하는 방식으로 이 타입을 사용하려면 persistence.xml 파일에 영속단위의 transaction-type을 RESOURCE_LOCAL로 지정하면 된다.그리고 EntityTransaction을 이용하여 트랜잭션을 시작(begin())하고, 커밋(commit())한다. 트랜잭션 커밋 시점에 영속 컨텍스트로 추적한 변경 내역을 DB에 반영하기 때문에 트랜잭션 없이 엔티티 객체를 수정하는 경우 변경 내역이 DB에 저장되지 않는다.3.2 JTA 트랜잭션 타입이 타입을 사용하려면 persistence.xml 파일에 영속단위의 transaction-type을 JTA로 지정하면 된다. 이 타입을 사용하면 JPA에서 트랜잭션을 관리하지 않는다. EntityManager를 JTA 트랜잭션에 참여시켜 트랜잭션을 관리한다.UserTransaction utx = (UserTransaction) new InitialContext().lookup(\"java:comp/UserTransaction\");utx.begin();EntityManager em = emf.createEntityManager();em.joinTransaction(); //JTA 트랜잭션에 참여한다.try{ User user = em.find(User.class, email); if(user == null){ throw new UserNotFoundException(); } em.remove(); utx.commit();}catch(Exception e) { try{ utx.rollback(); }catch(SystemException e) { } throw new RuntimeException(ex);}finally{ em.close();}컨테이너 관리 EntityManager는 반드시 JTA 트랜잭션 타입을 사용해야 한다. 명시적으로 joinTransaction를 사용하지 않아도 JTA 트랜잭션 시작 이후 EntityManager를 생성하면 자동으로 트랜잭션에 참여한다.04. EntityManager의 영속 컨텍스트 전파보통 서비스는 트랜잭션을 관리하는 주체가 된다. 즉 서비스 메서드의 시작 시점에 트랜잭션을 시작하고 서비스 메서드의 종료 시점에 트랜잭션을 커밋한다.엔티티를 수정하는 경우 find()메서드와 save()메서드가 사용하는 EntityManager는 같은 메서드에서 생성한 EntityManager와 같아야 한다. 서로 다른 EntityManager를 사용하는 경우 영속 컨텍스트와 트랜잭션을 공유하지 않으므로 원하는 쿼리가 실행되지 않는다.EntityManager를 전파하는 가장 쉬운 방법은 find(), save() 메서드에 EntityManager 객체를 메서드 인자로 전달하는 것이다.4.1 ThreadLocal을 이용한 애플리케이션 관리 EntityManager의 전파ThreadLocal은 쓰레드 단위로 객체를 공유할 때 사용하는 클래스이다. 이 클래스를 사용하면 한 메서드에서 호출하는 메서드가 동일한 객체를 공유할 수 있다.public class EMF { private static EntityManagerFactory emf; private static ThreadLocal&lt;EntityManager&gt; currentEm = new ThreadLocal&lt;&gt;(); //..... public static EntityManager currentEntityManager() { EntityManager em = currentEm.get(); if(em == null) { em = emf.createEntityManager(); currentEm.set(em); } return em; } public static void closeCurrentEntityManager() { EntityManager em = currentEm.get(); if(em != null) { currentEm.remove(); em.close(); } }}public class JoinService{ private UserRepository userRepository = new UserRepository(); public void join(User user) { EntityManager em = EMF.currentEntityManager(); try{ em.getTransaction().begin(); User found = userRepository.find(user.getEmail()); if(found != null) { throw new DuplicateEmailException(); } userRepository.save(user); em.getTransaction().commit(); } catch(Exception e) { em.getTransaction().rollback(); throw ex; } finally { EMF.closeCurrentEntityManager(); } }}public class UserRepository{ public User find(String email) { EntityManager em = EMF.currentEntityManager(); return em.find(User.class, email); } public void save(User user) { EntityManager em = EMF.currentEntityManager(); em.persist(user); } public void remove(User user) { EntityManager em = EMF.currentEntityManager(); em.remove(user); } //.....}4.2 컨테이너 관리 EntityManager의 전파컨테이너 관리 EntityManager는 컨테이너가 알아서 EntityManager를 전파해준다. @PersistenceContext 애노테이션을 사용하면 현재 트랜잭션에 참여하는 EntityManager를 구할 수 있다.컨테이너 관리 EntityManager는 항상 JTA 트랜잭션 타입을 사용해야 하므로 @PersistenceContext로 구한 EntityManager는 JTA를 이용한 글로벌 트랜잭션에 참여한다." }, { "title": "4. 밸류와 @Embeddable", "url": "/posts/04.%EB%B0%B8%EB%A5%98%EC%99%80-@Embeddable/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2022-12-21 23:02:12 +0900", "snippet": "01. 밸류로 의미 더 드러내기Hotel 클래스는 주소 자체를 의미하는 address 데이터를 갖고 있다. 그리고 Address 클래스는 zipcode, address1, address2를 데이터로 갖고 있어 따로 유추하지 않아도 주소가 우편번호, 주소1, 주소2로 구성된다는 것을 알 수 있다.Address 클래스 같은 타입을 value라고 부르는데 value의 특징은 다음과 같다. value는 개념적으로 한 개의 값을 표현한다. (Address 클래스는 세 개의 데이터로 구성되어 있지만 개념적으로 한 개의 주소를 나타낸다.) 식별자를 갖지 않는다. 자신만의 라이프사이클을 갖지 않는다.(자신이 속한 객체가 생성될 때 함께 생성되고 삭제될 때 함께 삭제됨)value 객체를 사용하는 이유는 값의 의미를 더 잘 드러내기 때문이다. zipcode, address1, address2 의 세 데이터보다 Address 클래스가 주소의 의미를 더 잘 드러낸다.02. 밸류 클래스의 구현기본 타입 값은 1)값을 비교한다. 2)값 자체는 바뀌지 않는다. 라는 특징을 갖고 있다. 밸류 클래스도 값으로 활용하기 위해 기본 타입 값 특징을 적용해볼 수 있다. 그러기 위해 다음과 같이 구현해야 한다. 생성 시점에 모든 프로퍼티를 파라미터로 받는다. 읽기 전용 프로퍼티만 제공한다. 각 프로퍼티의 값을 비교하도록 equals() 메서드를 재정의한다. hashCode() 메서드를 재정의 한다.@Entitypublic class Hotel{ @Id private String id; //… private Address address; public Address getAddress() { return address; } //주소를 변경하려면 다음 코드 처럼 Address 객체를 새로 할당한다. public void changeAddress(Address newAddress){ this.address = newAddress; }}03. @Embeddable 애노테이션과 @Embedded 애노테이션을 이용한 밸류 매핑Address 밸류 타입을 갖는 Hotel 엔티티를 테이블에 매핑하려면 다음과 같은 매핑 설정을 추가해야한다. 밸류 타입인 Address 클래스에 @Embeddable 애노테이션을 적용한다. Hotel 클래스는 @Embedded 애노테이션을 사용해서 밸류 타입을 매핑 설정한다.//대상 클래스가 다른 엔티티의 일부로 함께 저장될 수 있다는 것을 설정@Embeddablepublic class Address { private String zipcode; private String address1; private String address2;}@Entitypublic class Hotel{ @Id private String id; private String name; @Eumerated(EnumType.STRING) private Grade grade; //@Embeddable 클래스의 인스턴스라는 것을 설정한다. @Embedded priavate Address address;}//사용 예제Hotel hotel = em.find(Hotel.class, \"H100-10\");Address address = hotel.getAddress();//address.getAddress1();//address.getAddress2();//address.getZipcode();Hotel의 address도 매핑 대상이므로 트랜잭션 범위 안에서 address가 변경되면 UPDATE 쿼리를 실행해서 변경 내역을 DB에 반영한다.3.1 null 밸류의 매핑 처리public Hotel(String id, String name, Grade grade, Address address){ this.id = id; this.name = name; this.grade = grade; this.address = address;}위와 같은 생성자가 정의되어 있을 때 address 파라미터를 null로 주고 저장하면 Address와 매핑된 세 개의 칼럼에 모두 null 값이 할당된다. 그리고 조회할 때 매핑 대상도 null이 된다.3.2 @Embeddable의 접근 타입기본적으로 @Embedded로 매핑한 대상은 해당 엔티티의 접근 타입을 따른다. 예) 위 예제에서 Hotel 클래스는 필드 접근 타입을 사용하므로 @Embedded로 매핑한 Address를 처리할 때에도 필드 접근 타입을 사용한다.반대로 Hotel 클래스에서 프로퍼티 접근 타입을 사용하면 Address 프로퍼티도 프로퍼티 접근 타입을 따른다. 그래서 Address 클래스도 프로퍼티 처리를 위한 get/set 메서드를 정의해야 한다.만약 Address 클래스에 항상 필드 접근 방식을 사용해서 처리하려는 경우 Address 클래스에 @Access 애노테이션을 사용해서 @Embeddable의 접근 타입을 고정하면 된다.04. @Entity와 @Embeddable의 라이프 사이클@Embedded로 매핑한 객체는 엔티티와 동일한 라이프사이클을 갖는다. 즉 엔티티를 저장하고 수정하고 삭제할 때 엔티티에 속한 @Embeddable 객체도 함께 저장되고 수정되고 삭제된다.위 예에서는 @Entity로 설정한 객체와 @Embeddable로 설정한 객체를 한 테이블에 매핑하여 엔티티의 라이프 사이클을 따르는 것이 당연해 보였다. JPA는 @Entity로 매핑한 클래스와 @Embeddable로 매핑한 클래스를 서로 다른 테이블에 저장하는 방법도 제공하는데 이때도 엔티티의 라이프사이클을 따른다.05. @AttributeOverrides를 이용한 매핑 설정 재정의@Embeddablepublic class Address { private String zipcode; private String address1; private String address2;}@Entitypublic class Sight { @Id @GeneratedValue(stratrgy = GenerationType.IDENTITY) private Long id; private String name; @Embedded private Address korAddress; @Embedded private Address engAddress;}위의 경우 영어주소, 한글주소의 테이블 칼럼의 이름이 같아진다. 그래서 초기화 과정에서 에러가 발생하게 된다. 이때 사용할 수 있는 설정이 @AttributeOverrides이다.@Entitypublic class Sight { @Id @GeneratedValue(stratrgy = GenerationType.IDENTITY) private Long id; private String name; @Embedded private Address korAddress; @Embedded //매핑 대상이 여러개인 경우 s가 붙은 AttributeOverrides를 사용한다. @AttributeOverrides({ //개별 매핑 대상에 대한 설정을 재정의 한다. @AttributeOverride(name=\"zipcode\", column=@Column(name=\"eng_zipcode\")), @AttributeOverride(name=\"address1\", column=@Column(name=\"eng_addr1\")), @AttributeOverride(name=\"address2\", column=@Column(name=\"eng_addr2\")), }) private Address engAddress;} korAddress.zipcode -&gt; zipcode korAddress.address1 -&gt; address1 korAddress.address2 -&gt; address2 engAddress.zipcode -&gt; eng_zipcode engAddress.address1 -&gt; eng_addr1 engAddress.address2 -&gt; eng_addr206. @Embeddable 중첩@Embeddable로 지정한 클래스에 또 다른 @Embeddable 타입을 중첩해서 매핑할 수 있다.@Embaddablepublic class ContactInfo{ @Column(name=\"ct_phone\") private String phone; @Column(name=\"ct_email\") private String email; @Embedded @AttributeOverrides({ @AttributeOverride(name=\"zipcode\", column=@Column(name=\"ct_zipcode\")), @AttributeOverride(name=\"address1\", column=@Column(name=\"ct_addr1\")), @AttributeOverride(name=\"address2\", column=@Column(name=\"ct_addr2\")), }) private Address address;}//중첩된 @Embeddable 클래스에 대한 설정 재정의@Entitypublic class City{ //... @Embedded @AttributeOverrides({ //address. @AttributeOverride(name=\"address.zipcode\", column=@Column(name=\"city_zip\")), @AttributeOverride(name=\"address.address1\", column=@Column(name=\"city_addr1\")), @AttributeOverride(name=\"address.address2\", column=@Column(name=\"city_addr2\")) }) private ContactInfo contactInfo;}07. 다른 테이블에 밸류 저장하기지금까지 예제는 엔티티와 밸류 객체를 한 테이블에 저장했다. 하지만 밸류 객체를 반드시 같은 테이블에 저장해야 하는 것은 아니다. 엔티티와 밸류를 서로 다른 테이블에 저장하는 예로 기본 정보와 상세 정보를 들 수 있다.//밸류이므로 주요키를 갖지 않는다.@Embeddablepublic class SightDetail { @Column(name=\"hours_op\") private String hoursOfOperation; private String holidays; private String facilities;}@Entity//밸류를 저장할 테이블 지정@SecondaryTable( name=\"sight_detail\", pkJoinColumns=@PrimaryKeyJoinColumn( name=\"sight_id\", referenceColumnName=\"id\"))public class Sight{ @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; privats String name; //... @Embedded //칼럼의 테이블 이름을 재정의 @AttributeOverride({ @AttributeOverride( name=\"hoursOfOperation\", column=@Column(name=\"hours_op\", table=\"sight_detail\")), @AttributeOverride( name=\"holidays\", column=@Column(ntable=\"sight_detail\")), @AttributeOverride( name=\"facilities\", column=@Column(ntable=\"sight_detail\")), }) private SightDetail detail; //getter, setter}@SecondaryTable은 데이터의 일부를 다른 테이블로 매핑할 때 사용한다. name은 테이블 명을 pkJoinColumns는 @SecondaryTable로 지정한 테이블에서 @Entity와 매핑되는 테이블의 주요키를 참조할 때 사용할 칼럼을 설정한다.Sight sight = new Sight(\"경복궁\", new Address(\"03045\", \"서울시 종로구\", \"세종로 1-1\"), new Address(\"03045\", \"Jongno-gu Seoul\", \"1-1, Sejong-ro\"));sight.setDetail(new SightDetail(\"09~17시\", \"매주 화요일\", \"안내 설명\"));EntityManager entityManager = emf.createEntityManager();EntityTransaction transaction = entityManager.getTransaction();try{ transaction.begin(); entityManager.persist(sight); //SightDetail은 sight_detail 테이블에 저장 transaction.commit();}catch(Exception ex) { transaction.rollback(); throw ex;}finally{ entityManager.close();}Sight sight = new Sight(\"경복궁\", new Address(\"03045\", \"서울시 종로구\", \"세종로 1-1\"), new Address(\"03045\", \"Jongno-gu Seoul\", \"1-1, Sejong-ro\"));entityManager.persist(sight); //detail이 null이면 sight_detail 테이블에는 insert 하지 않음EntityManager.find()로 엔티티를 조회하면 @SecondaryTable로 매핑한 테이블을 레프트 조인으로 조회한다.그리고 SightDetail의 경우 Sight에만 포함되므로 Address와 달리 포함되는 엔티티에 따라 컬럼 설정이 달라지지 않는다. SightDetail와 매핑할 테이블 설정을 SightDetail에 직접 설정해도 된다.//SightDetail @Column에 table 명을 지정하면 Sight 클래스는 @AttributeOverride 애노테이션을 사용해서 테이블을 지정할 필요가 없다.@Embeddablepublic class SightDetail { @Column(name=\"hours_op\", table=\"sight_detail\") private String hoursOfOperation; @Column(table=\"sight_detail\") private String holidays; @Column(table=\"sight_detail\") private String facilities;}7.1 다른 테이블에 저장한 @Embeddable 객체 수정과 쿼리Sight sight = entityManager.find(Sight.class, 1L);sight.setDetail(new SightDetail(\"오전9시~오후5시\", \"연중무휴\", \"10대 주차가능\"));transaction.commit();위 예에서 Sight 객체를 조회했을 때 detail이 존재하느냐 여부에 따라 실행되는 쿼리가 달라진다. find()로 읽어온 Sight의 detail이 null이 아니면 detail 테이블의 데이터를 update 하고, null이면 insert 한다.08. @Embeddable과 복합키테이블의 주요키가 두 개 이상의 컬럼으로 구성된 복합키이고, 이 복합키를 엔티티의 식별자에 매핑해야 하는 경우 @Embeddable 타입을 복합키에 매핑할 식별자 타입으로 사용할 수 있다.//복합키 밸류 클래스@Embeddablepublic class MonChangeId implements Serializable { @Column(name=\"hotel_id\") priavate String hotelId; @Column(name=\"year_mon\") private String yearMon; //.... //equals, hashcode 구현}@Entity@Table(name=\"month_change\")public class MonthCharge{ @Id priavate MonChangeId id; @Column(name=\"change_amt\") priavate int chargeAmount; @Column(name=\"unpay_amt\") priavate int unpayAmount;}//복합키를 사용하므로 find() 메서드로 조회시 식별자 값에 복합키 객체를 전달한다.MonthCharge monthCharge = em.find(MonthCharge.class, new MonChargeId(\"H100-10\", \"201608\"));복합키로 사용할 밸류 클래스는 값 비교를 위한 equals() 메서드와 hashCode() 메서드를 알맞게 구현해야 한다. 그리고 Serializable 인터페이스를 상속해야 한다." }, { "title": "3. 엔티티", "url": "/posts/03.%EC%97%94%ED%8B%B0%ED%8B%B0/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2022-12-18 17:40:38 +0900", "snippet": "01. 엔티티 클래스JPA에서 엔티티는 영속성을 가진 객체로서 가장 중요한 타입이다. JPA의 엔티티는 DB 테이블에 보관할 대상이 된다. EntityManager를 사용해서 엔티티 단위로 저장하고 조회하고 삭제한다.JPA는 두 가지 방법으로 엔티티를 설정하는데 1)@Entity 애노테이션을 사용하는 방법 2)XML 매핑 설정을 사용하는 방법이 있다. 많은 프로젝트에서 주로 @Entity를 이용한 설정을 주로 사용한다.1.1 @Entity 애노테이션과 @Table 애노테이션EntityManager는 @Entity 애노테이션을 적용한 클래스를 이용해서 SQL 쿼리를 생성할 때 클래스 이름을 테이블 이름으로 사용한다. DBMS가 테이블 이름의 대소문자를 구분하거나 클래스 이름과 테이블 이름이 다른 경우 @Table 애노테이션을 사용해서 테이블 이름을 직접 지정할 수 있다.1.2 @Id 애노테이션엔티티의 가장 큰 특징은 식별자를 갖는다는 것이다. DB에서 주요키를 사용하는 것처럼 엔티티를 구분할 때 식별자를 사용한다.@Entitypublic class User{ @Id private String email; private String name; //...}@Id 애노테이션을 필드에 적용했는데 이 경우 모든 필드가 매핑 대상이 된다. 즉 email 뿐만 아니라 name 필드도 DB 테이블과의 매핑 대상이 된다. 필드뿐만 아니라 getter 메서드에도 @Id를 적용할 수도 있다.@Id 애노테이션을 적용한 필드 값은 EntityManager.find() 메서드에서 엔티티 객체를 찾을 때 식별자로 사용된다.1.3 @Basic 애노테이션과 지원 타입@Id 애노테이션을 적용한 대상을 제외한 나머지 영속 대상은 @Basic 에노테이션을 이용해서 설정한다. 설정하지 않은 경우 생략한 것으로 생각하면 된다.@Basic 애노테이션을 사용할 수 있는 타입으로는 자바의 기본 데이터타입 기본 데이터 타입에 대응하는 래퍼타입 BigInteger, BigDecimal String Date, Calendar Date, Time, TimeStamp enum byte[], Byte[], char[], Character[]날짜와 시간 타입은 Temporal 애노테이션과 함께 사용한다.또 열거 타입에 대한 매핑은 Enumerated 애노테이션을 사용한다.public enum Grade{ STAR1, STAR2, STAR3, STAR4, STAR5}@Entitypublic class Hotel{ @Id private String id; private String name; @Enumerated(EnumType.STRING) //EnumType.STRING : 매핑된 칼럼이 열거 타입의 상수 이름을 값으로 가질 때 사용 private Grade grade;}매핑된 컬럼이 열거 타입의 상수 이름 대신 인덱스를 저장하는 경우에는 EnumType.ORDINAL을 사용한다. 열거 타입 상수 순서는 유지보수 과정에서 변할 수 있다. 따라서 상수의 순서보다는 이름을 사용하는 것이 유리하다. EnumType.ORDINAL이 기본 값이므로 별도 설정을 추가하지 않으면 EnumType.ORDINAL을 사용하여 매핑을 처리한다.1.4 @Column 애노테이션과 이름 지정필드/프로퍼티의 이름과 테이블의 칼럼 이름이 다를 경우 @Column 애노테이션을 사용해서 컬럼 이름을 지정한다.@Entity@Table(name=\"room_info\")public class Room{ @Id private String number; private String name; @Column(name=\"description\") private String desc; //...}1.5 @Column 애노테이션을 이용한 읽기 전용 매핑 설정@Column을 사용하면 변경 내역이 DB에 반영되지 않는 읽기 전용 데이터를 설정할 수 있다.예) 자동 증가하는 id 컬럼을 갖고 있는 경우 제약을 갖는다. 새로운 객체 생성시 insert 쿼리에서 제외되어야 하고, 이 필드를 수정해도 그 값이 DB 테이블에 반영되면 안 된다.@Entity@Table(name=\"room_info\")public class Room{ @Id private String number; private String name; @Column(name=\"description\") private String desc; @Column(name=\"id\", insertable=false, updatable=false) private Long dbId;}insertable=false이면 엔티티 객체를 DB에 저장시 insert 쿼리에서 해당 값을 제외한다. (update도 마찬가지)02. 접근 타입: 영속 대상 필드와 프로퍼티@Id 애노테이션을 필드에 적용하면 JPA는 다음의 두 과정에서 데이터를 읽고 쓸 때 필드를 사용한다. 앤티티 객체에서 값을 읽어와 DB에 반영할 때 DB에서 읽어온 값을 엔티티 객체에 적용할 때매핑을 필드에만 설정할 수 있는 것은 아니다. 자바빈 방식의 프로퍼티 메서드 중 get 메서드에도 설정할 수 있다. 필드가 아닌 get 메서드에 @Id 애노테이션을 설정하면 JPA는 필드대신 get/set 메서드를 이용하여 데이터를 처리한다.예) DB에서 데이터를 읽어와 엔티티 객체에 전달할 때는 set 메서드를 이용하고, 반대로 엔티티를 DB에 반영할 때는 get 메서드를 이용해서 엔티티에서 값을 읽어온다.기본적으로 필드 접근 방식을 사용하고, 특정 영속 대상에 대해서만 프로퍼티 접근 방식을 사용해야 한다면 @Access 애노테이션을 사용한다.@Entity@Table(name=\"room_info\")public class Room { @Id private String number; private String name; @Column(name=\"description\") private String desc; @Column(name=\"id\", insertable=false, updatable=false) //AccessType.PROPERTY은 dbId에 해당하는 데이터만 필드가 아닌 프로퍼티를 통해서 접근함을 의미한다.(get/set 메서드를 통해서만 접근) @Access(AccessType.PROPERTY) private Long dbId; //... public Long getDbId() { return dbId; } private void setDbId(Long dbId) { this.dbId = dbId; }}반대로 프로퍼티 접근 타입을 기본으로 사용하고 특정 영속 대상만 필드 접근 타입을 사용하고 싶다면 get 메서드에 @Access 애노테이션을 설정하면 된다.@Entity@Table(name=\"room_info\")public class Room { //... private Long dbId; @Id public String getNumber() { return number; } public void setNumber(String number) { this.number = number; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Column(name=\"description\") public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } @Column(name=\"id\", insertable=false, updatable=false) //접근 타입이 필드라서 setDbId() 메서드를 사용하지 않는다. @Access(AccessType.FIELD) public Long getDbId() { return dbId; }}또 클래스에 @Access 애노테이션을 적용해서 접근 타입을 지정할 수도 있다. 그러면 @Id 애노테이션을 프로퍼티 메서드에 설정해야 한다.2.1 영속 대상에서 제외하기필드 접근 타입을 사용하는데 영속 대상이 아닌 필드가 존재한다면 transient 키워드를 사용해서 영속 대상에서 제외할 수 있다. 또는 JPA에서 제공하는 @Transient 애노테이션을 사용해도 영속 대상에서 제외된다.transient private long timestamp = System.currentTimeMillis();@Transientprivate long timestamp = System.currentTimeMillis();03. 엔티티 클래스의 제약 조건 엔티티 클래스는 인자가 없는 기본 생성자를 제공해야 한다. 기본 생성자의 접근 범위는 public 이나 protected이어야 한다. private의 경우 JPA의 특정 기능이 올바르게 동작하지 않을 수 있다. 엔티티는 클래스여야 한다. 인터페이스나 열거 타입을 엔티티로 지정할 수 없다. 엔티티 클래스는 final이면 안 된다. 엔티티의 메서드나 영속 대상 필드도 final이면 안 된다.04. 엔티티 목록 설정엔티티 클래스를 작성했다면 persistence.xml 파일의 태그를 사용하여 엔티티 클래스를 영속 단위에 추가한다.JPA는 영속 단위에 추가한 클래스를 엔티티로 사용한다. ....&lt;persistence-unit name=\"jpastart\" transaction-type=\"RESOURCE_LOCAL\"&gt; &lt;class&gt;jpastart.reserve.model.User&lt;/class&gt; &lt;class&gt;jpastart.reserve.model.Room&lt;/class&gt; &lt;class&gt;jpastart.reserve.model.Hotel&lt;/class&gt; &lt;exclude-unlisted-classes&gt;true&lt;/exclude-unlisted-classes&gt; ......05. EntityManager의 엔티티 관련 기본 기능5.1 find() 메서드public &lt;T&gt; T find(Class&lt;T&gt; entityClass, Object primaryKey); 첫 번째 파라미터로 찾을 엔티티의 타입을 전달하고 두 번째 파라미터로 식별자를 전달한다. 식별자가 존재하는 경우 엔티티 객체를 리턴하고, 존재하지 않는 경우 null을 리턴한다.5.2 getReference() 메서드find() 메서드와 동일한 파라미터를 갖는다. find() 메서드와 다르게 데이터가 존재하지 않는경우 EntityNotFoundException을 발생한다.//getReference()는 프록시 객체를 리턴하며, 이 시점에 쿼리를 실행하지 않는다.Hotel hotel = entityManager.getReference(Hotel.class, \"NON_HOTEL_ID\");//getName()을 통해 최초로 데이터에 접근할 때 쿼리를 실행한다.String name = hotel.getName();getReference() 메서드는 쿼리를 바로 실행하지 않고 대신 프록시 객체를 리턴한다. 이 프록시 객체는 최초로 데이터가 필요한 시점에 select 쿼리를 실행한다. 그리고 select 쿼리 결과가 존재하지 않으면 exception을 발생한다.getReference() 메서드로 구한 프록시 객체는 최초에 데이터가 필요한 시점에 쿼리를 실행하기 때문에 EntityManager 세션이 유효한 범위에서 프록시 객체를 처음 사용해야 한다. 범위 밖에서 처음 사용하게 되면 필요한 커넥션을 구할 수 없어 exception이 발생한다.5.3 persist() 메서드새로운 엔티티 객체를 DB에 저장할 때에는 persist() 메서드를 사용한다. 이 메서드는 상태를 변경하므로 트랜잭션 범위 안에서 실행해야 한다.트랜잭션 범위 안에서 persist()를 실행하면 JPA는 알맞은 insert 쿼리를 실행하는 데 insert 쿼리를 실행하는 시점은 엔티티 클래스의 식별자를 생성하는 규칙에 따라 달라진다. 직접 식별자를 설정하는 경우 트랜잭션을 커밋하는 시점에 insert 쿼리를 실행하고, auto_increment를 사용하는 경우 persist()를 실행하는 시점에 insert 쿼리를 실행한다.@Entity@Table(name=\"hotel_review\")public class Review{ @Id @GerneratedValue(strategy = GenerationType.IDENTITY) private Long id; //.....}GeneratedValue 애노테이션은 JPA가 식별자의 값을 생성한다는 것을 뜻한다.5.4 remove() 메서드remove() 메서드를 사용하면 엔티티 객체를 제거한다.try{ transaction.begin(); Room room = entityManager.find(Room.class, \"R10\"); if(room != null) { entityManager.remove(room); //영속 컨텍스트에 삭제 대상 엔티티 추가 } transaction.commit(); //커밋 시점에 delete 쿼리 실행} catch(Exception e) { transaction.rollback(); throw ex;} finally{ entityManager.close();}5.5 엔티티 수정JPA는 트랜잭션 범위에서 엔티티 객체의 상태가 변경되면 이를 트랜잭션 커밋 시점에 반영한다.try{ transaction.begin(); Room room = entityManager.find(Room.class, \"R10\"); if(room != null) { room.changeName(\"카프리\"); } transaction.commit(); //트랜잭션 범위 내에서 변경된 영속 객체를 DB에 반영} catch(Exception e) { transaction.rollback(); throw ex;} finally{ entityManager.close();}06. 식별자 생성 방식엔티티 식별자 생성 방식은 애플리케이션 코드에서 직접 생성하는 방식과 JPA가 생성(식별 칼럼 방식, 시퀀스 방식, 테이블 방식)하는 두 가지 방식이 존재한다.6.1 직접 할당 방식별도의 식별자 생성 규칙이 존재하는 경우에 적합하다. 식별자를 직접 생성하는 방식은 @Id 애노테이션을 사용해서 식별자로 사용할 영속 대상만 지정하면 끝난다.6.2 식별 칼럼 방식이 방식은 @Id 애노테이션 대상에 다음과 같은 설정을 추가한다. @GeneratedValue 애노테이션 추가 위 애노테이션 strategy 값으로 GenerationType.IDENTITY 설정자동 증감 컬럼은 insert 쿼리를 생성해야 식별자를 알 수 있다.6.3 시퀀스 사용 방식@SequenceGenerator 애노테이션을 사용해서 시퀀스 기반 식별자 생성기를 설정한다. @GeneratedValue 애노테이션의 generator 값으로 앞서 설정한 식별자 생성기를 지정한다.@Id@SequenceGenerator( name=\"review_seq_gen\", //시퀀스 생성기의 이름 지정 sequenceName=\"hotel_review_seq\", //시퀀스 이름 지정 allocationSize=1 //몇 개의 식별자를 생성할지 결정)@GeneratedValue(generator=\"review_seq_gen\")private Long id;시퀀스를 사용하는 경우 시퀀스만 사용해서 식별자를 생성할 수 있으므로 persist() 시점에 insert 쿼리를 실행하지 않고 시퀀스 관련 쿼리만 실행한다. 그리고 트랜잭션을 커밋하는 시점에 새로 추가한 엔티티를 저장하기 위한 insert 쿼리를 실행한다.allocationSize 속성 설정@SequenceGenerator 애노테이션을 사용할때 allocationSize 속성 값은 1로 설정해야 한다. 이 속성의 기본값은 50인데 이는 DB 시퀀스 사용시 문제를 유발한다.(94p 참고)6.4 테이블 사용 방식모든 DB에서 동일한 방식으로 식별자를 생성하길 원하는 경우 테이블 사용 방식을 사용하면 된다. 테이블 방식을 사용하면 먼저 식별자를 보관할 때 사용할 테이블을 생성(주요키 컬럼, 다음 식별자로 사용할 숫자 컬럼)한다.@Entitypublic class City{ @Id @TableGenerator(name=\"idgen\", //테이블 생성기 table=\"id_gen\", //테이블 지정 pkColumnName=\"entity\", //테이블 주요키 컬럼 pkColumnValue=\"city\", //주요키 컬럼에 사용할 값 valueColumnName=\"nexrid\", //생성할 식별자를 갖는 컬럼 지정 initialValue=0, //초기 값 allocationSize=1) //할당 크기 @GeneratedValue(generator=\"idgen\") private Long id;}시퀀스 사용방식과 마찬가지로 persist()를 실행하는 시점에는 식별자를 생성하기 위한 컬럼만 실행하고, 트랜잭션을 커밋하는 시점에 엔티티 객체를 저장하기 위한 insert 쿼리를 실행한다." }, { "title": "2. JPA 시작하기", "url": "/posts/02.JPA-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/", "categories": "BOOK, JPA 프로그래밍 입문", "tags": "jpa, sql", "date": "2022-12-15 21:43:38 +0900", "snippet": "01. 예제 프로젝트02. 메이븐 프로젝트 생성 및 이클립스 임포트03. 데이터베이스 생성04. 모델 클래스와 매핑 설정@Entity //1)@Table(name=\"user\") //2)public class User { @Id //3) private String email; private String name; //4) @Temporal(TemporalType.TIMESTAMP) //5) @Column(name=\"create_date\") private Date createDate; protected User() {} public User(String email, String name, Date createDate) { this.email = email; this.name = name; this.createDate = createDate; } public String getEmail() { return email; } public String getName() { return name; } public Date getCreateDate() { return createDate; }}1) @Entity : JPA에서 엔티티는 DB 테이블과 매핑되는 기본 단위이다.2) @Table : 클래스가 어떤 테이블과 매핑되는지 설정 name 속성을 이용해서 테이블 이름을 지정3) @Id : DB에서의 PK 설정, JPA에서는 식별자라 한다.4) name 필드 : name 필드의 경우 애노테이션이 없는데 이 경우에는 필드 이름과 동일한 이름의 테이블 컬럼에 매핑한다.5) Date 타입을 매핑할 땐 @Timestamp 애노테이션을 사용한다.//JPA가 EntityManager를 이용해서 식별자가 madvirus@madvirus.net에 해당하는 User 객체를 찾는다.User user = entityManager.find(User.class, \"madvirus@madvirus.net\");JPA는 테이블과 매핑된 클래스의 객체를 생성할 때 인자가 없는 기본 생성자를 사용한다. 그래서 엔티티 클래스에 기본 생성자를 추가한다.05. JPA 설정JPA 설정 파일을 작성해야한다. src/main/resources/META-INF/persistence.xml 경로에 persistence.xml를 생성한다.&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;persistence xmlns=\"http://xmlns.jcp.org/xml/ns/persistence\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence\t\thttp://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd\" version=\"2.1\"&gt; &lt;!-- transaction-type 설정을 통해 JPA 트랜잭션 타입을 지정할 수 있다. (로컬 트랜잭션 or 글로벌 트랜잭션) --&gt; &lt;persistence-unit name=\"jpastart\" transaction-type=\"RESOURCE_LOCAL\"&gt; &lt;class&gt;jpastart.reserve.model.User&lt;/class&gt; &lt;!-- 1) false로 설정시 &lt;class&gt;태그로 지정하지 않은 클래스는 관리 대상에 포함하지 않음 --&gt; &lt;exclude-unlisted-classes&gt;true&lt;/exclude-unlisted-classes&gt; &lt;properties&gt; &lt;!-- 2) 데이터베이스 연결 정보 설정 --&gt; &lt;property name=\"javax.persistence.jdbc.driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"javax.persistence.jdbc.url\" value=\"jdbc:mysql://localhost/jpastart?characterEncoding=utf8\" /&gt; &lt;property name=\"javax.persistence.jdbc.user\" value=\"jpauser\" /&gt; &lt;property name=\"javax.persistence.jdbc.password\" value=\"jpapass\" /&gt; &lt;!-- 3) 하이버네이트 설정 --&gt; &lt;property name=\"hibernate.show_sql\" value=\"true\" /&gt; &lt;property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.MySQL5InnoDBDialect\" /&gt; &lt;property name=\"hibernate.c3p0.min_size\" value=\"5\" /&gt; &lt;property name=\"hibernate.c3p0.max_size\" value=\"20\" /&gt; &lt;property name=\"hibernate.c3p0.timeout\" value=\"500\" /&gt; &lt;property name=\"hibernate.c3p0.idle_test_period\" value=\"2000\" /&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt;JPA는 영속 단위(persistence unit 별로 엔티티 클래스를 관리한다. 영속 단위는 JPA가 영속성을 관리할 단위로 영속 단위별로 매핑 대상, DB 연결 설정 등을 관리한다. 보통 한 개의 애플리케이션은 한 개의 영속 단위를 설정한다.5.1 DB 종류와 Dialecthibernate.dialect 속성은 하이버네이트가 쿼리를 생성할 때 사용할 Dialect 종류를 지정한다. 속성값으로 사용할 DBMS에 맞는 클래스 이름을 지정한면 하이버네이트가 DB 종류에 맞는 쿼리를 생성한다.06. 영속 컨텍스트와 영속 객체 개요@Entity 애노테이션이 붙은 클래스를 JPA에서는 엔티티라고 부른다. 이 엔티티는 DB에 보관되는 대상으로 JPA는 엔티티들을 영속성 컨텍스트로 관리한다.영속성 컨텍스트는 JPA가 관리하는 엔티티 객체 집합으로 영속 컨텍스트에 속한 엔티티 객체를 DB에 반영한다.보통 영속 컨텍스트는 세션 단위로 생긴다. 즉 세션 생성 시점에 영속 컨텍스트가 생성되고 세션 종료 시점에 컨텍스트가 사라진다. 응용 프로그램은 영속 컨텍스트에 직접 접근할 수 없기 때문에 EntityManager를 통해서 영속 컨텍스트와 관련된 작업을 수행한다. EntityManager를 통해서 영속 컨텍스트에 엔티티 객체를 추가하고, EntityManager를 통해서 영속 컨텍스트로부터 엔티티 객체를 구한다.07. 간단한 예제 실행public class AddUserMain { public static void main(String[] args) { //persistence.xml 파일에 명시한 영속 단위 이름을 파라미터로 보내준다. EntityManagerFactory emf = persistence.createEntityManagerFactory(\"jpastart\"); //EntityManager를 사용해서 DB 연동을 처리한다. EntityManager entityManager = emf.createEntityManager(); EntityTransation transaction = entityManager.getTransaction(); try{ //JPA는 트랜잭션 범위에서 DB를 변경을 처리하도록 제한하고 있기 때문에, 먼저 트랜잭션을 시작해야 새로운 데이터를 추가하거나 기존 데이터를 변경할 수 있다. transaction.begin(); User user = new User(\"user@user.com\", \"user\", new Date()); entityManager.persist(user); //영속 컨텍스트에 객체 추가 //정상 실행하면 트랜잭션 커밋 transaction.commit(); //커밋하는 순간 실제 DB에 반영된다. } catch(Exception ex) { ex.printStackTrace(); //문제 발생하면 트랜잭션 롤백 transaction.rollback(); } finally { //필요한 작업이 끝나면 EntityManager를 종료한다. entityManager.close(); } //애플리케이션 자체를 종료할 때는 EntityManagerFactory를 종료하여 커넥션 풀과 같은 자원을 반환받는다. emf.close(); }}08. EntityManagerF트actory 관련 보조 클래스//EntityManager를 쉽게 생성할 수 있도록 보조 클래스를 작성할 수 있다.public class EMF { private static EntityManagerFactory emf; public static void init() { emf = Persistence.createEntityFactory(\"jpastart\"); } public static EntityManager createEntityManager() { return emf.createEntityManager(); } public static void close() { emf.close(); }}public class AddUserMain { public static void main(String[] args) { EMF.init(); EntityManager em = EMF.createEntityManager(); try{ //jpa 프로그램 수행 }finally{ em.close(); } EMF.close(); }}09. 콘솔을 사용한 사용자 관리 예제public class UserMain{ private static JoinService = new JoinService(); private static GetUserService getUserService = new GetUserService(); //... public static void main(String[] args) { EMF.init(); BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); while(true) { System.out.println(\"명령어를 입력하세요.\"); String line = reader.readLine(); String[] commends = line.split(\" \"); if(commends[0].equalsIgnoreCase(\"exit\")) { System.out.println(\"종료합니다.\"); break; } else if(commends[0].equalsIgnoreCase(\"join\")){ handleJoinCommand(commands); }else if(commends[0].equalsIgnoreCase(\"view\")){ handleViewCommand(commands); }else if(commends[0].equalsIgnoreCase(\"list\")){ //... }else if(commends[0].equalsIgnoreCase(\"changename\")){ //... }else if(commends[0].equalsIgnoreCase(\"withdraw\")){ //... }else { System.out.println(\"올바른 명령어를 입력하세요.\"); } System.out.println(\"-----\"); } EMF.close(); } private static void handleJoinCommand(String[] cmd) { if(cmd.length != 3) { System.out.println(\"명령어가 올바르지 않습니다.\"); System.out.println(\"사용법: join 이메일 이름\"); return; } try{ joinService.join(new User(cmd[1], cmd[2], new Date()); System.out.println(\"가입 요청을 처리했습니다.\"); }catch(DuplcateException e) { System.out.println(\"이미 같은 이메일을 가진 사용자가 존재합니다.\"); } } private static void handleViewCommand(String[] cmd) { if(cmd.length != 2) { System.out.println(\"명령어가 올바르지 않습니다.\"); System.out.println(\"사용법: view 이메일\"); return; } Optional&lt;User&gt; userOpt = getUserService.getUser(cmd[1]); if(userOpt.isPresent()) { User user = userOpt.get(); System.out.println(\"이름 : \" + user.getName()); System.out.printf(\"생성 : %tY-%&lt;tm-%&lt;td\\n\", user.getCreateDetail()); }else { System.out.println(\"존재하지 않습니다.\"); } } //....}9.1 사용자 가입 기능 구현public class JoinService { public void Join(User user) { EntityManager em = EMF.createEntityManager(); em.getTransaction().begin(); try{ //em.find()는 식별자를 이용하여 엔티티 객체를 찾는다. User found = em.find(User.class, user.getEmail()); if(found != null) { throw new DuplicateEmailException(); } em.persist(user); em.getTransaction().commit(); }catch(Exception ex) { em.getTransaction().rollback(); throw ex; }finally{ em.close(); } }}9.2 사용자 정보 조회 기능 구현 : 단일 사용자public class GetUserService{ //getUser() 메서드는 트랜잭션 범위에서 실행하지 않는다. 수정 기능이 없고 단일 엔티티 객체를 조회하므로 트랜잭션이 필요없다. public Optional&lt;User&gt; getUser(String email) { EntityManager em = EMF.createEntityManager(); try{ User user = em.find(User.class, email); return Optional.ofNullable(user); }finally{ em.close(); } }}9.3 사용자 정보 변경 기능 구현@Entity@Table(name=\"user\")public class User { @Id private String email; private String name; @Temporal(TemporalType.TIMESTAMP) @Column(name=\"create_date\") private Date createDate; //.... public void changeName(String newName) { this.name = newName; }}public class ChangeNameService{ public void changeName(String email, String newName) { EntityManager em = EMF.createEntityManager(); try{ em.getTransaction().begin(); User user = em.find(User.class, email); if(user == null)thorw new UserNotFoundException(); //수정한 user 객체를 DB에 반영하는 코드가 없다. //JPA는 트랜잭션을 종료할 때 영속 컨텍스트에 존재하는 영속 객체의 값이 변경되었는지를 검사하여 값이 바뀐 경우 변경된 값을 DB에 반영한다. user.changeName(newName); em.getTransaction().commit(); }catch(Exception e) { em.getTransaction().rollback(); throw ex; }finally{ em.close(); } }}9.4 사용자 정보 조회 기능 구현 : 목록public class GetUserListService{ public List&lt;User&gt; getAllUsers() { EntityManager em = EMF.createEntityManager(); try{ em.getTransaction().begin(); //JPQL을 실행하기 위한 TypedQuery를 생성 아래 쿼리에서 User는 user 테이블이 아닌 User 클래스를 의미한다. TypedQuery&lt;User&gt; query = em.createQuery(\"select u from User u order by u.name\", User.class); List&lt;User&gt; result = query.getResultList(); em.getTransaction().commit(); return result; }catch(Exception ex) { em.getTransaction().rollback(); throw ex; }finally{ em.close(); } }}JPA는 SQL과 유사한 JPQL을 제공한다.JPQL은 매핑 설정을 담은 클래스를 이용해서 쿼리를 작성한다.9.5 사용자 정보 삭제 기능 구현public class WithdrawService{ public void withdraw(String email) { EntityManager em = EMF.createEntityManager(); em.getTransaction().begin(); try{ User user = em.find(User.class, email); if(user == null) { throw new UserNotFoundException(); } em.remove(user); em.getTransaction().commit(); }catch(Exception ex) { em.getTransaction().rollback(); throw ex; }finally { em.close(); } }}10. 정리JPA 프로바이더가 SQL 쿼리를 생성하기 때문에 개발자는 기본적인 추가, 조회, 삭제를 위한 SQL 쿼리를 작성하지 않아도 된다. persist() 메서드를 사용하면 자바 객체를 매핑된 테이블에 삽입하는 insert 쿼리를 실행한다.find() 메서드를 사용하면 테이블에서 데이터를 조회하는 select 쿼리를 살행하고 그 결과로부터 객체를 생성한다.주요한 특징은 엔티티에 수정이 발생하면 이를 자동으로 DB에 반영해준다는 것이다. JPA는 객체의 변경내용을 추척하여 트랜잭션 종료시 알맞게 update 쿼리를 실행해서 변경된 값을 DB에 반영한다.주의할 점으로는 높은 성능이 요구되는 SQL 쿼리가 필요한 기능은 JPA의 쿼리 생성 기능이 문제를 유발할 수 있다. 예) 대량 데이터를 배치로 처리, 복잡한 조회 쿼리가 필요할 때 등등.." }, { "title": "9. 집계함수", "url": "/posts/9.%EC%A7%91%EA%B3%84%ED%95%A8%EC%88%98/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2022-12-13 22:03:07 +0900", "snippet": "집계 함수는 다중 값을 단일 값으로 집계하는 함수다. 다중 행을 입력받아 단일 행을 반환하기 때문에 다중 행 함수로 부르기도 한다. 집계 함수는 기능과 용도에 따라 기본 함수, 통계 함수, 순위 함수, 분포 함수, 기타 함수로 구분할 수 있다.9.1 기본 함수 COUNT - 전체 행의 개수나 expr의 개수를 반환한다. 행이 없거나 모두 널이면 0을 반환한다. COUNT(*) - 전체 행의 개수를 반환COUNT(expr) - 널이 아닌 expr의 개수를 반환COUNT(DISTINCT expr) - 널이 아닌 expr의 고유한 개수를 반환 MIN - expr의 최저 값을 반환한다. COUNT 함수 이외의 기본 함수는 expr이 모두 널이면 널을 반환한다. MAX - expr의 최고 값을 반환한다. SUM - expr의 합계 값을 반환한다. expr은 숫자 값만 입력할 수 있다. AVG - expr의 평균 값을 반환 -- null 포함 여부에 따라 평균 값이 달라진다.SELECT AVG(comm) AS c1, AVG(NVL(comm, 0)) AS c2FROM empl 집계 함수를 사용한 쿼리는 WHERE 절을 만족하는 행이 없더라도 하나의 행을 반환한다.9.2 통계 함수통계 함수는 통계와 관련된 값을 집계한다. STDDEV - 표준편차를 반환 VARIANCE - expr의 분산을 반환 STATS_MODE - expr의 최빈값을 반환186~187p9.3 순위 함수순위 함수는 가상의 행을 생성하고, 가상의 행에 해당하는 순위를 반환한다. RANK - expr에 대한 순위를 반환하고, expr이 동일하면 동순위를 부여하고, 다음 순위는 동순위의 수만큼 건너뛴다. DENSE_RANK - expr에 대한 순위를 반환, expr이 동일하면 동순위를 부여하고 다음 순위는 동순위에 이어서 부여한다. CUME_DIST - expr의 누적분포 값을 반환한다. (0 &lt; y &lt;= 1) PERCENT_RANK - expr의 백분위 순위 값을 반환한다. (0 &lt;= y &lt;= 1)9.4 분포 함수 PERCENTILE_CONT - 연속 분포 모형에서 expr에 해당하는 백분위 값을 반환한다. (expr 0~1) PERCENTILE_DISC - 이산 분포 모형에서 expr에 해당하는 백분위 값을 반환한다. (expr 0~1) MEDIAN - 연속 분포 모형의 중앙값을 반환9.5 기타 함수LISTAGG : LISTAGG(measure_expr [, 'delimiter'][listagg_overflow_clause]) WITHIN GROUP(order_by_clause)measure_expr를 order_by_clause으로 정렬한 후 delimiter로 구분하여 연결한 값을 반환한다.9.6 KEEP 키워드행 그룹의 최저 또는 최고 순위 행으로 집계를 수행할 수 있다." }, { "title": "8. ORDER BY 절", "url": "/posts/8.ORDER-BY-%EC%A0%88/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2022-12-12 21:30:55 +0900", "snippet": "ORDER BY 절을 사용하면 SELECT 문의 결과를 정렬할 수 있다.8.1 기본 문법 항목 설명 ASC 오름차순(기본값) DESC 내림차순 NULLS FIRST 널을 앞쪽으로 정렬 NULLS LAST 널을 뒤쪽으로 정렬 SELECT ename, salFROM empWHERE deptno = 30ORDER BY sal;-- sal의 내림차순, comm의 오름차순 정렬SELECT ename, sal, commFROM empWHERE deptno = 30ORDER BY sal DESC, comm;-- SELECT 절의 열의 위치 지정SELECT ename, sal, commFROM empWHERE deptno = 30ORDER BY 2 DESC, comm;8.2 활용 예제조건 정렬ORDER BY 절에 DECODE 함수나 CASE 표현식을 사용하면 조건에 따라 다른 정렬 기준을 지정할 수 있다.-- job을 MANAGER, CLERK 순서로 먼저 정렬하고, sal를 오름차순으로 정렬SELECT job, salFROM empWHERE deptno = 20ORDER BY DECODE(job, 'MANAGER', 1, 'CLERK', 2), sal;-- deptno로 정렬하되 deptno가 10인 행은 sal을 내림차순, deptno가 30인 행은 comm과 sal를 오름차순으로 정렬SELECT deptno, sal, commFROM empWHERE deptno IN (10, 30)ORDER BY detpno , DECODE(deptno, 10, sal) DESC , DECODE(deptno, 30, comm) , sal;동적 정렬바인드 변수를 사용하면 정렬 순서를 동적으로 조정할 수 있다.VAR v1 NUMBER = 1;SELECT *FROM deptORDER BY DECODE(:v1, 1, dname, 2, loc);정렬 순서 조정캐릭터 셋에 따라 특수문자, 숫자, 영문, 한글의 정렬 순서가 달라질 수 있다." }, { "title": "7. WHERE 절", "url": "/posts/7.WHERE%EC%A0%88/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2022-12-10 22:10:43 +0900", "snippet": "WHERE 절을 사용하면 행을 선택하여 조회할 수 있다. WHERE 절은 FROM 절 다음에 기술하고, FROM 절이 수행된 후 수행된다. WHERE 절에서 조건은 행마다 평가되며 TRUE, FALSE, UNKOWN 중 하나의 값을 반환한다. 그리고 SELECT 문은 평가 결과가 TRUE인 행만 반환한다.7.1 비교 조건| 비교 조건 | 설명 ||———–|———–|| = | 같음 || \t\t&gt; | 큼 || \t\t&gt;= | 크거나 같음 || &lt;&gt;,!=,^= | 다름 || &lt; | 작음 || &lt;= | 작거나 같음 || ALL | 목록 전체를 비교 || ANY, SOME | 목록 일부를 비교 |비교 조건은 데이터 타입이 동일한 값을 비교해야 한다. 데이터 타입이 다르면 암시적 데이터 변환이 발생한다.7.2 논리 조건논리 조건으로 조건을 결합하거나 부정할 수 있다. AND - 조건이 모두 true인 경우 true이다. OR - 조건이 하나라도 true인 경우 true이다. NOT - true -&gt; false, false -&gt; true 로 조건을 부정한다.7.3 BETWEEN 조건expr1 [NOT] BETWEEN expr2 AND expr3 expr1이 expr2와 expr3의 범위에 해당하는 행을 반환한다.SELECT enamd, salFROM empWHERE sal BETWEEN 2500 AND 3000; -- sal &gt;= 2500 AND sal &lt;= 30007.4 IN 조건expr1 [NOT] IN (expr2 [, expr2]) expr1이 expr2의 목록에 포함되는 행을 반환한다.SELECT ename, jobFROM empWHERE job IN ('ANALYST', 'MANAGER'); -- job = 'ANALYST' OR job = 'MANAGER'-- 아래와 같이 다중 열을 사용할 수도 있다.SELECT ename, deptno, jobFROM empWHERE (deptno, job) IN ((10, 'MANAGER'), (20, 'ANALYST'));-- NOT IN 조건은 AND 조건으로 평가된다.SELECT ename, jobFROM empWHERE job NOT IN ('ANALYST', 'MANAGER'); -- job != 'ANALYST' AND job != 'MANAGER'7.5 LIKE 조건char [NOT] LIKE char2 [ESCAPE esc_char] char1이 char2패턴과 일치하는 행을 반환한다. char2에는 아래의 특수문자를 사용할 수 있다. % : 0개 이상의 문자와 일치 _ : 하나의 문자와 일치-- A로 시작하는 행 조회SELECT enameFROM empWHERE ename LIKE 'A%';-- A로 시작하고 S로 끝나는 행 조회SELECT enameFROM empWHERE ename LIKE 'A%S';-- ON이 포함된 행 조회SELECT enameFROM empWHERE ename LIKE '%ON%';-- ename의 세 번째 문자가 M이고 길이가 5자리인 행 조회SELECT enameFROM empWHERE ename LIKE '__M__;-- A가 포함되지 않은 행 조회SELECT enameFROM empWHERE ename NOT LIKE '%A%';-- 특수문자를 검색할 경우 ESCAPE 문자를 사용할 수 있다.SELECT c1FROM w1WHERE c1 LIKE '_\\%_' ESCAPE '\\';7.6 널 조건expr IS [NOT] NULL expr이 널인 행을 반환한다.SELECT ename, commFROM empWHERE comm IS NULL;SELECT ename, commFROM empWHERE comm IS NOT NULL;-- comm이 널이거나 0인 행SELECT ename, commFROM empWHERE (comm IS NULL OR comm = 0);-- NVL 함수를 사용하여 동일한 결과를 얻을 수 있다.SELECT ename, commFROM empWHERE NVL (comm, 0) = 0;LENNVL 함수 LENNVL(condition) condition이 FALSE나 UNKOWN이면 TRUE, TRUE면 FALSE를 반환SELECT ename, commFROM empWHERE LNNVL(comm &lt;&gt; 0);7.7 조건 우선순위|우선순위| 조건 ||—–|———————————-||1| 연산자 ||2| 비교조건 ||3| IN 조건, LIKE 조건, BETWEEN 조건, 널 조건 ||4| 논리조건(NOT) ||5| 논리조건(AND) ||6| 논리조건(OR) |7.8 활용 예제열 가공WHERE 절의 열을 가공하면 쿼리의 성능이 저하될 수 있다. 따라서 가급적 열을 가공하지 않는 편이 바람직하다.-- 산술 연산이 행의 개수만큼 수행된다.SELECT *FROM empWHERE sal * 12 &gt;= 36000;-- 산술 연산을 수행한 결과로 조건을 평가할 수 있다SELECT *FROM empWHERE sal &gt;= 36000 / 12;-- 결합 연산자로 열을 가공한 경우SELECT *FROM empWHERE deptno || job = '10CLERK';-- 열을 가공하지 말고 AND 조건을 사용하는 것이 좋다.SELECT *FROM empWHERE deptno = 10AND job = 'CLERK';-- ename이 A로 시작하는 행 조회-- 1) 나쁜 예SELECT *FROM empWHERE SUBSTR(ename, 1, 1) = 'A';-- 2) 바람직한 예SELECT *FROM empWHERE ename LIKE 'A%';특정 단어가 포함된 행을 조회하는 경우에는 INSTR 함수를 사용하는 편이 LIKE 조건을 사용하는 것보다 성능 측면에서 유리하다.동적 조건바인드 변수의 인수에 따라 조건이 변경되는 것을 동적 조건이라고 한다.VAR v1 NUMBER = 10;SELECT ename, deptnoFROM empWHERE deptno = :v1;VAR v2 NUMBER;SELECT ename, deptnoFROM empWHERE deptno = NVL(:v1, deptno);날짜 기간 조회날짜 값은 다양한 데이터 타입에 저장될 수 있다. 데이터 타입 값 VARCHAR2(8) YYYYMMDD 형식의 시분초가 포함되지 않은 값 VARCHAR2(14) YYYYMMDDHH24MISS 형식의 시분초가 포함된 문자 값 DATE 시분초가 포함된 DATE 값 TIMESTAMP 소수점 이하 초가 포함된 TIMESTAMP 값 " }, { "title": "6. 단일 행 함수", "url": "/posts/6.%EB%8B%A8%EC%9D%BC%ED%96%89-%ED%95%A8%EC%88%98/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2022-12-05 22:28:43 +0900", "snippet": "오라클 데이터베이스는 다양한 내장 SQL 함수를 제공한다. 단일 행 함수 - 단일 행을 입력받아 단일 행을 반환하는 함수 집계 함수 - 다중 행을 입력받아 단일 행을 반환하는 함수 분석 함수 - 다중 행을 입력받아 다중 행을 반환하는 함수 모델 함수 - MODEL 절에서 사용하는 함수단일 행 함수는 다음과 같이 구분된다. 문자 함수, 숫자 함수, 날짜 함수, 변환 함수, 널 관련 함수, 비교 함수, 인코딩 디코딩 함수, 환경 식별자 함수, 계층 함수, 컬렉션 함수, XML 함, JSON 함수6.1 문자 함수 CHR - CHR(n) n에 해당하는 데이터베이스 캐릭터 셋의 문자 값을 반환한다. LOWER - char를 소문자로 변경한다. UPPER - char를 대문자로 변경한다. INITCAP - INITCAP(char) char에 포함된 단어의 첫 글자는 대문자, 나머지는 소문자로 변경한다. LPAD - LPAD(expr1, n [,expr2]) expr1의 길이를 좌측으로 n만큼 늘린 후, 늘어난 공간을 expr2로 반복해서 채운다. RPAD - RPAD(expr1, n [,expr2]) expr1의 길이를 우측으로 n만큼 늘린 후, 늘어난 공간을 expr2로 반복해서 채운다. LTRIM - LTRIM(char [, set]) char의 좌측부터 set에 포함된 문자를 제거한다. RTRIM - RTRIM(char [, set]) char의 우측부터 set에 포함된 문자를 제거한다. TRIM - TRIM([{{LEADING TRAILING BOTH}[trim_character] trim_character} FROM] trim_source) trim_source의 좌측 또는 우측이나 양측에서 trim_character를 제거한다. SUBSTR - SUBSTR(char, position [, substring_length]) char를 position 위치에서 우측으로 substring_length 만큼 자른다. substring_length 생략시 끝까지 자르고 음수의 경우 끝에서 좌측으로 음수만큼 이동한 위치에서 우측으로 자른다. REPLACE - REPLACE(char, search_string [, replacement_string]) char에 포함된 search_string을 replacement_string으로 변경한다. TRANSLATE - TRANSLATE(expr, from_string, to_string) expr 문자와 일치하는 from_string 문자를 대응하는 위치의 to_string 문자로 변환한다. ASCII - ASCII(char) char의 아스키값을 십진수로 반환한다. INSTR - INSTR(string, substring [, position [, occurrence]]) string의 position에서 우측으로 occurrence번째 substring의 시작 위치를 반환한다. LENGTH - LENGTH(char) char의 길이를 반환한다.6.2 숫자 함수 ABS - 절대 값을 반환한다. SIGN - SIGN(n)의 부호를 반환한다. n이 양수면 1, 음수면 -1, 0이면 0 ROUND(number) - ROUND(n1[,n2]) n1을 n2자리로 반올림한다. TRUNC(number) - TRUNC(n1[,n2]) n1을 n2자리로 버린다. CEIL - CEIL(n) n보다 크거나 같은 정수의 최소값을 반환한다. FLOOR - FLOOR(n) n보다 작거나 같은 정수의 최대값을 반환한다. MOD - MOD(n1, n2) n1을 n2로 나눈 나머지를 반환한다. n2가 0이면 n1을 반환한다. REMAINDER - REMAINDER(n1, n2) n1을 n2로 나눈 나머지를 반환한다. n2가 0이면 에러가 발생한다. POWER - n1을 n2로 거듭제곱한 값을 반환한다. BITAND - exp1, exp2의 비트 AND 연산 값을 반환한다. WIDTH_BUCKET - WIDTH_BUCKET(expr, min_value, max_value, num_bucket)6.3 날짜 함수 SYSDATE - 서버의 날짜 값을 DATE 타입으로 반환한다. SYSTIMESTAMP - 소수점 이하 초가 포함된 데이터베이스 서버의 날짜 값을 TIMESTAPM WITH TIME ZONE 타입으로 반환한다. NEXT_DAY - date이후 char에 지정된 요일에 해당하는 가장 가까운 날짜 값을 반환한다. LAST_DAY - date가 속한 월의 월말일을 반환한다. ADD_MONTHS - date에서 integer의 개월 수를 가감한 날짜 값을 반환한다. MONTHS_BETWEEN - date1과 date2 사이의 개월 수를 반환한다. EXTRACT - EXTRACT({YEAR MONTH DAY HOUR MINUTE SECOND} FROM expr) expr에서 날짜 정보를 추출한다. ROUND - ROUND(date) fmt를 기준으로 date를 반올림한다. TRUNC - TRUNC(date) fmt를 기준으로 date를 버린다.6.4 변환 함수변환 함수는 값의 데이터 타입을 다른 데이터 타입으로 변환하는 함수다. TO_CHAR(number) - TO_CHAR(n[,fmt [, ‘nlsparm’]]) 숫자 값 n을 fmt 형식의 문자 값으로 변환한다. TO_CHAR(datetime) - TO_CHAP({datetime interval} [, fmt [, ‘nlsparm’]]) datetime, interval 값을 fmt 형식의 문자 값으로 변환한다. TO_NUMBER - TO_NUMBER(expr [, fmt [, ‘nlsparm’]]) fmt 형식의 expr을 숫자 값으로 변환한다. TO_DATE - TO_DATE(char [, fmt [, ‘nlsparm’]]) fmt 형식의 char를 DATE 값으로 변환한다. TO_TIMESTAPM - TO_TIMESTAPM(char [, fmt [, ‘nlsparm’]]) fmt 형식의 char를 TIMESTAMP 값으로 변환한다. TO_YMINTERVAL - 문자 값을 YEAR TO MONTH 인터벌 값으로 변환한다. TO_DSINTERVAL - 문자 값을 DAY TO SECOND 인터벌 값으로 변환한다. NUMTOYMINTERVAL - n을 YEAR TO MONTH 인터벌 값으로 변환한다. NUMTODSINTERVAL - n을 DAY TO SECOND 인터벌 값으로 변환한다. CASE - CASE(expr AS type_name [, fmt [, ‘nlsparam’]]) expr을 type_name에 지정한 데이터 타입으로 변환한다. VALIDATE_CONVERSION - VALIDATE_CONVERSION(expr AS type_name [, fmt [, ‘nlsparam’]]) expr을 type_name에 지정한 데이터 타입으로 변환할 수 있으면 1, 없으면 0, expr이 널이면 0을 반환한다.6.5 널 관련 함수 NVL - NVL(expr1, expr2) expr1이 null이면 expr2를 반환 NVL2 - NVL2(expr1, expr2, expr3) expr1이 null이 아니면 expr2, 널이면 expr3를 반환 COALESCE - null이 아닌 첫 번째 expr을 반환 NULLIF - NULLIF(expr1, expr2) expr1과 expr2가 다르면 expr1, 같으면 null을 반환6.6 비교함수 LEAST - LEAST(expr [, expr]…) expr 중 최소값을 반환, null이 입력되면 null반환 GREATEST - expr 중 최댓값을 반환, null이 입력되면 null반환6.7 인고팅 디코딩 함수 DECODE - DECODE(expr, search, result [, search, result]…[,default]) expr과 search기 일치하면 result, 모두 일치하지 않으면 default를 반환한다. DUMP - DUMP(expr [, return_fmt [, start_position [, length]]]) expr의 데이터 타입과 바이트 길이를 return_fmt 형태로 반환한다. VSIZE - expr의 바이트 크기를 반환 ORA_HASH - expr의 해시값을 반환 STANDARD_HASH - method에 지정한 해시 알고리즘으로 생성한 expr의 해시 값을 반환한다.6.8 환경 식별자 함수 USER - 로그인한 사용자의 이름을 반환 UID - 로그인한 사용자의 ID를 반환 SYS_GUID - 전역 고유 식별자를 16바이트 RAW 값으로 반환 USERENV - 현재 세션에 대한 정보를 반환 SYS_CONTEXT - SYS_CONTEXT(‘namespace’, ‘parameter’ [,length]) - namespace에 속한 parameter 값을 반환" }, { "title": "5. SELECT 문", "url": "/posts/5.SELECT%EB%AC%B8/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2022-12-02 22:58:22 +0900", "snippet": "기본 SELECT 문은 SELECT 절과 FROM 절로 구성된다. SELECT - 조회할 열이나 표현식을 기술 FROM - 조회할 테이블을 기술FROM 절이 수행된 후, SELECT 절이 수행된다.[어휘 단위] 용어 설명 예시 키워드 개별적인 SQL 요소 DISTINCT 절 SQL의 한 부분 SELECT DISTINCT 문 2개 이상의 절이 결합된 문장 SELECT DISTINCT deptno FROM emp; 5.1 SELECT 절SELECT 절에 조회할 열이나 표현식을 기술할 수 있다.5.1.1 애스터리스크SELECT절에 애스터리스크(*)를 기술하면 테이블의 전체 열이 조회된다.**SQL*Plus의 DESC 명령어로 테이블의 열 정보를 확인할 수 있다.5.1.2 열SELECT절에 조회할 열을 기술할 수 있다. 열은 쉼표로 구분한다.SELECT dname, deptno FROM dept;5.1.3 열 별칭열은 별칭을 지정할 수 있다. 별칭을 지정하면 열이나 표현식을 간결하게 사용할 수 있다. 별칭은 대소문자를 구분하지 않고, 숫자로 시작할 수 없으며, 공백이나 특수 문자를 포함할 수 없다. 그리고 “ 큰따옴표로 감싸면 제약을 회피할 수 있다.## 별칭 사용 방법SELECT deptno dept_no, dname AS dept_nm, loc AS \"Location\" FROM dept;가급적 AS 키워드를 사용하도록 하고, 큰 따옴표는 되도록 사용하지 말자5.1.4 DISTINCT 키워드SELECT 절에 DISTINCT 키워드나 UNIQUE 키워드를 기술하면 중복 행이 제거된 결과가 반환된다. ALL 키워드를 기술하면 중복 행을 제거하지 않는다.(기본 값은 ALL)5.2 FROM 절FROM 절에는 조회할 테이블을 기술할 수 있다. 테이블은 쉼표로 구분한다. 2개 이상의 테이블을 기술하면 조인이 수행된다.5.2.1 스키마테이블에 스키마를 지정하면 해당 스키마의 테이블을 조회할 수 있다. 지정하지 않는 경우 현재 사용자의 테이블, 전용 시노님, 공용 시노님 순서로 구문이 해석된다.SELECT * FROM t1;SELECT * FROM u1.t1;SELECT * FROM u2.t1;SELECT * FROM u3.t1;5.2.2 테이블 별칭테이블에도 별칭을 지정할 수 있다.SELECT a.deptno FROM dept a;5.2.3 SAMPLE 절SAMPLE 절을 사용하면 테이블을 샘플링하여 조회할 수 있다. 대용량 테이블에 대한 통계 값을 생성할 때 활용할 수 있다. BLOCK - 블록 샘플링을 사용 sample_percent - 샘플링 비율 SEED - 항상 동일한 샘플을 반환5.3 기본 요소5.3.1 리터럴리터럴은 변하지 않는 값이다.(상수와 유사) 문자 리터럴 - 문자열은 작은 따옴표를 감싸서 기술한다. 10.1버전부터 인용 방식의 문자 리터럴을 사용할 수 있다. [], {}, &lt;&gt;, ()등 사용, 리터럴은 전체 행에서 동일한 값을 반환한다.```– 문자열에 작은 따옴표를 기술하려면 작은 따옴표를 2개 연속 기술하면 된다.select ‘1!A’ AS c1, ‘2’‘B’ AS c2from dual;– 결과 1!A | 2’Bselect q’[2’B]’ AS c1, q’{[3C]}’ AS c2from dual;– 결과 2’B | [3C]* 숫자 리터럴select 1 as c1, -2 as c2, 3.4 as c3, -5.6 as c4, 1.2E2 as c5, -3.4E-2 as c6from dual;– 결과 1 | -2 | 3.4 | -5.6 | 120 | -0.034* 날짜 리터럴 - 날짜 리터럴은 날짜 값을 지정한다. DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE 리터럴을 사용할 수 있다. NLS 파라미터 설정에 따라 출력 포멧을 결정할 수 있다.ALTER SESSION SET NLS_DATE_FORMAT = “YYYY-MM-DD HH24:MI:SS”;ALTER SESSION SET NLS_TIMESTAMP_FORMAT = “YYYY-MM-DD HH24:MI:SS.FF”;ALTER SESSION SET NLS_TIMESTAMP_TZ_FORMAT = “YYYY-MM-DD HH24:MI:SS.FF TZH:TZM”;– DATE 리터럴은 연월일을 지정한다. 시분초까지 지정하려면 TO_DATE 함수를 사용해야 한다.SELECT DATE ‘2022-12-04’ AS c1, TO_DATE(‘2022-12-04 20:07:00’, ‘YYYY-MM-DD HH24:MI:SS’) AS c2FROM dual;– TIMESTAMP 리터럴은 소수점 이하 초를 지정할 수 있다.SELECT TIMESTAMP ‘2022-12-04 20:07:00.9999999999’ AS c1FROM dual;– TIMESTAMP WITH TIME ZONE 리터럴은 TIMESTAMP에 시간대 변위 값을 포함시킬 수 있다.SELECT TIMESTAMP ‘2022-12-04 20:07:00.9999999999 +09:00’ AS c1FROM dual;* 인터벌 리터럴 - 시간 간격을 지정하는 리터럴로 YEAR TO MONTH, DAY TO SECOND 리터럴을 사용할 수 있다.SELECT INTERVAL ‘99’ YEAR AS c1, INTERVAL ‘99’ MONTH AS c2, INTERVAL ‘99-11’ YEAR TO MONTH AS c3 –11월까지 지정FROM dual;SELECT INTERVAL ‘99’ DAY AS c1, INTERVAL ‘863999.999999999’ SECOND(1,9) AS c2, – SECOND만 기술한 경우 쉼표로 정밀도 지정 가능, 쉼표 앞자리는 일 정밀도, 뒷자리는 초 정밀도 INTERVAL ‘9 23:59:59.999999999’ DAY(1) TO SECOND(9) AS c3, INTERVAL ‘239:59’ HOUR(1) TO MINUTE AS c4FROM dual;DUAL 테이블 : DUAL 테이블은 Dummy 열로 구성되며 1개의 행을 가지고 있다. 리터럴 조회, 행 복제 등의 다양한 용도로 활용할 수 있다.### 5.3.2 널null은 값이 없거나 정해지지 않은 것을 의미한다. 오라클에서는 __널과 빈문자를 동일__ 하게 처리한다.### 5.3.3 연산자* 산술 연산자 - 숫자 값과 날짜 값에 대한 연산을 수행한다.– c1, c2의 결과 값은 같다. 가독성을 위해 괄호를 사용하자SELECT 1+2-34/5 AS c1, ((34)/5) AS c2FROM dual;– 날짜 값의 산술 연산에 사용되는 숫자 값은 일수로 계산된다.SELECT DATE ‘2050-01-31’ + 31 AS c1, DATE ‘2050-01-31’ + (1/24/60/60) AS c2, DATE ‘2050-01-31’ + INTERVAL ‘1’ SECOND AS c3FROM dual;–TIMESTAMP 값에 숫자 값을 연산하면 소수점 이하 초가 유실된다. 인터벌 값을 사용하면 소수점 이하 초를 유지할 수 있다.SELECT TIMESTAMP ‘2050-01-31 23:59:59.999999999’ + 31 AS c1, TIMESTAMP ‘2050-01-31 23:59:59.999999999’ + INTERVAL ‘31’ DAY AS c2FROM dual;– 날짜 값의 월 연산은 ADD_MONTHS 함수를 사용해야 한다.SELECT ADD_MONTH(DATE ‘2050-01-31’, 1) AS c1FROM dual;* 연결 연산자 - 연결 연산자는 피연산자를 연결한 문자 값을 반환한다. 문자 값이 아닌 피연산자는 문자 값으로 변환되고 널은 무시된다.SELECT 1 || NULL || ‘A’ AS c1FROM dual;– 결과 1A* 연산자 우선순위 - 표현식은 연산자 우선순위에 따라 계산된다. 우선순위가 동일한 경우 좌측부터 계산된다. 1)단항 산술 연산자(+,-), 2)다항 산술 연산자(*, /), 3)다항산술연산자(+,-), 연결연산자(||)### 5.3.4 표현식표현식은 값으로 평가될 수 있는 리터럴, 연산자, SQL 함수 등의 조합이다.__CASE 표현식__CASE 표현식을 사용하면 IF THEN ELSE 논리를 평가할 수 있다.1. 단순 CASE 표현식– expr과 comparison_expr이 일치하는 첫번째 return_expr을 반환하고, 일치하는 값이 없으면 else_expr을 반환한다.– CASE 표현식은 expr과 comparison_expr의 데이터 타입이 동일하지 않으면 에러가 발생한다.– return_expr와 else_expr도 데이터 타입이 일치해야 한다.CASE expr {WHEN comparison_expr THEN return_expr}… [ELSE else_expr]END2. 검색 CASE 표현식– condition이 TRUE인 첫번째 return_expr을 반환한다.CASE {WHEN condition THEN return_expr}… [ELSE else_expr]END### 5.3.5 슈도 칼럼슈도 칼럼은 테이블에 저장되지 않은 의사 칼럼으로 쿼리 수행 시점에 값이 결정된다.* 일반 - ROWID, ROWNUM, ORA_ROWSCN* 계층 쿼리 - LEVEL, CONNECT_BY_ISLEAF, CONNECT_BY_ISCYCLE* 시퀀스 - CURRVAL, NEXTVAL* 버전 쿼리 - VERSIONS_STARTSCN, VERSIONS_STARTTIME,...### 5.3.6 주석* 단일 행 주석 : --로 시작함* 다중 행 주석 : /* 로 시작해서 */ 로 끝남### 5.3.7 힌트힌트는 옵티마이저에 명령을 전달하는 특별한 형태의 주석이다. 힌트의 대부분은 실행계획을 수립할 때 사용되지만 일부 힌트는 SQL 문의 동작을 제어한다.* 단일 행 힌트 : --+로 시작함* 다중 행 힌트 : /*+로 시작해서 */로 끝남## 5.4 바인드 변수바인드 변수를 사용하면 쿼리의 재사용성을 높일 수 있다.VAR v1 NUMBER; – 바인드 변수 선언EXEC :v1 :=1; – 바인드 변수에 값을 할당SELECT :v1 AS c1 FROM DUAL;– 12.1 버전부터 선언한 변수에 값을 할당할 수 있는 기능이 추가되었다.VAR v1 NUMBER :=3;SELECT :v1 AS c1 FROM DUAL;```" }, { "title": "4. SQL", "url": "/posts/4.SQL/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2022-12-02 20:58:22 +0900", "snippet": "4.1 역사SQL은 관계형 데이터베이스의 표준 언어이다. 원래 이름은 SEQUEL이었다. SQL은 ANSI 표준이 늦게 정해진 탓에 RDBMS 마다 문법이 조금씩 다르다.4.2 특징SEQUEL은 구조화된 영문 질의어로 해석할 수 있고, 자연어에 가까운 프로그래밍 언어로 설계되어 프로그래머가 아니더라도 쉽게 접근할 수 있다.SELECT dname FROM dept WHERE deptno = 10;4.3 종류 SELECT - SELECT DML(Data Manipulation Language) - INSERT, UPDATE, DELETE, MERGE TCS(Transaction Control Statement) - COMMIT, ROLLBACK, SAVEPOINT, SER TRANSACTION DDL(Data Definition Language) - CREATE, ALTER, DROP, TRUNCATE, COMMIT DCL(Data Control Language) - GRANT, REVOKE SCS(Session Control Statement) - ALTER SESSION, SET ROLE4.4 처리 과정 syntax check - SQL의 문법을 검사 semantic check - 오브젝트와 권한의 존재 유무를 검사 shared pool check - shared pool의 library cache에 SQL이 저장되어 있는지 검사 optimization - SQL의 쿼리 변환과 최적화를 수행 row source generation - SQL 엔진에 의해 수행될 로우 소스를 생성4.5 수행 과정SQL은 내부적으로 복잡한 과정을 통해 수행된다. SQL의 종류에 따라 수행 과정도 다르다.46~48p" }, { "title": "3. 오라클 데이터베이스", "url": "/posts/3.%EC%98%A4%EB%9D%BC%ED%81%B4-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2022-12-01 23:20:01 +0900", "snippet": "3.1 개념오라클 데이터베이스는 오라클 사에서 개발한 ORDBMS 제품이다. 오라클 데이터베이스는 세계적으로 가장 많이 사용되고 있는 DBMS이다. 사용자 : 데이터베이스에 로그인할 수 있는 계정으로 데이터베이스 생성시 관리자 계정이 함께 생성된다. 관리자 계정은 DBA가 사용하고 개발자는 DBA가 생성한 사용자 계정으로 로그인한다. 오브젝트 : 오브젝트는 논리적 데이터 구조로, 사용자에게 종속된 오브젝트를 스키마 오브젝트(테이블, 인덱스, 뷰, 시퀀스 등..), 종속되지 않은 오브젝트를 비스키마 오브젝트(사용자, 롤, 디렉터리)라고 한다. 그리고 데이터 저장여부에 따라 세그먼트 오브젝트(테이블, 클러스터, 인덱스), 비 세그먼트 오브젝트(뷰, 시퀀스, 사용자, 롤 등..)으로 구분할 수 있다. 테이블 : 데이터를 구성하는 기본 단위로 행과 열로 구성된다. 데이터 타입 : 열은 데이터 타입을 지정할 수 있다. 데이터 무결성 : 데이터의 정확성과 일관성이 유지되고 있는 상태를 의미한다. 개체 무결성 : 엔터티의 인스턴스가 속성이나 속성의 조합으로 식별되어야 함(PK 제약조건, UNIQUE 제약조건, NOT NULL 제약조건) 참조 무결성 : 자식 엔터티의 외래 식별자가 부모 엔터티의 기본 식별자에 존재해야 함(FK 제약조건, 트리거) 범위 무결성 : 속성 값이 지정한 범위에 유효해야 함(데이터 타입, 기본값, CHECK 제약 조건) 사용자 정의 무결성 : 개체 무결성, 참조 무결성, 범위 무결성에 속하지 않는 무결성(트리거) 트랜잭션 : 트랜잭션은 함께 수행해야 하는 작업의 논리적 단위다. 원자성 : 트랜잭션의 작업은 모두 수행되거나 모두 수행되지 않아야 함 일관성 : 트랜잭션이 완료되면 데이터 무결성이 일관되게 보장되어야 함 독립성 : 트랜잭션은 다른 트랜잭션으로부터 고립된 상태로 수행되어야 함 지속성 : 트랜잭션이 완료되면 장애가 발생하더라도 변경 내용이 지속되어야 함 정적 데이터 딕셔너리 뷰 : 데이터베이스의 메타데이터를 조회할 수 있는 읽기 전용 뷰이다. 동적 성능 뷰 : 데이터베이스의 동적 정보를 조회할 수 있는 읽기 전용 뷰이다.3.2 구조오라클 데이터베이스는 운영체제에서 구동되는 응용 프로그램이다.3.2.1 데이터베이스와 인스턴스오라클 데이터베이스는 하나의 데이터베이스(데이터를 저장하는 파일의 모음)와 하나 이상의 인스턴스로 구성된다.오라클 데이터베이스는 다음의 상태를 거쳐 단계적으로 기동된다. SHUTDOWN(인스턴스가 없음) NOMOUNT(인스턴스가 시작됨) MOUNT(데이터베이스의 상태를 검사) OPEN(데이터베이스가 열림)하나의 데이터베이스와 하나의 인스턴스로 구성된 오라클 데이터베이스를 Single 서버라고 한다. 고가용성과 성능 향상을 위해 오라클 데이터베이스를 RAC(하나의 데이터베이스와 2개 이상의 인스턴스)로 구성할 수 있다.3.2.2 프로세스 구조오라클 데이터베이스의 프로세스는 백그라운드 프로세스와 서버 프로세스로 구성된다. 백그라운드 프로세스는 데이터베이스 운영에 필요한 백그라운드 작업을 수행한다. 주요 백그라운드 프로세스는 아래와 같이 동작한다.3.2.3 메모리 구조오라클 데이터베이스의 메모리는 SGA와 PGA로 구분된다. SGA는 백그라운드 프로세스와 서버 프로세스의 공유 메모리 영역으로, 인스턴스가 시작될 때 할당되고 종료될 때 해제된다. PGA는 서버 프로세스의 독점 메모리 영역으로, 서버 프로세스가 생성될 때 할당되고 종료될 때 해제된다. (36p)3.2.4 저장 구조오라클 데이터베이스는 물리 저장 구조와 논리 저장 구조가 분리되어 있다. 물리 저장 구조를 변경해도 논리 저장 구조에는 영향을 주지 않는다.물리 저장 구조는 파일로 저장되며 OS에서 확인할 수 있다. 논리 저장 구조는 오라클 데이터베이스 내부에서 관리된다. 논리 저장 구조의 단위는 아래와 같다. 블록 - 데이터를 저장하는 가장 작은 논리적 단위 익스텐트 - 논리적으로 연속된 data block의 집합 세그먼트 - 오브젝트에 할당된 익스텐트의 집합 테이블스페이스 - 세그먼크를 포함하는 데이터베이스 저장 단위3.2.5 네트워크 구조리스너는 데이터베이스 서버에서 동작하는 프로그램으로 오라클 데이터베이스의 접속을 처리한다. listener.ora 파일은 리스너의 설정 파일이다. tnsnames.ora 파일은 클라이언트의 설정 파일로 데이터베이스 서버의 접속 정보가 저장된다.3.2.6 애플리케이션 구조**커넥션과 세션 : 커넥션은 클라이언트 프로세스와 데이터베이스 인스턴스 사이의 물리적 통신 경로, 세션은 데이터베이스에 로그인한 사용자의 상태를 나타내는 논리적 객체다. 커넥션을 통해 세션이 생성된다." }, { "title": "2. 데이터 모델링", "url": "/posts/2.%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2022-11-30 22:55:22 +0900", "snippet": "2.1 데이터 모델데이터 모델은 현실 세계를 데이터베이스로 구축할 수 있도록 추상화한 것이다.예) 에스프레소, 아메리카노 &gt; 커피, 주스 &gt; 음료, 간식 &gt; 음식, 소품 &gt; 상품데이터 모델은 상세화 수준에 따라 개념 데이터 모델, 논리 데이터 모델, 물리 데이터 모델로 구분된다. 요구사항을 분석하여 개념 데이터 모델을 설계하고, 데이터베이스 모델에 따라 개념 데이터 모델을 논리 데이터 모델로 상세화한 후 DBMS에 따라 논리 데이터 모델을 물리 데이터 모델로 전환한다.2.2 E-R 모델Entity-Relationship Model은 엔티티와 관계로 데이터를 표현한다. 엔터티 타입은 인스턴스화된 엔터티의 집합이다. 엔터티는 속성으로 구성되고, 관게는 엔터티간의 연관이고 페어링의 집합이다. 페어링은 인스턴스 간의 연관이다.E-R 모델, 관계형 모델, 오라클 데이터베이스의 유사한 용어로 다음과 같다. E-R 모델 관계형 모델 오라클 엔터티 릴레이션 테이블 인스턴스 튜블 행 속성 속성 열 2.2.1 엔터티엔터티는 개체로 인식할 수 있는 데이터의 집합이다. 추상화한 개체를 엔터티로 도출한다.기본 식별자기본 식별자는 엔터티에서 인스턴스를 고유하게 식별 할 수 있는 속성이다. 엔터티는 반드시 기본 식별자를 가져야 한다. 하나의 속성으로 구성된 식별자를 단일 식별자, 2개 이상의 속성으로 구성된 식별자를 복합 식별자라고 한다.2.2.2 속성속성은 엔터티에서 관리되는 데이터의 최소 단위다. 속성은 업무적으로 분리되지 않아야하며, 하나의 속성값만 가져야 한다.도메인도메인은 속성값의 범위를 나타내며, 물리 모델에서 데이터 타입과 제약 조건으로 변환된다.2.2.3 관계관계는 엔터티간의 업무적 연관이다 하나의 엔터티는 하나 이상의 엔터티와 관계를 가질 수 있고, 관계를 가진 엔터티와 또 다른 관계를 가질 수도 있다. 연관관계가 생기면 자식 엔터티는 부모 엔터티의 기본 식별자를 상속받고, 부모 엔터티로부터 상속받은 식별자를 외래 식별자(FK)라고 한다.카디널리티카디널리티는 하나의 부모 인스턴스가 몇 개의 자식 인스턴스와 페어링될 수 있는지를 나타낸다. 1:1, 1:M, M:M 관계가 존재한다.옵셔널리티옵셔널리티는 부모 인스턴스와 자식 인스턴스의 페어링 여부를 나타낸다. 페어링되어야 하면 필수 관계, 페어링되지 않아도 되면 선택 관계를 가진다.관계 유형관계 유형은 식별 관계와 비식별 관계로 구분된다. 부모 엔터티의 기본 식별자가 자식 엔터티의 기본 식별자 속성으로 상속되면 식별 관계, 일반 속성으로 상속되면 비식별 관계다. 비식별 관계는 부모 엔터티와 자식 엔터티의 느슨한 관계를 가진다.2.2.4 예시 데이터 모델20~21p2.3 정규형정규형은 데이터 이상 현상을 제거하기 위한 관계형 모델의 설계지침이다.2.3.1 정규화정규형을 위배한 릴레이션을 정규형으로 만드는 과정을 정규화라고 한다. 1정규형 : 1정규형은 원자성과 관련이 있다. 다중 값이나. 반복 그룹을 갖는 경우 1정규형을 위반했다고 할 수 있다. 2정규형 : 2정규형은 부분 종속과 관련이 있다. 부분 종속이란 일반 속성이 식별자의 일부 속성에만 종속되는 것이다. 3정규형 : 3정규형은 이행 종속과 관련이 있다. 이행 종속은 일반 속성이 다른 일반 속성에 종속되는 것이다.2.3.2 반정규화반정규화는 성능 개선을 위해 의도적으로 데이터를 중복시키는 것이다. 정규형을 위배한 릴레이션은 데이터 무결성을 보장하기 어렵기 때문에 제한적으로 사용하는 편이 바람직하다.2.4 물리 데이터 모델|논리 데이터 모델|물리 데이터 모델||—–|——||엔터티|테이블||속성|열||도메인|데이터타입, NOT NULL 제약조건, CHECK 제약 조건||기본 식별자|PK 제약 조건||외래 식별자|FK 제약 조건|물리 데이터 모델은 DDL문을 통해 데이터베이스 오브젝트로 생성된다." }, { "title": "1. 데이터", "url": "/posts/1.%EB%8D%B0%EC%9D%B4%ED%84%B0/", "categories": "BOOK, 불친절한 SQL 프로그래밍", "tags": "sql", "date": "2022-11-29 22:47:22 +0900", "snippet": "1.1 데이터데이터에 대한 정의 해석할 수 있는 의미를 가진 기호 정성적 또는 정량적 변수 값의 집합숫자처럼 양으로 측정할 수 있는 데이터를 정량적, 텍스트나 이미지처럼 양으로 측정할 수 없는 데이터를 정성적 데이터라고 한다. 또 정량적 데이터는 구조화되어 저장되기 때문에 정형 데이터, 정성적 데이터는 비정형 데이터라고 부른다. SQL은 정형 분석에 사용되는 프로그래밍 언어이다.데이터, 정보, 지식, 지혜는 순환 관계를 가진다. 데이터를 분석하여 정보를 생성하고, 정보를 해석함으로써 지식을 축적하고, 축적한 지식에서 지혜를 얻고, 지혜를 실천함으로써 새로운 데이터가 발생하는 과정이 반복된다.1.2 데이터베이스데이터베이스는 ‘데이터를 정리해서 모아둔 것’으로 해석할 수 있다. 데이터 초기에는 파일 시스템으로 관리되었지만, 데이터 증가에 따라 데이터를 효율적으로 관리할 수 있는 방법이 필요해졌다. 이런 방법을 데이터베이스 모델이라고 한다.현재는 주로 관계형 모델이 사용되고 있다. 관계형 모델은 릴레이션에 데이터를 저장한다. 릴레이션은 2차원 형태의 표로 구성되고, 릴레이션은 튜플의 집합이고, 튜플은 속성의 집합이다.관계형 모델을 채택한 데이터베이스를 관계형 데이터베이스(RDB)라고 한다. 현재는 관계형 데이터베이스를 확장한 객체-관계형 데이터베이스가 주류를 이루고 있다.또 최근에는 NoSQL 데이터베이스도 널리 활용되고 있다. 이는 관계형 데이터베이스보다 느슨한 일관성 모델을 채택한 데이터베이스로 빅 데이터와 실시간 웹 애플리케이션 영역에 널리 활용되고 있다.1.3 데이터베이스 관리 시스템데이터베이스 관리 시스템(DBMS)은 데이터베이스를 관리하기 위한 응용 프로그램이다.1.4 IT 시스템IT 시스템은 데이터의 발생 유형과 사용 목적에 따라 운영 시스템, EDW 영역, BI 영역으로 구분된다. 운영 시스템 - 기업 운영에 필요한 데이터를 관리 EDW - 분석을 위한 데이터를 저장 BI - 기업의 효율적인 의사 결정을 지원각각의 시스템은 아래의 목적으로 운영된다. 목적에 따라 사용하는 SQL 유형 또한 다르다. OLTP - 온라인 트랜잭션 처리 ODS - 운영 데이터를 원본의 형태로 보관 DW - 운영 데이터를 통일된 형식으로 저장 DM - DW 데이터를 사용 목적에 따라 요약 OLAP - DM 데이터를 분석1.5 직종과 직무 EA - 전사 아키텍처를 설계 BA - 업무 아키텍쳐를 설계 AA - 애플리케이션 아키텍처를 설계 TA - 하드웨어 아키텍처와 네트워크 아키텍처를 설계 DA - 데이터 아키텍처를 설계" }, { "title": "23. 지속적 통합", "url": "/posts/23.%EC%A7%80%EC%86%8D%EC%A0%81-%ED%86%B5%ED%95%A9/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-11-28 20:11:47 +0900", "snippet": "지속적 통합(CI)은 팀원들이 작업 결과를 자주 통합하는 소프트웨어 개발 방식이다. 통합할 때마다 자동 빌드하여 통합 오류를 빠르게 찾아낸다.간단히 말해 CI의 기본 목적은 문제를 일으키는 변경을 가능한 한 조기에 자동으로 발견해내는 것이다.현실을 반영하고 특히 대규모 개발을 고려해 CI를 다시 정의해보면 지속적 통합은 빠르게 진화하는 복잡한 생태계 전체를 지속적으로 조립하고 테스트하는 개발 방식이다.23.1 지속적 통합이란?23.1.1 빠른 피드백 루프버그는 발견하는 시점이 늦을수록 처리 비용이 기하급수적으로 증가한다.CI는 우리가 빠른 피드백 루프를 이용하도록 유도하여 버그 비용을 최소로 줄여준다.카나리 배포를 활용하면 프로덕션에서 일어나는 문제가 확실하게 줄어든다. 프로덕션 전체에 배포하기 전에 일부에만 먼저 배포하여 초기 피드백 루프를 만들 수 있기 때문이다. 하지만 여러 가지 버전이 동시에 배포되어 있으면 호환성 문제가 생길 수 있으니 카나리 배포 자체로 문제를 일으킬 여지도 있다.버전 왜곡이라는 이 문제는 분산 시스템에서 호환되지 않는 여러 코드, 데이터, 설정 정보가 공존하는 상태를 말한다.실험과 기능 플래그도 매우 강력한 피드백 루프이다. 변경을 컴포넌트 단위로 격리한 후 프로덕션 환경에서 동적으로 켜고 끌 수 있게 하여 배포 위험을 줄여주는 기법들이다.볼 수 있고 조치할 수 있는 피드백CI가 제공하는 피드백을 많은 사람이 볼 수 있어야 한다.테스트 이력을 볼 수 있게 한 덕분에 엔지니어들은 피드백을 공유하고 협업할 수 있다. 마지막으로 CI 테스트가 제공하는 피드백은 모두 조치가 가능해야 한다. 즉 문제를 찾고 고치기가 쉬워야 한다.23.1.2 자동화개발 관련 활동들을 자동화하면 장기적으로 엔지니어링 자원을 아낄 수 있다는 건 잘 알려진 사실이다. 구글에서 변경이 체크인되는 즉시 동료 리뷰를 진행하여 오류가 스며들 가능성을 낮춘것 역시 프로세스를 코드로 정의해 자동화했기 때문이다.여러 개발 활동 중 CI는 특별히 빌드와 릴리스 프로세를 자동화한다.지속적 빌드지속적 빌드는 가장 최근의 코드 변경을 헤드에 통합한 다음 자동으로 빌드와 테스트를 수행한다. 지속적 빌드도 컴파일을 통과하더라도 테스트에 실패하면 빌드 실패로 간주한다.지속적 배포지속적 배포의 첫 번째 단계는 릴리스 자동화이다. 헤드로부터 지속해서 최신 코드와 설정 정보를 가져와서 릴리스 후보를 만들어내는 작업구조이다.릴리스 후보 : 자동화된 프로세스가 만든 서로 밀접하게 관련된 요소들로 구성된 배포 가능한 단위, 지속적 빌드를 통과한 코드, 설정정보, 기타 의존성들을 조합해 만든다.지속적 배포 : 지속해서 릴리스 후보를 조립한 다음 다양한 환경에 차례로 승격시켜 테스트하는 활동, 프로덕션까지 승격시키는 경우도 있고 그렇지 않은 경우도 있다.614~~" }, { "title": "22. 대규모 변경", "url": "/posts/22.%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%B3%80%EA%B2%BD/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-11-26 23:15:03 +0900", "snippet": "22.1 대규모 변경이란?우리 경험상 대규보 변경(LSC)는 논리적으로는 연관되어 있으나 현실적인 한계 때문에 원자적으로 서브밋할 수 없는 변경들의 집합이다.구글의 경우 LSC는 거의 항상 자동화 도구를 이용해 생성한다. LSC를 만드는 이유는 다양하지만 LSC로 인해 생성되는 변경들은 대체로 다음과 같다. 코드베이스 전반을 훑는 분석도구로 찾은 공통 안티패턴 청소 폐기 대상 API 호출 대체 저수준 인프라 개선사항 활성화 사용자들을 옛 시스템에서 새로운 시스템으로 마이그레이션LSC를 촉발하는 원인은 다양하다. 더 효율적인 프로그래밍 이디엄을 적용하거나 내부 라이브러리의 인터페이스가 바뀌었을 수 있고 잠재해 있던 문제들을 신버전 컴파일러가 찾아줘서 모두 해결해야 할 수도 있다. 구글에서 수행하는 LSC의 대다수는 기능은 거의 변경하지 않는다. 주로 명확성, 최적화, 미래 호환성 개선이 목표이다.22.2 누가 대규모 변경을 처리하나?구글에서는 LSC의 상당 비중을 인프라팀이 수행한다. 하지만 LSC 도구들과 지원 자원들은 누구나 이용할 수 있다. 이 일을 인프라팀이 수행하는 이유는 하부 시스템을 구축하고 관리하는 인프라팀들은 그 시스템을 활용하는 수만 개의 참조를 수정하는 데 필요한 도메인 지식 역시 갖추고 있다. 인프라팀이 이미 잘 아는 전문 지식을 다른 모든 팀에게 새로 배우도록 시키는 것도 비효율적이다. 합당한 보상 없이 할 일만 늘어나는 상황을 좋아할 사람은 없다. 반드시 마이그레이션해야 할 만큼 새로운 시스템이 중요하다면 비용을 조직 차원에서 부담하는 게 맞다. 대규모로 변경해야 할 시스템을 소유한 팀이 주도해야 변경을 완료하는 데 유리하다.22.3 원자적 변경을 가로막는 원인22.3.1 기술적 한계대부분의 버전 관리 시스템에서는 기능을 수행하는 비용이 변경의 크기에 비례해 커진다. 파일 수천 개를 원자적으로 커밋하기에는 메모리나 프로세싱 능력이 부족할 수 있다. 중앙집중형 버전 관리 시스템에서는 커밋 중에는 다른 사용자가 쓰기 작업을 하지 못한다. 다시 말해 거대한 커밋은 다른 사용자들의 일을 멈춰세운다.22.3.2 병합 충돌변경의 규모가 커질수록 자연스럽게 병합 시 충돌이 생길 가능성이 커진다. 버전 관리 시스템은 변경하려는 파일보다 중앙 리포지터리에 있는 파일의 버전이 높다면 수동으로 업데이트후 병합하는 기능을 제공한다. 이 일을 완벽하게 처리해주는 시스템은 없다.22.3.3 유령의 묘지유령의 묘지란 너무 오래되고 둔하고 복잡해서 아무도 손대려 하지 않는 시스템을 뜻한다.구글은 충실한 테스트가 유령의 묘지 퇴출에 아주 효과적임을 깨달았다. 소프트웨어가 철저하게 테스트된다면 변경해도 이상이 생기지 않으리라는 믿음이 생긴다.22.3.4 이질성LSC가 가능하려면 LSC에 수반되는 작업 대부분을 사람이 아니라 컴퓨터가 처리해줘야 한다. 사람과 달리 컴퓨터는 모호한 일은 잘 처리하지 못한다. 그래서 컴퓨터가 변경 코드를 정확한 위치에 올바르게 반영하려면 환경이 일관되어야 한다.22.3.5 테스트모든 변경은 테스트되어야 한다. 하지만 변경의 덩치가 커지면 제대로 테스트하기가 훨씬 어렵다. 구글의 CI 시스템은 변경이 직접적으로 영향을 주는 테스트뿐 아니라 변경된 파일들을 간접적으로 이용하는 코드의 테스트도 모두 수행한다.작고 독립적인 변경은 검증하기가 쉽다. 수정된 파일이 25개뿐이라면 근본 원인을 어렵지 않게 찾을 수 있다. 하지만 파일 10,000개가 수정됐다면 쉽지 않다.사례) 595~596p22.3.6 코드 리뷰모든 변경은 서브밋하기 전에 리뷰를 거쳐야 한다. LSC도 예외가 아니다. 거대한 커밋을 검토하기란 지루하고 번거롭고 오류가 스며들기 쉽다.사례) 597p22.4 대규모 변경 인프라22.4.1 정책과 문화구글은 수많은 소스 코드를 하나의 리포지터리에 보관하며 모든 엔지니어가 그 안의 코드 대부분을 볼 수 있다. 이러한 개방성 덕에 구글에서는 누구라도 다른 프로젝트의 파일을 수정한 후 승인 권한자에게 검토를 요청할 수 있다. 하지만 그럴때마다 변경하는 비용과 리뷰 비용이 발생한다.구글에서는 LSC 도구가 진화하면서 큰 변경을 매우 저렴하게 생성할 수 있게 되었다.최종적으로 구글은 LSC를 만들려는 팀과 개인을 위한 가벼운 승인 프로세스를 고안했다. 이 프로세스는 다양한 언어의 미묘한 특성에 익숙한 숙련된 엔지니어 그룹이 감독하며, 이때 새로 만들려는 LSC 관련 도메인 전문가를 초대한다. 프로세스의 목표는 LSC를 막은게 아니다. 오히려 변경 작성자가 구글의 기술과 인적 자원을 최대한 활용하여 가장 이상적인 변경을 생성하도록 돕는 것이다.이러한 정책과 관련하여 LSC를 둘러싼 문화적 규범에 변화가 있었다. 코드 소유자가 담당 소프트웨어에 대한 책임감을 갖는 것도 중요하지만 LSC가 구글의 소프트웨어 엔지니어링 관행을 확장하는 데 중요한 축임도 이해해야 한다.22.4.2 코드베이스 인사이트LSC를 진행하려면 코드베이스 전반을 분석할 수 있어야 한다. 텍스트 기반의 전통적인 분석은 물론 의미를 추적하는 분석도 중요하다.어떤 도구로 변경을 생성하든 인력 투입량이 코드베이스보다 느리게 커져야 한다. 달리 말하면 리포지터리가 커져도 사람이 개입하는 시간은 크게 달라지지 않아야 한다. 또한 변경 생성 도구가 코드베이스 전반을 포괄해 다룰 수 있어야 한다.22.4.3 변경 관리대규모 변경 인프라에서 가장 중요한 도구는 마스터 변경을 여러 개의 샤드로 나눈 후 테스트, 메일링, 리뷰, 커밋 단계를 독립적으로 관리해주는 도구일 것이다. 구글은 Rosie라는 도구를 사용하는데, 이는 단순 도구라기 보다 LSC를 구글 규모에서 진행할 수 있게 해주는 플랫폼이라 할 수 있다.22.4.4 테스트테스트도 대규모 변경 인프라에서 없어서는 안 될 요소이다. 테스트는 소프트웨어가 기대한 대로 동작함을 검증하는 중요한 수단이다. 사람이 작성하지 않은 변경을 적용하려 할 때 특히 중요하다.22.4.5 언어 지원구글은 LSC를 주로 언어별로 진행하며, 언어에 따라 LSC 난이도가 크게 다르다. 또 정적 타입 언어가 동적 타입 언어보다 훨씬 유리하다. 강력한 정적 분석과 컴파일러 기반 도구가 제공하는 상당한 양의 정보를 LSC 도구 제작에 활용하면 문제를 일으키는 변경을 테스트 단계까지 가기 전에 걸러낼 수 있다.마지막으로 자동 포맷터 역시 LSC 인프라에서 중요한 역할을 담당한다. 구글은 코드베이스를 읽기 좋게 만들고자 노력한다.22.5 대규모 변경 프로세스LSC 프로세스는 크게 다음의 네 단계로 이루어진다.22.5.1 권한 부여구글은 LSC 작성자에게 다음의 내용을 포함한 간단한 제안 문서를 작성해달라고 요청한다. 변경을 제안하는 이유 코드베이스 전반에 주는 예상 영향 리뷰어들이 던질만한 질문과 그에 대한 답변이 절차는 해당 변경과 관련한 기반 지식이 부족한 사람들에게 변경을 어떻게 설명할지를 다시 한번 생각해보게 하는 효과가 있다. 작성자는 또한 리팩터링될 API들의 소유자들로부터 도메인 리뷰도 받아야 한다.그런다음 전체 프로세스 감독자 10여명으로 구성된 위원회에 제안을 송부한다. 이때 위원회는 LSC에 관한 코드 리뷰 전체를 한 명의 글로벌 승인자에게 할당한다.22.5.2 변경 생성승인을 얻은 LSC 작성자는 실제로 코드를 수정하기 시작한다. 변경 생성 프로세스는 가능한 한 자동화해야 한다.우리는 사람이 읽기 편한 코드베이스를 원한다. 그래서 도구가 생성한 변경들로 되도록 사람이 생성한 코드와 비슷해야 한다. 그래서 스타일 가이드와 자동 포맷팅 도구를 적용한다.22.5.3 샤드로 나누기와 서브밋글로벌 변경을 생성했다면 작성자는 이어서 Rosie를 실행한다. Rosie는 거대한 변경을 하나 입력받아서 서브밋할 수 있는 작은 변경(샤드)들로 쪼개준다. 이때 프로젝트 경계와 소유권 규칙을 참고한다. 그런 다음 개별 샤드를 독립된 테스트-메일-서브밋 파이프라인에 태운다.테스트하기독립된 샤드 각각은 구글의 CI 프레임워크인 TAP에 의해 테스트된다. 이때 수정되는 파일들에 직간접적으로 의존하는 모든 테스트를 수행하기 때문에 때로는 CI 시스템에 큰 부담을 준다.리뷰어에게 메일 보내기Roise는 테스트를 수행하여 변경이 안전하다고 검증한 다음 적절한 리뷰어에게 메일을 보낸다.리뷰하기Rosie가 생성한 변경들도 표준 코드 리뷰 프로세스를 거쳐야 한다. 하지만 각 코드의 소유자들이 LSC를 여느 변경만큼 엄격하게 살펴보지 않는 경우가 많다. 이상적으로는 LSC 변경들도 똑같이 리뷰해야겠지만 인프라팀을 믿고 피상적인 수준으로만 살펴보고 통과시킨다.서브밋하기마지막으로 개별 변경을 커밋힌다. 메일 보내기 단계 때와 마찬가지로 변경을 리포지터리로 실제 커밋하기 전에는 다양한 프로젝트별 프리커밋 검사가 진행된다.22.5.4 마무리 청소22.6 마치며LSC는 구글 소프트웨어 엔지니어링 생태계에서 중요한 요소이다. 과거에는 한 번 결정하면 되돌릴 수 없던 설계를 LSC 덕분에 필요하면 사후에 변경할 수 있게 되었다. 설계 시 새로운 가능성을 열어준 것이다.22.7 핵심 정리 LSC 프로세스는 되돌릴 수 없다고 여기던 기술적 결정들을 다시 생각해볼 수 있게 해준다. 전통적인 리팩터링 모델은 코드 규모가 커지면 한계를 드러낸다. LSC에 성공하려면 LSC를 습관처럼 진행해야 한다." }, { "title": "21. 의존성 관리", "url": "/posts/21.%EC%9D%98%EC%A1%B4%EC%84%B1%EA%B4%80%EB%A6%AC/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-11-24 00:15:03 +0900", "snippet": "의존성 관리란 우리가 통제하지 못하는 라이브러리, 패키지, 그 외 의존성들의 네트워크를 관리하는 일을 말한다.의존성 관리와 관련이 가장 깊은 주제는 소스 버전 관리이다. 의존성 관리는 시간과 확장 양 축 모두에서 복잡도를 키운다. 소스 관리에서는 코드를 변경할 때 테스트를 수행하고 기존 코드를 손상시키지 않아야 한다. 코드베이스가 공유되어 있어 무엇이 어떻게 이용되는지 볼 수 있고 우리가 직접 빌드하고 테스트할 수 있다. 반면 의존성 관리는 우리에게 접근 권한이 없거나 속을 들여다볼 수 없는, 조직 외부에서 이루어지는 변경 때문에 일어나는 문제를 다룬다.소스 관리와 의존성 관리는 ‘이 하위 프로젝트의 개발, 업데이트, 관리를 우리 조직이 통제하는가?’ 라는 질문으로 구분지을 수 있다. 예) 리포지터리, 목표, 개발 프로세스를 팀마다 다르게 가져간다면 이 팀들이 생산하는 코드끼리의 연동과 조율은 의존성 관리에 가깝다.21.1 의존성 관리가 어려운 이유의존성 하나를 관리하는 방법이 중요한 게 아니다. 수많은 의존성들로 구성된 네트워크와 그 네트워크에 미래에 일어날 변화까지 고려해 관리하는 방법을 강구해야 한다.21.1.1 요구사항 충돌과 다이아몬드 의존성의존성 관리에서는 의존성 네트워크를 중심에 두고 생각해야 한다. 대부분의 난제는 하나의 문제에서 비롯된다 ‘의존성 네트워크상의 두 의존성 사이에서 요구사항 충돌할 때 어떻게 해결하는가?’ 이런 문제는 다양한 이유로 발생한다. 그 중 기존 버전과 호환되지 않아서일 수 있는데 대표적인 예로 다이아몬드 의존성 문제이다.요구사항 충돌 문제의 대부분은 의존성 그래프에 특정 조건을 요구하는 노드가 추가되어 일어난다.554~556p21.2 의존성 임포트하기프로그래밍 측면에서 보면 직접 처음부터 새로 짜는 것보다 기존 인프라를 재활용하는 게 분명히 더 낫다.21.2.1 호환성 약속개발 비용을 줄일 수 있다고 해서 의존성을 임포트하는 게 꼭 옳은 선택은 아니다. 특히 소프트웨어 엔지니어링 조직이라면 시간과 변경을 항시 염두에 두어야 한다.다음의 요인들을 고려하면 의존성의 유지보수 비용을 조금 더 정확하게 계산할 수 있다. 호환성이 얼마나 잘 지켜지나요? 진화가 얼마나 빠르게 이루어지나요? 변경 처리 방법은 무엇일까요? 각 버전의 지원 기간은 어떻게 되나요?C++C++ 표준 라이브러리는 거의 무한대의 하위 호환성을 제공하는 예이다. 구버전 표준 라이브러리용으로 빌드한 바이너리는 신버전에서도 빌드되고 링크된다. API 호환성뿐 아니라 바이너리 아티팩트들과의 하위 호환성도 꾸준히 제공해준다. 이를 ABI 호환성 이라 한다.GOGO 언어는 대부분의 릴리스에서 소스코드가 호환되게 해주었지만 바이너리를 그렇지 않다. GO 언어에서는 빌드한 버전이 다른 바이너리끼리는 링크할 수 없다.AbseilGO와 많이 비슷하면서 시간에 대한 경고를 추가한 버전이라고 할 수 있다. Abseil는 온전한 ABI 호환성 대신 API 호환성을 다소 제한된 형태로 약속한다. 정확하게는 호환되지 않는 API 변경도 있을 수 있으나, 이때는 반드시 새 API로 마이그레이션 해주는 자동 리팩터링 도구를 함께 제공할 것을 약속한다.BoostC++ 라이브러리인 Boost는 버전 간 호환성을 보장하지 않는다. 따라서 Boost 이용자들은 호환성 문제가 생기기 전까지만 업그레이드하는게 바람직하다.Boost의 특정 릴리스가 운 좋게 완벽하게 안정적이라서 많은 프로젝트에서 사용하기에 적합할 수 있겠지만 다른 버전과의 호환성은 우선순위가 높지 않다. 그래서 수명이 긴 프로젝트에서 Boost를 계속 최신으로 유지하려다가는 언젠가 호환성 문제를 겪을 것이다.21.2.2 임포트시 고려사항프로그래밍 프로젝트라면 의존성 임포트는 거의 공짜에 가깝다. 하지만 소프트웨어 엔지니어링으로 발을 옮기는 순간 똑같은 의존성들이 미묘하게 더 삐싸진다.구글에서 의존성을 임포트하려는 엔지니어들에게 던지는 질문 (560p)21.2.3 의존성 임포트하기 @구글구글 프로젝트들이 이용하는 의존성들의 압도적 다수를 구글이 직접 개발했다. 구글의 내부 의존성 관리의 대다수는 진정한 의존성 관리가 아니다.(설계상 소스코드 버전 관리에 해당)구글은 오픈소스 생태계나 상용 파트너사로부터 임포트하는 의존성들은 모노리포의 별도 디렉터리에 추가한다.예시 (561~563p)21.3 (이론상의) 의존성 관리안정적인 의존성 관리 체계란 시간과 규모 모든 면에서 유연해야 한다. 의존성 그래프의 어느 노드라도 영원히 변치 않으리라 가정해서는 안 된다. 마찬가지로 새로운 의존성이 더해질 일은 없으리란 기대도 금물이다.21.3.1 변경 불가(정적 의존성 모델)애초부터 변경 자체를 허용하지 않으면 기존 의존성 때문에 불안해할 일이 사라진다. 사용자 코드 동작에 영향을 주지 않는 선에서의 버그 수정만 유일하게 허용된다.변경 불가는 신생 조직에게는 적합한 모델일 수 있다. 프로젝트가 오래 살아남을수록 언제까지 유효할지를 정확하게 알 수 있는 지표가 없다.21.3.2 유의적 버전(SemVer)유의적 버전은 오늘날 의존성 네트워크를 관리하는 가장 대표적인 방법이다. SemVer는 의존성 버전을 표기하는 보편적인 방식으로 숫자 세 개로 표현한다. 메이저.마이너.패치버전을 의미하며 각각 다음과 같은 경우 증가한다. 메이저: API가 변경되어 의존성을 이용하던 기존 코드를 깨뜨릴 수 있음 마이너: 순수하게 기능 추가만 있음 패치: API에 영향을 주지 않는 내부 구현 개선과 버그 수정메이저 버전이 달라지면 일반적으로 호환성이 크게 떨어진다. 기존 기능들이 달라지거나 심지어 사라졌을 수도 있어서 이를 이용하던 모든 코드가 잠재적으로 문제를 겪을 수 있다.의존성 네트워크 전체를 대상으로 어떤 알고리즘을 수행하여 모든 버전 요구사항을 충족하는 의존성 버전을 찾는 행위를 버전 선택이라 한다. 그리고 만족스러운 버전 조합이 네트워크에 존재하지 않는 상황을 소위 의존성 지옥이라 한다.21.3.3 하나로 묶어 배포하기하나로 묶어 배포하기는 애플리케이션 구동에 필요한 의존성들을 모두 찾아서 애플리케이션과 함께 배포하는 방법이다.이 모델에서는 새로운 역할인 배포자가 등장한다. 개별 의존성의 메인데이터들은 다른 의존성들에 대해서는 거의 몰라도 된다. 더 거시적인 관리를 책임지는 배포자가 상호 호환되는 버전들을 찾고 패치하고 검증하는 일을 수행해주기 때문이다.외부 사용자 입장에서는 적당한 특정 배퐌 하나에만 의존하면 되니 매우 편리하다.21.3.4 헤드에서 지내기이 방법은 이론적으로는 멋지지만 의존성 네트워크 참여자들에게 비싼 부담을 새로 지운다는 단점이 있다. 헤드에서 지내기는 트렁크 기반 개발을 의존성 관리 영역까지 확장한 걸로 보면 된다. 소스 관리 정책인 트렁크 기반 개발을 업스트림 의존성에까지 적용한 모델이다.헤드에서 지내기는 의존성 관리에서 시간과 선택이라는 요소를 제거하려는 시도이다. 모든 컴포넌트가 항상 최신 버전에 의존하며, 의존하는 쪽에서 수용하기 어려운 형태의 변경은 절대 허용하지 않는다. 의도치 않게 API나 행위가 달라지게 하는 변경은 일반적으로 다운스트림 의존성의 CI에서 포착되므로 커밋되지 않도록 한다.헤드에서 지내기 모델에서는 더 이상 SemVer에게 이 버전은 안전할까? 라고 묻지 않는다. 대신 테스트와 CI 시스템을 이용해서 시야에 들어오는 모든 사용자들에게 안전한 지를 실험을 통해 확인한다.21.4 유의적 버전의 한계헤드에서 지내기는 트렁크 기반 개발이라는 버전 관리 방식을 토대로 하지만 확장성이 좋은지까지는 입증이 더 필요하다. 현재까지 업계 표준 의존성 관리는 유의적 버전(SemVer)이다.SemVer에서 점으로 구분한 버전 번호의 정확한 정의에 대해서 릴리스에 부여된 버전 숫자가 호환성을 확실하게 보장해주는지 알 수 없다. 간단한 버드 수정이라도 현실에서는 libbase를 설계 의도와 다르게 사용 중인 사용자 때문에 빌드가 깨질 수도 있고 단순한 API 추가 행위가 라이브러리가 엉뚱하게 동작하게 만드는 등 온갖 경우의 수가 있다. 근본적으로 자신의 API만 고려해서는 호환성에 대해 아무것도 증명할 수 없다.21.4.1 지나치게 구속할 수 있다libbase가 Foo와 Bar라는 단 두 개의 함수만 제공한다고 했을 때, 중간 단계 의존성인 liba와 libb는 모두 Foo만 사용한다. 이때 libbase의 메인테이너가 Bar에 파괴적인 변경을 진행했다. SemVer 규칙에 따라 메이저 버전을 올려야하는 상황인데 libbase 1.x에 의존 중인 liba, libb에게 SebVer 의존성 솔버는 2.x 버전은 허용하지 않을 것이다. 하지만 실제로는 2.x를 이용해도 아무런 문제가 없다. 파괴적인 변경이 있었으니 메이저 버전을 높여야 해 라는 표현을 독립적인 API 단위까지 적용하지 않는다면 지금 예처럼 정보가 손실된다.21.4.2 확실하지 않은 약속일 수 있다SemVer의 패치 버전은 내부 구현만 달라져서 이론적으로는 안전한 변경이다. 얼핏 사소해 보이는 변경도 하이럼의 법칙에서 자유로울 수 없다. 사용자 수가 늘어나면 누군가는 기존의 동작 방식에 의존하는 코드를 작성하게 된다.572~573p21.4.3 버전업 동기21.4.4 최소 버전 선택21.4.5 그래서 유의적 버전을 이용해도 괜찮은가?21.5 자원이 무한할 때의 의존성 관리현재 SemVer에 의지하는 이유는 다음의 세 가지이다. 내부 정보만 있으면 된다. 충분한 테스트를 수행할 컴퓨팅 자원, 테스트 결과를 모니터링해줄 CI 시스템이 존재하지 않아도 된다. 관행이다.특히 의존성 네트워크는 대체로 다음의 두 가지 환경에서만 만들어진다. 하나의 조직 안 OSS 생태계 안577~579p21.5.1 의존성 내보내기선한 의도로 라이브러리를 오픈 소스로 공개했는데 오히려 조직에 해를 끼치는 방식은 크게 두 가지 이다. 구현 품질이 떨어지거나 제대로 관리하지 못하면 조직의 평판을 떨어트린다.(예시 gflags 580~582p) 동기화를 유지할 수 없다면 선의의 릴리스가 엔지니어링 효율을 떨어트릴 것이다.21.6 마치며의존성 관리는 본질적으로 어렵다. 현재 의존성 네트워크를 관리하는 업계 표준 방법은 유의적 버전, 즉 SemVer이다. 하지만 SemVer는 변경에 수반되는 위험을 요약해 제공하다 보니 때로는 중요한 내용을 빠뜨린다는 한계가 있다.21.7 핵심 정리 의존성 관리보다는 되도록 버전 관리가 되도록 한다. 소프트웨어 엔지니어링 프로젝트에서 의존성 추가는 공짜가 아니다. 의존성 역시 하나의 계약이다. 주는게 있고 받는 게 있다. SemVer는 변경이 얼마나 위험할지를 사람이 추정하는 간단하지만 정보가 일부 손실되는 표현법이다. 테스트와 CI는 새로운 버전들이 잘 어울려 돌아가는지를 실제로 보여준다. SemVer 기반 패키지 관리에 최소 버전 선택 전략을 가미하면 충실성이 올라간다. 단위 테스크, 지속적 통합, 컴퓨팅 자원이 의존성 관리를 이해하고 처리하는 식에 변화를 가져올 수 있다. 의존성을 제공하는 일 역시 공짜가 아니다. 공개한 의존성을 안정성 있게 지원한다면 마음대로 수정하는 것이 어려워진다." }, { "title": "20. 정적 분석", "url": "/posts/20.%EC%A0%95%EC%A0%81-%EB%B6%84%EC%84%9D/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-11-23 01:57:09 +0900", "snippet": "정적 분석은 프로그램을 실행하지 않은 채로 소스 코드를 분석하여 버그나 안티패턴등의 잠재적인 문제를 찾아내는 것을 말한다.정적 분석은 버그 찾기 이상의 혜택을 제공한다. 구글은 정적 분석을 이용해 모범 사례를 코드에 널리 배포하고, 최신 API를 이용하게 하며, 기술 부채를 막거나 줄여준다. 또 개발자 교육에도 유용하고 코드베이스에 안티패턴이 침투하는 걸 걸러준다는 증거도 많다.20.1 효과적인 정적 분석의 특징20.1.1 확장성소프트웨어 덩치가 커지면서 분석에 걸리는 시간도 늘어나 분석 도구들은 코드량이 많아져도 결과를 제때 내놓을 수 있도록 확장성에 집중하기 시작했다.구글의 정적 분석 도구는 수십억 줄의 코드베이스를 주무를 수 있어야 한다. 이를 위해 코드를 분할하고, 점진적으로 분석하는 길을 택했다. 분석 도구가 거대한 코드베이스를 다룰 수 있게 하는 동시에 제공하는 분석 기법 측면에서의 확장성에도 신경 썼다.20.1.2 유용성분석 유용성 측면에서는 사용자들의 비용-편익 트레이드오프를 고려해야 한다. 비용이라 하면 개발 시간과 코드 품질이 될 수 있다.개발자의 시간은 소중하기 때문에 분석 보고서에서 중요한 문제를 선별하거나 강조된 문제를 수정하는 데 쓴 시간을 그 분석이 제공한 편익과 저울질해봐야 한다. 자동으로 수정할 수 있는 문제라면 뭐든 자동으로 해야 한다.분석 결과 검토 비용을 더 줄이려면 개발자 워크플로에 자연스럽게 녹이는 데도 신경 써야 한다. 하나의 워크플로에 모든 것을 유기적으로 융합시키면 분석 도구와 소스 코드가 함께 진화한다는 장점이 생긴다.20.2 정적 분석을 적용하며 깨우친 핵심 교훈20.2.1 개발자 행복에 집중하자20.2.2 정적 분석을 개발자 워크플로에 반드시 끼워 넣자구글은 정적 분석을 코드 리뷰 도구에 통합하여 핵심 워크플로에 녹였다. 구글에서는 커밋되는 모든 코드를 사전에 검토한다. 분석 결과를 살펴본 리뷰어들이 정적 분석 경고를 해결하라며 압박을 줄 수 있고, 흔한 문제를 자동으로 부각시켜주기 때문에 리뷰어의 시간도 절약시켜준다.20.2.3 사용자가 기여할 수 있도록 하자구글에는 우수한 도메인 전문가가 많다. 전문가들은 새로운 분석 도구를 만들거나 기존 도구에 검사 로직을 추가하는 식으로 기여할 수 있다.20.3 Tricorder: 구글의 정적 분석 플랫폼구글 정적 분석의 핵심에는 Tricorder가 있다. Tricorder가 이전 실패작들과 크게 다른 점은 사용자에게 가치 있는 결과만을 제공하는 데 모든 노력을 쏟았다는 것이다. Critique에 통합되어 Critique의 디프 뷰어에 회색 댓글 상자로 경고를 표시해준다.구글의 개발자 모두는 Tricorder 분석기를 직접 작성하거나 기존 분석기에 검사 항목을 추가하는 식으로 기여할 수 있다. 그러기 위해서는 다음 네 가지 조건을 충족해야 한다. 이해하기 쉬움 실행 가능 및 수정 용이 유효 거짓 양성 비율 10% 미만 코드 품질 개선에 크게 기여할 수 있는 잠재력20.3.1 도구 통합Tricorder에는 다양한 유형의 정적 분석 도구들이 통합되어 있다. (542p)20.3.2 피드백 채널 통합개발자가 얼마나 행복해하는지를 추적하고 관리하려면 분석기 사용자와 분석기 작성자를 잇는 피드백 루프를 반드시 구축해야 한다. 결과가 유용하지 않은 경우 그 이유를 분석기 작성자에게 직접 버그 형태로 전달할 수 있는 옵션도 가지고 있다.분석기의 문제 원인이 아주 간단하여 바로 고칠 수 있을 때도 있다. 분석기가 출력하는 메시지의 텍스트를 다듬는 정도로 충분한 경우다. 진단 메시지를 다듬으면 무엇이, 왜, 잘못되었고 어떻게 수정해야 하는지를 가장 적절한 지점에서 바로 설명해줄 수 있다. 그렇게 하면 개발자는 메시지를 읽고 상황을 이해할 수 있다.20.3.3 수정 제안Tricorder 검사 항목은 가능한 경우 어떻게 수정해야 하는지까지 제안을 준다.20.3.4 프로젝트별 맞춤 설정적중률 높은 분석 결과만을 보여주어 신뢰를 쌓은 다음에는 기본 분석기 외에 프로젝트별로 선택적 분석기를 추가할 수 있게 하였다. 프로젝트 단위로 설정되도록 해야 모든 팀원이 일관된 분석 결과를 받아볼 수 있다.20.3.5 프리서브밋코드 리뷰시 표시되는 정적 분석 경고를 개발자가 무시할 수도 있다. 그래서 작성 중인 변경이 커밋되지 못하게 막는 분석기를 추가하였다. 이를 프리서브밋 검사 라고 한다. 프리서브밋 검사에서는 사용자화할 수 있는 매우 간단한 빌트인 검사들을 수행한다. 또 규칙을 추가할 수도 있다.20.3.6 컴파일러에 통합문제를 워크플로의 앞단에서 알려줄 방법을 찾기 위해 구글은 정적 분석을 가능한 한 컴파일러에 통합하려 노력한다.빌드 속도가 느려지지 않도록 컴파일러 검사는 빠르게 수행되어야 한다. 그 괴에 다음의 세 가지 기준도 충족해야 한다. 쉽게 수정할 수 있음 유효 거짓 양성이 발생하지 않음 정확성 관련 문제만 보고20.3.7 코드 편집 및 브라우징 중 분석정적 분석을 통합 개발 환경에 통합할 수도 있다. 하지만 IDE에서는 분석을 빠르게 끝마쳐야 하므로 속도가 느린 분석기라면 통합하기 애매하다. 구글은 하나의 IDE를 모든 팀에 강제하지 않기 때문에 IDE와의 통합은 리뷰 프로세스에 통합하는 것보다 지저분한 경향이 있다.548p20.4 마치며정적 분석은 코드베이스를 개선하고 버그를 조기에 발견해준다. 나아가 코드 리뷰와 테스트처럼 비용이 더 많이 드는 활동에서는 기계적으로 검증할 수 없는 문제에 집중하도록 해주는 훌륭한 도구이다.20.5 핵심정리 개발자 행복에 집중하자 정적 분석을 개발자 워크플로에 반드시 포함하자(코드리뷰) 사용자가 기여할 수 있도록 하자" }, { "title": "19. Critique 구글의 코드 리뷰 도구", "url": "/posts/19.%EA%B5%AC%EA%B8%80%EC%9D%98-%EC%BD%94%EB%93%9C-%EB%A6%AC%EB%B7%B0-%EB%8F%84%EA%B5%AC/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-11-22 01:03:09 +0900", "snippet": "코드 리뷰는 소프트웨어 개발에서 없어서는 안 될 요소이다. 특히 성장하기 위해 매우 중요하다. 코드 리뷰의 가장 큰 목적은 코드베이스의 가독성과 유지보수성 개선인데 이것은 리뷰 프로세스가 뒷받침해줘야 가능한 이야기이다.구글의 자체 시스템인 Critique를 예로 삼아 어떻게 해야 성공적인 코드리뷰 도구를 도입할 수 있는지를 알아보자. Critique는 리뷰어와 작성자에게 코드 리뷰용 화면과 댓글 기능을 제공한다. 또 변경에 점수를 매겨 코드베이스에 체크인할 코드를 선별하는 게이트키핑도 지원한다.19.1 코드 리뷰 도구 원칙Critique 도구가 성공적인 이유는 코드 리뷰는 개발자 워크플로의 핵심이다라는 구글 개발 문화가 Critique에 녹아 있기 때문이다. 간결성 - Critique의 UI는 불필요한 선택을 줄여 코드 리뷰를 쉽게 진행할 수 있는 매끄러운 인터페이스를 제공한다. 신뢰 제공 - 변경들을 구글 직원 모두가 보고 리뷰할 수 있도록 공개함으로써 신뢰를 높일 수 있다. 익숙한 소통 방식 - 사용자가 댓글로 원하는 내용을 어떻게 수정하는 게 좋을지 제안할 수 있도록 하였다. 워크플로 통합 - Critique은 다른 소프트웨어 개발 도구들에 통합할 수 있는 통합 포인트를 다양하게 제공한다.19.2 코드 리뷰 흐름코드 리뷰는 소프트웨어 개발 단계 곳곳에서 이루어진다. Critique 리뷰는 변경이 코드베이스에 커밋되기 전에 진행한다.(프리커밋 리뷰) 변경 생성 - 작성자가 코드베이스의 변경을 생성하고, 스냅샷을 Critique에 업로드 -&gt; 자동 코드 분석 실행 리뷰 요청 - Critique이 디프(변경으로 인해 달라질 코드)와 코드 분석 결과를 보여준다. 작성자가 만족한다면 리뷰어에게 리뷰 요청을 한다. 댓글 달기 - 리뷰어가 Critique에서 변경 사항을 열어보고 댓글 초안 작성’미해결’ -&gt; 선택사항, 정보차원의 댓글은 ‘해결’ 변경 수정 및 댓글에 답하기 - 작성자가 피드백을 확인하여 변경을 수정하고 새로운 스냅샷을 업로드(최소한 미해결 댓글에는 모두 대응해야 한다.) 변경 승인 - 리뷰어가 변경의 모습이 맘에 들면 변경을 승인하고 ‘좋아 보임’이라고 표시한다. 변경 커밋 - 변경이 승인되었음을 Critique이 알려주면 작성자가 커밋 프로세스를 시작할 수 있다.19.2.1 알림 기능위 단계를 하나씩 통과할 때마다 Critique은 다른 지원 도구들에서 이용할 수 있게끔 알림 이벤트를 보내준다. 이 알림 덕분에 Critique은 코드 리뷰라는 본연의 기능에 집중하면서도 개발자 워크플로에 녹아들 수 있다.19.3 1단계: 변경 생성Critique에서 변경 디프를 보여주면 작성자에게는 리뷰어 역할을 스스로 해볼 기회가 주어진다. 또 가벼운 수정은 Critique 안에서 해결할 수 있고, 적절한 리뷰어를 추천해주기도 한다.19.3.1 디프, 차이점 보여주기코드 리뷰 프로세스의 핵심은 코드 변경사항 자체를 이해하는 것이다. 좋은 코드 리뷰 도구라면 반드시 변경의 디프를 효과적으로 보여줘야 한다.[Critique이 제공하는 기능] 구문강조 상호참조 공백 무시 옵션 제공 인트라라인 디프(줄바꿈이나 공백과 상관없이 문자 수준으로 분해해 차이를 보여줌) 이동 검출(코드 덩어리가 단순 이동만 한 경우에 ‘이동했음’ 이라고 표시됨)사용자는 디프를 다양한 모드로 바꿔가며 볼 수 있다. Critique은 변경에 의해 달라지는 아티팩트의 디프도 제공할 수 있게끔 커스텀 도구도 다양하게 지원한다.19.3.2 분석 결과변경의 스냅샷을 업로드하면 코드 분석이 시작된다. Critique은 변경 페이지에 분석 결과를 함께 보여준다.분석기 설명 (522p)19.3.3 긴밀한 도구 통합구글은 Piper를 토대로 다음과 같은 다양한 도구를 만들었다. Cider - 클라우드에 저장된 소스 코드를 편집하는 온라인 IDE Code Search - 코드베이스의 코드를 검색하는 도구 Tricoder - 정적 분석 결과를 보여주는 도구 Rapid - 일련의 변경을 포함하는 바이너리들을 묶어 배포하는 릴리스 도구 Zapfhahn - 테스트 커버리자 계산 도구Critique을 개발자 작업 공간에 긴밀이 통합할 수 있던 이유는 작업 공간이 어디서든 접근할 수 있는 FUSE 기반 파일 시스템에 저장되어 있는 덕분이다.19.4 2단계: 리뷰 요청변경의 상태가 맘에 들면 같은 양식을 작성해 리뷰를 요청한다. 이때 리뷰어를 선정해야 한다. 구글은 코드 리뷰 요청 메일을 발송할 때 별칭을 이용하곤 한다. 별칭을 이용하면 GwsQ라는 도구가 별칭별 설정을 보고 적절한 리뷰어를 할당해준다.Critique 역시 변경을 승인하기에 충분한 수의 리뷰어 목록을 제안해주는 기능을 제공한다. 리뷰어 선정시 고려되는 요인으로는 수정되는 코드의 소유자는? 해당 코드를 가장 잘 아는 사람은? 리뷰할 여건이 되는 사람은? GwsQ 별칭 설정19.5 3~4단계: 변경 이해하고 댓글 달기19.5.1 댓글 달기댓글 달기는 Critique 사용자가 변경 살펴보기에 이어 두 번째로 많이 하는 작업이다. 리뷰는 누구나 달 수 있고, 개인별 상태를 통해 리뷰 진행 상황을 추적할 수 있다. (526p)19.5.2 변경의 상태 이해하기Critique은 변경이 3~4단계를 반복하는 과정에서 정확히 어디 위치하는지를 명시해주는 메커니즘을 몇 가지 제공한다.‘누구 차례’ 기능리뷰 프로세스의 속도를 높이려면 내가 무언가를 해야 할 차례가 되었을 때 바로 알 수 있어야 한다. Critique은 변경별로 관심 집합을 관리하여 다음 차례가 누구인지 정의하는 데 도움을 준다.관심 집합은 변경의 진행을 막고 있는 사람들로 구성된다.대시보드와 검색 시스템528p19.6 5단계: 변경 승인(변경에 점수 매기기)구글에서 변경에 점수 매길 때 고려하는 요소 LGTM - 리뷰어가 변경을 컴토한 결과 우리 표준에 부합하며 미해결 댓글 해결 후 커밋해도 좋다라며 찍는 도장이다. 승인 미해결 댓글 수LGTM이 하나 이상, 충분한 수의 승인, 미해결 댓글이 0개라면 작성자가 변경을 커밋할 수 있다.등급 체계는 코드 리뷰 문화에 긍정적인 영향을 줬다. 리뷰어가 변경을 거부하려면 반드시 유용한 피드백을 함께 줘야 한다.19.7 6단계: 변경 커밋Critique은 변경 커밋 버튼을 제공하여, 터미널에서 별도 명령을 실행할 필요가 없도록 해준다.19.7.1 커밋 후: 변경 이력 추적Critique의 핵심은 소스 코드를 변경해 리포지터리로 커밋하기 전에 리뷰를 하는 것이다. 하지만 변경 이력을 둘러보는 도구로도 많이 쓰인다. 구글에서는 누구든 파일의 변경 이력을 볼 수 있다. 개발자들은 코드가 어떻게 진화되었는지 배우고 코드 리뷰 데이터를 취합하여 학습 자료를 만들어 내기도 한다.19.8 마치며Critique은 매끄러운 리뷰 경험을 선물하기 위해 다양한 기능을 구현하고 다른 도구들을 통합했다. 코드 리뷰에 쓰는 시간은 코드를 생산하지 못하는 시간이기 때문에 리뷰 프로세스를 최적화하면 그만큼 회사의 생산성이 개선된다.19.9 핵심 정리 신뢰와 소통이 코드 리뷰 프로세스의 핵심이다. 다른 도구와의 긴밀한 통합이 멋진 코드 리뷰 경험을 선사하는 핵심이다. 관심 집합 명시 같은 작은 워크플로 최적화로도 인터페이스가 더 명확해지고 사용자들에게 더 살갑게 다가갈 수 있다." }, { "title": "18. 빌드 시스템과 빌드 철학", "url": "/posts/18.%EB%B9%8C%EB%93%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC-%EB%B9%8C%EB%93%9C-%EC%B2%A0%ED%95%99/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-11-20 02:30:09 +0900", "snippet": "구글 엔지니어들에게 구글에서 일하면서 무엇을 가장 좋아하는지 설문조사한 결과에서 빌드 시스템이 4위에 올랐다. 구글은 엔지니어가 빠르게 안정적으로 빌드할 수 있도록 설립 초기부터 지금까지 자체 빌드 시스템을 구축하는 데 엄청나게 투자했다. 그리고 빌드 시스템의 핵심 구성요소인 Blaze는 2015년에 Bazel이라는 이름의 오픈 소스로 세상에 공개되었다.18.1 빌드 시스템의 목적빌드 시스템의 목적은 엔지니어들이 작성한 소스 코드를 기계가 읽을 수 있는 바이너리로 변환하는 것이다. 훌륭한 빌드 시스템은 일반적으로 다음의 두 가지 중요 속성을 최적화한다. 속도 - 개발자가 명령 하나로 빌드를 수행하고 몇 초 안에 결과 바이너리를 얻을 수 있어야 한다. 정확성 - 소스 파일과 기타 입력 데이터가 같다면 모든 개발자가 어떤 컴퓨터에서 빌드하더라도 항상 동일한 결과를 내어줘야 한다.빌드 시스템은 사람만 이용하는 게 아니다. 테스트 목적으로 혹은 프로덕션에 릴리스하기 위해 머신들이 자동으로 빌드를 수행하기도 한다. 자동 빌드 시스템이 워크플로에 도움을 주는 예로는 다음과 같이 있다. 사람의 개입 없이 코드가 자동으로 빌드되고 테스트된 후 프로덕션에 배포된다. 개발자 변경사항은 자동 테스트되어 코드 리뷰용으로 전달된다. 빌드나 테스트에서 문제가 생기면 변경 작성자와 리뷰어 모두 즉시 알 수 있다. 변경이 트렁크에 병합되기 전 다시 테스트되어 파괴적인 변경이 스며들기 어렵다. 엔지니어들이 한 번에 수만 개의 소스 파일을 건드리는 대규모 변경을 생성하면서도 안전하게 서브밋하고 테스트할 수 있다.18.2 빌드 시스템이 없다면?18.2.1 컴파일러로 충부한지 않나?처음에는 빌드 시스템이 절실하지 않을 수 있다. 명령줄에서 명령어를 사용해서 컴파일러를 직접 실행하거나 IDE의 메뉴를 이용해서 컴파일할 수 있다. 하지만 코드가 살짝만 늘어나도 상황이 복잡해진다. javac도 임포트한 파일이 현재 디렉터리의 하위 디렉터리에 있기만 하면 알아서 잘 찾아낸다. 하지만 다른 프로젝트와 공유하는 라이브러리처럼 파일 시스템의 다른 곳에 저장된 코드까지 찾아주지는 못한다.그리고 커다란 시스템은 각 조각을 서로 다른 프로그래밍 언어로 작성하는 경우가 드물지 않는데 조각들끼리 의존성이 거미줄처럼 얽혀서 특정 언어용 컴파일러 하나만으로는 시스템 전체를 빌드하기 어렵다.또 컴파일러는 외부 의존성을 다루는 방법을 전혀 모른다. 빌드 시스템 없이 해결하려면 필요한 라이브러리를 인터넷에서 내려받아 lib 디렉터리에 넣고 컴파일러가 이 디렉터리에서 라이브러리를 읽어가도록 설정하는 방법이 최선일 것이다. 하지만 시간이 오래 지나면 lib 디렉터리에 어떤 라이브러리들을 넣어놨는지 어디서 가져왔는지 여전히 사용중인지 잊어버리게 된다.18.2.2 셸 스크립트가 충돌한다면? 지루해진다. 코딩에 투자하는 시간만큼 빌드 스크립트에 쏟아야 한다. 느리다. 옛 버전 라이브러리에 의존하게 만드는 실수를 막으려면 빌드 스크립트가 의존성들을 매번 정확한 순서로 빌드하도록 해야 한다. 릴리스할 시간이 되어 최종 빌드를 만들기 위해 jar 명령에 건넬 인수를 모두 파악해 정리해야하고, 결과를 업로드하고, 중앙 리포지터리에도 추가해야 한다. ==&gt; 새로짜야할 스크립트가 한 무더기가 된다. 문제가 생겨 하드 드라이브가 깨졌다면? 소스코드의 버전 전부를 관리하고 있다고 해도 라이브러리들, 환경세팅 등을 똑같이 다시 하기 힘들다. 새로운 개발자가 팀에 합류할 때, 사람마다 시스템이 미묘하게 다르다. 한 사람의 컴퓨터에서는 잘 동작하던 것이 다른 사람의 컴퓨터에서는 그렇지 못한 일이 자주 생긴다. 프로젝트가 커지면서 빌드가 느려진다.18.3 모던 빌드 시스템18.3.1 핵심은 의존성이다본인이 작성한 코드를 관리하는 건 아주 간단하지만 외부 의존성 관리는 훨씬 어렵다. 의존성에는 여러 종류가 있다. 하지만 어떤 경우든 빌드 시스템을 구축하는 데는 이걸 하려면 저게 필요해 패턴이 반복되며, 이러한 의존성을 관리하는 일이 빌드 시스템 구축에서 가장 기본이 되는 작업일 것이다.18.3.2 태스크 기반 빌드 시스템셸 스크립트가 기본적인 태스크 기반 빌드 시스템이다.대부분의 모던 빌드 시스템은 셸 스크립트 대신 파일을 이용한다. 빌드 파일은 수행 방법을 기술한 파일로 대부분 엔지니어가 작성한다. 표현 방식만 다를 뿐 빌드 파일은 빌드 스크리트와 본질적으로 크게 다르지 않다. 빌드 파일들을 서로 다른 디렉터리에 만든 후 연결할 수 있다. 기존 태스크에 의존하는 새로운 태스크들을 임의의 복잡한 방식으로 쉽게 추가할 수 있다.태스크 기반 빌드 시스템의 어두운 면태스크 기반 빌드 시스템은 빌드 스트립트가 커져서 복잡해질수록 다루기가 어려워진다. 시스템은 스크립트가 무얼 하는지 알 수 없으므로 각각의 빌드 단계를 매우 보수적으로 실행할 수밖에 없고, 결국 성능 문제로 이어진다. 또 시스템은 각 스크립트가 할 일을 올바르게 수행하고 있는지 확인할 방법이 없다. 빌드 단계들을 병렬로 실행하기 어렵다 - 태스크 기반 시스템에서는 병렬로 실행해도 문제될 게 없어 보이는 태스크들마저 그렇게 하지 못하는 경우가 허다하다. 따라서 충돌의 위험을 안고 가든가, 아니면 전체 빌드를 프로세서 하나에서 스레드 하나로 수행하도록 제한해야 한다. 증분 빌드를 수행하기 어렵다 - 좋은 빌드 시스템은 작은 변경으로 전체 코드베이스를 처음부터 다시 빌드하지 않도록 증분 빌드를 수행해준다. 태스크는 무슨 일이든 할 수 있으므로 일반적으로 이미 실행됐는지를 확인할 방법이 없다. 따라서 확실하게 하려면 시스템은 빌드 때마다 모든 태스크를 다시 실행해야 한다. 스크립트를 유지보수하고 디버깅하기 어렵다 - 태스크 기반 빌드 시스템에 따라오는 빌드 스크립트 자체가 관리하기 어렵다. 태스크 기반 프레임워크에서는 성능, 정확성, 유지보수성 문제를 한꺼번에 해결할 수 있는 방법이 없다.18.3.3 아티팩트 기반 빌드 시스템더 나은 빌드 시스템을 설계하려면 한 걸음 떨어져서 바라볼 필요가 있다. 이전 시스템들의 문제는 엔지니어에게 자신의 태스크를 정의할 수 있게 하는 너무 큰 힘을 부여한게 원인이었다. 이를 해결하기 위해서는 엔지니어는 여전히 시스템에게 무엇을 빌드할지 정해줄 수 있지만, 어떻게는 시스템이 알아서 하도록 맡기도록 하는 것이다.이 길이 바로 Blaze와 Blaze에서 파생된 다른 아티팩트 기반 빌드 시스템들이 선택한 길이다. 엔지니어가 빌드할 대상들을 명시하여 명령줄에 Blaze를 실행하면 Blaze는 나머지 컴파일 단계들을 설정, 실행, 스케줄링 한다.기능적 관점아트팩트 기반 빌드 시스템과 함수형 프로그래밍은 비슷한 점이 많다. 함수형 언어에서는 수행할 계산을 설명하지만 그 계산을 정확히 언제 어떻게 수행할지에 관한 상세 내용은 컴파일러에 맡긴다. 함수형 언어로는 문제들을 병렬화하기가 아주 쉽고 정확성을 보장해준다. 빌드 시스템은 실질적으로 소스 파일을 입력으로 받아서 바이너리를 출력해주는 커다란 수학 함수와 같다.예시) Bazel의 빌드파일 492~495p빌드 프로세스를 태스크 중심에서 아티팩트 중심으로 재구성하는 일은 미묘하지만 강력하다. 프로그래머 입장에서는 유연성이 줄어드는 대신 빌드의 각 단계에서 무슨 일이 이루어지는지를 빌드 시스템이 알게 된다. 빌드 시스템은 이 지식을 활용하여 빌드 프로세스를 병렬화하고 최대한 많은 것을 재사용하여 효율을 극대화시킨다.Bazel의 또 다른 멋진 묘수들도구도 의존성으로 취급하기[빌드가 로컬 컴퓨터에 설치된 도구에 의존하는 문제] 같은 도구라도 컴퓨터에 따라 설치된 위치와 버전이 다를 수 있어 문제가 될 수 있다. 도구 역시 각 타깃에서 정의해야 하는 의존성으로 다뤄서 해결한다. 빌드에 필요한 도구를 선언하도록 해서 언제 어느 시스템에서 빌드하든 정확한 도구들이 먼저 갖춰지도록 한다. 플랫폼마다 다른 도구를 사용해야 하는 언어로 프로젝트를 진행 중이라면 문제가 심각해진다. 툴체인을 이용해 해결한다. 툴체인은 특정 플랫폼에서 각 타깃 유형을 빌드하는 데 이용하는 도구들과 속성들의 모음이다. 빌드 시스템 확장하기Bazel은 커스텀 규칙을 추가하여 타깃 종류를 확장하는 길을 열어두었다. 규칙을 정의하려면 작성자는 규칙이 요구하는 입력들과 규칙이 생성해야하는 결과물들을 선언해야 한다. 또 규칙이 생성할 액션들도 선언한다. 각 액션은 필요한 입력과 출력을 통해 다른 액션과 연결할 수 있다.환경 격리하기액션들끼리도 같은 파일을 써서 서로 충돌할 수도 있을거 같다. 하지만 Bazel은 샌드박싱 기술로 이런 충돌을 원천봉쇄했다. 이 기술을 지원하는 시스템에서는 파일시스템 샌드박스를 통해 모든 액션이 다른 액션들과 격리된다. 액션은 입력으로 선언하지 않은 파일은 읽을 수 없고, 출력으로 선언하지 않은 파일에 쓰면 액션 종료 즉시 버려진다. 심지어 액션들이 네트워크로도 서로 통신하지 못하게 막는다. 그렇기 때문에 액션끼리의 충돌은 불가능하다.외부 의존성 명확히 드러내기필요한 의존성을 직접 빌드하지 않고 외부에서 다운로드해야 하는 일이 많다. 현 워크스페이스 바깥의 파일에 의존하는 건 위험한 일이다. 이 파일들은 언제든 변경될 수 있어 빌드 시스템은 계속해서 최신 파일인지 확인해야한다. 외부 파일의 변경에 워크스페이스 내의 소스코드가 적절히 대응하지 못했다면 빌드 문제를 재현할 수 없게 된다. 외부 의존성의 소유자가 서드파티라면 잠재적으로 심각한 보안 위험에 노출된다.의존성 변경은 의식적으로 진행해야 하지만 중앙에서 한 번만 이루어져야 한다. 개별 엔지니어가 관리하거나 시스템에 의해 자동으로 이뤄지게 두면 안된다.Bazel을 포함한 일부 빌드 시스템은 외부 의존성 각각의 암호화 해시를 워크스페이스 차원의 매니페스트 파일에 기록하게 하여 이 문제를 해결했다. 이 해시를 통해 전체 파일을 소스 관리하에 두지 않고도 고유하게 식별할 수 있는 것이다. 워크스페이스에 새로운 외부 의존성이 추가될 때마다 해당 의존 파일의 해시가 매니페스트 파일에 수동으로든 자동으로든 추가된다. Bazel은 빌드가 실행되면 캐시해둔 의존 파일들의 실제 해시와 매니페스트에 정의된 예상 해시를 비교하여 둘이 다른 경우에만 파일을 다시 다운로드한다.18.3.4 분산 빌드분산 빌드란 단위 작업들을 여러 컴퓨터에 뿌려 빌드한 후 취합해 최종 결과를 만들어주는 기술이다. 빌드 단위를 충분시 작게 쪼갤 수 있다면 아무리 큰 빌드라도 원하는 시간 내에 끝마칠 수 있다.원격 캐싱가장 단순한 분산 빌드는 원격 캐시만 이용하는 형태이다. 빌드를 수행하는 모든 시스템은 원격 캐시 서비스를 참조하는 모양새이다. 빌드 시스템은 우선 원격 캐시에 해당 아티팩트가 이미 존재하는지 확인하고, 존재한다면 새로 빌드하는 대신 다운로드하고, 존재하지 않으면 직접 빌드한 후 캐시에 추가한다.원격 캐시 시스템이 제역할을 하려면 빌드 시스템이 완벽하게 재현할 수 있어야 한다. 즉 모든 타깃에 대해서 필요한 입력 집합을 결정할 수 있고, 같은 입력이 주어지면 어떤 머신에서 빌드하더라도 정확하게 같은 결과가 나와야 한다. Bazel은 이를 보장하여 원격 캐시를 지원한다.아티팩트를 다운로드하는 시간이 새로 빌드할 때보다 빨라야 원격 캐시가 의미가 있다.원격 실행원격 캐시는 진정한 분산 빌드는 아니다. 캐시가 사라지거나 전체에 영향을 주는 저수준 라이브러리를 변경한다면 여전히 모든 빌드를 로컬 컴퓨터에서 수행해야 한다. 그래서 최종 목표는 원격 실행이다. 원격 실행은 빌드를 하는 실제 작업들을 여러 워커에 나눠 수행하는 기술이다. 각 사용자의 컴퓨터에서 구동되는 빌드 도구가 중앙 빌드 마스터에 요청을 보내는 구조이다. 빌드 마스터는 요청 받은 빌드를 구성하는 액션들을 스케줄링한다.500~502p18.3.5 시간, 규모, 트레이드 오프빌드 시스템의 역할은 세월이 흐르고 규모가 커져도 코드를 쉽게 다룰 수 있게 해주는 것이다. 어떤 형태의 빌드 시스템을 이용하느냐에 따른 트레이드오프가 존재한다.쉘 스크립트응 이용하거나 도구를 직접 호출하는 DIY 방식은 코드를 오래 안고 가지 않아도 되는 가장 작은 프로젝트에나 적합하다. DIY 스크립트를 버리고 태스크 기반 빌드 시스템으로 옮겨가면 복잡한 빌드를 자동화하고 다른 컴퓨터에서 빌드를 재현하기 쉬워 프로젝트의 확장성이 극적으로 좋아진다. 이때 트레이드오프틑 빌드의 구조를 더 깊게 고민해야 하며 빌드 파일을 직접 작성해야 한다는 것이다.프로젝트가 커지면 태스크 기반 빌드 시스템의 문제가 드러나기 시작한다. 이 문제는 아티팩트 기반 빌드 시스템으로 해결할 수 있다. 아티팩트 기반 빌드 시스템은 거대한 빌드를 여러 컴퓨터에 분산할 수 있게 하여 프로젝트의 규모를 또 다른 차원으로 키워준다. 이때의 트레이트오프는 유연성이다.18.4 모듈과 의존성 다루기아티팩트 기반 빌드 시스템을 이용하는 프로젝트는 여러 개의 모듈로 나눠지며 각 모듈은 다른 모듈과의 의존 관계를 BUILD 파일에 기술하게 된다. 모듈과 의존성을 어떻게 구성하느냐가 빌드 시스템의 성능과 감당할 수 있는 작업량에 지대한 영향을 준다.18.4.1 작은 모듈 사용과 1:1:1 규칙자바 같은 언어는 언어 차원에서 견고한 패키징 개념을 지원하여 각 디렉터리가 보통 하나의 패키지, 타깃, BUILD 파일을 갖는다. Pants에서는 이를 1:1:1 규칙이라 부른다.프로젝트 규모가 커지면 작은 빌드 카깃의 효과가 나타나기 시작한다. 분산 빌드가 더 빨라지며 타깃을 다시 빌드하는 빈도는 줄어든다. 테스트까지 고려하면 장점이 더욱 커진다.18.4.2 모듈 가시성 최소화가시성이란 자신에게 의존할 수 있는 타깃의 범위를 지정하는 속성이다. 가시성이 public으로 지정된 타깃은 워크스페이스 내의 모든 타깃이 참조할 수 있다. 가시성이 private이면 같은 BUILD 파일에 정의된 타깃과 허용목록에 명시된 타깃만이 참조할 수 있다.대부분의 프로그래밍 언어에서와 마찬가지로 가시 범위는 가능한 한 좁히는 게 좋다.18.4.3 의존성 관리내부 의존성큰 프로젝트를 작은 모듈들로 나누면 의존성 대부분이 내부 모듈 사이에서 만들어진다. 즉 의존하는 타깃 대부분이 같은 소스 리포지터리에서 정의되고 빌드된다. 또 하나의 타깃과 그 타깃이 만들어내는 모든 내부 의존성은 언제나 같은 커밋/리비전에서 빌드된다. (내부 의존성에는 버전이란 개념이 없다는 것을 의미)내부 의존성과 관련하여 주의할 점으로 전이 의존성 을 어떻게 취급하느냐이다. 예) A-&gt;B-&gt;C 에서 A는 C의 정의된 심볼을 모두 볼 수 있다.Blaze도 이를 허용했었으나 구글이 성장하며 문제가 생기기 시작했다. B를 리팩터링하여 C에 대한 의존성을 제거하는 경우 A가 동작하지 않게 된다. 그래서 구글은 엄격한 전이 의존성 모드를 도입하여 이 문제를 해결했다. 직접 의존하지 않는 심볼을 참조하는 타깃이 검출되면 빌드가 실패하게된다.외부 의존성외부 의존성은 빌드 시스템 바깥에서 빌드되고 저장되어 있는 아티팩트를 말한다. 외부 의존성은 소스코드로부터 빌드하는 대신 아티팩트 리포지터리에서 직접 가져와 그대로 이용한다. 내부 의존성과의 차이는 버전이 있고, 버전이 소스코드와 독립적으로 매겨진다는 점이다.자동 vs 수동 의존성 관리빌드 시스템에서 외부 의존성을 수동으로 관리할 경우 아티팩트 리포지터리에서 다운로드할 버전을 빌드 파일에 명시해야 한다. 자동으로 관리할 때는 소스 파일에 호환 버전의 범위를 명시하고, 빌드 시스템이 범위 안에서 가장 최신 버전을 다운로드해준다.자동 의존성 관리는 작은 프로젝트에서는 편리하지만 큰 프로젝트에서는 위험하다. 자동 관리의 문제는 의존성의 버전이 언제 업데이트되는지를 통제할 수 없다는 것이다. 이와 달리 수동으로 관리할 때는 변경을 버전관리 할 수 있다.원-버전 규칙같은 라이브러리라도 버전이 다르면 일반적으로 다른 아티팩트로 표현한다. 여러 버전을 허용할 때의 가장 큰 문제는 다이아몬드 의존 관계가 만들어진다는 것이다. 원-버전 규칙은 이러한 충돌을 원천봉쇄하고 타깃에 서드파티 라이브러리를 의존성으로 추가해도 기존의 의존성 모두 같은 버전을 가리키기 때문에 평화롭게 공존할 수 있다.전이 외부 의존성여러 아티팩트 리포지터리에서는 아티팩트가 리포지터리 내의 다른 아티팩트의 특정 버전에 의존하는 걸 허용한다. Maven, Gradle 같은 빌드 도구는 기본적으로 전이 의존성을 재귀적으로 다운로드한다. 프로젝트에 추가한 의존성 하나가 수십개의 아티팩트를 다운로드하게 만들 수 있는 것이다. 하지만 단점으로는 둘 이상의 라이브러리가 똑같은 서드파티 라이드러리의 상이한 버전을 사용할 가능성이 있다. 필연적으로 원-버전 규칙을 위배하여 다이아몬드 의존성 문제를 낳을 수 있는 방식이다.이런 이유로 Bazel은 전이 의존성을 자동으로 다운로드하지 않는다. Bazel은 전역 파일 하나에 리포지터리의 외부 의존성 모두와 그 각각이 이용하는 의존성의 정확한 버전을 전부 기록하게 한다. 그리고 Maven 아티팩트들의 전이 의존성을 추적하여 이 파일을 자동으로 생성해주는 도구를 제공한다. 이 도구로 프로젝트 초기 워크스페이스 파일을 한 번 생성해두고, 이후로는 수작업으로 각 의존성 버전을 조정하면 된다.외부 의존성을 이용해 빌드 결과 캐시하기외부 의존성이라 하면 보통 서드파티에서 제공하는 안정된 버전의 라이브러리이다. 조직에 따라 직접 개발한 코드 일부를 아티팩트 형태로 공유하여 마치 서드파티 라이브러리처럼 사용하기도 한다. 아티팩트를 직접 빌드하기보다 다운로드하는 게 빠르다면 빌드 속도를 높여줄 수 있는 방법이다.빌드가 오래걸리는 아티팩트들은 원격 캐시를 지원하는 빌드 시스템을 이용해 대처하는 게 더 낫다.외부 의존성의 보안과 안정성[서드파티 아티팩트의 위험성] 가용성 위험 - 서드파티 아티팩트 리포지터리에 접속할 수 없게 되면 외부 의존성을 다운로드할 수 없어 빌드 전체가 멈춘다. 보안 위험 - 공격자가 서드파티 시스템을 점령하면 우리 빌드 결과에 악성 코드를 심을 수 있다.이 문제를 해결하는 방법으로는 필요한 모든 아티팩트를 통제할 수 있는 서버에 미러링해놓고, 서드파티 아티팩트 리포지터리를 이용하지 못하게 하면 된다. 또는 프로젝트에 필요한 의존성을 복사하여 프로젝트에 포함시키는 방법도 있다.18.5 마치며때로는 엔지니어의 힘과 유연성을 제한해야 생산성을 높일 수 있다. 구글에서 선택한 방법은 엔지니어로부터 빌드 수행 방식을 정의할 수 있는 자유를 빼앗는 것이다. 개인의 선택을 제한하고 가장 중요한 결정을 자동화 도구에 위임했다.그리고 태스크 기반 빌드 시스템과 대조되는 아티팩트 기반 빌드 시스템을 만들어내어 빌드를 구글 규모의 조직으로까지 확장할 수 있었다.아티팩트 세계에서 의존성을 관리하는 방법은 작은 모듈 방식이 굵직한 모듈 방식보다 잘 확장됨 이다.그리고 의존성의 버전 관리가 얼마나 어려운지 깨닫고 원-버전 규칙을 지켜 모든 의존성의 버전을 수동으로 명시해야한다는 결론이 도달했다.18.6 핵심 정리 조직이 성장해도 개발자들의 생산성을 유지하려면 제대로된 빌드 시스템이 반드시 필요하다. 빌드 시스템에 적절한 제한을 두면 개발자가 더 편하게 일할 수 있다. 아티팩트 중심으로 구성된 빌드 시스템은 확장성과 안정성이 모두 뛰어나다. 아티팩트와 의존성을 정의할 때 모듈은 작게 나누는 게 유리하다.(병렬빌드와 증분 빌드의 이점을 더 잘 활용한다.) 외부 의존성의 버전도 명확하게 버전관리 해야한다." }, { "title": "17. Code Search", "url": "/posts/17.CodeSearch/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-11-17 18:36:22 +0900", "snippet": "Code Search는 구글이 이용하는 코드 브라우징 및 검색 도구로 프런트엔드 UI와 다양한 백엔드 요소로 이루어져 있다. 구글의 거대한 코드베이스를 감당하며 쉽게 확장할 수 있는 도구가 필요해서 만들어졌다.Code Search는 대규모 코드를 읽고, 이해하고, 탐색하는 데 최적화되었다. 이를 위해 클라우드 기반 백엔드를 적극 활용하여 콘텐츠를 찾고 상호참조를 식별해낸다.17.1 Code Search UICode Search UI의 핵심 요소는 당연히 검색창이다. 웹 검색처럼 타이핑을 시작하면 제안 기능이 작동하여 개발자가 파일, 심볼, 디렉터리로 빠르게 찾아 들어갈 수 있다. 검색 자체는 성능 좋은 파일에서 찾기 정도로 생각할 수 있다. 여기에 관련성 랭킹과 코드 강조, 범위 인식, 주석 및 문자열 인식 같은 개선이 더해져 있다.또 Code Search는 Piper와도 통합되어 있어서 파일의 변경 이력도 보여준다. 파일의 이전 버전을 확인하고, 어디가 변경되었는지, 누가 작성했는지 확인할 수 있다.17.2 구글 개발자가 Code Search를 이용하는 방법Code Search와 비슷한 기능을 제공하는 다른 도구들도 있지만 구글 개발자들은 검색하고 파일 내용을 살펴보기 위해 무엇보다 코드를 이해하기 위해 Code Search UI를 적극 활용한다. 구글 개발자가 Code Search로 하려는 일은 코드에 대한 답을 찾고 코드의 의도를 분명하게 이해하는 것이다.17.2.1 어디에?Code Search는 두 가지 방식으로 도와준다. 결과에 랭킹을 매겨 보여주고 표현력 좋은 질의어를 제공하는 것이다. 결과를 동료과 공유하기 쉽게 해준다.17.2.2 무엇을?Code Search 사용량의 1/4은 전통적인 파일 브라우징에 쓰인다. 코드 베이스의 이 부분이 무슨 일을 하는가?라는 질문에 답하는 거라 볼 수 있다.17.2.3 어떻게?약 1/3을 차지하는 쓰임은 다른 사람이 어떻게 썼는지를 보는 것이다. 특정 문제에 이용할 라이브러리를 찾은 다음, 그 안에서 가장 적합한 구현을 선택하게 도와준다.17.2.4 왜?Code Search 사용량의 약 16%는 이 코드가 왜 추가되었나? 혹은 왜 이런식으로 동작하지?의 답을 찾는 것이다. 여기서 특정 시점에서 코드베이스의 정확한 상태를 찾고 탐색할 수 있는 기능이 중요하다.17.2.5 누가 언제?Code Search 사용량의 약 8%는 특정 코드 조각을 누가 언제 추가했는지를 찾는데 쓰인다. 이때는 버전 관리 시스템과 연계해 동작한다.17.3 독립된 웹 도구로 만든 이유다른 회사에서는 Code Search의 기능 대부분을 로컬 IDE에서 수행한다. 구글은 왜 독립된 도구로 만들었을까?17.3.1 대규모 코드베이스 지원구글의 코드베이스가 너무 거대해서 코드베이스 전체를 로컬로 복사하는 게 불가능하다. 로컬에서 감당할 수 있는 규모라 해도 로컬 검색과 상호참조 인텍스를 생성하느라 IDE 구동 시간이 느려져서 개발자 생산성을 떨어드린다. 반면 인덱스를 중앙에서 생성할 경우 한 번만 해두면 모두에게 혜택이 돌아온다. 변경된 코드가 서브밋되면 변경된 파일들의 인덱스만 갱신하면 되므로 전역 인덱스는 병렬로 따로 갱신할 수 있다.상호참조 인덱스는 같은 방식으로 즉각 갱신할 수가 없다. 상호참조 인덱스를 만드는 데 매일 막대한 컴퓨팅 자원을 사용한다.17.3.2 설정 없이 모든 코드 보기Code Search의 웹 UI는 아무런 설정(프로젝트 설명, 빌드 환경) 없이도 이용할 수 있다. 어디에서 등장하는 코드든 상관없이 매우 쉽고 빠르게 찾아 검토할 수 있다.17.3.3 기능 특화IDE가 아니기 때문에 편집이 아닌 코드 탐색과 이해에 사용자 경험을 최적화할 수 있었다.17.3.4 다른 도구에 통합소스 코드 관련 정보를 회부에 제공하는 플랫폼으로 자리 잡았다. 예1) Code Search를 통합한 로그 뷰어, 로그 뷰어는 로그 문장으로부터 해당 소스 코드로 연결해줄 때 Code Search가 제공하는 링크를 이용하는 것이다. 예2) 코드랩이나 다른 문서자료에서도 API, 예시, 구현 코드를 참조하는 경우가 많다.17.3.5 API 제공Code Search는 검색, 상호참조, 구문 강조 기능을 API로 제공하여 다른 도구 개발자가 가져다 쓸 수 있다.17.4 규모가 설계에 미치는 영향코드 검색을 확장하는 데 가장 큰 걸림돌은 전체 코드의 크기이다. 수 MB 정도의 작은 리포지터리라면 별다른 고민 없이 grep으로 검색해도 된다. 수백 MB로 늘어나면 간단한 로컬 인덱스를 도입해 검색 속도를 10배 이상 높일 수 있다. 코드량이 GB나 TB 단위로 가면 클라우드로 옮겨 서버를 여러 대 띄우면 쓸만한 검색 속도를 유지할 수 있다. 이처럼 중앙집중형 검색 솔루션은 이용자 수와 코드량이 늘면 함께 비대해진다.17.4.1 검색 쿼리 지연시간대체로 사람은 지연시간이 200밀리초보다 짧기만 하면 UI가 빠르다고 느낀다. 하지만 1초가 넘어가면 주의가 분산되기 시작하고, 10초가 더 흐르면 전혀 다른 일을 하기 시작하여 생산성을 급격히 떨어뜨릴 가능성이 크다.Code Search가 처리하는 쿼리의 상당수가 코드베이스를 탐색하는 과정에서 발생한다.검색에서는 글자 두어 개 타이핑하는 것만으로 원하는 파일을 찾을 수 있다. 이렇게 하기 위해서는 현재 보고 있는 파일 같은 맥락 정보를 검색 백엔드에 제공해야 한다. 맥락 정보를 이용해 검색 범위를 특정 프로젝트로 한정하거나 물리적인 거리순으로 추천하는 것이다.17.4.2 인덱싱 지연시간개발자는 자신이 방금 수정한 코드나 그로 인한 변경 사항들을 검토해야 하는데 수정 내용이 반영되어 있지 않으면 혼란을 불러올 수 있다. 작은 수정이든 리팩터링이든 완전히 새로 작성한 코드든 마찬가지이다. 개발자는 자신이 IDE에서 작은 프로젝트를 진행할 때와 똑같이 모든 코드가 최신 버전이기를 기대한다.검색 후 대체 형태로 이루어지는 리팩터링도 마찬가지이다. 제거한 코드는 검색 결과에서 곧장 사라져야 한다. 편의성 면에서도 그렇지만, 잔재가 남아 있으면 후속 리패터링에 지장을 준다.문제가 생겼는데 인덱스와 실행 중인 코드가 다르면 진짜 원인을 감추거나 혼선을 줄 수 있다. 실제 구글에서는 상호참조 기능에서 이 문제를 겪는다. 구글 규모에서는 인덱스 생성에 몇 시간이 걸리고, 너무 복잡하여 인덱스를 하나의 버전만 유지하기 때문이다.17.5 구글은 어떻게 구현했나?17.5.1 검색 인덱스현재 Code Search는 약 1.5TB의 콘텐츠를 인덱싱하며 초당 약 200개의 쿼리를 처리한다. 서버단 기준으로 지연시간은 50밀리초 이하이고, 인덱싱 지연시간의 중간 값은 10초 미만이다. grep으로 이 성능을 내려면 자원이 얼마나 들까? 데이터 1.5TB를 지연시간 50밀리초 이내로 처리하려면 30만 개의 CPU 코어를 동원해야 한다.469~471p17.5.2 랭킹코드베이스가 커져 결과 수가 늘어나면서 랭킹 기능이 중요해진다. 구글의 코드베이스에서 짧은 키워드만으로 검색하면 결과가 수천에서 백만 단위까지 나온다. 랭킹 기능이 없다면 사용자가 엄청난 건초더미를 다 뒤져 바늘을 찾아내거나, 결과수가 충분히 적어질 때까지 쿼리를 다음어야 한다.랭킹을 매기려면 먼저 각 파일의 여러 특성(시그널)을 점수로 환산해줄 함수가 필요하다. 일반적으로 시그널을 2가지로 분류한다. 1)문서(파일)에만 의존적인 쿼리 독립적 시그널, 2)검색 쿼리와 쿼리를 어떻게 문서에 매치시킬지에 의존하는 쿼리 의존적 시그널쿼리 독립적 시그널쿼리 독립적 시그널로는 파일 조회수와 파일로의 참조량을 뽑을 수 있다. 파일 조회수가 높다는 것은 개발자들이 그 파일을 중요하게 생각하여 찾고자 할 가능성이 더 높다는 의미이다. 이 시그널의 가장 큰 문제는 피드백 루프가 만들어진다는 점이다. 자주 조회돼서 점수를 높이면 개발자들이 또 조회할 가능성이 커져서, 그로인해 다른 문서가 검색 순위 안에 들어올 가능성은 낮아진다. (탐색과 활용 문재)**탐색: 새로운 도전 / 활용: 기존 자원을 활용파일을 가리키는 참조의 수를 이용할 때 웹 링크를 참조로 간주하는 원래의 페이지 랭크 알고리즘과 비슷하게 프로그래밍 언어에서 사용하는 include/import 부류의 문장을 이용하는 것이다.랭킹에 참조를 이용할 때는 크게 두 가지에 주의해야 한다. 참조 정보를 안정적으로 추출해낼 수 있어야 한다. 핵심적인 오픈 소스 라이브러리 등에서 종종 진행하는 대규모 리팩터링도 커다란 문제다. 이런 변경은 여러 단계로 나누어 진행되면서 리팩터링 도중 ‘간접 참조’가 만들어져서 파일이 이동되었다는 사실이 감춰지는 일이 많다. (간접 참조는 이동된 파일의 랭크를 낮춰서 개발자들이 새로운 위치를 찾기 어렵게 한다.)쿼리 의존적 시그널쿼리 의존적 시그널은 쿼리마다 계산하는 방식이라서 계산량이 적어야 한다. 즉 인덱스로부터 빠르게 얻을 수 있는 쿼리와 정보만 이용해야 한다.검출(검색)Code Search는 문서에 점수를 매기기 전에 검색 쿼리와 일치할 가능성이 있는 후보를 찾는다. 이 단계를 검출이라고 한다. 모든 문서를 다 검색하려면 현실적으로 비효율적이기 때문에 검출된 문서들에만 점수를 매긴다.검출 단계에서 해결해야 할 주요 과제는 관련이 적은 수많은 파일 중에서 관련도 높은 소수의 파일을 찾는 일이다. 효과가 좋은 해결책으로 ‘보충 검출’이란 것이 있다. 보충 쿼리를 이용하여 검색 대상을 정의와 파일 이름만으로 제한하고, 이렇게 새로 검출한 문서들을 검출 단계의 결과에 추가한다.결과 다양성검색은 결과를 다양하게 보여줄 수 있어야 한다. 예) 간단한 함수 이름을 검색할 때 자바 언어에서 찾은 결과와 파이썬 언어에서 찾은 결과를 함께 제공하는 것17.6 구글이 선택한 트레이드오프17.6.1 완벽성: 헤드 리포지터리코드 베이스가 클수록 검색하기는 어려워진다. 인덱싱이 느려지고 비용은 더 들고, 쿼리 응답도 드려진다. 이때 완벽성을 희생하고 콘텐츠 일부를 인덱싱에서 제외하면 이 비용을 줄일 수 있다. 하지만 제외된 파일들 때문에 때론 피드백에 구멍이 생겨서 혼란과 생산성 손실로 이어진다. 그래서 구글은 자원을 절약하기 보다는 인덱싱을 많이 하는 쪽을 선택했다.17.6.2 완벽성: 전부 vs 가장 관련성 높은 결과만웹 검색에서는 속도를 위해 완벽성을 희생한다. 수백만 개의 후보 중 함수 정의 같은 단 하나의 결과를 찾을 때는 순위 검색이 적합하다. 하지만 개발자는 종종 모든 결과를 원할때가 있다. 예) 리팩터링을 할 때는 특정 심볼이 쓰이는 곳을 하나라도 놓치면 안 된다.하나의 아키텍처로 두 마리 토끼를 잡기 위해 구글은 파일들을 우선순위대로 정렬하고 코드베이스 전체를 샤드(조각)로 나눴다. 그리고 보통은 각 샤드에서 우선순위가 높은 파일들과만 일치 여부를 확인하고, 모든 결과를 내어달라고 요청하는 경우 각 샤드로부터 모든 결과를 가져온다.17.6.3 완벽성: 헤드 vs 브랜치 vs 모든 변경 이력 vs 작업공간476~477p17.6.4 표현력: 토큰 vs 부분 문자열 vs 정규 표현식Code Search는 정규 표현식 검색을 지원한다. 정규 표현식 덕분에 지정한 용어들 모두를 포함하거나 제외할 수 있다. 또 어떤 텍스트에든 이용할 수 있어 문서 검색이나 강력한 의미론적 도구가 없는 프로그래밍 언어로 작성한 코드 검색에 특히 유용하다.토큰 기반 인텍스는 실제 소스 코드의 일부만 저장하면 되고 표준 검색 엔진들에서 잘 지원하기 때문에 확장성이 좋다. 반대 급부로 활용성은 많이 줄어든다. 또 다른 문제점으로는 코드 식별자가 잘못 정의될 수 있고, 일반적으로 토큰화는 대소문자를 구분하지 않으며 단어들을 뭉개기도 한다. 마지막으로 토큰화 코드에서는 매우 중요한 공백 문자나 다른 구분자를 검색할 수 없게 만든다.전체 부분 문자열 검색은 문자들의 순서에 상관없이 검색할 수 있다. 단순 텍스트 매칭이 아닌 의미를 이해한 분석과 검색을 지원하는 도구를 말한다. 같은 토큰이라도 변수인지 함수인지, 전역 변수인지 방금 선언한 지역 변수인지 등을 정확하게 구분해준다.부분 문자열 인덱스가 준비되면 정규 표현식 검색으로 확장하기는 쉬워진다.17.7 마치며Code Search는 grep을 대체하여 개발자 생산성을 높이는 핵심 도구로 성장하였으며, 그 과정에서 구글의 웹 검색 기술을 활용했다.Code Search가 주는 가장 중요한 가치는 명백성이다. 코드를 이해하는 것이야말로 코드를 개발하고 유지보수하는 열쇠이다.17.8 핵심 정리 개발자들이 코드를 쉽게 이해하도록 도와주면 엔지니어링 생산성을 크게 끌어올릴 수 있다. 구글의 중심에는 Code Search가 있다. Code Search는 다른 도구들의 기반을 제공하며, 모든 문서자료와 개발자 도구가 참조하는 중앙의 표준 저장소라는 가치를 추가로 제공한다 Code Search는 대화형 도구이므로 반응이 빨라야 한다. 검색, 브라우징, 인덱싱 모든 면에서 지연 시간이 짧아야 한다. 신뢰할 수 있는 도구여야 널리 쓰인다. 신뢰를 얻으려면 모든 코드를 인덱싱하고, 빠뜨림 없이 결과로 제공하고, 이용자가 원하는 결과를 먼저 보여줘야 한다." }, { "title": "16. 버전 관리와 브랜치 관리", "url": "/posts/16.%EB%B2%84%EC%A0%84%EA%B4%80%EB%A6%AC%EC%99%80-%EB%B8%8C%EB%9E%9C%EC%B9%98%EA%B4%80%EB%A6%AC/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-11-15 18:36:22 +0900", "snippet": "16.1 버전 관리란?버전 관리 시스템(VCS)는 파일의 시간에 따른 변경 기록(버전)을 추적하는 시스템이다. 파일의 메타 데이터를 관리하며 이 메타 데이터와 파일들의 버전별 복사본을 합쳐 리포지토리라고 한다. VCS를 이용하면 여러 개발자가 같은 파일들로 동시에 작업할 수 있어서 팀 업무를 효과적으로 조율할 수 있다.초창기 VCS에서는 파일 단위로 락을 걸어 수정중인 파일에 대해 다른 사람은 수정하지 못하도록 막았고, 조금 진보된 VCS에서는 변경된 파일들의 묶음을 하나의 단위로(원자적으로) 취급 하였다.1990년대에 널리 쓰인 CVS 시스템은 이런 원자성을 제공하지 못하여 잘못하면 커밋이 충돌나서 변경 내역을 잃어버릴 수 있었다. 원자성을 보장하면 기존 변경이 의도치 않게 덮어써지는 사태를 막아준다.16.1.1 버전 관리가 중요한 이유버전 관리는 엔지니어가 소스 코드와 시간의 상호작용을 관리하는 핵심 도구이다. VCS는 파일이름, 작성시각 조합을 파일 내용과 연결해주며, 동시에 마지막 동기화 지점과 리뷰 기록을 추적하는 데 필요한 메타데이터도 관리해준다. 버전 관리는 개발 작업의 한 요소인 시간을 명확하게 드러내준다. 프로그래밍에서는 꼭 필요하지 않지만, 소프트웨어 엔지니어링에서는 아주 중요한 요소인 시간을 말이다. 오늘날의 VCS는 대부분 브랜치 이름까지 입력으로 받아 병렬로 매핑해준다.VCS를 주저하는 이유가 있다면 프로그래밍과 소프트웨어 엔지니어링을 제대로 융합하지 못했기 때문이다. 경영진이 엔지니어의 일을 소프트웨어 엔지니어링이 아닌 소프트웨어 개발로만 생각해도 VCS를 주저하게 된다. 엔지니어의 업무 핵심을 프로그래밍으로 인식하여 코드와 시간의 상호작용을 제대로 이해하지 못한다면 실수를 되돌리기 위해 이전 버전으로 돌아간다라는 기능은 이상하고 값비싼 사치로 느껴질 수 있다.버전 관리를 이용하면 개발자가 한 명이든 여럿이든 비슷한 프로세스로 개발할 수 있다는 장점도 있다. 프로젝트 되돌리기 기능은 잘 사용하지 않을 수 있다. 하지만 일관된 프로세스는 팀과 조직을 확장할 수 있는 중요한 열쇠다. 개발이란 본질적으로 분기하고 병합하며 전진하는 프로세스이다.또 VCS는 법과 규제 관련 관행도 변화 시켰다. VCS는 모든 코드라인에 가해진 모든 변경을 기록한 공식 이력으로 인정되어 법적 다툼이 발생했을 때 감사 자료로도 이용된다. 그리고 개발자들의 행동 양식에도 변화를 가져왔다. 커밋 메세지를 작성하는 동안 자신을 되돌아보며 의미 있는 시간을 갖게 된다.16.1.2 중앙집중형 VCS vs 분산형 VCS중앙집중형 VCS단 하나의 중앙 리포지터리를 이용하는 모델로 개발자들은 각 파일을 체크아웃하여 로컬 컴퓨터에서 이용할 수 있다. 이 파일들의 버전 관리 상태와 관련한 작업들은 반드시 중앙 서버에 전달해야 한다.1970~1980년대에는 동시 편집을 막아주는 락킹에 집중했다. 단 한 사람만이 파일을 편집할 수 있도록 보장했다. 작은 수정사항이나 여럿이 같은 파일을 편집할 일이 거의 없을 때는 이 모델도 훌륭했으나 이런 구조는 확장하기가 어렵다.확장 문제를 해결하고자 1990~2000년대에는 락을 한 사람이 독점하는 대신 어느 버전과 동기화했는지 추적하기 시작했다. 커밋에 포함된 모든 파일이 가장 최신 버전을 기준으로 했는지를 확인하는 것이다. CVS 시스템은 한 번에 여러 파일을 수정할 수 있고, 하나의 파일을 동시에 여러 개발자가 체크아웃할 수 있도록 했다.분산형 VCS2000년대 중반을 시작으로 가장 유명한 VCS들이 분산형 VCS 패러다임으로 갈아타기 시작했다. 선봉에 선 것이 깃과 머큐리얼이다. 분산형 VCS 세계에서는 중앙 리포지터리라는 제약이 사라지고 리포지터리의 복제본을 가지고 있다면 커밋할 수 있는 리포지터리를 소유한 것이다.중앙이라는 것은 개념적으로만 존재할 뿐이다. 본질상 특정한 하나를 진실 공급원이라고 지정하지 않아도 되므로 오프라인 작업과 협업에 더 유리하다.중앙집중형 VCS에서는 기술적으로 명확하게 정의된 중앙 리포지터리를 제공하고, 분산형 VCS에서는 프로젝트 대다수가 중앙 리포지터리를 정책 수준에서 정의한다.16.1.3 진실 공급원중앙집중형 VCS는 시스템 설계에서부터 진실 공급원 이라는 개념을 사용한다. trunk에 가장 최근 커밋된 것이 현재 버전이다. 개발자가 프로젝트를 체크아웃하면 기본적으로 트렁크 버전이 제공되고 수정 내역을 이 버전위에 다시 커밋하면 해당 변경이 완료된다.분산형 VCS에는 여러 리포지터리 중 어느 것이 단일 진실 공급원이라는 개념이 없다. 중앙 통제나 조율 없이 커밋 태그와 PR을 전혀 다른 개발 브랜치로 전달할 수 있다.실제로 깃 허브와 깃랩 같은 분산형 VCS 서비스를 많이 사용하고 있다. 이 서비스 이용자들은 프로젝트의 리포지터리를 복제하고 포크할 수 있지만 주 리포지터리는 여전히 하나뿐이다. 변경 사항이 주 리포지터리의 트렁크 브랜치에 반영되어야만 비로소 작업이 완료된다.중앙의 진실 공급원이 없다면 누군가는 다른 릴리스에 포함시킬 기능 목록을 따로 관리해야 할 것이고, 결국 이 목록이 중앙화된 진실 공급원 모델을 모방한게 된다.팀이 커져도 인원수 증가보다 적은 추가 노력으로 관리할 수 있는 시스템을 찾는다면 단 하나의 리포지터리와 하나의 브랜치를 궁극적인 진실 공급원으로 지정해야 한다.16.1.4 버전관리 vs 의존성 관리버전관리 정책은 개념적으로 의존성 관리와 매우 비슷하나 버전관리 정책은 주로 코드를 어떻게 관리할지를 다루고, 의존성 관리는 다른 조직에서 통제하는 프로젝트들을 관리해야 하기 때문에 훨씬 어렵다.16.2 브랜치 관리16.2.1 진행 중인 작업은 브랜치와 비슷하다.브랜치 관리 정책을 논의하려면 최소한 진행 중인 작업은 모두 하나의 브랜치와 같다는 점을 인정하고 시작해야 한다. 개발자가 상위 진실 공급원으로 푸시하기 전까지 수많은 변경사항을 로컬 리포지터리에 커밋해 놓은 분산형 VCS 모델을 생각하면 더 명확하다. 중앙집중형 VCS에서도 아직 커밋하지 않고 계류 중인 변경들은 브랜치에 커밋한 변경과 개념적으로 다르지 않다.16.2.2 개발 브랜치개발 브랜치는 구현은 다 했지만 커밋하진 않았어요 와 이제부터 이 코드를 기준으로 개발하세요의 중간 단계이다. 하지만 테스트, 지속적 통합, 철저한 코드 리뷰와 같은 품질 강화 활동을 더 광범위하게 진행하는 편이 더 효과가 좋다.제품의 안정성 유지 차원에서 개발 브랜치를 과하게 사용하는 버전 관리 정책은 잘못되었다. 거대한 개발 브랜치를 병합할 때는 많은 것이 변경된 상태이므로 문제 원인이라고 예상되는 범위를 좁히기가 어렵다. 브랜치 하나를 병합할 때도 극복할 게 많으므로 개발 브랜치에 의존하는 방식은 확장하는 데 한계가 있다.병합 후 다시 테스트하는 데 드는 노력은 무가치한 오버헤드이다. 다른 접근 방법으로 트렁크 기반 개발이 있다. 대신 테스트와 CI를 적극 활용하여 모든 빌드와 테스트가 항상 성공하도록 관리하며 완벽하지 않거나 테스트되지 않은 기능은 비활성화한다. 엔지니어 개개인이 트렁크와 동기화하고 트렁크에 커밋해야 한다. 수많은 개발 브랜치에서 단일 진실 공급원으로 좁힌다는 것은 어차피 포함시킬 기능을 더 일찍 확정하기 위한 원점회귀 전략인 것이다.16.2.3 릴리스 브랜치제품의 릴리스 간격이 몇 시간 이상이면 릴리스 브랜치를 따로 생성하는 게 좋다. 이 브랜치는 릴리스한 제품과 정확히 같은 코드를 담게 된다. 공식 릴리스 후 다음 릴리스 전에 심각한 결함이 발견된다면 트렁크에서 해당 수정 코드를 최소한으로 선별하여 릴리스 브랜치로 병합한다.개발 브랜치와 달리 릴리스 브랜치는 대체로 무해하다. 브랜치라는 기술이 문제가 아니라 어떻게 활용하느냐가 문제이다.트렁크로부터 하루에도 몇 번씩 릴리스할 수 있는 지속적 배포가 잘 자리잡은 조직에서는 대체로 릴리스 브랜치를 건너 뛴다. 수정사항을 적용해 다시 배포하는 게 훨씬 쉽기 때문이다.16.3 버전 관리 @구글구글의 소스 코드 대부분은 하나의 리포지터리, 즉 모노리포에서 관리되며 약 5만여 엔지니어에게 공유된다. 구글이 주관하는 프로젝트 거의 모두가 이 안에서 이루어지고, 일반 대중을 상대하는 제품뿐만 아니라 이런 제품을 개발하고 지탱하는 데 필요한 내부 인프라까지 아우른다.구글은 자체 개발한 중앙집중형 VCS(Piper)를 이용한다. 프로덕션 환경에서 분산 마이크로서비스 형태로 구동되게끔 만들어져서 세계 곳곳에 흩어져 있는 구글 엔지니어들에게 표준화된 스토리지와 소통 수단을 제공한다. 초기 구상 단계부터 구글 규모를 감당하는 데 집중한 덕분에 지금까지도 엔지니어들에게 부담을 주지 않는다.16.3.1 원-버전버전관리의 또 다른 축은 정책이다. 구글 버전 관리 정책의 중심에는 원-버전 이 있다. 이는 단일 진실 공급원 개념을 확장한 개념으로 ‘모든 의존성이 우리 리포지터리에 담겨 있고, 각 의존성은 단 하나의 안정된 버전만 존재해야 한다.’는 뜻이다. 따라서 서드파티 패키지들도 Piper에는 단 하나의 버전만 저장해둬야 한다.16.3.2 시나리오: 여러 버전을 허용한다면?여러 버전을 허용하게 되면 운 좋으면 빌드 실패로 끝나지만 최악의 경우에는 라이브러리의 서로 다른 두 버전과 링크되어서 이해하기 어려운 런타임 버그가 발생한다.16.3.3 원-버전 규칙개발자가 이 구성요소는 어떤 버전을 사용해야 하죠? 라고 묻는 상황을 만들지 않아야 한다. 이 말이 곧 원-버전 규칙이다. 즉 의존성을 새로 추가할 때 선택할 수 있는 버전을 제한한다. 라는 식으로 풀어서 표현할 수 있다.16.3.4 장수 브랜치는 (웬만하면)금지원-버전 규칙에는 몇 가지 더 깊은 뜻과 정책이 내포되어 있다. 그중 가장 중요한 정책은 개발 브랜치를 되도록 만들지 말고, 만들더라도 매우 짧게 쓰고 없애햐 한다는 것이다. 오래 묵히지 말고 작업을 작은 증분으로 나눠 정기적으로 트렁크에 커밋해야 한다.16.3.5 릴리스 브랜치는 어떤가?릴리스를 매달 하면서 동시에 다음 릴리스를 준비하는 팀이라면 릴리스 브랜치 이용은 매우 합리적인 선택이다.16.4 모노리포(단일 리포지터리)모노리포 방식은 그 자체로 몇 가지 이점을 제공한다. 그중 최고는 원-버전을 고수하기가 쉽다는 것이다. 일관성 덕분에 도구를 새로 도입하거나 코드를 최적화한 혜택이 조직 전체에 훨씬 빠르게 전파된다.중요한 것은 모노리포냐 아니냐가 아니라 원-버전을 최대한 준수하는 것이다. 즉 조직에서 이미 사용중인 라이브러리에 대한 의존성을 추가할 때 개발자가 버전을 선택하게 해서는 안 된다.16.5 버전 관리의 미래모노리포 방식의 이점을 공개적으로 논의 중인 기업이 구글만은 아니다. 마이크로소프트, 페이스북, 넷플릭스, 우버 역시 자신들의 방식을 공개한 바 있다.모노리포에 대한 가장 큰 우려는 모든 것을 하나의 리포지터리에 담을 수 있는 기술이 있느냐 이다. 지난 몇 년에 걸쳐 깃에는 얕은 복제, 희소 브랜치, 최적화 등 대규모 리포지터리를 지원하는 기능이 다수 갖춰졌다. 구글은 이 노력이 앞으로 계속되어 그래도 리포지터리를 작게 유지해야 한다는 주장의 힘이 점점 약해지리라 기대한다.구글은 버전 관리와 의존성 관리가 향후 10~20년 사이에 이 방향으로 발전할 것으로 본다. 아마도 현존하는 패키지 관리 단체나 리눅스 배포자 중 하나가 업계 표준의 가상 모노리포 구축을 촉진할 것이다.16.6 마치며버전 관리 시스템은 협업 효율을 끌어올리기 위해 업무 조율 정책에 기술을 접목하면서 자연스럽게 탄생된 결과물이다. 초기의 VCS들은 단순히 파일 단위의 락킹만 제공했고, 프로젝트와 팀의 규모가 커지면서 이 방식의 한계가 드러났고 버전 관리를 바라보는 관점도 달라졌다.현재 분산 VCS의 탈 중앙화는 업계가 팔요로 해서 탄생한 합리적인 결과물이다. 그러나 분산 VCS는 설정을 엄격하게 통제하고 각 조직에 맞는 브랜치 관리 정책과 결합될 때 비로소 빛을 발한다. 또 예기치 못한 확장성 문제로 고생할 때도 많다.선택에는 대가가 따르고 구글은 원-버전 규칙을 적극 권장한다. 개발자들이 어디로 커밋해야 할지, 어느 버전을 이용해야 할지를 선택할 수 없어야 한다.16.7 핵심 정리 개인 토이프로젝트가 아니라면 소프트웨어 개발 프로젝트에서는 무조건 버전 관리 시스템을 이용하자 어느 버전을 사용할지 선택할 수 있다면 잠재적으로 확장성이 떨어진다는 뜻이다. 원-버전 규칙은 조직의 효율에 지대한 영향을 준다. 선택할 일을 없애므로써 단순화할 수 있다. 기존 연구들이 트렁크 기반으로 개발하는 조직일수록 성과가 좋을 가능성이 높음을 보여줬다. 여러분에게 적합한 버전 관리 시스템을 사용하라" }, { "title": "15. 폐기", "url": "/posts/15.%ED%8F%90%EA%B8%B0/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-11-14 02:59:18 +0900", "snippet": "모든 시스템은 나이를 먹는다. 새로운 기술, 라이브러리, 기법, 언어 등이 등장하면서 주변 환경이 끊임 없이 변하기 때문에 기존의 시스템은 서서히 구식이 되어 간다. 오래된 시스템을 유지하려면 관리하는 데 지속해서 비용이 들어가고 난해한 옛 기술에 대한 전문 지식이 필요하다. 이러한 낡은 시스템을 언제까지고 끌고 다니기 보다는 완전히 떼어내는 편이 나을 때가 많다. 궁극적으로 낡은 시스템을 완전히 걷어내는 과정을 폐기 라고 한다.15.1 폐기시키는 이유‘코드는 자산이 아니라 부채다.’ 코드에는 비용이 따라온다. 대부분 구축 후 생이 끝날 때까지 유지보수하는 데서 발생한다.시스템에서 오래됐다고 해서 무조건 폐기시켜야하는 것은 아니다. 폐기는 시대에 뒤처졌음을 보여줄 수 있고 비슷한 기능의 대체재가 존재하는 시스템에 적합하다.코드 자체는 가치를 창출하지 않는다. 가치를 만들어내는 것은 바로 기능이다. 사용자의 요구에 부합하는 기능은 자산이다. 코드 자체는 비용을 낳기 대문에 기능이 같다면 코드 자체는 단순할수록 좋다. 따라서 얼마나 많은 코드를 작성하느냐나 코드베이스가 얼마나 큰가가 아니라. 단위 코드당 얼마나 많은 기능을 제공하느냐에 집중하여 극대화해야 한다.15.2 폐기는 왜 그리 어려운가?시스템은 사용자가 늘수록 설계자가 예상하지 못한 전에 본 적 없는 방식으로 이용될 가능성이 커져서(하이럼의 볍칙) 폐기 작업을 그만큼 어렵게 만든다. 또 옛 시스템을 향한 애착이 의외의 저항으로 나타날 수 있다. 구글에서도 정책적으로 옛 코드를 제거하려 할 때 변화를 거부하는 움직임이 나타나곤 한다.마지막으로 비용을 확보해 폐기를 진행하려면 정치라는 관문도 통과해야 한다. 오래된 시스템을 제거하는 데는 눈에 보이는 비용이 드는 반면, 아무것도 하지 않고 시스템을 방치해서 새어나가는 비용은 눈에 잘 띄지 않는다. 따라서 이해관계자들을 납득시키는데에 어려움이 있을 수 있다.15.2.1 설계 단계에서의 폐기소프트웨어 시스템의 폐기 계획도 시스템을 처음 구축할 때 함께 세워둘 수 있다. 언젠가는 폐기하게 될 시스템을 설계한다는 개념이 생소할 수 있지만 다른 엔지니어링 분야에서는 흔한 일이다. 예를 들어 원자력 발전소의 경우 훗날 수명이 다한 원자로를 어떻게 해체하고 자금은 어떻게 조달할지도 반드시 고려해야 한다. 소프트웨어 시스템은 그렇게 깊게 고민해 설계되는 경우가 아주 드물다.언제가 이루어질 폐기가 매끄럽게 진행되게 하려면 시스템을 설계할 때 무엇을 고려해야 할까? 내 제품의 고객이 잠재적인 대체품으로 이주하기가 얼마나 쉬울까? 내 시스템을 한 부분씩 점진적으로 교체하려면 어떻게 해야 할까?프로젝트의 장기 지원 여부는 조직에서 프로젝트를 처음 승인할 때 결정된다. 소프트웨어가 론칭되고 나면 할 수 있는 일은 계속 지원하거나 조심스레 폐기하거나 어쩔 수 없는 외부 요인이 발생하여 운영을 중단하거나 셋 중 하나이다. 따라서 회사에서 기대 수명동안 제대로 지원하지 못할 것 같은 프로젝트는 시작하지 말자. 폐기시키기로 결정하는 것에도 비용이 든다.15.3 폐기 유형폐기의 유형을 크게 권고와 강제로 구분한다.15.3.1 권고 폐기권고 폐기는 기한이 없고 조직에서도 우선순위가 높지 않은 경우이다. 이 유형의 폐기에는 대체로 강제성이 없다. 고객이 알아서 움직여주기를 희망한다.권고 폐기는 새로운 시스템이 출시됐음을 알리고 이용해보라고 권하기 좋은 수단이지만 베타 수준일 때는 해서는 안 된다. 반드시 기능과 안전성 모두 정식 서비스가 가능한 수준에 올라섰을 때 그리고 새로운 사용자를 확실하게 지원할 준비가 되었을 때 시행해야 한다.권고 폐기는 사용자들을 원하는 방향으로 움직이게 슬쩍 찔러보는 정도라서 대다수가 움직여주리라고 기대해서는 안 된다.15.3.2 강제 폐기강제 폐기는 대개 낡은 시스템의 지원 종료일을 못 박는 형태로 이루어진다. 종료일까지 이주를 끝내지 못한 시스템은 제대로 작동되지 않을 것이다.큰 조직에서는 강제 폐기를 효율적으로 수행하려면 기존 시스템을 완전히 제거하는 역할을 전담할 팀을 하나 따로 꾸리는 것이 가장 좋다. 그리고 강제 폐기가 잘 이루어지려면 일정대로 집행할 수 있는 권한이 주어져야 한다. 이주 과정에서 충분히 경고하였다면 기한을 넘겨서까지 기존 시스템을 이용하는 시스템에 문제가 생겨도 책임을 묻지 않도록 해야 한다.또 정책적으로 뒷받침되더라도 강제 폐기는 정치적 반대에 직면할 수 있음을 염두해둬야 한다.구글에서는 어떤 시스템을 폐기시켜야 할 때 담당 팀이 디데이 몇달 또는 몇주전에 서비스의 점진적인 일시 중지 일정을 계획해 공표한다. 이 실험을 통해 인지하지 못하던 시스템들 사이의 의존성을 새로 발견하는 경우가 많다. 의존성을 발견한 팀은 폐기에 대비한 해법을 계획하거나 여의치 않으면 폐기 담당팀과 협의해 일정을 조율할 수 있다.15.3.3 폐기 경고해당 시스템이 폐기 대상임을 프로그래밍적으로 알려주면 좋다. 폐기 경고는 새로운 사용자 유입은 대체로 막아주지만 기존 사용자를 이주시키는 데는 효과가 거의 없다.사용자에게 전달되는 폐기 경고 메시지에 반드시 담겨야하는 특성으로 실행 가능서과 적시성이 있다.해당 문제와 관련한 전문 지식을 갖춘 평균적인 엔지니어가 이론적으로 뿐 아니라 실질적인 조치를 취할 수 있다면 실행 가능한 경고이다.폐기 경고가 유용하려면 적시에 떠야 한다. 사용자가 실제로 관련 동작을 수행할 때 경고가 뜬다면 적절한 때라고 할 수 있다.그리고 기회가 될 때마다 경고하려는 충동은 자제하자 경고를 쏟아내게 되면 우호적인 엔지니어들까지 질리게 할 수 있다.15.4 폐기 프로세스 관리15.4.1 프로세스 소유자구글에서는 시스템이 아무리 경고를 쏟아내도 소유자가 명확하지 않으면 폐기 프로세스가 진척되지 않음을 배웠다. 소유자 없이는 아무것도 폐기시키지 말자 그리고 폐기 업무를 시스템 이용자들에게 절대 떠넘기지 말자. 책임자를 두어 폐기에 필요한 전문지식을 집중시키면 집행 비용을 더 투명하게 알 수 있어서 실제로도 비용이 절감된다.15.4.2 마일스톤새로운 시스템을 구축하는 프로젝트에서는 일반적으로 마일스톤이 명확하다. 점진적인 개발 방식을 따라 팀은 기능을 하나씩 구축하여 사용자에게 제공하며 사용자는 새로운 기능을 활용할 때마다 혜택을 얻는다.이와 대조적으로 폐기 프로젝트는 낡은 시스템을 완전히 제거하는 것만이 유일한 마일스톤이라고 생각하는 경향이 있다. 폐기팀을 관리할 때도 측정할 수 있고 고객에게 가치를 전달해주는 명확하고 점진적인 마일스톤들을 세워야 한다. 폐기시킬 때도 핵심 컴포넌트들을 하나씩 제거하는 걸 점진적 마일스톤으로 삼으면 효과가 좋았다.15.4.3 폐기 도구발견폐기를 진행하는 내내 특히 초기 단계에서는 낡은 시스템을 누가, 어떻게 이용하고 있는지를 알아야 한다. 그리고 어떻게 이용 중인지에 따라 폐기를 계속 진행할지 혹은 결정을 번복해야 할 지를 다시 검토해야 할 수도 있다.구글에서는 Code Search 같은 검색도구와 Kythe 같은 정적 분석 도구를 써서 폐기시킬 라이브러리를 누가 이용 중인지를 코드를 돌려보지 않고도 알아낸다. 또 폐기시킬 심볼의 참조가 모두 제거되었는지를 확인하는 데 전역 테스트 스위트를 신탁처럼 이용한다.마이그레이션(이주)퇴행 방지새로 작성하는 코드에서 폐기중인 대상을 이용하는 것을 퇴행이라 한다. 퇴행을 실무 수준에서 방지하기 위해서 구글에서는 Tricorder라는 정적 분석 프레임워크를 이용한다. 폐기 중인 시스템을 호출하는 코드를 추가한 사용자에게 적절한 대처 방법을 피드백할 수 있다.거시적으로는 빌드 시스템에 가시성 허용목록을 도입하여 폐기된 시스템에 의존하는 시스템이 새로 생겨나는 일을 막는다.15.5 마치며폐기가 축제가 끝난 거리를 청소하는 지저분한 일처럼 느껴질 수 있으나 이런 노력 덕분에 유지보수 부담이 줄고 소프트웨어 생태계가 개선된다. 점점 커지고 복잡해져가는 소프트웨어 시스템을 오래도록 관리하려면 새로운 소프트웨어를 구축해 운영하는 것만으로는 부족하다. 낡았거나 더는 쓰이지 않는 시스템은 없애줘야 한다.15.6 핵심 정리 소프트웨어 시스템이 존재하는 한 유지보수 비용은 계속 발생하므로 제거하는 비용과 저울질해봐야 한다. 시스템을 원래 의도와 다르게 사용하는 사용자가 많기 때문에 제거하는 일이 아예 처음부터 만들기보다 어려울 때도 많다. 폐기 비용을 생각하면 기존 시스템을 개선하는 편이 일반적으로 더 저렴하다. 폐기 여부를 결정하려면 비용을 따져봐야 한다. 생태계 비용은 곳곳에 퍼져있어서 측정하기 어렵다." }, { "title": "14. 더 큰 테스트", "url": "/posts/14.%EB%8D%94%ED%81%B0%ED%85%8C%EC%8A%A4%ED%8A%B8/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-11-09 21:42:08 +0900", "snippet": "14.1 더 큰 테스트란?더 큰 테스트들은 작은 테스트와 많은 면에서 다르다. 따라야 하는 제약도 다르다.[특성] 느릴 수 있다. 구글에서 대규모 테스트의 기본 타임아웃 값은 15분~1시간이다. 밀폐되지 않을 수 있다. 대규모 테스트는 다른 테스트나 최종 사용자와 자원 및 트래픽을 공유하기도 한다. 비결정적일 수 있다.이러한 단점들에도 불구하고 더 큰 테스트를 이용하는 이유는 단위 테스트는 호환성 문제가 있는지 확인하는 데 그다지 도움이 안되고, 개별 함수, 객체, 모듈에 대한 확신을 심어준다. 반면 더 큰 테스트는 시스템 전체가 의도대로 동작한다는 확신을 더해주는 역할을한다.14.1.1 충실성더 큰 테스트가 존재하는 첫 번째 이유는 바로 충실성(실제 행위를 얼마나 반영했느냐)을 높이기 위함이다. 더 큰 테스트는 환경 충실성의 낮음-높음 사이에서 가장 적합한 지점을 찾아내는 것이다. 충실성이 높아질수록 비용이 커져서 테스트 실패시 입는 손해도 크다.14.1.2 단위 테스트가 손 대기 어려운 영역 부정확한 테스트 대역 설정 문제 - 단위 테스트는 주어진 바이너리 내의 코드를 다룬다. 일반적으로 바이너리는 단독으로 실행될 수 없고, 배포 설정, 시작 스크립트 같은 게 필요할 때가 많다. 과부하 시 나타나는 문제 - 성능, 부하, 스트레스 테스트는 바이너리에 상당한 양의 트래픽을 일으키므로 통상적인 단위 테스트 모델에 녹이기 어렵다. 예기치 못한 동작, 입력, 부작용 - 단위 테스트의 범위는 작성자의 상상력에 갇히게 된다. 단위 테스트만으로는 공대 API에 명시되지 않은 행위까지 모두 확인할 가능성이 극히 낮다. 창발적 행위와 진공 효과14.1.3 더 큰 테스트를 만들지 않는 이유좋은 단위 테스트라면 높은 신뢰성, 빠른 속도, 높은 확장성의 특징을 갖는다. 반면 더 큰 테스트에서는 이 특징을 하나도 갖지 못하는 경우도 생긴다. 예)더 큰 테스트는 많은 인프라를 이용하기 때문에 결과가 비결정적일 때가 많다.그리고 극복해야 할 과제가 두 가지가 더 있다. 소유권 문제 - 단위 테스트는 소유자가 누구인지 명확하다 더 큰 테스트는 다수의 단위에 걸져 있어 관련 소유자가 많다. 이로인해 시간이 흐를수록 소유권이 더 모호해지고 유지보수의 책임, 테스트 실패시 누가 문제를 해결할지에 대한 문제가 발생한다. 표준화 부족 - 더 큰 테스트는 작성하고 실행하고 디버깅하기 위한 인프라와 프로세스가 부실하다. 그로인해 미치는 영향이 상당히 크다. 더 큰 테스트는 실행 방식이 너무 다양하여 테스트를 수행하는 표준화된 방식이 없으므로 자연스럽게 인프라의 지원을 받지 못한다.14.2 더 큰 테스트 @구글 구글은 테스트 피라미드를 장려했다. 대다수 테스트가 단위 테스트가 되길 원하여 단일 테스트에 집중했다. 훗날 C/J Build를 대신하여 TAP을 공식 지속적 빌드 시스템으로 도입하였는데 TAP은 특정한 조건을 충족하는 테스트인 경우에만 C/J Build를 대체할 수 있었다.14.2.1 더 큰 테스트와 수명더 큰 테스트들은 시간이라는 관점에서 어떤 영향을 줄까? 단위 테스트는 기대 수명이 몇 시간 이상만 되면 충분히 가치가 있다.더 큰 테스트들은 모두 수명이 더 긴 소프트웨어에 유용하다. 하지만 수명이 길어질수록 주 관심사가 테스트의 유지보수로 옮겨간다.건강한 상태를 오래 유지하는 핵심은 개발 시작 후 며칠 안으로 단위 테스트를 만들어 테스트 피라미드를 쌓기 시작하는 것이다. 그런 다음 수동 테스트를 자동화된 통합 테스트로 대체해 피라미드 위층으로 올린다. 오랫동안 코드를 건강하게 유지하려면 단위 테스트와 수동 테스트 사이의 간극을 매우는데 소홀해서는 안 된다.14.2.2 구글 규모에서의 더 큰 테스트규모가 큰 소프트웨어라면 더 큰 테스트가 그만큼 더 필요하고 유용하다. 하지만 작성하고 수행하고 관리하고 디버깅하는 복잡도는 규모가 커질수록 함께 증가한다. (382~383p)**통합 테스트라 하더라도 가능한 한 작을수록 좋다. 작은 통합 테스트들로 나눠 연결하는 것으로 ‘연쇄 테스트’라는 방법이 있다.14.3 큰 테스트의 구조 테스트 대상 시스템 확보 필요한 테스트 데이터 준비 대상 시스템을 이용해 동작 수행 행위 검증14.3.1 테스트 대상 시스템대규모 테스트의 핵심은 테스트 대상 시스템(SUT)이다. 대규모 테스트에서의 SUT는 대체로 하나 이상의 독립된 프로세스에서 수행된다.SUT의 형태는 주로 다음 두 요소에 의해 결정된다. 밀폐성 - SUT는 현재 테스트하려는 기능과 관련 없는 구성요소를 사용하거나 상호작용하지 못해야 한다. 충실성 - SUT는 테스트 중인 프로덕션 시스템을 충실히 반영해야 한다.그런데 이 두 요소가 충돌할 때가 많다. 단일 프로세스 SUT - SUT 전체가 하나의 바이너리로 패키징되고, 테스트 코드까지 함께 패키징된다. 충실성 측면에서는 프로덕션의 토폴리지나 설정과 거리가 가장 먼 테스트가 된다. 단일 머신 SUT - SUT는 독립된 바이너리로 구성되고, 테스트도 별도의 바이너리로 만들어지나 모두가 하나의 머신에서 구동한다. 다중 머신 SUT - SUT를 여러 머신에 분산시킨다. 단일 머신 SUT보다 충실성이 높지만 여러 머신 사이를 잇는 네트워크가 불안정성을 키워 테스트에 예기치 못한 영향을 줄 가능성이 커진다. 공유 환경(스테이징과 프로덕션) - SUT를 독립적으로 실행하는 대신 테스트에서 공유 환경을 직접 사용한다. 하지만 공유 환경을 함께 이용중인 다른 엔지니어와 충돌할 수 있고, 테스트 만을 위해 임의로 변경할 수 없다. 하이브리드 - 어떤 SUT는 혼합된 형태를 띈다.밀폐된 SUT의 이점큰 테스트에서 SUT는 테스트 신뢰성을 떨어뜨리고 피드백 시간을 늘리는 주범이 될 수 있다. 예) 프로덕션 환경에서의 테스트는 실제 운영 중인 시스템을 이용한다. 테스트 코드가 프로덕션 환경에 배포될 때까지 대기해야 한다. 즉 환경에 릴리스되는 시점을 테스트 수행자가 직접 통제하지 못한다.대안으로 거대한 공유 스테이징 환경을 만들고 테스트를 그 안에서 실행하는 방법이 있다. 그래도 여전히 테스트용 코드가 공유 환경에 반영된 후에야 테스트할 수 있다는 한계는 여전하다.또 다른 안으로 엔지니어가 스테이징 환경에서 사용할 수 있는 시간을 예약해두고 그 시간동안은 계류 중인 코드를 배포하고 테스트를 실행해 볼 수 있도록 하는 팀도 있다.다음 단계는 클라우드에서 격리된 영역을 만들어내거나 머신을 밀폐할 수 있는 환경을 구축하고 그 안에 SUT를 배포하는 방법이다. 이런 환경이 갖춰지면 충돌 걱정이다 시간 예약없이 코드를 릴리스할 수 있다.문제 경계에서 SUT 크기 줄이기테스트를 하다 보면 피해야 할 고통스러운 경계가 존재한다. 프런트엔드와 백엔드가 만나는 경계가 대표적이다. 이 경계를 포괄하는 테스트는 되도록 피해야 한다.또 다른 경계로 서드파티 의존성을 들 수 있다. 서드파티 시스템은 대체로 테스트를 위한 공유 환경을 따로 제공하지 않을 것이다. 또 서드파티로 보내는 트래팍애 비용이 매겨지는 경우도 있어 실제 서드파티 API를 직접 사용하는 자동 테스트는 권장하지 않는다.기록/재생 프록시??? 389~390p14.3.2 테스트 데이터대규모 테스트에서는 두 가지 데이터가 필요하다. 시드 데이터 - SUT를 사전 초기화해주는 데이터 테스트 트래픽 - 테스트 수행 과정에서 SUT로 보내는 데이터SUT의 상태를 테스트 전에 초기화해두는 작업은 대체로 단위 테스트에서 수행하는 셋업보다 훨씬 복잡하다. 도메인 데이터 - 어떠 데이터베이스는 환경 구성용 데이터가 테이블들에 미리 채워져 있어야 한다. 이런 데이터베이스를 이용한다면 적절한 도메인 데이터 없이는 테스트를 제대로 실행할 수 없을 것이다. 현실적인 기준선 - 현실적인 SUT가 되려면 품질과 양적 측면 모두에서 현실적인 데이터셋이 기본으로 갖춰져있어야 할 것이다. 데이터 기록 API 손수 가공한 데이터 - 데이터를 사람이 손수 만들 수 있다. 복사한 데이터 - 실제 데이터를 복사해 쓸 수 있다. 샘플링한 데이터 - 실제 데이터에서 표본을 추출해 사용한다. 14.3.3 검증SUT가 구동되고 트래픽이 보내졌다면 제대로 작동했는지 검증해야 한다. 검증 방식으로는 다음과 같이 있다. 수동 검증 - 사람이 SUT와 직접 상호작용하며 올바르게 동작하는지 확인 단정문 - 시스템이 의도된 대로 동작하는지 명확히 검사하는 검증 방식이다. A/B 비교 - 두 벌의 SUT를 구동시켜 똑같은 데이터를 보낸 다음 결과를 비교하는 검증 방식이다.14.4 더 큰 테스트 유형14.4.1 하나 혹은 상호작용하는 둘 이상의 바이너리 기능 테스트 SUT : 밀폐된 단일 머신 혹은 격리된 클라우드에 배포 데이터 : 수동 생성 검증 방식 : 단정문여러 바이너리가 상호작용하는 기능이라면 바이너리가 하나일 때보다 테스트하기가 훨씬 복잡한 게 당연하다. 대표적인 예로 MSA 환경에서 기능 테스트시 관련된 바이너리를 모두 포함한 SUT를 구동시키고 오픈 API를 통해 바이너리 사이의 실제 상호작용을 검증할 것이다.14.4.2 브라우저와 기기 테스트서드파티 입장이 되어 프런트엔드를 통해 애플리케이션을 이용하는 테스트는 커버리지를 높여주는 또 다른 수단이 되어준다.14.4.3 성능, 부하, 스트레스 테스트 SUT : 격리된 클라우드에 배포 데이터 : 수동 생성 혹은 프로덕션 환경에서 복사 검증 방식 : 차이 비교(성능 지표)성능, 부하, 스트레스 테스트를 작은 단위로 진행할 수도 있지만 때로는 외부 API를 써서 동시다발적인 트래픽을 감당할 수 있는지 확인해야 한다.부하의 스트레스 처리는 시스템에서 매우 시급한 능력이다. 이 복잡한 동작은 시스템의 개별 구성요소가 아니라 전체와 관련이 있다. 따라서 가능한 한 프로덕션과 비슷한 환경에서 수행되어야 한다.14.4.4 배포 설정 테스트 SUT : 밀폐된 단일 머신 혹은 격리된 클라우드에 배포 데이터 : 없음 검증 방식 : 단정문결함의 원인이 소스코드가 아니라 데이터 파일, 데이터베이스, 옵션 등의 설정에 있는 경우도 많다. SUT가 구동될 때 이러한 설정들을 읽어 반영하므로 더 큰 테스트에서는 SUT와 설정 파일을 통합해 테스트해야 한다.14.4.5 탐색적 테스팅 SUT : 프로덕션 혹은 공유 스테이징 환경에 배포 데이터 : 프로덕션에서 수집 혹은 알려진 테스트 시나리오 테스트 검증 방식 : 수동새로운 사용자 시나리오를 시도해가며 의문스러운 동작을 찾는 수동 테스트를 말한다. 훈련된 사용자나 테스터가 공개 API를 이용해서 제품을 구동해보는데 이때 시스템을 관통하는 새로운 실행 경로로 시험해보며 예상이나 직관과 다르게 동작하는지 혹은 보안 취약점은 없는지를 찾는다.탐색적 테스팅은 새로운 시스템은 물론 이미 서비스 중인 시스템에서도 예상치 못한 동작과 부작용을 발견해낼 수 있어 유용하다.한계 : 수동 테스트는 선형으로 확장되지 않는다. 탐색적 테스팅에서 발견한 모든 결함은 자동 테스트로 만들어서 다음 번에는 사람이 수행하지 않도록 해야 한다.버그 파티 : 관련된 모든 사람이 모여 제품을 수동으로 테스트한다. 버그 파티마다 집중적으로 살펴볼 영역이나 시작점을 미리 정해둘 수 있다.14.4.6 A/B 차이 회귀 테스트 SUT : 두 개의 격리된 클라우드에 배포 데이터 : 대체로 프로덕션 환경에서 복사한 혹은 샘플링한 데이터 검증 방식 : A/B 차이 비교구버전 제품과 신버전 제품의 공개 API로 트래픽을 보내 둘의 반응이 어떻게 다른지 비교한다. 모든 차이는 기대한 반응과 기대하지 않은 반응으로 구분한다.A/B 차이 테스트는 출시된 시스템에서 예상치 못한 부작용을 찾아낼 수 있는 저렴하면서도 자동화 가능한 방법이다.한계 : 다음의 난관들을 잘 극복해야 한다. 인가 - 어떤 유의미한 차이가 생겼는지 알아챌 만큼 결과를 이해할 수 있어야 한다. 노이즈 - 예상치 못한 노이즈로 인한 차이가 결과에 더해진다면 또다시 사람이 직접 조사해봐야 한다. 커버리지 설정14.4.7 사용자 인수 테스트(UAT) SUT : 밀폐된 단일 머신 혹은 격리된 클라우드에 배포 데이터 : 수동 생성 검증 방식 : 단정문대상 코드의 작성자가 테스트 코드까지 짠다는 점은 단위 테스트의 주요한 특성이다. 그래서 제품이 의도하는 기능을 엔지니어가 잘못 이해했다면 제품 코드뿐 아니라 단위 테스트에도 고스란히 반영될 우려가 매우 크다.사용자 인수 테스트 공개 API를 통해 제품을 조작하면서 특정 사용자 여정이 의도한대로 이루어지는지를 보장하는 테스트이다.14.4.8 프로버와 카나리 분석 SUT : 프로덕션에 배포 데이터 : 프로덕션에서 수집 검증 방식 : 수동 및 (지표상의) A/B 차이프로버는 프로덕션 환경을 대상으로 단정문을 수행하는 기능 테스트이다. 시간이 흘러 프로덕션 데이터가 변경되어도 단정문이 지켜지는지, 잘 알려지고 결정적인 읽기 전용 동작이 검증 대상이다.카나리 분석은 비슷하나 신버전을 프로덕션 환경에 언제 배포할지가 주된 관심사라는 점이 다르다. 프로덕션 서비스 중 일부를 새로운 버전(카나리아)으로 조금씩 대체해 가면서 신버전과 기존 버전 모두를 대상으로 프로버를 수행한다.한계 : 프로덕션 환경에서 이루어지므로 문제가 포착되었다는 것은 이미 최종 사용자에게 영향을 주고 있음을 뜻한다.14.4.9 재해 복구와 카오스 엔지니어링 SUT : 프로덕션에 배포 데이터 : 프로덕션에서 수집 혹은 사용자가 제작(결함 주의) 검증 방식 : 수동 및 (지표상의) A/B 차이시스템이 예기치 못한 변경이나 실패에도 얼마나 굳건히 대응하는가를 확인하는 테스트이다. 카오스 엔지니어링은 시스템에 꾸준히 결함을 심어서 무슨 일이 벌어지는지 관찰하는 테스트이다.한계 : 프로덕션 환경에서 이루어지므로 문제가 포착되었다는 것은 이미 최종 사용자에게 영향을 주고 있음을 뜻한다.14.4.10 사용자 평가 SUT : 프로덕션에 배포 데이터 : 프로덕션에서 수집 검증 방식 : 수동 및 (지표상의) A/B 차이프로덕션에서 수행하는 테스트로는 사용자가 서비스를 어떻게 이용하는지에 관한 많은 데이터를 수집할 수 있다. 다음과 같이 준비 중인 기능의 예상 반응과 우려사항 관련 지표를 수집하는 방법이 몇 가지 있으며 사용자 인수 테스트의 대안이 될 수 있다. 개밥 주기 - 공개 대상을 제한하는 식으로 프로덕션 환경에서 일부 사용자가 새로운 기능을 맛보도록 할 수 있다. 실험 - 새로운 기능을 일부 사용자에게 제공하고 그 사실을 알리지 않고 진행한다. 평가자 감정 - 변화된 결과를 인간 평가자들에게 보여주고 어느 것이 나은지와 왜 그런지를 선택한다.14.5 큰 테스트와 개발자 워크플로표준 단위 테스트 인프라를 활용하지는 못하더라도 큰 테스트 역시 개발자 워크플로에 통합하는 일은 여전히 매우 중요하다. 한 가지 묘안은 서브밋 전과 후에 자동 수행되는 메커니즘 갖추기이다. 그 다음에는 포스트서브밋 단계에서 큰 테스트들을 자동 수행하는 별도의 지속적 빌드를 갖추는 것이다.사람에 의한 평가가 개입되는 A/B 차이 테스트 역시 개발자 워크플로에 녹일 수 있다. 프리서브밋 테스트인 경우 변경을 승인하기 전에 코드 리뷰시 UI의 차이를 확인하게끔 요구할 수 있다.너무 거대하고 고통스러운 프리서브밋 테스트는 개발자들이 매우 곤혹스러워한다. 이런 테스트는 포스트서브밋 방식으로 수행하고 릴리스 프로세스에도 포함시켜 또 실행한다.14.5.1 큰 테스트 작성하기큰 테스트를 작성할 때 가장 좋은 방법은 명확한 라이브러리, 문서자료, 예시 코드를 참조하는 것이다.더 큰 테스트를 관리하려면 투입되는 시간과 자원 모든 면에서 비용이 많이 든다.14.5.2 큰 테스트 수행하기 테스트 속도 개선하기 - 테스트가 느릴수록 엔지니어가 테스트를 수행하는 빈도가 줄어들어서 실패하는 테스트가 나와도 수정되어 성공으로 바뀌기까지의 시간이 길어진다. 테스트의 속도를 높이는 가장 좋은 방법은 테스트 범위를 줄이거나 더 작은 테스트로 나눠 병렬로 수행하는 것이다. 내부 시스템 타임아웃과 지연 낮추기 테스트 빌드 시간 최적화 불규칙한 결과에서 벗어나기 - 불규칙한 결과는 테스트 자체를 활용하기 어렵게 한다. 불규칙성을 최소화하려면 가장 먼저 테스트 범위를 줄여야 한다. 이해되는 테스트 만들기 - 테스트 엔지니어가 이해할 수 없는 결과를 낳는 테스트는 개발자 워크플로에 통합하기가 특히 더 어렵다. 실패를 잘 처리하는 요령으로 다음과 같이 있다. 무엇이 실패했는지 명확히 알려주자 최소한의 노력으로 근본 원인을 찾을 수 있도록 하자 지원 정보 및 연락처 정보를 제공하자 14.5.3 큰 테스트의 소유권더 큰 테스트에는 반드시 소유자가 문서로 기록되어 있어야 한다. 소유자는 테스트가 변경될 때 검토해주고 테스트가 실패했을 때 지원해줄 수 있는 사람을 뜻한다. 소유권이 불분명 하면 기여자가 테스트를 수정하거나 개선하기가 더 어려워지고, 테스트 실패 시 해결되기까지 더 오래 걸린다.14.6 마치며종합적인 테스트 스위트라면 대상 시스템에 충실해야 하고, 그러려면 단위 테스트가 다루기 어려운 문제를 검증해주는 더 큰 테스트가 필요하다. 소유자관리, 유지보수, 적시에 수행되고 있는지 등에 신경을 써야한다. 더 큰 테스트라도 되도록 작게 만들어서 개발자 워크플로에 부드럽게 녹여야 한다는 원칙은 변하지 않는다.14.7 핵심 정리 더 큰 테스트는 단위 테스트가 다루지 못하는 문제를 책임진다. 더 큰 테스트는 테스트 대상 시스템, 데이터, 동작, 검증으로 구성된다. 위험을 식별해주는 테스트 전략과 그 위험을 완화해줄 더 큰 테스트까지 포함해야 좋은 설계이다. 더 큰 테스트가 개발자 워크플로에 마찰 없이 녹아들도록 관리하려면 더 많이 노력해야 한다." }, { "title": "13. 테스트 대역", "url": "/posts/13.%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8C%80%EC%97%AD/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-11-07 17:41:18 +0900", "snippet": "예를 들어 외부 서버에 요청을 보내고 응답을 받아 데이터베이스에 저장하는 함수를 검증하는 경우 테스트 몇 개만 작성하면 충분할 것이다. 하지만 이런 테스트를 수백, 수천개 작성하게 된다면 전체를 한 번에 수행하는데만 몇 시간씩 걸리고 예기치 못한 네트워크 실패나 테스트들끼리 테이터를 덮어쓰는 등의 일이 발생하여 테스트 스위트가 불규칙적으로 실패하기 시작할 것이다.이런 상황에서는 테스트 대역이 아주 유용하다. 테스트 대역은 실제 구현 대신 사용할 수 있는 객체나 함수를 말한다.아마도 가장 직관적인 유형의 테스트 대역은 실제와 비슷하게 동작하되 더 간단하게 구현한 객체일 것이다. (예. 인메모리 데이터베이스[휘발성 메모리])13.1 테스트 대역이 소프트웨어 개발에 미치는 영향 테스트 용이성 - 코드베이스가 테스트하기 쉽도록 설계되어 있어야 한다. 그래야 테스트에서 실제 구현을 테스트 대역으로 교체할 수 있다. 적용 가능성 - 테스트 대역을 제대로 활용하면 엔지니어링 속도가 크게 개선되겠지만 잘못 사용하면 오히려 깨지기 쉽고 복잡하고 효율도 나쁜 테스트로 전락한다. 충실성 - 테스트 대역이 실제 구현의 행위와 얼마나 유사하냐를 말한다.13.2 테스트 대역 @구글구글은 여러 경험들이 쌓여 테스트 대역을 올바르게 사용하는 관례를 발전시켰다. 어렵게 깨우친 교휸 하나로 테스트 대역을 쉽게 만들어주는 모의 객체 프레임워크를 과용하면 위험하다는 것이다. 모의 객체 프레임워크를 처음 도입했을 때는 만능 요술램프처럼 보였으나 몇 해가 지나자 커다란 대가를 치르게 되었다. 테스트를 작성하기는 쉬웠지만 버그는 잘 찾아내지 못했고 끊임없이 보수해야 했다.그래서 오늘날에는 많은 엔지니어가 모의 객체 프레임워크를 피하고 실제에 더 가까운 테스트를 작성한다.13.3 기본 개념13.3.1 테스트 대역 예//예) 신용카드 서비스class PaymentProcessor { private CreditCardService creditCardService; .... boolean makePayment(CreditCard creditCard, Money amount) { if(creditCard.isExpired()) {return false;} boolean success = creditCardService.chargeCreditCard(creditCard, amount); return success; }}//기초적인 테스트 대역class TestDoubleCreditCardService implements CreditCardService { @Override public boolean chargeCreditCard(CreditCard creditCard, Money amount) { return true; }}//테스트 대역 적용@Testpublic void cardIsExpired_returnFalse() { boolean success = paymentProcessor.makePayment(EXPIRED_CARD, AMOUNT); assertThat(success).isFalse();}13.3.2 이어주기단위 테스트를 고려해 짜인 코드를 테스트하기 쉽다라고 말한다. 그리고 이어주기는 제품 코드 차원에서 테스트 대역을 활용할 수 있는 길을 터줘서 테스트하기 쉽게끔 만들어주는 걸 뜻한다. 대표적인 이어주기 기술로는 의존성 주입이 있다.class PaymentProcessor { private CreditCardService creditCardService; //생성자에서 CreditCardService의 인스턴스를 직접 생성하지 않고 대신 인수로 건네 받는다. PaymentProcessor(CreditCardService creditCardService) { this.creditCardService = creditCardService; } ...}//CreditCardService 인스턴스를 생성할 책임은 생성자를 호출하는 측에 주어진다. CreditCardService구현을 넘길수도 있고 다음과 같이 테스트 대역을 넘길 수 있다.PaymentProcessor paymentProcessor = new PaymentProcessor(new TestDoubleCreditCardService());13.3.3 모의 객체 프레임워크모의 객체 프레임워크는 테스트 대역을 쉽게 만들어주는 소프트웨어 라이브러리이다. 즉 객체를 대역으로 대체할 수 있게 해준다. 모의 객체는 구체적인 동작 방식을 테스트가 지정할 수 있는 테스트 대역을 말한다. 업계에서 많이 쓰이는 프로그래밍 언어라면 대부분 모의 객체 프레임워크가 존재한다. (예. java의 mokito)13.4 테스트 대역 활용 기법13.4.1 속이기(가짜 객체)가짜 객체는 실제 구현과 비슷하게 동작하도록 가볍게 구현한 대역이다. 인메모리 데이터베이스가 좋은 예이다.//가짜 객체는 빠르고 쉽게 만들 수 있다.AuthorizationService fakeAuthorizationService = new FakeAuthorizationService();AccessManager accessManager = new AccessManager(fakeAuthorizationService);//모르는 사용자의 ID로는 접근을 불허한다.asserFalse(accessManager.userHasAccess(USER_ID));//사용자 ID를 인증 서비스에 등록한 다음에는 접근을 허용한다.fakeAuthorizationService.addAuthorizedUser(new User(USER_ID));assertThat(accessManager.userHasAccess(USER_ID)).isTrue();13.4.2 뭉개기(스텁)스텁은 원래는 없던 행위를 부여하는 과정을 말한다. 예) 대상 함수가 반환할 값을 지정한다고 하면, 이를 반환값을 뭉갠다(스텁한다)라고 말한다.//모의 객체 프레임워크로 생성한 테스트 대역을 건낸다.AccessManager accessManager = new AccessManager(mockAuthorizationService);//USER_ID에 해당하는 사용자를 찾지 못하면(null을 반환하면) 접근을 불허한다.when(mockAuthorizationService.lookupUser(USER_ID)).thenReturn(null);assertThat(accessManager.userHasAccess(USER_ID)).isFalse();//null이 아니면 접근을 허용한다.when(mockAuthorizationService.lookupUser(USER_ID)).thenReturn(USER);assertThat(accessManager.userHasAccess(USER_ID)).isTrue();13.4.3 상호작용 테스트하기상호작용 테스트란 대상 함수를 실제로 호출하지 않고도 그 함수가 어떻게 호출되는지를 검증하는 기법이다.스텁과 비슷하게 상호작용 테스트에도 주로 모의 객체 프레임워크를 활용한다.13.5 실제 구현테스트 대역은 좋은 테스트 도구지만 구글은 가능하다면 시스템이 의존하는 실제 구현을 사용한다. 즉 제품 코드가 사용하는 것과 똑같은 구현체를 사용한다. 코드가 프로덕션 환경에서와 동일하게 동작해야 테스트 충실성이 높아지는데 실제 구현을 이용하면 자연스럽게 그렇게 된다.13.5.1 격리보다 현실성을 우선하자의존하는 실제 구현을 이용하면 테스트 대상이 더 실제와 가까워진다.좋은 테스트라면 어떤 구현을 사용하든 상관없어야 한다. 좋은 테스트는 구현이 어떻게 구성되었느냐의 관점이 아니라 검사할 API를 중심으로 작성되어야 한다.13.5.2 실제 구현을 사용할지 결정하기빠르고 결정적이고 의존성 구조가 간단하다면 실제 구현을 사용하는 게 좋다. 예를 들어 값 객체라면 실제 구현을 사용해야 한다. 금액, 날짜, 주소, 리스트, 맵 같은 컬렉션 클래스가 대표적인 값 객체다.다음과 같은 고려사항들을 염두해 두고 판단하자 실행시간 - 실제 구현의 수행시간이 오래걸릴때는 테스트 대역이 유용할 수 있다. 느린 것의 기준은 엔지니어마다 다르기 때문에 너무 느려졌다고 생각되는 때가 오면 테스트 대역을 투입하면 된다. 테스트 병렬화도 실행시간을 줄이는 데 효과적이다. 결정성 - 같은 버전의 시스템을 대상으로 실행하면 언제든 똑같은 결과를 내어주는 테스트를 결정적인 테스트라고 한다. 반대로 대상 시스템은 그대로인데 결과가 달라지는 테스트를 비결정적이라고 한다. 테스트에서 비결정성은 불규칙한 결과로 이어진다. 결과가 자주 튄다면 테스트 대역 투입을 고려할 때가 온 것이다. 의존성 생성 - 실제 구현을 이용하려면 의존 대상들도 모두 생성해야 한다. 이에 반해 테스트 대역은 대체로 다른 객체를 별로 사용하지 않는다. 따라서 생성하기가 훨씬 쉽다.13.6 속이기(가짜 객체)실제 구현을 이용할 수 없을 때는 가짜 객체가 최선일 경우가 많다. 가짜 객체는 실제 구현과 비슷하게 동작하기 때문에 다른 테스트 대역들보다 우선적으로 활용된다.//실제 구현도 같은 인터페이스를 이용한다.public class FakeFileSystem implements FileSystem { private Map&lt;String, String&gt; files = new HashMap&lt;&gt;(); @Override public void writeFile(String fileName, String contents){ files.add(fileName, contents); } @Override public String readFile(String fileName) { String contents = files.get(fileName); if(contents == null) {throw new FileNotFoundException(fileName);} return contents; }}13.6.1 가짜 객체가 중요한 이유가짜 객체는 테스트를 도와주는 강력한 도구이다. 빠른 것은 물론이고 실제 객체를 사용할 때의 단점을 제거한 채 테스트를 효과적으로 수행할 수 있게 해준다.13.6.2 가짜 객체를 작성해야 할 때가짜 객체는 실제 구현과 비슷하게 동작하기 때문에 노력도 더 들고 도메인 지식도 더 필요하다. 또 실제 객체의 행위가 변경될 때마다 발맞춰서 갱신해야 하므로 유지보수도 신경써야 한다.가짜 객체를 만들지 판단하려면 유지보수까지 포함한 비용과 가짜 객체를 사용해서 얻는 생산성 향상 정도를 잘 저울질해야 한다. 사용할 사람이 많지 않다면 굳이 시간들일 이유가 없지만 사용자가 수백명이라면 생산성이 높아지는 경험을 할 수 있을 것이다.13.6.3 가짜 객체의 충실성가짜 객체를 활용하는 핵심 이유는 충실성이 있을 것이다. 충실성은 가짜 객체가 실제 구현의 행위를 얼마나 비슷하게 흉내 내느냐를 말한다. 100% 충실하여 만들기는 어렵지만 그럼에도 가짜 객체는 실제 구현의 API 명세에 가능한 한 충실해야 한다. API를 통해 어떤 데이터를 건네든 가짜 객체는 실제 구현과 동일한 결과를 돌려주고 상태 변화도 똑같이 시뮬레이션해야 한다.13.6.4 가짜 객체도 테스트해야실제 구현의 API 명세를 만족하는지 확인하려면 가짜 객체에도 고유한 테스트가 딸려 있어야 한다. 실제 구현이 변경되면 실제 동작과 달라지게 되므로 자체 테스트로 이런 사태를 막아줘야 한다.13.6.5 가짜 객체를 이용할 수 없다면사용할 수 있는 가짜 객체가 없다면 가장 먼저 API 소유자에게 하나 만들어달라고 하면 된다. 그런데 소유자가 가짜 객체를 만들 생각이 없거나 만들 수 없다면 직접 작성할 수도 있다. 먼저 해당 API를 감싸는 클래스를 하나 만들어서 모든 API 호출이 이 클래스를 거쳐 이루어지게 한다. 그런 다음 인터페이스는 똑같지만 실제 API를 이용하지는 않는 클래스를 한 벌 더 준비한다. 이 클래스가 바로 가짜 객체다.13.7 뭉개기(스텁)스텁을 이용한 뭉개기는 원래는 없는 행위를 테스트가 함수에 덧씌우는 방법이다.13.7.1 스텁 과용의 위험성스텁은 적용하기 쉬워서 실제 구현을 이용하기가 여의치 않을 때마다 엔지니어들을 유혹한다. 하지만 스텁을 과용하면 테스트를 유지보수할 일이 늘어나서 오히려 생산성을 갉아먹곤 한다. 불명확해진다 - 스텁을 이용하려면 대상 함수에 행위를 덧씌우는 코드를 추가로 작성해야 한다. 이 추가로 코드는 읽는 이의 눈을 어지럽혀서 테스트의 의도를 파악하기 어렵게 한다. 깨지기 쉬워진다 - 스텁을 이용하면 대상 시스템의 내부 구현 방식이 테스트에 드러난다. 좋은 테스트라면 사용자에게 영향을 주는 공개 API가 아닌 한, 내부가 어떻게 달라지든 영향받지 않아야 한다. 테스트 효과가 감소한다 - 원래 행위를 뭉개버리면 해당 함수가 실제 구현과 똑같이 동작하는지 보장할 방법이 사라진다. 또 스텁을 이용하면 상태를 저장할 방법이 사라져서 대상 시스템의 특성 일부를 테스트하기 어려울 수 있다. 스텁을 과용한 예 - 364~365p13.7.2 스텁이 적합한 경우스텁은 실제 구현을 포괄적으로 대체하기보다는 특정 함수가 특정 값을 반환하도록 하여 대상 시스템을 원하는 상태로 변경하려 할 때 제격이다.목적이 분명하게 드러나게 하려면 스텁된 함수 하나하나가 단정문들과 직접적인 연관이 있어야 한다. 그래서 테스트들은 대체로 적은 수의 함수만 스텁으로 대체한다.13.8 상호작용 테스트하기상호작용 테스트는 대상 함수의 구현을 호출하지 않으면서 그 함수가 어떻게 호출되는지를 검증하는 기법이다.13.8.1 상호작용 테스트보다 상태 테스트를 우선하자상태 테스트란 대상 시스템을 호출하여 올바른 값을 반환하는지, 혹은 대상 시스템의 상태가 올바르게 변경되었는지를 검증하는 테스트를 말한다.구글은 오랜 경험을 통해 상태 테스트에 집중해야 훗날 제품과 테스트를 확장할 때 훨씬 유리하다는 사실을 깨달았다. 깨지기 쉬운 테스트가 줄어들고 나중에 테스트를 변경하거나 유지보수하기가 쉬워진다.상호작용 테스트의 문제점으로는 다음과 같이 있다. 시스템이 특정 함수가 호출되었는지만 알려줄 뿐 올바르게 작동하는지는 말해주지 못한다. 대상 시스템의 상세 구현 방식을 활용한다. 특정 함수가 호출되는지 검증하려면 대상 시스템이 그 함수를 호출할 것임을 테스트가 알아야 한다.13.8.2 상호작용 테스트가 적합한 경우 실제 구현이나 가짜 객체를 이용할 수 없어서 상태 테스트가 불가능한 경우 함수 호출 횟수나 호출 순서가 달라지면 기대와 다르게 동작하는 경우, 예) 데이터베이스 호출 횟수를 줄여주는 캐시 기능을 검증상호작용 테스트는 상태 테스트를 완전히 대체하지 못한다. 따라서 단위 테스트에서 상태 테스트를 수행할 수 없다면 상호작용 테스트를 추가하는 대신 더 큰 범위의 테스트 스위트에서 상태 테스트를 수행하여 보완하는 게 좋다.13.8.3 상호작용 테스트 모범 사례 상태 변경 함수일 경우에만 상호작용 테스트를 우선 고려하자 - 일반적으로 상호작용 테스트는 상태 변경 함수에 한해서만 수행해야 한다. 너무 상세한 테스트틑 피하자 - 어떤 함수들이 어떤 인수들을 받아 호출되는지를 너무 세세하게 검증하지 않는게 좋다. 그래야 테스트가 더 명확하고 간결해진다.13.9 마치며테스트 대역을 활용하면 대상 코드를 포괄적으로 검증하고 테스트 속도를 높여줘서 엔지니어링 속도에 아주 중요하다는 걸 알게되었다. 하지만 잘못 사용하면 테스트를 불분명하고, 깨지기 쉽고, 덜 효과적으로 만들어서 오히려 생산성을 크게 떨어뜨리기도 한다.테스트 대역은 테스트에서 사용하기 어려운 의존성 문제를 멋지게 우회하게 도와준다.13.10 핵심 정리 테스트 대역보다는 되도록 실제 구현을 사용해야 한다. 테스트에서 실제 구현을 사용할 수 없을 때는 가짜 객체가 최선일 때가 많다. 스텁을 과용하면 테스트가 불명확해지고 깨지기 쉬워진다. 상호작용 테스트는 되도록 피하는 게 좋다." }, { "title": "12. 단위 테스트", "url": "/posts/12.%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-11-04 22:01:18 +0900", "snippet": "구글에서 말하는 단위 테스트는 단일 클래스나 메서드처럼 범위가 상대적으로 좁은 테스트를 뜻한다.테스트의 가장 중요한 목적은 버그 예방이다. 그 다음으로는 엔지니어의 생산성 개선이 있다. 범위가 넓은 테스트와 비교했을 때 단위 테스트는 생산성을 끌어올리는 훌륭한 수단이 될 수 있다. 단위 테스트는 대체로 작은 테스트에 속한다. 작은 테스트는 빠르고, 결정적이여서 수시로 수행하여 즉각적인 피드백을 받을 수 있다. 단위 테스트는 작성하기 쉽다. 빠르게 작성할 수 있어 테스트 커버리지를 높이기 좋다. 기존 동작을 망가뜨리지 않으리라는 확신 속에서 코드를 변경할 수 있다. 실패시 원인을 파악하기 쉽다. 대상 시스템의 사용법과 의도한 동작 방식을 알려주는 문서자료 혹은 예제 코드 역할을 해준다.단위 테스트는 일상에서 비중이 크기 때문에 구글은 테스트 유지보수성을 상당히 중시한다. 유지보수하기 쉬운 테스트란 한 번 작성해두면 실패하지 않는 한 엔지니어가 신경 쓸 필요없고, 실패한다면 원인을 바로 알 수 있는 진짜 버그를 찾았다는 뜻이다.12.1 유지보수하기 쉬워야 한다.주변에서 흔히 목격되는 테스트 작성의 문제의 원인으로 버그도 없고 자신의 검증 대상과 관련없는 변경 때문에 실패하는 깨지기 쉬운 테스트들이 도사리고 있다. 무엇이 잘못되어 실패했는지 어떻게 고쳐야 하는지 파악하기 어려운 불명확한 테스트들이다.12.2 깨지기 쉬운 테스트 예방하기깨지기 쉬운 테스트란 실제로는 버그가 없음에도, 검증 대상 코드와는 관련조차 없는 변경 때문에 실패하는 테스트를 말한다. 이러한 테스트는 엔지니어가 직접 진단하고 수정해야 한다.12.2.1 변하지 않는 테스트로 만들기 위해 노력하자기본적인 변경 유형은 다음과 같다. 순수 리팩터링 - 외부 인터페이스는 놔두고 내부만 리팩터링 하는 경우 테스트는 변경되지 않아야 한다. 리팩터링 과정에서 테스트를 변경해야 한다면 원인은 1)시스템의 행위가 달라졌다, 2)테스트의 추상화 수준이 적절하지 않았다. 새로운 기능 추가 - 새로운 기능이나 행위를 추가할 때는 기존 행위들에 영향을 주지 않아야 한다. 기존 테스트를 변경해야 한다면 해당 테스트가 검증하는 기능에 의도치 않은 영향을 주었거나 테스트 자체에 문제가 있다는 뜻이다. 버그 수정 - 버그 수정은 새로운 기능 추가와 비슷하다. 행위 변경 - 시스템의 기존 행위를 변경하는 경우로 기존 테스트 역시 변경되어야 한다.리팩터링, 새 기능 추가, 버그수정시에는 기존 테스트를 손볼 일이 없어야 한다.12.2.2 공개 API를 이용해 테스트하자테스트가 시스템을 사용자와 똑같은 방식으로 사용하게 하면 테스트가 실패한 경우 사용자도 똑같은 문제를 겪는다. 그렇게 되면 테스트가 사용자에게 유용한 예제 코드와 문서자료가 되어준다는 이점을 얻을 수 있다.어디까지가 공개 API냐가 항상 명확한 것은 아니며 이는 단위 테스트에서 말하는 단위가 무엇이냐를 규정하는 핵심적인 질문으로 이어진다. 이런 맥락에서 공개 API란 이런 단위의 코드 소유자가 서드파티에 노출한 API를 뜻한다.(??)어디까지가 공개 API인가를 정하는 일에 정답은 없지만 경험법칙으로 다음과 같이 있다. 소수의 다른 클래스를 보조하는 용도가 다인 메서드나 클래스는 직접 테스트하지 말고 이들을 보조하는 클래스를 통해 우회적으로 테스트해야 한다. 소유자의 통제 없이 누구든 접근할 수 있게 설계된 패키지나 클래스라면 예외없이 직접 테스트해야하는 단위로 취급해야 한다. 소유자만이 접근할 수 있지만 다방면으로 유용한 기능을 제공하도록 설계된 패키지나 클래스 역시 직접 테스트해야 하는 단위로 본다.12.2.3 상호작용이 아니라 상태를 테스트하자시스템이 기대한대로 동작하는지 검증하는 방법으로 다음과 같이 있다. 상태 테스트 - 메서드 호출 후 시스템 자체를 관찰한다. 상호작용 테스트 - 호출을 처리하는 과정에서 시스템이 다른 모듈들과 협력해서 기대한 일련의 동작을 수행하는지를 확인한다.대체로 상호작용 테스트가 상태 테스트보다 깨지기 쉽다. 우리가 원하는 것은 결과가 무엇이냐 이지만, 상호작용 테스트는 결과에 도달하기까지 시스템이 어떻게 작동하냐를 확인하려 들기 때문이다.잠재적으로 문제가 될 수 있는 상호작용 테스트가 만들어지는 가장 큰 원인은 바로 모의 객체 프레임워크에 지나치게 의존하기 때문이다. 모의 객체 프레임워크를 이용하면 테스트 대역을 만들기 쉽고, 이는 자신을 향한 모든 호출을 기록하고 검증할 수 있게 해준다. 이러한 편리함에 엔지니어들에게 깨지기 쉬운 상호작용 테스트를 만들도록 유혹한다.그래서 우리는 진짜 객체가 빠르고 결정적이라면 진짜 객체를 사용해야 한다.12.3 명확한 테스트 작성하기깨지기 쉬운 요소를 제거했더라도 언젠가는 테스트가 실패한다. 실패하는 이유로는 대상 시스템에 문제가 있거나 불완전한 경우 테스트 자체에 결함이 있는 경우테스트 실패의 이유를 얼마나 빠르게 찾느냐는 테스트 명확성에 달려있다. 명확한 테스트는 존재 이유와 실패 원인을 엔지니어가 곧바로 알아차릴 수 있는 테스트를 말한다. 명확한 테스트는 대상 시스템의 문서자료 역할을 해주고, 새로운 테스트를 작성하기 쉽게 도와주는 토대가 되어주는 등의 이점도 제공한다.제품의 코드가 명확하지 않은 문제와는 다르다. 대체로 제품 코드는 해당 코드를 제거했을 때 어디에 문제가 생기는지나 호출 관계 등을 파헤쳐보면 비교적 쉽게 목적을 알아낼 수 있다. 반면 불명확한 테스트는 목적을 결코 알아내지 못할 가능성도 크다.12.3.1 완전하고 간결하게 만들자완전하고 간결성은 테스트를 명확하게 만드는 데 도움이 되는 거시적인 특성이다. 완전한 테스트는 결과에 도달하기까지의 논리를 읽는 이가 이해하는 데 필요한 모든 정보를 본문에 담고 있는 테스트를 말한다. 간결한 테스트는 코드가 산만하지 않고 관련 없는 정보는 포함하지 않는 테스트이다.[두 특성 중 어느 것도 갖추지 못한 안 좋은 테스트 예]@Testpublic void shouldPerformAddition() { //Calculator 생성자에서 관련 없는 정보를 잔뜩 받고 있다. Calculator calculator = new Calculator(new RoundingStrategy(), \"unused\", ENABLE_COSINE_FEATURE, 0.01, calculusEngine, false); //중요한 부분은 도우미 메서드인 newTestCalculation에 숨겨져 있다. int result = calculator.calculate(newTestCalculation()); assertThat(result).isEqualsTo(5);}[완전하고 간결한 테스트]@Testpublic void shouldPerformAddition() { Calculator calculator = new Calculator(); int result = calculator.calculate(newCalculation(2, Operation.PLUS, 3)); assertThat(result).isEqualsTo(5);}12.3.2 메서드가 아니라 행위를 테스트하자많은 엔지니어가 본능적으로 테스트의 구조를 대상 코드의 구조와 일치시키려고 한다. (제품 코드의 메서드 하나에 테스트 메서드도 하나씩 두는 식으로) 이렇게 되면 대상 메서드가 복잡해질수록 테스트도 함께 복잡해져서 실패해도 원인을 파악하기 어려워진다.public void displayTransactionResult(User user, Transaction transaction) { ui.showMessage(transaction.getItemName() + \"을(를) 구입하셨습니다.\"); if(user.getBalance() &lt; LOW_BALANCE_THRESHOLD) { ui.showMessage(\"잔고가 부족합니다!\"); }}[메서드 중심 테스트]@Testpublic void testDisplayTransactionResult() { transactionProcessor.displayTransactionResult(newUserWithBalance(LOW_BALANCE_THRESHOLD.plus(dollars(2))), new Transaction(\"물품\", dollers(3))); assertThat(ui.getText()).contains(\"물품을(를) 구입하셨습니다.\"); assertThat(ui.getText()).contains(\"잔고가 부족합니다!\");}[행위 주도 테스트]@Testpublic void testDisplayTransactionResult_showsItemName() { transactionProcessor.displayTransactionResult(new User(), new Transacion(\"물품\")); assertThat(ui.getText()).contains(\"물품을(를) 구입하셨습니다.\");}@Testpublic void testDisplayTransactionResult_showLowBalanceMarning() { transactionProcessor.displayTransactionResult( newUserWithBalance(LOW_BALANCE_THRESHOLD.plus(dollars(2)) ), new Transaction(\"물품\", dollers(3)) ); assertThat(ui.getText()).contains(\"잔고가 부족합니다!\");}테스트를 쪼개느라 코드가 늘어났지만 각 테스트가 명확하게 되었으니 결과적으로 그 이상의 값어치를 한 것이다. 행위 주도 테스트는 대체로 메서드 중심 테스트보다 명확하다. 이유는 자연어에 더 가깝게 읽히기 때문에 힘들여 분석하지 않아도 자연스럽게 이해할 수 있다. 테스트 각각이 더 좁은 범위를 검사하기 때문에 원인과 결과가 더 분명하게 드러난다. 각 테스트가 짧고 서술적이어서 이미 검사한 기능이 무엇인지 더 쉽게 확인할 수 있다.테스트의 구조는 행위가 부각되도록 구성하자모든 행위는 given, when, then 이라는 세 요소로 구성됨을 기억하자 given - 시스템의 설정을 정의 (예. 은행 잔고가 빈 상태에서) when - 시스템이 수행할 작업을 정의 (예. 돈을 인출하려 하면) then - 결과를 검증 (예. 거래를 거부한다.)@Testpublic void transferFundsShouldMoveMoneyBetweenAccount() { //given 두 개의 계좌, 각각의 잔고는 150과 20 Account account1 = newAccountWithBalacve(usd(150)); Account account2 = newAccountWithBalacve(usd(20)); //when 첫 번째 계좌에서 두 번째 계좌로 100 이체 bank.transferFunds(account1, account2, usd(100)); //then 각 계좌 잔고에 이체결과 반영 assertThat(account1.getBalance()).isEqualTo(usd(50)); assertThat(account2.getBalance()).isEqualTo(usd(120));}여러 단계로 진행되는 작업을 단계별로 검증하고 싶을 때는 when과 then 블록을 교대로 정의하는 방법도 있다. 이런 테스트를 작성할 때는 동시에 여러 행위를 검사하는 실수를 범하지 않도록 주의해야 한다. 테스트 각각은 단 하나의 행위만 다뤄야 한다.테스트 이름은 검사하는 행위에 어울리게 짓자메서드 중심 테스트들의 이름은 대체로 대상 메서드의 이름을 따서 짓는다. 반면 행위 주도 테스트에서는 이름 짓기가 더 자유롭기 때문에 더 의미 있는 정보를 담을 수 있다.테스트의 이름은 검사하려는 행위를 요약해 보여줘야 한다. 시스템이 수행하는 동작과 예상 결과를 모두 담아야 좋은 이름이다.메서드 이름에 전부 녹이게 되면 상당히 상세하고 길어진다. 제품에 들어갈 코드였다면 추천하지 않지만 우리는 이 메서드를 호출하는 코드를 작성할 일이 없다. 대신 이 이름들을 주로 보고서에 담겨서 사람에게 전달될 것이다.12.3.3 테스트에 논리를 넣지 말자복잡성은 대체로 논리라는 형태로 나타난다. 논리는 프로그래밍 언어에서 명령형 요소(연산자, 반복문, 조건문 등)를 이용해 표현한다.//논리가 버그를 감추는 예@Testpublic void shouldNavigateToAlbumsPage() { String baseUrl = \"http://photos.google.com/\"; Navigator nav = new Navigator(baseUrl); nav.goToAlbumPage(); assertThat(nav.getCurrentUrl()).isEqualTo(baseUrl + \"/albums\");}@Testpublic void shouldNavigateToAlbumsPage() { Navigator nav = new Navigator(http://photos.google.com/); nav.goToAlbumPage(); //전체 문자열을 적어주자 URL에 슬래시를 두 번 썼음이 바로 드러났다. assertThat(nav.getCurrentUrl()).isEqualTo(\"http://photos.google.com//albums\"); // ???}위 예처럼 단순한 문자열 연결에서도 버그를 잡아내기 쉽지 않은데 반복문이나 조건문처럼 더 복잡한 로직이 들어갔다면 말할 것도 없다. 테스트 코드에서는 스마트한 로직보다 직설적인 코드를 고집해야 한다. 또 서술적이고 의미 있는 테스트를 만들기 위한 약간의 중복은 허용하는 것이 좋다.12.3.4 실패 메시지를 명확하게 작성하자실무에서는 테스트 실패 보고서나 로그에 찍힌 메시지 한 줄로만 문제의 원인을 찾아야 할 때가 많다. 잘 작성된 실패 메시지라면 테스트의 이름과 거의 동일한 정보를 담고 있어야 한다. 원하는 결과, 실제 결과, 이때 건네진 매개변수의 값을 명확히 알려줘야 한다.12.4 테스트와 코드 공유: DRY가 아니라 DAMP!테스트를 명확하고 잘 깨지지 않게 해주는 마지막 요인은 코드 공유라는 주제와 관련이 있다. 대부분의 소프트웨어는 반복하지 말라는 뜻의 DRY 원칙을 숭배한다.DRY는 개념들을 각각 독립된 하나의 장소에서 구현하여 코드 중복을 최소로 줄이면 유지보수하기 더 쉽다고 말한다. 이 원칙대로 한다면 참조에 참조를 따라야 실제 로직을 구현한 코드를 찾아 분석할 수 있기 때문에 코드 명확성이 떨어진다는 단점도 생긴다.좋은 테스트는 안정적이고, 대상 시스템의 행위가 변경되면 실패하도록 설계된다. 따라서 테스트코드에서는 DRY가 주는 혜택이 그리 크지 않다. 테스트 코드는 DRY를 고집하는 대신, DAMP가 되도록 노력해야 한다. DAMP는 ‘서술적이고 의미 있는 문구’를 뜻한다. 단순하고 명료하게만 만들어준다면 테스트에서 다소의 중복은 괜찮다.테스트에서의 리팩터링은 반복을 줄이는 게 아니라 더 서술적이고 의미 있게 하는 방향으로 이루어져야 한다.12.4.1 공유 값[이름이 모호한 공유 값]private static final Account ACCOUNT_1 = Account.newBuilder().setState(AccountState.OPEN).setBalance(50).build();private static final Account ACCOUNT_2 = Account.newBuilder().setState(AccountState.CLOSED).setBalance(0).build();private static final Item ITEM = Item.newBuilder().setName(\"치즈버거\").setPrice(100).build();// 수백 줄의 다른 테스트들....@Testpublic void canBuyItem_returnsFalseForCloserdAccounts() { assertThat(store.canBuyItem(ITEM, ACCOUNT_1)).isFalse();}@Testpublic void canBuyItem_returnsFalseWhenBalanceInsufficient() { assertThat(store.canBuyItem(ITEM, ACCOUNT_2)).isFalse();}위 예는 테스트 스위트가 커질수록 문제가 된다. 각 테스트에서 왜 그 값을 선택했는지를 이해하기 어렵다.다음의 예는 도우미 메서드를 이용하여 데이터를 구성하는 방법을 사용한다. 테스트 작성자가 필요한 값들만 명시해 도우미 메서드에 요청하면 그 외 값들에는 적절한 기본값을 설정해 돌려준다.[도우미 메서드를 사용해 값을 공유하는 예]// 도우미 메서드는 각 매개변수에 임의의 기본 값을 정의하여 생성지를 래핑한다.def newContact(firstName = \"Grace\", lastName=\"Hopper\", phoneNumber=\"555-123-4567\"): return Contact(firstName, lastName, phoneNumber)// 테스트는 필요한 매개변수의 값만 설정하여 도우미를 호출한다.def test_fullNameShouldCombineFirstAndLastNames(self): def contact = newContact(firstName=\"에이다\", lastName=\"러브레이스\") self.assertEqual(contact.fullName(), \"에이다 러브레이스\")private static Contact.Builder newContact() { return Contact.newBuilder() .setFirstName(\"그레이스\") .setLastName(\"호퍼\") .setPhoneNumber(\"555-123-4567\");}@Testpublic void fullNameShouldConbineFirstAndLastNames() { Contact contact = newContact() .setFirstName(\"에이다\") .setLastName(\"러브레이스\") .build(); assertThat(contact.getFullName()).isEqualTo(\"에이다 러브레이스\");}이처럼 도우미 메서드를 이용하면 불필요한 정보로 오염되거나 다른 테스트와 출돌할 염려 없이 정확히 필요한 값들만 생성해 사용할 수 있다.12.4.2 공유 셋업테스트 각각을 수행하기 직전에 실행되는 메서드를 정의할 수 있게 해주는 것을 ‘셋업’ 메서드라고 한다 셋업 메서드는 대상 객체와 협력 객체들을 생성하는 데 매우 유용하다.//셋업 메서드에서 사용한 값에 의존@Beforepublic void setUp() { nameService = new NameService(); nameService.set(\"user1\", \"도널드 커누스\"); userStore = new UserStore(nameService);}//.....@Testpublic void shouldReturnNameFromService() { UserDetails user = userStore.get(\"user1\"); assertThat(user.getName()).isEqualTo(\"도널드 커누스\");}//셋업 메서드에서 사용한 값을 덮어씀@Beforepublic void setUp() { nameService = new NameService(); nameService.set(\"user1\", \"도널드 커누스\"); userStore = new UserStore(nameService)l}@Testpublic void shouldReturnNameFromService() { nameService.set(\"user1\", \"마거릿 해밀턴\"); UserDetails user = userStore.get(\"user1\"); assertThat(user.getName()).isEqualTo(\"마거릿 해밀턴\");}12.4.3 공유 도우미 메서드와 공유 검증 메서드도우미 메서드를 이용하면 테스트용 값을 생성하는 코드가 간결해진다. 하지만 모든 테스트가 마지막에 도우미 메서드를 호출하는 극단적인 상황은 위험한 습관이다.하나의 목적에 집중하는 검증 메서드는 유용하다. 검증용 도우미 메서드는 여러 조건을 확인하는 게 아니라 입력에 대한 단 하나의 개념적 사실만을 검증한다.12.4.4 테스트 인프라 정의하기가끔은 테스트 스위트와도 코드를 공유하면 유용할 때가 있다. 구글은 이런 종류의 코드를 테스트 인프라라고 부른다. 테스트 인프라는 주로 통합 테스트나 종단간 테스트 때 빛을 발한다.테스트 인프라는 단일 테스트 스위트 안에서의 코드 공유보다 훨씬 신중하게 접근해야 한다. 테스트 인프라는 많은 곳에서 호출되는 만큼 이에 의존하는 코드가 많다. 그래서 동작이 달라지면 다른 코드들이 깨지기 때문에 변경하기도 어렵다.12.5 마치며단위 테스트는 예기치 못한 변경에도 시스템이 오래도록 잘 구동되게끔 보증하기 위해 소프트웨어 엔지니어가 할 수 있는 가장 강력한 도구에 속한다. 하지만 단위 테스트를 생각 없이 만들면 시스템에 대한 확신을 키워주는 건 고사하고 시스템을 유지보수하거나 변경하기가 훨씬 어려워 진다.12.6 핵심 정리 변하지 않는 테스트를 만들기 위해 노력하자 공개 API를 통해 테스트하자 상호작용이 아닌 상태를 테스트하자 테스트를 완전하고 명확하게 만들라 메서드가 아닌 행위를 테스트하라 행위가 부각되게끔 테스트를 구성하라 테스트 이름은 검사하는 행위가 잘 드러나게 지으라 테스트에 로직을 넣지 말라 실패 메시지를 명확하게 작성하라 테스트들이 코드를 공유할 때는 DRY 보다 DAMP를 우선하자" }, { "title": "11. 테스트 개요", "url": "/posts/11.%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B0%9C%EC%9A%94/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-11-02 17:22:12 +0900", "snippet": "테스트는 처음부터 프로그래밍과 함께였다. 하지만 오랫동안 테스트 프로세스는 크게 개선되지 못 했고, 대부분 수동으로 이루어져 오류가 나기 쉬운 프로세스였다. 2000년대 초부터 테스트 방식이 진화되었고 그 진회의 중심에는 개발자가 주도하는 테스트와 자동 테스트가 있었다.자동 테스트는 버그가 몰래 숨어들어 고객을 놀라게 하는 시태를 막아준다. 또 새로운 기능을 추가하거나 코드가 더 건실해지도록 리팩터링하거나 대규모 재설계를 진행하는 상황에서 자동 테스트는 실수를 빠르게 잡아주므로 안심하고 소프트웨어를 변경할 수 있다.테스트 체계가 잘 갖춰져 있다면 변화를 두려워할 이유가 없다. 따라서 테스트 체계를 소프트웨어 개발의 핵심 역량으로 취급할 수 있다. 시스템을 더 많이 더 빠르게 변경하고 싶다면 더 빠르게 테스트하는 방법을 모색해야 한다.한편 테스트를 작성하는 행위가 시스템의 설계도 개선해준다. 자동 테스트를 작성하면 여러 문제를 개발 주기의 초반에 잡아내게 된다. 그 결과 모듈화가 더 잘되어 미래의 변화에 훨씬 유연한 소프트웨어가 만들어진다.11.1 테스트를 작성하는 이유테스트는 다음 요소들로 정의할 수 있다. 테스트하려는 단 하나의 행위 특정한 입력 관측 가능한 출력 혹은 동작 통제된 조건간단한 테스트가 수백, 수천개 모이면(test suit) 제품이 전체적으로 의도한 설계대로 잘 작동하는지, 혹은 언제 그렇지 못한 지를 이야기할 수 있게 된다. 테스트 스위트를 건실하게 만들고 유지하는 데는 많은 노력이 든다. 코드베이스의 덩치가 커지면 테스트 스위트도 커지는데 이때 테스트 결과가 일관되지 못하거나 느려지는 문제가 나타나기도 한다. 이러한 문제를 해결하지 못하면 테스트 스위트의 존재가 위태로워진다.테스트는 좋은 제품을 빠르게 만들 수 있게 해줄 뿐 아니라 우리 삶에서 중요한 제품과 서비스의 안전을 보장하는 데도 점점 핵심적인 역할을 하고 있다.구글은 문제가 터진 후에야 테스트를 고민해서는 안 된다. 라고 결론을 지었다.11.1.1 구글 웹 서버 이야기283~284p11.1.2 오늘날의 개발 속도에 맞는 테스트대부분의 소프트웨어는 기능과 자원 플랫폼이 너무 폭증해서 사람이 모든 행위를 수동으로 검증할 수 있는 한계를 아득히 넘어섰다. 모든 기능을 사람이 조작하여 제품 품질을 확인하는 방식은 확장이 불가능하다. 그래서 테스트에서의 해법은 단 하나 자동화 뿐이다.11.1.3 작성하고, 수행하고, 조치하라가장 순수한 형태의 자동 테스트는 테스트 작성, 테스트 수행, 실패한 테스트에 대한 조치 이렇게 세 가지 활동으로 이루어 진다. 자동 테스트는 적은 양의 코드로 구성된다. 테스트 코드는 환경을 원하는 모습으로 설정하고, 시스템을 호출하고, 결과를 검증한다.과거의 품질보증(QA) 프로세스와 달리 오늘날의 개발자들은 자신의 코드를 검사하는 자동 테스트를 작성하고 수행하는데 능동적이고 핵심적인 역할을 한다.테스트 작성은 테스트 자동화 프로세스의 첫 번째 단계일 뿐이다. 테스트를 작성한 후에는 작성한 테스트를 수시로 실행해야 한다. 자동 테스트의 핵심은 같은 동작을 끊임없이 반복하는 데 있다. 그리고 테스트 프로세스가 얼마나 효과적이냐는 이러한 테스트 실패를 어떻게 처리하느냐에 달려 있다. 실패 테스트가 해결되지 못하고 빠르게 쌓여간다면 테스트에 투자한 노력이 허사가 되니 그렇게 되지 않도록 하는 것이 중요하다.11.1.4 테스트 코드가 주는 혜택 디버깅 감소 - 테스트를 거친 코드는 통상적으로 결함이 적다. 테스트를 한 번 작성해두면 프로젝트가 살아 있는 내내 결함을 예방해주고 디버깅에서 해방시켜주는 식으로 지속해서 혜택을 준다. 자신 있게 변경 - 좋은 테스트들로 무장한 팀은 자신감을 가지고 변경들을 리뷰하고 수용할 수 있다. 더 나은 문서자료 - 한 번에 하나의 행위만 집중해 검증하는 명확한 테스트는 마치 실행 가능한 문서와 같다. 코드가 특정 상황에서 어떻게 동작하는지 궁금하다면 그 상황을 검증하는 테스트를 보면 된다. 더 단순한 리뷰 - 코드 리뷰시 다양한 측면에서 코드를 검사해주는 테스트가 준비되어 있다면 리뷰어가 변경된 코드가 제대로 작동하는지를 검증하는 시간을 크게 줄여준다. 사려 깊은 설계 - 새로 작성한 코드의 테스트를 작성하는 일은 실질적으로 해당 코드의 API가 잘 설계되어 있는지를 시험하는 행위이다. 고품질의 릴리스를 빠르게11.2 테스트 스위트 설계하기엔지니어들은 커다란 시스템 규모의 테스트를 작성하는 편을 선호하지만, 이러한 테스트는 작은 테스트와 비교하여 느리고 신뢰도가 낮고 디버깅하기도 어렵다. 고통을 줄이고자 하는 욕구가 엔지니어들을 점점 더 작은 테스트를 작성하도록 이끌었다. 그러면서 더 작은 테스트가 더 빠르고, 안정적이고, 평균적으로 고통이 적다는 걸 깨우쳤다.테스트에서 작다는 의미에는 두 가지 요소가 있다. ‘크기’, ‘범위’11.2.1 테스트 크기테스트의 크기를 가늠하는 기준은 코드 줄 수가 아니라 어떻게 동작하고, 무엇을 하고, 얼마나 많은 자원을 소비하는지로 평가한다.테스트 스위트에 바라는 품질은 속도와 결정성이다. 실제로 범위와 상관없이 작은 테스트는 더 많은 인프라나 자원을 사용하는 테스트보다 거의 항상 더 빠르고 더 결정적이다.작은 테스트가장 작은 테스트는 제약이 가장 엄격 하다. 가장 중요한 제약은 바로 테스트가 단 하나의 프로세스에서 실행되어야 한다는 것이다.서버를 두고 독립된 테스트 프로세스에 연결해 수행하는 방식도 허용되지 않고, 또 데이터베이스와 같은 제 3의 프로그램을 수행해서도 안 된다. 그리고 작은 테스트는 sleep, I/O 연산 같은 블로킹 호출을 사용해서는 안 된다. (네트워크, 디스트에 접근 불가) 그래서 블로킹 호출을 수반하는 대상을 검사하는 테스트 코드는 테스트 대역을 사용해야 한다.제약이 과한 이유는 작은 테스트 케이스 수백개로 이루어진 테스트 스위트가 하루종일 실행되는 환경에서 불규칙한 테스트가 단 몇 개만 있어도 원인을 찾아 헤매느라 생산성이 급격하게 떨어질 것이기 때문이다.중간 크기 테스트중간 크기 테스트는 여러 프로세스와 스레드를 활용할 수 있고, 로컬 호스트로의 네트워크 호출 같은 블로킹 호출도 이용할 수 있다. 단, 외부 시스템과의 통신은 여전히 불허하다.유연성이 커지면 반대급부로 테스트는 느려지고, 비결정적이 될 가능성이 높아진다. 여러 프로세스에 걸쳐 있거나 블로킹 호출을 하기 시작하면 운영체제나 서드파티 프로세스에 의존하게 된다. 외부 요인이 개입되므로 성능과 결정성을 온전히 우리 스스로가 보장할 수 없다는 뜻이다.큰 테스트큰 테스트는 로컬 호스트 제약에서 해방되어, 테스트와 대상 시스템이 여러 대의 기기를 활용할 수 있게 된다. 더 유연해지는 만큼 위험도 늘어나 여러 기기에 걸쳐있는 시스템을 네트워크로 연결해 다루게 되면서 단일 기기에서 구동할 때보다 느려지거나 비결정성이 커질 가능성이 훨씬 높아진다.테스트 크기와 무관한 공통 특성모든 테스트는 setup, execute, tear down 하는데 필요한 모든 정보를 담고 있어야 한다. 또 테스트 수행 순서 같은 외부 환경에 관해서는 가능한한 아무것도 가정하지 않아야 한다.테스트는 확인하려는 행위를 수행하는 데 필요한 정보만을 포함해야 한다. 깔끔한 코드는 테스트 실패 원인을 진단하는 데도 도움이 된다. 테스트는 무엇을 검사하는지가 명확해야 한다.실제 상황에서의 테스트 크기테스트 크기를 명확히 정의한 덕분에 구글은 규칙을 실무에 적용할 수 있는 도구들을 만들 수 있었다.11.2.2 테스트 범위테스트 범위란 주어진 테스트가 얼마나 많은 코드를 검증하느냐를 말한다. 좁은 범위 테스트는 독립된 클래스나 메서드 같이 코드베이스 중 작은 일부 로직을 검증하도록 설계된다. 중간 범위 테스트는 적은 수의 컴포넌트들 사이의 상호작용을 검증하도록 설계된다. 넓은 범위의 테스트는 시스템의 서로 다른 부분들 사이의 상호작용, 혹은 클래스나 메서드 하나만 실행할 때는 괜찮다가 여럿을 조합해 실행하면 나타나는 예기치 못한 동작을 검증하도록 설계된다.단위 테스트의 범위가 좁다고 할 때는 실행되는 코드가 아니라 검증되는 코드의 양이 기준이다.구글은 되도록 작은 테스트를 추구하며, 마찬가지로 좁은 범위 테스트를 추구한다. 단위 테스트는 빠르고 안정적이며 범위를 극적으로 좁혀줘서 클래스나 함수가 제공하는 동작들을 적은 노력으로도 모두 식별하게 해준다. 주의해야할 안티패턴으로 아이스크림콘과 모래시계가 있다.아이스크림 콘에서는 엔지니어들이 종단간 테스트를 많이 작성하고 통합 테스트나 단위 테스트는 훨씬 적게 작성한다. 이런 테스트 스위트는 일반적으로 느리고 신뢰할 수 없으며 고치기도 어렵다.모래시계는 종단간 테스트와 단위 테스트는 많지만 통합 테스트가 적다. 모래시계는 아이스크림 콘만큼 나쁘지는 않다. 모래시계 패턴은 구성요소들이 강하게 커플링되어 각각의 인스턴스를 독립적으로 만들어낼 수 없을 때 나타난다.11.2.3 비욘세 규칙어떤 행위나 속성을 테스트해야 할까? 깨뜨려보고 싶은 모든 것을 테스트하라비욘세 규칙은 네가 좋아했다면 CI 테스트를 준비해뒀어야지라는 뜻이다. 문제를 수정하고, 검증하는 테스트를 추가할 책임은 전적으로 코드를 작성한 자에게 있다.11.2.4 코드 커버리지코드 커버리지는 어느 테스트가 기능 코드의 어느 라인을 실행하는지를 측정하는 수단이다. 코드 커버리지는 테스트 품질을 파악하는 표준 지표로 간주되기도 하나 적은 수의 테스트만으로 상당량의 라인을 실행하면서도 의미 있는 동작은 거의 돌려보지 않을 수 있고, 또한 코드 커버리지는 호출된 라인 수만 셀 뿐, 실행 결과로 어떤 일이 벌어졌는지 고려하지 않는다.테스트 스위트의 품질을 높이는 더 나은 방안은 무엇일까? 바로 검사해야 할 행위에 집중하는 것이다.11.3 구글 규모의 테스트구글은 모든 코드를 모노리포 즉 하나의 리포지터리에서 관리한다. 구글의 코드베이스에서는 매주 약 2천 5백만 라인이 변경된다. 그중 절반 가량은 수만 명에 이르는 엔지니어들의 손가락에서 시작되며, 나머지는 자동화 시스템이 변경한다.또 코드베이스를 열어두면 코드베이스를 모두가 함께 책임지는 공동 소유 의식이 싹튼다.또 구글의 다른 독특한 점으로 리포지토리 브랜치를 사용하는 팀이 거의 없다. 모든 변경이 리포지토리 헤드에 직접 커밋되어 변경 즉시 모두가 볼 수 있다. 그리고 모든 소프트웨어는 테스트 인프라가 검증한 가장 최신 커밋까지 반영해 빌드된다.11.3.1 대규모 테스트 스위트의 함정코드베이스가 커지다 보면 기존 코드를 변경하는 일을 피할 수 없다. 자동 테스트가 엉망으로 작성되어 있다면 이럴 때 코드를 변경하기 어렵다. 특히 깨지기 쉬운 테스트가 우리를 가로막는다. 깨지기 쉬운 테스트를 만드는 주범으로 모의 객체 오용을 들 수 있다.깨지기 쉬운 테스트로 인한 저항 외에도 테스트 스위트가 커지면 수행 시간이 길어진다는 점도 문제이다. 느려질수록 수행 빈도는 자연스럽게 줄어들 것이고, 테스트의 가치는 그만큼 작아진다.테스트 스위트가 비결정적이고 느려지면 생산성을 갉아 먹는다. 테스트 스위트가 득보다 실이 많다면 엔지니어들은 결국 테스트를 실행하지 않고서라도 구현 작업을 끝마칠 수 있는 방법을 찾으려 할 것이다. 거대한 테스트 스위트를 잘 관리하는 비결은 바로 테스트를 존중하는 문화이다. 엔지니어들에게 테스트에 관심을 갖도록 장려하자문화를 가꾸는 일과 더불어 린터를 개발하거나 문서자료를 보강하는 등, 안 좋은 테스트를 만드는 실수를 줄여주는 테스트 인프라에도 투자해야 한다.11.4 구글의 테스트 역사11.4.1 오리엔테이션 수업구글의 초기 엔지니어 상당수가 테스트를 기피했다. 구글에서는 모든 신규 엔지니어가 반드시 거쳐야 하는 제도가 있었다. 바로 입사 오리엔테이션이다. 구글 초기에는 오리엔테이션 프로그램의 대부분이 의료혜택이나 구글 검색의 작동 방식 같은 주제로 다뤘다. 하지만 2005년을 시작으로 자동 테스트의 가치를 이야기하는 한 시간짜리 수업이 추가되었다. 이때 중요한 것은 이 모든 것이 구글 표준 관행인 것처럼 교육을 했다는 것이다.오리엔테이션을 마친 엔지니어들은 팀에 배정되어 배운 대로 테스트를 작성하기 시작했고, 그렇지 않은 팀원들에게 질문을 던지곤 했다. 이 후 1~2년 만에 오리엔테이션을 거친 엔지니어 수가 기존 엔지니어의 수를 넘어섰고, 올바른 토대 위에서 새로 시작하는 프로젝트가 많아졌다.11.4.2 테스트 인증초기에는 테스트 품질이 너무 많이 떨어져서 테스트하기가 거의 불가능했다. 그래서 테스팅 그룹릿은 테스트 인증이라는 인증 프로그램을 만들었다. 테스트 인증의 목적은 각 팀이 자신의 테스트 프로세스 수준을 알게 하고 한 단계 올라서기 위한 지침을 제공하는 것이었다.이 프로그램은 5개 레벨로 구성되며 해당 레벨로 인정 받는데 필요한 구체적인 조건을 정의했다.테스트 인증 레벨1이 되려면 가장 기본이 되는 조건 몇 가지를 충족해야 한다. 지속적 빌드 구축, 코드 커버리지 추적, 모든 테스트를 작은/중간 크기/큰 테스트로 구분, 불규칙한 테스트 식별, 바로 실행할 수 있는 빠른 테스트 스위트 마련이다. 레벨5가 되려면 모든 테스트를 자동화하고, 모든 커밋 전에 빠른 테스트 스위트가 수행되도록 하고, 비결정성을 완전히 제거하고, 모든 행위를 테스트해야 한다.11.4.3 화장실에서도 테스트테스팅 그룹릿이 구글의 테스트 문화 개선을 위해 취한 모든 활동 중 화장실에서도 테스트(TotT)만큼 참신한 건 없을 것이다. TotT의 목표는 회사 전반의 테스트에 대한 인식을 적극적으로 높이는 것이었다. 처음에는 정기적인 이메일 뉴스레터를 고려했으나 이미 구글 직원들은 메일의 홍수 속에 살고 있었기 때문에 관심 가지고 챙겨볼 직원은 거의 없을 것 같았다. 농담처럼 나온 화장실 변기 앞에 전단지를 붙여두자는 아이디어를 시작으로 TotT가 생겼다.TotT는 빠르게 구글의 대표적인 문화로 자리 잡았고, 현재까지 세계에 퍼져있는 구글 엔지니어들은 테스트에서 상상할 수 있는 거의모든 측면을 다루는 수백 편의 TotT를 제작했다.11.4.4 오늘날의 테스트 문화구글의 테스트 문화는 2005년부터 먼길을 걸어왔다. 신규 입사자 오리엔테이션에서는 여전히 테스트를 가르치고, 거의 매주 새로운 TotT가 배포되는 것도 똑같다.구글에서는 코드를 변경할 때마다 코드 리뷰를 거쳐야 한다. 그리고 모든 변경에는 테스트 코드가 포함되어 있어야 한다. 그렇다고 리뷰어가 테스트가 누락되었단 이유만으로 변경을 거부할 수는 없다. 또 테스트 인증 프로그램을 대체하고자 프로젝트 건실성(pH)란 개념이 생겼다.11.5 자동 테스트의 한계모든 종류의 테스트를 다 자동화할 수는 없다. 창의력이 필요한 분야에서 인간이 더 뛰어날 수 있다. 이를 일반화한 용어가 탐색적 테스팅이다.탐색적 테스팅은 기본적으로 창의력을 요구하는 작업으로 검사 대상을 마치 고장내야 할 퍼즐로 취급한다. 탐색적 테스팅으로 문제를 발견하는 즉시 자동 테스트를 추가하여 문제가 재발하지 않도록 예방해야 한다.11.6 마치며개발자 주도 자동 테스트는 구글에서 가장 혁신적인 소프트웨어 엔지니어링 관행 중 하나였다. 이 덕분에 구글은 더 큰 팀을 구성해 더 큰 시스템을 생각보다 빠르게 구축해냈다.11.7 핵심 정리 자동 테스트는 소프트웨어를 변경할 수 있게 해주는 토대이다. 테스트를 확장하려면 반드시 자동화해야 한다. 테스트 커버리지를 건실하게 유지하려면 균형 잡힌 테스트 스위트가 필요하다. 조직의 테스트 문화를 바꾸는 데는 시간이 걸린다." }, { "title": "10. 문서자료", "url": "/posts/10.%EB%AC%B8%EC%84%9C%EC%9E%90%EB%A3%8C/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-10-30 17:32:29 +0900", "snippet": "대부분의 엔지니어의 대표적인 불만이 양질의 문서자료가 부족하다는 것이다. 현실적으로 대부분의 문서자료는 소프트웨어 엔지니어 스스로가 작성해야 한다. 따라서 엔지니어가 문서화를 효과적으로 할 수 있도록 도와주는 적절한 도구와 보상이 필요하다.구글에서 문서자료를 개선하고자 해본 시도 중 가장 성공적이었던 방법은 문서자료를 코드처럼 취급하여 엔지니어링 워크플로에 통합하는 것이다. 그 결과 엔지니어들이 간단한 문서자료를 작성하고 유지보수하는 일이 한결 수월해졌다.10.1 문서자료란?문서자료란 엔지니어가 작업을 끝마치기 위해 작성해야 하는 모든 부수적인 텍스트를 의미한다.(코드 주석까지 포함됨)10.2 문서자료가 필요한 이유양질의 문서자료는 엔지니어링 조직에서 커다란 축복이다. 코드와 API가 이해하기 다 쉬워지고, 실수가 줄어든다. 하지만 문서자료가 주는 혜택은 주로 후임자들에게 돌아가므로 작성자에게는 즉각적인 이득이 없는 경우가 많다.문서자료는 단 한 번만 작성하면 되지만 결국 수백 번, 수천 번 읽히게 된다. 초기 비용은 미래의 모든 독자에게 혜택으로 돌아간다.문서작료는 작성자에게 다음과 같은 혜택을 준다. API를 가다듬는데 도움을 준다. 문서화를 하다보면 자연스럽게 자신의 설계를 되돌아보게 된다. 유지보수를 위한 로드맵과 과거 이력을 제공한다. 코드를 더 전문적이고 매력있어 보이게 한다. 이용자들의 질문이 줄어든다. 만약 다른이에게 두 번 이상 똑같은 설명을 하고 있는 자신을 발견한다면 그 내용을 문서화하는 것이 좋다.10.3 문서자료는 코드와 같다문서 쓰기는 코드 작성과 크게 다르지 않다. 프로그래밍 언어처럼 규칙이 있고, 구문 규정이 있고, 스타일도 있다. 코드와 마찬가지로 일관되어야 하고, 명확해야 하고, 이해를 방해하는 오류를 피해야 한다. 기술문서를 작성할 때는 문법도 중요하기 때문에 구글에서는 코드 주석도 프로그래밍 언어별로 표준 스타일을 정해놨다.문서자료를 다음과 같이 취급해야 한다. 꼭 따라야하는 내부 정책과 규칙이 있어야 한다. 버전 관리 시스템에 등록해 관리해야 한다. 관리 책임자를 명시해야 한다. 변경시 리뷰를 거쳐야 한다. 코드상의 버그를 추적하듯 문제를 추적해야 한다. 주기적으로 평가를 받아야 한다. 가능하다면 정확성이나 최신 정보 반영 여부등을 측정해야 한다.사례연구) 260p10.4 독자를 알자엔지니어들이 문서자료를 작성하며 범하는 가장 큰 실수는 자신만을 위해 쓴다는 것이다. 하지만 실제로는 그 문서자료의 독자는 사내의 모든 엔지니어와 외부 개발자까지 상당히 다양할 수 있다. 그래서 문서자료를 작성하기 전에 만족시켜야 할 독자가 누구인지 공식적으로든 비공식적으로든 알아내야 한다.10.4.1 독자 유형도메인 지식을 독자의 눈높이에 맞는 기술 수준으로 써야 한다 경험수준 : 전문 프로그래머 또는 초보 엔지니어 도메인 지식 : 팀원, API 정도만 친숙한 사내의 다른 엔지니어 목적 : API를 사용하는 최종 사용자 또는 책임감 있는 소프트웨어 전문대부분의 경우에는 가능한 한 모든 독자에게 적합한 방식으로 쓰는 것이 하나의 요령이다. 문서 작성의 핵심은 균형을 잘 잡는 것으로 문서를 짧게 쓰는게 유리하다.사용자가 문서자료를 접하게 되는 방식에 따라서 독자를 구분해볼 수 있다. 탐색자 : 자신이 원하는 것을 정확히 알고, 읽고 있는 문서자료가 원하는 정보를 담고 있는지를 알고 싶어 하는 엔지니어이다. 이런 독자에게는 일관성 이 핵심이다. 배회자 : 무엇을 원하는지 정확하게 알지 못하는 사람이다. 이런 독자에게는 명료한 글이 효과적이다.또 고객(API 사용자)냐 제공자(프로젝트 팀원)이냐도 중요한 독자 구분 기준이다. 가능하다면 각각의 독자를 위한 문서를 구분해주는 것이 좋다.10.5 문서자료 유형엔지니어는 개발 과정에서 설계 문서, 코드 주석, How-to 문서, 프로젝트 페이지 등 다양한 문서자료를 작성한다. 중요한 것은 종류가 다름을 알고 서로 섞이지 않게 하는 것이다. 하나의 문서는 일반적으로 하나의 목적에 집중해야 한다.10.5.1 참조용 문서자료참조용 문서자료는 엔지니어가 작성해야 할 문서자료 중 가장 흔한 형태이다. 실제로 거의 매일 작성해야 한다. 대표적인 예로 코드 주석이 있다. 이는 엔지니어들이 반드시 유지보수해줘야 한다. API 주석 - 구체적인 구현 방법이나 설계 결정 사항은 언급할 필요 없다. 사용자가 작성자만큼 API에 대해 잘 안다고 가정해서는 안 된다. 구현 주석 - 읽는 이가 도메인 지식을 상당히 갖추고 있다고 가정해도 된다.파일 주석구글에서는 거의 모든 파일에 파일 주석이 적혀있어야 한다. 일반적으로 파일 주석에는 파일에 담겨있는 내용을 요약해줘야 한다. (해당 코드의 주요 쓰임새와 어떤 독자를 의도하고 만든 코드인지 명시)클래스 주석클래스 주석은 코드베이스에서 사용되는 API 객체들을 정의하는 중요한 주석이다. 구글에서 모든 공개 클래스는 클래스 주석을 담고 있어야 한다.(해당 클래스의 목적과 주요 메서드들을 설명)함수 주석구글에서는 자유 함수나 클래스의 공개 메서드에는 무조건 함수가 무슨 일을 하는지 설명하는 함수 주석이 있어야 한다. 함수주석은 함수가 무슨 동작을 하고 무엇을 반환하는지를 설명하고 능동성을 부각하기 위해 동사로 시작해야 한다.10.5.2 설계 문서구글의 팀 대부분은 중요한 프로젝트에 착수하기 전에 설계 문서부터 승인받아야 한다. 엔지니어들은 일반적으로 팀에서 승인한 특정 템플릿을 이용해서 설계 문서 초안을 작성한다.좋은 설계 문서라면 설계의 목표와 구현 전략을 설명하고 설계상의 핵심 선택들과 관련한 트레이드오프를 명시해야 한다. 즉 설계 목표를 제시하고 대안이 될 수 있는 설계들의 장점과 단점까지 함께 기술해줘야 한다. 그리고 설계된 문서는 프로젝트가 목표를 성공적으로 완수했는지를 평가하는 기초 자료로 활용해야 한다.10.5.3 튜토리얼새로 팀에 합류한 엔지니어들을 위해 프로젝트 환경을 새로 구축하는 과정을 담은 튜토리얼이 아주 중요하다. 튜토리얼은 모든 팀원이 올바른 첫 발을 내딛는데 가장 좋은 방법 중 하나다.튜토리얼을 작성은 수행해야 했던 모든 일을 적는 것이다. 어떠한 사전 설정, 권한, 도메인 지식도 가정하지 말라 무언가 먼저 설정되어 있다고 가정했다면 튜토리얼 앞부분의 사전 요구사항 절에 명시하라 대부분의 튜토리얼은 전체 과정을 여러 단계로 나눠 독자가 순서대로 수행하도록 안내한다. 이런 경우 각 단계에 명확한 번호를 붙여야 한다.10.5.4 개념 설명 문서어떤 코드는 코드 주석 같은 참조용 문서자료만으로는 부족하여 깊이 있는 설명을 곁들여야 한다. 이럴때 시스템의 개요를 알려주는 개념 문서를 첨부한다. 개념 문서는 벌어질 수 있는 모든 상황을 다 설명하지 않아도 된다. 개념을 더 명확하게 전달하는 게 목적이라서 정확성을 다소 희생할 수 있다.개념 문서는 전문가에서 초보자까지 많은 독자에게 유익해야 한다. 그리고 명확성이 중요하므로 다소 완전하지 않거나 때로는 정확성을 희생하곤 한다.10.5.5 랜딩 페이지팀 페이지들은 대부분 어수선하다 랜딩 페이지에는 흥미를 끄는 링크들이 보일 것이고, 팀원용 정보와 고객용 정보가 섞여 있기도 할 것이다. 이런 문서들을 수정하기 위해서 랜딩 페이지의 목적을 명확히 인식하고 자세한 정보는 모두 다른 페이지를 가리키는 링크로 대체하면 된다. 랜딩 페이지에 링크가 많다면 절을 구분해서 페이지를 분류별로 분할하는 게 좋다.10.6 문서자료 리뷰구글은 코드 리뷰 외에 일반적으로 문서자료 역시 리뷰를 거쳐야 한다. 기술 문서 리뷰에 효과적인 방식은 크게 세 가지이다. 정확성 확인용 기술 리뷰 : 주로 해당 주제의 전문가가 수행하며 코드 리뷰 과정에서 함께 다루곤 한다. 명확성 확인용 독자 리뷰 : 주로 도메인을 잘 모르는 사람이 수행한다. 일관성 확인용 작문 리뷰 : 주로 테크니컬 라이터나 자원자가 수행한다.사례연구) 개발자 가이드 273p10.7 문서화 철학10.7.1 누가, 무엇을, 언제, 어디서, 왜대부분의 기술 문서자료는 어떻게에 대한 답을 제시한다. 그래서 엔지니어들은 다른 질문들은 잊은채 어떻게만 생각하는 경향이 생겼다. 누가 : 대상 독자가 누구인지 무엇 : 문서의 목적 언제 : 문서가 생성되고, 리뷰되고, 갱신된 날짜 어디에 : 문서가 존재해야 할 장소 왜 : 문서의 목적, 문서를 읽은 독자가 무엇을 얻어가기를 바라는지를 요약한다.10.7.2 시작, 중간, 끝대부분의 엔지니어는 중복을 꺼린다. 하지만 문서자료에서는 중복이 때론 유용하다. 각 절의 도입 단락에서 핵심을 요약해 알려준 후 해당 절의 나머지에서 구체적으로 사례를 설명하는 방법이 독자가 중요 내용을 이해하는 데 중복이 도움이 된다.10.7.3 좋은 문서자료의 특징일반적으로 좋은 문서자료들은 세 가지 특징을 보인다. (완전성, 정확성, 명확성) 하지만 하나의 문서에 세 특징을 모두 담기는 어렵다. 예) 문서를 더 완벽하게 만들려다 보면 명확성이 떨어지기 쉽다. 결국 좋은 문서란 의도한 역할을 잘 수행하는 문서라고 할 수 있다. 따라서 하나의 문서에 둘 이상의 역할을 맡기는 일은 거의 없다. 각각의 문서는 무엇에 집중할지를 정하고 그에 맞게 작성되야 한다.10.7.4 문서 폐기하기오래된 코드와 마찬가지로 오래된 문서도 문제를 일으키곤 한다. 그래도 문서를 버리는 일은 되도록 생기지 않도록 노력해야 한다. 문서가 본래의 목적을 더 이상 수행할 수 없다면 폐기하거나 폐기 대상으로 표시해줘야 한다.구글에서는 문서자료에 신선도 보증 기간을 붙여두곤 한다. 마지막에 리뷰한 날짜를 기록해두면 이 데이터를 활용하여 3개월동안 갱신되지 않을 시 알림 메일을 보내는 식이다.10.8 테크니컬 라이터가 필요한 순간구글의 엔지니어링 팀 대다수가 팀에 필요한 문서자료를 스스로 완벽하게 작성할 수 있음을 깨달았다. 다른 이의 도움이 필요한 경우는 오직 팀원 외 독자를 위한 문서를 작성할 때뿐이었다.테크니컬 라이터는 도메인에 익숙하지 않은 사람을 더 잘 대변할 수 있다. 그래서 테크니컬 라이터의 핵심 역할 하나가 프로젝트가 어디에 유용한가에 관한 팀 내 가정에 의문을 품어보는 것이다.10.9 마치며10.10 핵심 정리 문서자료는 시간이 흐르고 조직 규모가 커질수록 더 중요해진다. 문서자료 변경도 기존 개발자 워크플로에 통합되어야 한다. 하나의 문서는 하나의 목적에 집중해야 한다. 문서자료는 자신이 아니라 독자를 위해 써야 한다." }, { "title": "09. 코드 리뷰", "url": "/posts/09.%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-10-29 23:38:04 +0900", "snippet": "코드 리뷰는 작성자 이외의 사람이 코드를 검토하는 프로세스로, 주로 코드를 코드베이스에 반영하기 전에 수행한다. 코드 리뷰는 버그가 코드베이스로 침투하기 전에 잡아낸다처럼 확실하고 쉽게 납득되는 이점을 제공한다.9.1 코드 리뷰 흐름코드 리뷰는 소프트웨어 개발 단계 곳곳에서 이루어질 수 있다. 구글에서는 변경을 코드베이스에 커밋하기 전에 수행한다. 코드 리뷰의 최종 목표는 다른 엔지니어로부터 해당 변경을 적용해도 된다는 합의를 이끌어내는 것이다. 합의한 엔지니어는 좋아보임(LGTM)이라는 태그를 달아 의사를 표현한다.구글이 코드리뷰 절차) 234p코드는 부채다코드는 존재만으로 어느 순간 누군가 유지보수해야 할 대상이 되어 버린다.새로운 기능이 필요한 상황은 아주 흔하다. 하지만 개발을 시작하기 앞서 정말 새로운 기능이 맞는지 주의 깊게 살펴봐야 한다.중복 코드는 작성하는 시간 자체도 낭비지만 그 코드가 아예 존재하지 않을 때보다 관리 비용이 날이 갈수록 더 늘어나곤 한다. 이상적으로는 중복 확인이 먼저 이루어져야 한다.코드 리뷰 전에는 내린 설계를 번복하거나 재논의하는 자리여서는 안된다. 설계를 결정하는 데는 보통 시간이 걸린다. 설계 후보를 수차례 제안하고, API 리뷰 회의에서 토론하고, 프로토타입을 만들어보기도 한다. 따라서 코드 리뷰 과정 자체를 기존 결정을 다시 논의할 기회로 보아서는 안 된다.9.2 코드 리뷰 @ 구글구글에서는 어떤 변경이든 승인을 얻으려면 다음의 세가지 측면에서 리뷰를 통과해야 한다. 다른 엔지니어로부터 정확성과 이해 용이성을 평가 받는다. 의도한 작업을 코드가 적절히 수행하는지를 본다. 변경되는 코드 영역을 관리하는 코드 소유자로부터 변경 코드가 적절하다는 승인을 받는다.(코드베이스에 변경을 반영하려면 해당 디렉터리 소유자의 승인이 반드시 필요하다.) 가독성 승인을 받는다.9.3 코드 리뷰의 이점잘 설계된 코드 리뷰 프로세스와 코드 리뷰를 중요하게 다루는 문화가 주는 대표적인 이점으로 코드가 정확한지 확인해준다. 변경된 코드를 다른 엔지니어도 잘 이해한다. 코드베이스가 일관되게 관리된다. 팀이 소유권을 더 강하게 느낀다. 지식이 공유된다. 코드 리뷰 자체의 기록이 남는다.9.3.1 코드 정확성리뷰어는 일차적으로 변경된 코드의 정확성을 확인해주며 코드 리뷰가 주는 가장 확실한 이점이다. 한 연구에서 결함을 프로세스 초반에 잡아낼수록 나중에 발견해 고칠 때보다 시간이 덜 든다고 한다. 코드 리뷰에 들이는 시간은 테스트, 디버그, 회귀 테스트에 투입되는 시간을 줄여준다.물론 코드 리뷰 프로세스 자체를 단순화하여 가볍게 유지해야 한다.는 거시 핵심이다. 무겁거나 확장하기 어렵다면 코드 리뷰를 지속할 수 없다.정확성 평가가 주관적으로 흘러가지 않도록 하기 위해서 일반적으로 변경 작성자가 선택한 방식을 존중해야 한다. 리뷰어는 자신이 선호한다는 이유로 다른 안을 주장해서는 안 된다. 대안을 제시하는 것은 가능하지만 이해하기 쉽거나 기능을 개선하는 대안인 경우에만 그리해야 한다.그리고 코드 정확성 검사는 도구를 사용하여 자동으로 수행할 수 있으나 이는 일반적으로 해당 변경이 의도대로 작동함을 보여준다. 하지만 새로운 코드가 이해하기 쉽고 세월이 흘러 코드베이스가 커져도 여전히 의미가 통할것이다. 라는 측면은 단순히 코드가 논리적으로 정확하다거나 이해되는지만 살피는 것으로 부족하다.9.3.2 코드 이해 용이성코드 리뷰는 일반적으로 작성자외의 누군가가 변경을 살펴볼 수 있는 첫 번째 기회이다. 코드는 작성되는 횟수보다 읽히는 횟수가 몇 배는 많으므로 이해하기 쉽게 작성하는 게 매우 중요하다. 코드의 정확성과 이해 용이성 검토는 다른 엔지니어가 LGTM을 주기 위해 평가하는 주요 기준이 된다.9.3.3 코드 일관성규모가 커지면 내가 작성한 코드를 결국은 다른 사람이 이용하게 되고 다른 사람이 유지보수하게 된다. 따라서 코드는 일정한 표준을 따라야 하며 그래야 조직 안에서 이해되고 유지보수될 수 있다. 너무 복잡해져서도 안 된다. 코드가 단순해야 다른 사람들이 이해하기 쉽고, 유지보수하기도 쉽다.코드 리뷰 중 LGTM을 받은 상태와 가독성 승인을 분리한 이유는 유지보수성 때문이다.코드는 일관되고 단순해야지 사람들이 쉽게 이해할 수 있고 리팩터링 도구가 더 쉽게 다룰 수 있다.9.3.4 심리적, 문화적 이점코드 리뷰는 문화적으로 중요한 이점을 제공한다. 소프트웨어 엔지니어에게 코드는 자신의 것이 아니라 협업을 통해 만들어지는 조직의 공동 소유물임을 인식시켜주는 효과이다. 코드리뷰는 작성자가 다른 사람의 피드백을 받아들이고, 또 더 큰 이익을 위해 적절히 타협하도록 이끌어준다.자신의 코드에 대한 비판적 피드백이 달갑지 않은 것 역시 당연하다. 코드 리뷰는 이럴때 감정적으로 번질 수 있는 논쟁을 건전하게 만들어준다. 코드 리뷰가 제대로 작동한다면 작성자가 당연하게 여기던 가정이 틀릴 수 있음을 사전에 규정된 중립적인 방식으로 지적할 수 있다.또 다른 심리적 이점은 검증이다. 뛰어난 엔지니어조차 가면 증후군을 겪거나 자기비판이 심할 수 있다. 코드 리뷰는 그들의 작업 결과를 검증하고 인정해주는 효과가 있다. 그리고 작성자들에게 자신의 코드를 한번 더 들여다보게 하는 효과가 생긴다. 코드 리뷰라는 장치가 없다면 수많은 사람이 자연스럽게 절차를 무시하려 들 것이다. 사소한 결함은 나중에 해결하겠다는 안일함으로 말이다.9.3.5 지식 공유리뷰 프로세스는 제안, 신기술 소개, 조언을 통해 리뷰어가 변경 작성자에게 도메인 지식을 전파하도록 이끌어준다. 코드 리뷰중 피드백을 주고 받는 과정에서 양방향 정보 교환이 이루어진다. 작성자는 물론 리뷰어도 새로운 기술이나 패턴을 배울 수 있다는 뜻이다.리뷰를 통한 지식 공유는 지역, 국가, 프로젝트 경계에 구애받지 않고 코드베이스 구석구석의 모든 엔지니어에게 빠르게 전파된다.9.4 코드 리뷰 모범 사례9.4.1 공손하고 전문가답게구글은 신뢰와 존중 문화를 조성하기 위해 심혈을 기울인다. 코드 이해 용이성과 요건을 충족시키려면 단 한 명의 엔지니어만 LGTM이라고 선언해줘도 충분하다. 하지만 리뷰하는 엔지니어들은 해당 변경이 이번 한 번의 리뷰만 통과하면 코드베이스에 반영될 수 있음을 잘 알고 있어 절대 가볍게 LGTM을 남발하지 않는다.리뷰어들은 작성자가 선택한 방식을 존중하고 오직 그 방식에 결함이 있을 때만 대안을 제시해야 한다. 그리고 구글에서는 코드 리뷰 피드백이 24시간 내에 올 거라 기대하기 때문에 신속하게 피드백을 해주어야 한다.9.4.2 작게 변경하기코드 리뷰 프로세스를 날렵하게 가져가기 위해 가장 중요한 모범 사례를 보면 변경을 작게 만드는 것이다. 리뷰어나 작성자에게나 코드 리뷰는 단 하나의 문제만을 다루는 게 가장 이상적이다. 구글은 거대한 변경을 지양하며, 리뷰어는 큰 변경에 대해서는 거부할 권한이 있다.구글에서는 코드 리뷰가 대부분 작게 이루어지기 때문에 거의 모든 변경이 단 한 사람으로부터만 리뷰를 받는다. 이렇게 하지 않으면 프로세스 자체를 확장할 방법이 없다.9.4.3 변경 설명 잘쓰기변경 설명의 첫 줄은 어떤 종류의 변경인지를 잘 요약해야 한다. 첫 줄이 변경 전체를 요약해주지만, 구체적으로 무엇을 왜 변경하는지 알려주는 자세한 설명 역시 필요하다.만약 리뷰어가 코드를 이해하지 못한다면 비록 올바르게 동작하는 코드일지라도 구조를 개선하거나 주석을 더 잘 달아놔야 한다는 신호일 수 있다.9.4.4 리뷰어는 최소한으로구글에서 이루어지는 대부분의 코드 리뷰는 정확히 한 명의 리뷰어만으로 진행된다. 리뷰어가 한 명씩 추가될 때마다 새로운 시각이 한 스푼씩 더해지며, 결국 수확 체감으로 이어진다. 첫 번째 LGTM이 가장 중요하며 두 번째부터는 크게 신경 쓸 만큼의 가치가 없다는 걸 발견했다. 리뷰어를 추가해서 얻는 가치보다 비용이 훨씬 빠르게 증가한다.9.4.5 가능한 한 자동화하기코드 리뷰는 사람이 주도하는 프로세스라서 사람이 주는 피드백이 중요하다. 하지만 프로세스 중 자동화할 수 있는 요소가 있다면 자동화하자, 기계적인 작업을 찾아서 도구에 맡기면 투자한 만큼 거두게 될 것이다.자동화는 코드 리뷰 프로세스에 도움됨은 물론이고 리뷰어가 포맷팅보다 더 중요한 문제에 집중하도록 도와준다.9.5 코드 리뷰 유형9.5.1 그린필드 코드 리뷰그린필드 리뷰는 완전히 새로운 코드를 대상으로 하는 가장 드문 유형의 코드 리뷰이다. 대상 코드가 오랜 기간 존속될 수 있는지를 평가하기에 가장 중요한 기회이다.9.5.2 동작 변경, 개선, 최적화구글에서 이루어지는 대부분의 변경은 코드베이스 안의 기존 코드를 수정한다고 볼 수 있다. API 수정, 기존 구현 개선, 성능 최적화 등이 이루어진다. 이 경우에도 그린필드 리뷰의 지침이 그대로 적용된다. 꼭 필요한 변경인지, 코드베이스를 개선하는지를 살펴야 한다. 가장 바람직한 변경의 멋진 예로 죽은 코드나 낡은 코드 제거가 있다. 이는 코드베이스를 전반적으로 건실하게 만드는 아주 멋진 방법이다.9.5.3 버그 수정과 롤백버그 수정시 다른 문제까지 묶어 처리하고픈 마음을 꾹 눌러야 한다. 여러 주제가 섞이면 리뷰할 게 많아지고, 회귀 테스트나 롤백을 훨씬 어렵게 만든다. 버그 수정은 온전히 그 버그를 잡는 데만 집중하자.또 잠재적으로 롤백을 유발할 수 있는 모든 변경은 가능한 한 작고 원자적이어야 한다. 그래야 혹시 롤백으로 인해 해당 코드를 사용하던 다른 모듈이나 프로젝트들이 망가지는 문제를 막을 수 있다.9.5.4 리팩터링과 대규모 변경구글에서는 많은 변경이 자동으로 생성된다. 변경의 작성자가 사람이 아니라 기계라는 뜻이다. 기계가 생성한 변경도 리뷰가 필요하다. 어느 리뷰와 다를바 없지만 댓글을 다는 것은 지양하라고 안내한다.9.6 마치며코드리뷰는 구글에서 가장 중요하고 핵심적인 프로세스에 속한다. 따라서 작은 변경, 빠른 피드백과 반복 같은 모범 사례가 엄격히 지켜져야 한다. 그래야 개발 만족도와 생산 속도가 유지된다.9.7 핵심정리 코드 리뷰는 지식을 조직 전체에 공유하는 데 중요한 역할을 한다. 코드 리뷰 프로세스를 확장하려면 자동화가 아주 중요하다. 코드 리뷰 자체가 변경 이력이 되어 준다." }, { "title": "08. 스타일 가이드와 규칙", "url": "/posts/08.%EC%8A%A4%ED%83%80%EC%9D%BC-%EA%B0%80%EC%9D%B4%EB%93%9C%EC%99%80-%EA%B7%9C%EC%B9%99/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-10-27 23:21:04 +0900", "snippet": "대부분 엔지니어링 조직에는 내부 코드베이스를 관리하는 규칙이 있다. 예) 소스코드를 저장하는 위치, 코드 포맷팅, 명명 방식, 패턴, 예외와 스레드 사용법 등을 규정한다. 규칙은 제안이나 권장사항이 아닌 엄격하고 꼭 지켜야하는 법이다. 한편 지침은 권장사항과 모범 사례를 말한다.구글에는 코딩할 때 따라야하는 규칙들을 모아서 프로그래밍 스타일 가이드로 정리해 표준으로 삼았다. 이 스타일 가이드는 구글의 코드를 지배하는 종합적인 규약 모음집이다.8.1 규칙이 필요한 이유규칙을 관리하는 목표는 좋은 행동을 장려하고 나쁜 행동을 억제하기 위함이다. 좋은, 나쁜의 해석은 관심사가 다르기 때문에 조직마다 차이가 있다.가장 먼저 조직이 추구하는 가치를 파악해야 한다. 무엇을 장려하거나 억제할지를 규정하는 규칙과 지침은 그 가치를 기준으로 정해진다.확립된 규칙과 지침은 조직이 커지더라도 일관되게 통용되는 공통의 코딩 어휘가 되어 준다. 어휘가 통일되면 엔지니어들은 코드를 표현하는 형식보다 코드에 담을 내용에 집중할 수 있다.8.2 규칙 만들기규칙을 정의할 때는 어떤 목표를 이루려하는지에 집중해야 한다.8.2.1 기본 원칙 안내규칙을 만들 때 염두에 두어야 하는 중요한 원칙들은 다음과 같다. 규칙의 양을 최소화 한다 코드를 읽는 사람에게 맞춘다. 일관되어야 한다. 오류가 나기 쉽거나 예상치 못한 동작을 유발하는 구조를 피한다. 꼭 필요하다면 실용성을 생각해 예외를 허용한다.1)규칙의 양을 최소화 한다조직 내 모든 엔지니어가 새로운 규칙들을 익히고 적응하는 데는 비용이 든다. 규칙이 너무 많다면 엔지니어들이 다 기억하지도 못 할 것이고 새로 합류한 엔지니어가 적응하기도 어렵다.2)읽는 사람에게 맞춘다코드 작성자보다 읽는 사람에 최적화해야 한다. 작성되는 횟수보다 읽히는 횟수가 더 많으며 시간이 지날수록 차이가 벌어진다. 따라서 읽기 난해한 것보다 타이핑하기 지루한 편이 낫다. 독자 중심주의의 일환으로 구글은 엔지니어가 의도한 행위를 분명하게 알려주는 증거를 코드에 남기라고 요구한다.3)일관되어야 한다4)일관성이 안겨주는 이점코드베이스의 스타일과 기준이 일관되면 코드를 작성하는 엔지니어와 읽는 이들은 어떻게 표현하느냐가 아닌 무엇을 수행하느냐에 집중할 수 있다. 또 일관성은 규모를 확장하기 쉽게 도와준다. 조직 확장에는 도구 활용이 핵심이며 코드가 일관되면 코드를 이해하고 수정하고 생성하는 도구를 더 쉽게 만들 수 있다.그리고 조직이 성장하면서 같은 코드베이스를 공유하는 엔지니어의 수도 늘어나는데 이때 코드를 가능한한 일관성 있게 관리하면 엔지니어들이 새로운 팀으로 옮겨 적응 하는 시간이 단축된다. 그 결과로 조직의 필요에 맞게 인력을 유연하게 재배치할 수 있다. 또 시간이 흐르면서 엔지니어 일부가 프로젝트를 떠나고 새로운 인력이 합류하게 되도 코드가 일관성이 있으면 이런 전환 비용이 낮아지고 코드와 엔지니어 모두 거의 제약 없이 재배치될 수 있다.5)표준 정하기스타일 가이드는 과학적이고 기술적인 선택보다 지역적인 규약에 따르라고 명시한 규칙이 많다. 해당 영역에서의 일관성을 더 중요하게 생각하기 때문이다.일반적으로 규약은 바깥세상과 일관되게 잡는 편이 유리하다. 작고 독립적이고 수명이 짧은 코드라면 내부의 일관성이 중요하고, 수명이 길고 확장될 가능성이 큰 코드라면 널리 쓰이는 표준을 따르는 게 유리하다.6)오류를 내기 쉽거나 예상과 다르게 동작할 여지가 있는 구조는 피하자복잡한 기능에는 미묘한 함정이 숨어있는 경우가 많다. 따라서 정확하게 이해하지 못한 채 사용하면 그 복잡성 때문에 오용하여 버그를 유발하기 쉽다. 심지어 정확히 이해하고 사용했다고 해도 나중에 합류한 팀원이나 유지보수를 맡은 엔지니어도 같은 수준으로 이해할지는 보장할 수 없다.이로 인해 구글의 파이썬 스타일 가이드에서는 리플렉션 등 몇가지 고급 기능을 사용하지 못하게 제한하고 있다.7)실용적 측면을 인정하자스타일 가이드의 규칙들에 때로는 예외가 필요하다는 것을 잘 알고 있다. 따라서 꼭 필요하다면 최적화나 실용성을 위해 예외를 허용한다.8.2.2 스타일 가이드모든 스타일 가이드 규칙은 세 범주로 나눌 수 있다. 위험을 피하기 위한 규칙 - 구글의 스타일 가이드에는 기술적인 이유 때문에 반드시 써야 하거나 쓰면 안 되는 언어 특성들에 관한 규칙들이 담겨있다. 어떤 언어 특성은 사용하고 어떤 구조는 피해야 하는지를 설명하는 규칙들이다. 모범 사례를 적용하기 위한 규칙 - 코드 작성 시 모범 사례를 반드시 따르도록 강제하는 규칙도 담겨있다. 이런 규칙들은 코드베이스를 건실하고 관리 가능하게 지켜준다. (주석 관련 규칙들, 소스파일의 구조도, 명명 규칙…), 또 새롭거나 아직 널리 이해되지 못한 언어 기능을 제한하기도 한다. 일관성을 보장하기 위한 규칙 - 구글 스타일 가이드에는 사소한 문제를 다루는 규칙도 많다. 이 규칙들의 목적은 단순히 결정을 내리고 그 결정을 문서로 남기는 것이다. 사소한 것으로 어떻게 할지 시간 낭비를 하지 않고 더 중요한 일에 시선을 돌릴 수 있다.8.3 규칙 수정하기세월이 흐르면 기존 결정이 내려질 당시와는 내부 사정이 달라지고 결정에 영향을 준 요인들도 변할 수 있다. 만약 엔지니어들이 특정 규칙을 우회하는 데 에너지를 쓰고 있다면 그 규칙에 기대했던 트레이드오프를 재검토해야 할 것이다. 모든 규칙을 유용하고 최신 상태로 유지하려면 업데이트가 필요한 규칙이 무엇인지를 적시에 알아챌 수 있어야 한다.구글 스타일 가이드의 규칙에는 각각의 결정을 뒷받침하는 근거를 명시해뒀다. 규칙을 추가할 때는 장단점과 잠재적인 파장을 분석하고 결정을 실행하는 데 수반되는 변경량이 구글 규모에서는 무리가 없는지 검증하는 데 많은 시간을 사용한다. 각 결정에 이른 근거를 문서로 남겨두면 규칙을 변경해야 할 때가 언제인지를 알아내기 쉬워진다는 이점이 있다.사례) 221p8.3.1 프로세스구글이 추구하는 긴 수명과 확장 가능성을 감안하여 변경해야할 것이 있는지를 찾아내고 갱신하는 프로세스를 수립했다. 스타일 가이드의 수정 제안의 형식은 먼저 현재 문제를 찾아내 설명한 다음 해법을 보여준다. 이 때 문제는 현존하는 구글 코드에서 발견된 패턴으로 입증해야 한다.규칙이 수정되어야 할 시점을 알아차리기에는 스타일 가이드에 입각해 코드를 작성하는 엔지니어들의 커뮤니티가 가장 유리할 것이다. 실제로도 스타일 가이드 수정 대부분이 커뮤니티에서의 토론으로부터 출발한다.8.3.2 스타일 중재자구글 스타일 가이드들은 언어별로 소유자가 따로 있어서 최종 결정과 승인을 책임진다. 이 소유자들을 스타일 중재자라고 부른다. 프로그래밍 언어별로 경험 많은 전문가 그룹이 스타일 가이드를 소유하고 결정권자 역할을 한다.그리고 제안된 수정은 엔지니어링 측면에서 트레이드 오프를 논의하여 결정하며 스타일 가이드가 지향하는 목표에 입각하여 판단한다. (개인의 취향이 아닌 트레이드 오프가 기준이 됨)8.3.3 예외규칙을 따르기보다 예외를 인정하는 쪽이 이득이라고 판단될 때만 예외를 허용한다.8.4 지침규칙과 더불어 구글은 다양한 형태의 프로그래밍 지침도 관리한다. 지침이란 구글의 엔지니어링 경험에서 선별한 지혜이자 과거로부터 배운 교훈들로부터 추린 모범 사례들을 문서로 남긴 것이다. 지침은 주로 사람들이 자주 실수하는 것 혹은 아직 익수치 않는 새로운 주제라서 혼란스러워하는 것들에 집중한다.8.5 규칙 적용하기규칙을 강제하는 방법으로 교육과 훈련을 통한 사회적인 방법과 도구를 이용한 기술적인 방법이 있다. 구글은 다양한 정규 교육을 운영하고 있다. 또 엔지니어들이 규칙을 인지하고 이해하도록 하기 위해 구글의 훈련 프로그램의 중심에는 코드 리뷰가 자리한다.도구를 활용해서 규칙이 실제로 잘 지켜지는지 확인할 수도 있다. 도구를 사용하면 전에 없던 규칙이 생겼을 때도 모든 프로젝트의 모든 엔지니어가 규칙들을 잘 준수하는지 알 수 있다.하지만 도구를 활용하더라도 모든 규칙을 강제로 적용하기는 불가능할 수 있다. 때로는 사람이 판단해야만 하는 규칙도 있기 때문이다. 그리고 기술보다는 사회적 문제를 다루는 규칙도 있으며 사회적 문제를 기술적 시각으로 해결하려 드는 것은 현명하지 않다. 하지만 기술적 문제를 다루는 규칙이라면 가능한 한 기술적으로 자동 집행되게 하는 걸 선호한다.8.5.1 오류 검사기언어 사용법과 관련한 규칙들의 상당수는 정적 분석 도구로 강제할 수 있다. 이런 도구를 활용하면 코드 작성자는 적용해야 할 규칙을 모두 숙지해야 하는 부담을 덜 수 있다. 또 어떻게 고쳐야 할지도 함께 제시해주니 규칙을 준수하는 비용을 낮출 수 있다.8.5.2 코드 포맷터구글은 코드의 형식을 일관되게 관리하기 위해 자동 스타일 검사기와 포맷터를 적극 이용한다. 그래서 엔지니어들은 로직 구현에만 집중하면 된다.구글은 프리서브밋 검사로 포맷터를 반드시 사용하게 한다. 코드를 리포지토리로 서브밋 하기 전에 빌드 인프라의 서비스가 포맷터를 수행하여 서브밋할 코드와 차이가 있는지 비교한다.8.6 마치며큰 조직이라면 코드 베이스의 복잡성을 관리하여 감당할 수 있는 수준으로 유지하는 데 규칙이 큰 도움이 된다. 규칙 모음은 엔지니어링 프로세스에 기준을 잡아주어 코드베이스를 계속 확장하고 성장할 수 있게 해 준다.8.7 핵심 정리 규칙과 지침의 목표는 시간과 확장 관점에서의 탄력성을 높이는 것이어야 한다. 상황이 변하면 규칙도 달라져야 하니 규칙이 만들어진 근거 데이터를 알고 있어야 한다. 모든 것을 규칙으로 강제해서는 안 된다. 일관성이 핵심이다. 가능한 한 규칙들이 자동으로 적용되도록 해야 한다." }, { "title": "07. 엔지니어링 생산성 측정하기", "url": "/posts/07.%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81-%EC%83%9D%EC%82%B0%EC%84%B1-%EC%B8%A1%EC%A0%95%ED%95%98%EA%B8%B0/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-10-26 22:19:04 +0900", "snippet": "구글은 데이터를 토대로 결정하는 데이터 주도 회사이다. 대다수 결정을 객관적으로 내릴 수 있고, 그에 따라 대체로 좋은 결과로 이루어진다. 사람과 관련해서는 데이터를 수집하고 분석하기가 만만치 않다.구글은 소프트웨어 엔지니어링 측면에서 엔지니어링 생산성 자체에 집중하는 전문가 팀을 별도로 꾸려두면 회사 성장 과정에서 아주 중요하고 값진 통찰을 얻을 수 있음을 알아냈다.7.1 엔지니어링 생산성을 측정하는 이유사업을 키우면 자연스럽게 엔지니어링 조직의 규모도 늘려간다. 그런데 조직이 두 배 커지면 소통 비용은 제곱으로 늘어난다. 사업 확장 문제를 다르게 풀 수도 있다. 개개인의 생산성을 높여, 조직 내 엔지니어들 각자의 생산성이 높아진다면 소통 비용 증가를 억제하면서 사업을 키울 수 있다.구글은 엔지니어링 생산성을 이해하기 위한 전담 연구팀을 꾸렸다. 여기에는 소프트웨어 엔지니어링 연구자와, 일반 엔지니어, 다양한 분야의 사회과학자들로 팀을 꾸렸다. 사회 과학자들이 합류하여 개인의 동기, 성과 보상 구조 등 인간적인 측면까지도 이해할 수 있게 되었다.7.2 선별: 측정할 가치가 있는가?엔지니어들의 생산성을 측정할 방법을 정하기에 앞서 해당 지표가 측정할 가치가 있는지을 알아봐야 한다. 측정 자체에도 비용이 많이 들기 때문에 현명하게 측정하고 평가해야 한다.구글은 각 팀이 생산성 측정을 해도 될지를 결정하는 데 도움되는 질문 목록을 마련했다. 먼저 구체적인 질문을 던져서 그들이 측정하고 싶은 것을 설명하도록 요청한다. 이때 사람들이 이 질문에 더 구체적으로 답할수록 측정 과정에서 얻는 것도 많아짐을 알게 되었다.187~190p7.3 GSM 프레임워크: 목표와 신호를 뒷받침하는 의미 있는 지표 선정하기소프트웨어 프로세스를 측정하기로 했다면 이용할 지표를 선정해야 한다. 구글은 지표를 만들 때 GSM(목표, 신호, 지표)이라는 프레임워크를 쓴다. 목표 : 측정자가 원하는 최종 결과 신호 : 원하는 최종 결과를 이루었는지 판단하는 방법 지표 : 우리가 실제로 측정하는 대상GSM 프레임워크는 지표를 만들 때 유용한 지침이 되어준다. 목표를 세우고, 신호를 정하고, 지표를 만드는 순서 덕분에 가로등 효과를 없애준다. 실제 결과를 측정하기 앞서 원칙에 입각하여 적절한 지표들을 선정하게 해줌으로써 지표 크리프와 지표 편향을 예방해준다. GSM은 측정이 되는 영역과 그렇지 않은 영역을 알려준다.중요한 것은 추적 가능성을 잃지 않는 것이다. 각각의 지표로부터 관련한 신호를 찾아낼 수 있고, 나아가 그 신호가 대변하는 목표에까지 거슬러 추적할 수 있어야 한다. 그래야만 어떤 지표가 무엇을 측정하고 왜 측정하는지를 알 수 있다.7.4 목표(Goal)목표는 원하는 속성을 설명하되 어떠한 지표도 명시해서는 안 된다. 따라서 목표 자체는 측정이 불가능하다. GSM의 효과를 보려면 가장 먼저 측정할 목표 목록을 올바로 작성해야 한다.구글에서는 생산성을 다섯 개의 요소로 나눴다. 이 요소 사이에는 서로 트레이드오프가 일어난다. 생산성을 높이고자 하는 팀들에게 모든 요소 각각에 대한 목표를 정하라고 안내한다. 코드품질 엔지니어들의 몰입도 지적 복잡성 박자와 속도 만족도7.5 신호(Signal)신호는 목표 달성 여부를 알 수 있는 방법이다. 모든 목표에는 신호가 최소 하나는 필요하다.7.6 지표(Metric)지표는 신호를 측정하는 방법의 최종 형태이다.7.7 데이터로 지표 검증하기196~200p7.8 조치를 취하고 결과 추적하기구글의 생산성 연구팀은 주어진 주제로 연구를 마친 뒤에는 언제나 개선을 멈추지 않고 지속하는 방법을 담은 추천 할 일 목록을 제공했다.7.9 마치며구글은 엔지니어링 생산성 전문가로 구성된 팀을 두는 것이 소프트웨어 엔지니어링의 다양한 측면에서 아주 유익하다는 사실을 깨달았다. 하나의 팀이 복잡한 문제들의 해법에 대해 여러 방면에서 집중적으로 연구하는 것이다.7.10 핵심 정리 생산성 측정에 앞서 결과가 긍정적이든 부정적이든 실행 가능한 조치로 이어지는지 확인해야 한다. GSM 프레임워크를 활용하여 의미 있는 지표를 선택해야 한다. 지표는 생산성의 모든 측면을 다루도록 선택해야 한다. 정성적 지표도 지표이다. 엔지니어의 믿음을 장기간에 걸쳐 추적하는 설문 메커니즘을 고려해보자 개발자 워크플로와 보상 제도에 영향을 주는 제안을 찾아내는 걸 목표로 삼아야 한다." }, { "title": "06. 성장하는 조직 이끌기", "url": "/posts/06.%EC%84%B1%EC%9E%A5%ED%95%98%EB%8A%94-%EC%A1%B0%EC%A7%81-%EC%9D%B4%EB%81%8C%EA%B8%B0/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-10-25 02:14:38 +0900", "snippet": "팀 하나를 이끌게 되면 다음 순서로는 연관된 여러 팀을 이끄는 게 자연스러운 흐름이다. 역할이 커져도 기존의 모범 사례들은 계속 유효하다. 여러분은 똑같이 ‘섬기는 리더’여야 한다. 다만 섬겨야할 대상이 많아졌을 뿐이다. 이제 기술적이거나 엔지니어링적인 세부 내용을 접할 일은 점점 줄어서 깊게 보다는 넓게 살펴야 하는 위치가 된다. 그동안 자랑스러워한 엔지니어링 전문 지식과는 먼 과제를 맡게 된다. 대신 주어진 역할을 훌륭히 해내기 위해서 기술적 직관과는 다른, 엔지니어들을 올바른 방향으로 이끄는 능력이 그 어느때보다도 중요해진다.**3A 리더십6.1 늘 결정하라 (Always Be Deciding)여러 팀으로 구성된 팀을 관리한다고 함은 기존보다 높은 수준에서 더 많은 걸 결정해야 한다는 뜻이다.6.1.1 비행기 일화166P비행기 일화는 트레이드오프에 관한 것이다. 트레이드오프는 사람의 행동에도 적용된다. 리더는 팀이 매주 무엇을 해야 하는지 결정해야 한다. 트레이드오프가 명확할 때도 있지만 때로는 시간이 한참 지나서야 피해를 주는 예상치 못한 결과를 가져오기도 한다.리더로서의 역할은 사람들을 움직여서 어렵고 모호한 문제들을 풀게 이끄는 것이다. 리더의 역할은 나무들 사이로 숲 전체를 보면서 목표한 중요 나무까지로 가는 길을 찾아 엔지니어들을 안내해주는 것이다. 이 과정은 세 단계로 나뉜다. 눈 가리개를 찾아내고, 트레이드오프들을 파악한 다음, 해법을 결정하고 반복한다.6.1.2 눈 가리개 찾기우리에겐 처음이지만 누군가에겐 몇 년씩 씨름하던 문제인 경우가 종종 있다. 이 사람들은 한 문제에 너무 오래 빠져있다보니 눈가리개가 시야를 가려서 더는 숲을 보지 못하게 되곤 한다. 이 부분을 깨끗한 눈을 가진 여러분에게 굉장히 유리한 지점이다. 여러분은 눈가리개를 찾아낼 수 있고, 질문을 던질 수 있고, 그래서 새로운 전략을 모색할 수 있다.6.1.3 핵심 트레이드오프 파악하기세상이 끝날때까지 어떤 상황에서든 옳은 답이란 없다. 특정 상황에서의 최선의 답이 있을 뿐이다. 모든 트레이드오프를 테이블 위에 올려놓고 모두에게 설명한 다음 어떻게 균형을 맞출지를 결정하도록 돕는 것이 여러분의 일이다.6.1.4 결정하고 반복하기어떤 트레이드오프가 존재하고 어떻게 작용하는지를 이해하고 나면 여러분의 힘이 커진다. 이 정보를 활용하여 가령 이번 달에 수행할 최선의 결정을 내릴 수 있게 된다. 그리고 다음 달이 되면 트레이드오프들을 다시 평가하고 균형점도 새로 잡아야할 것이다.사례) 웹 서버 지연시간 해결하기 169~171p6.2 늘 떠나라(Always Be Leaving)구글의 전 엔지니어 디렉터인 바트 메더라다의 유명한 말로 ‘늘 떠나라’가 있다. 이 말의 진정한 뜻은 리더는 모호한 문제를 풀어줄 뿐 아니라 맡은 조직이 리더 없이도 스스로 문제를 풀 수 있도록 유도해야 한다는 것이다. 그렇게 되면 리더는 새로운 문제 또는 새로운 조직을 찾아 떠날 수 있게 된다. 리더 덕분에 스스로 자생력을 갖추게 된 팀을 남겨두고 말이다.6.2.1 미션: 자율주행 팀을 만들어라어려운 문제를 스스로 해결할 수 있는 조직이 되려면 강력한 리더들과 건실한 엔지니어링 프로세스와 긍정적이고 자기-영속적인 문화를 갖춰야 한다. 이런 형태의 자생력을 갖춘 조직으로 가꾸기 위해서는 세 가지가 필요하다. 문제 공간을 분할하고, 하위 문제를 위임하고, 필요에 따라 반복하는 것이다.6.2.2 문제 공간 분할하기가능하다면 조직의 구조를 느슨하게 관리하여 하위 팀들의 규모는 유동적이고, 팀원은 다른 하위 팀으로 옮길 수 있고, 상황이 변하면 할당된 문제를 바꿀 수도 있는 식으로 한다.예) 구글 검색의 지연시간 문제 분할하기 - 검색 지연시간 문제를 들여다 보면 지연의 징후를 찾는 작업과 지연의 원인을 찾는 작업으로 쪼갤 수 있다. (지연 원인 대응팀, 징후 대응팀을 동시에 가동시켜 지연시간을 체계적으로 통제함)하위 문제를 다른 리더에게 위임하기 - 모든 관리 책에서 빼놓지 않고 이야기하는 주제가 위임이다. 자율주행 조직을 일구기 위해 가장 효과적인 교육 메커니즘은 바로 위임이다. 직접 처리하는 것이 효율적인 일도 있겠지만 정말 시급한 일이 아니라면 꾹 참고 다른 이에게 맡기자. 나보다 느릴순 있지만 다른 리더에게 성장할 기회를 마련해줘야 한다.조율하고 반복하기 - 다음은 뭘 하지? 의 간단한 답은 바로 조직이 지속해서 건실함을 유지할 수 있도록 지도해주기 이다. 관찰과 경청 95%, 절묘하고 시의적절한 개입 5% 이것이 좋은 관리이다.팀 정체성 설정 시 주의점 - 팀에는 일반적인 문제를 맡겨야 한다. 그런데 우리는 특정 제품을 맡겨버리는 실수를 자주 범한다. 제품은 문제에 대한 해결책이다. 팀의 정체성을 특정 제품으로 못 박는다면 제품을 바꾸고 싶을 때 변화에 저항하려 들 것이다.6.3 늘 확장하라(Always Be Scaling)6.3.1 성공 사이클한 팀이 난제를 해결하는 사이클은 다음과 같다. 분석 - 눈가리개를 식별해내고 모든 트레이드오프를 찾아 관리 방안을 합의한다. 분투 - 팀이 준비가 덜 됐다 생각하더라도 일에 착수한다. 실패할 경우에도 대비해야 한다. 견인 - 문제를 정복하기 시작한다. 보상 - 성공의 보상은 더 많은 일과 더 많은 책임이다.위 과정을 거치면 곤경에 처하게 된다. 새로운 문제를 받게 되고, 인력 충원은 없다. 그래서 이 사이클의 마지막 단계를 ‘압축 단계’라고 부른다. 지금까지 하던 모든 작업을 절판 크기로 압축한다. 새로운 문제를 정복하고 압축하는 방법을 찾아낸 다음 또 다른 문제를 배정받아 반복한다.이 성공 사이클은 피할 수 없다. 관리하기는 어렵지만 여러 팀으로 구성된 팀으로 확장하려면 반드시 거쳐야하는 과정이다.6.3.2 중요한 일 VS 급한 일급한 일이 아니라 중요한 일에 더 몰두하려면 어떻게 해야할까? 위임하자 - 급한 일중 상당수는 조직내의 다른 리더에게 위임할 수 있다. 따로 정기적으로 시간을 내자 - 정기적으로 2시간 이상씩 방해받지 않고 중요한 일을 처리하는 시간을 마련하자 나에게 효과가 있는 추적 시스템을 마련하자6.3.3 공 떨어뜨리기공(업무)을 세 그룹으로 나누자 아래 칸에는 급하지도 중요하지도 않은 20%의 공을, 중간 칸 60%에는 조금 급하거나 중요할 수도 있는 공들을 모아둔다. 그리고 위 칸에는 아주 중요한 게 확실한 20%를 담는다. 그리고 상위 20% 즉 나만이 할 수 있는 중요한 일들을 신중하게 골라낸 다음 오직 그 일들에만 집중하는 것이다.이렇게 수많은 공들을 의도적으로 떨어뜨리다 보면 중간 60%는 위임하지 않더라도 때때로 나서서 가져가는 중간 리더들이 나타나게 되고, 중간 칸에 잘못 넣어둔 업무라도 진짜 중요한 것이라면 어떤 식으로든 다시 튀어올라 상위 20% 쪽으로 돌아온다.6.3.4 에너지 관리하기 진짜 휴가 떠나기 - 휴가라면 회사 일을 잊고 지낼 수 있는 시간이 최소 3일은 지속되어야 한다. 재충전하기 위해서는 일과 단절하는 훈련이 필요하다. 일과 쉽게 단절하기 - 업무용 랩탑은 회사에 두고 떠나자, 휴대폰에 있는 업무용 앱은 지우자 진짜 주말 보내기 - 주말에는 오롯이 자신이 좋아하는 일만 하자 매일매일 휴식하기 - 인간의 뇌는 90분 주기로 운용된다. 90분 마다 사무실 주변을 돌거나 10분정도 산책하는데 사용해보자 스스로에게 정신 건강의 날을 가질 수 있는 권한 부여하기 - 이유 없이 안 좋은 날이 있다. 이럴 땐 그냥 연차를 쓰고 귀가하기를 권한다.6.4 마치며리더의 성공에는 자연스럽게 더 많은 책임이 따라온다. 모든 것을 스스로 처리하고, 두 배로 열심히 일한다고 해서 훌륭한 리더가 아니다. 늘 결정하고, 늘 떠나고, 늘 확장하도록 노력하자6.5 핵심정리 늘 결정하라 늘 떠라나 늘 확장하라" }, { "title": "05. 팀 이끌기", "url": "/posts/05.%ED%8C%80-%EC%9D%B4%EB%81%8C%EA%B8%B0/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-10-23 21:17:29 +0900", "snippet": "지금까지는 소프트웨어를 제작하는 팀의 구성과 문화의 관한 이야기를 다뤘다면 이번 장에서는 이 모두를 궁극적으로 책임져야 할 ‘사람’으로 시선을 돌려본다.어떤 팀도 리더 없이는 제대로 굴러갈 수 없다. 구글에서는 리더 역할을 두 가지로 구분해 생각한다. 관리자 는 사람을 이끌고 테크 리드 는 기술과 관련한 책임을 진다. 선장없는 배와 같이 소프트웨어도 조종하는 사람이 없다면 엔지니어들은 값진 시간을 허비하며 그저 무슨 일이 벌어지기만을 기다리는 꼴이다.5.1 관리자와 테크리드(혹은 둘 다)신생 팀이라면 관리자와 테크 리드 역할을 한 사람이 맡는다. 이를 ‘테크 리드 매니저(TLM)’라 한다. 규모가 더 큰 팀에서는 사람을 관리해본 경험이 많은 이가 관리자 역할을, 기술을 잘 아는 선임 엔지니어가 테크 리드 역할을 맡는다. 관리자와 테크 리드는 각각이 엔지니어링팀의 성장과 생산성에 큰 영향을 주지만 관리자에게는 대인 관계 측면에서의 기술이 훨씬 많이 요구된다.5.1.1 엔지니어링 관리자많은 회사에서 소프트웨어 엔지니어링에는 거의 무지하더라도 훈련된 인사 관리자에게 엔지니어링팀의 운영을 맡긴다. 구글에서는 엔지니어링을 아는 사람만이 소프트웨어 엔지니어링 관리자가 될 수 있다.거시적인 측면에서 엔지니어링 관리자는 자신이 관리하는 팀의 구성원 모두의 성과, 생산성, 행복을 책임져야 한다. 그와 동시에 팀에서 만드는 제품의 사업적 요구까지 충족시켜야 한다.5.1.2 테크 리드테크 리드는 기술과 관련된 결정과 선택, 아키텍처, 우선순위, 성능과 일반적인 프로젝트 관리를 책임진다. 테크 리드는 엔지니어링 관리자와 긴밀히 협조하여 맡겨진 제품을 개발하는 데 필요한 팀원을 확보하고, 엔지니어들의 기술 스펙트럼과 기술 수준을 최대한 활용해 목표를 완수하게끔 이끌어야 한다.5.1.3 테크 리드 매니저소규모의 초기 팀에서는 기본적으로 테크 리드 매니저들을 두는 경우가 많다. TLM은 인적, 기술적 요구를 혼자 관장하는 사람이다. TLM 역할은 만만치 않아서 자신의 일, 위임, 사람 관리 사이에서 균형을 잡는 요령을 배워야 한다.**직속 직원에게 제품과 관련한 업무 지시를 내리는 것은 당연하다. 하지만 관리 조직 밖의 사람에게 심지어 제품 영역 밖의 사람들에까지 영향력을 행사하여 원하는 어떤 일을 하게끔 만드는 것은 매우 다른 차원의 일이다. 이를 권한 없는 영향력이라 하며 이것은 우리가 개발할 수 있는 가장 강력한 리더십의 특징에 속한다.5.2 개인 기여자에서 리더로스스로 난 절대 관리자는 되지 않을거야 라고 맹세했더라도 경력이 쌓이다 보면 어느 순간 리더의 위치에 올라서 있는 자신을 발견하게 될 것이다.5.2.1 두려워해야 할 건 오직… 전부다사람들이 관리자가 되기 싫어하는 이유로 소프트웨어 개발 분야에서 가장 큰 이유는 바로 코딩할 시간이 줄어든다는 점이다. 피터의 법칙 : 자신의 무능력이 드러나는 직급까지 승진하는 경향이 있다. (주어진 위치에서 뛰어난 성과를 내는 직원은 승진을 거듭하다가 더는 성과를 낼 수 없는 위치까지 올라선 후 멈추게 된다.)**코드는 정말 잘 짜지만 사람을 관리하거나 팀을 이끌 마음이 전혀 없는 엔지니어에게 억지로 관리자나 테크 리드 역할을 맡기면 형편없는 관리자를 얻는 대신 뛰어난 엔지니어를 잃게 된다.다음의 이유에서라면 테크 리드나 관리자가 되는것도 고려해볼만 하다. 경력 스펙트럼을 확장하는 길이다. 훌륭한 엔지니어들로 꾸려진 팀 하나가 여러분의 리더십 아래 생산해내는 코드를 상상해보라 사실 당신은 천부적인 관리자일지도 모른다.5.2.2 섬기는 리더십관리자들은 선임 관리자가 자신에게 했던 끔찍한 일들을 새까맣게 잊고, 자신도 어느덧 똑같은 식으로 사람들을 관리하게 되는 병이 있다. 적절히 치료하지 않으면 팀 전체를 죽일 수 있는 질병이다. 새로 부임한 관리자는 직원들을 능동적으로 관리하려는 충동에 휩싸인다. 하지만 그 결과는 보통 재앙으로 이어진다.관리병을 치료하려면 섬기는 리더십을 자유롭게 응용할 수 있어야 한다. 리더로서 여러분이 해야할 가장 중요한 일은 팀을 떠받드는 것이다. 섬기는 리더로서 여러분은 겸손, 존중, 신뢰의 분위기를 조성하려 힘써야 한다. 자신의 손을 더럽히는 데 주저하지 않는다. 섬기는 리더가 행하는 관리는 오직 팀의 기술적, 사회적 건강 관리뿐이다.5.3 엔지니어링 관리자과거 관리자는 자신의 목적을 달성하기 위해ㅓ라면 주어진 모든 권력을 동원해 노동자들을 채찍질했다. 하지만 현대적 소프트웨어 회사는 이렇게 일하지 않는다.5.3.1 관리자는 밥맛이야관리자의 역사를 되돌아 보면, 오늘날의 뾰족 머리 관리자(나쁜 관리자의 특징을 두루 갖춘 캐릭터) 부분적으로 군대 조직에서 처음 기인하여 지금으로부터 100년도 전에 산업 혁명 때 팽배해졌다. 공장들이 우후죽순으로 생겨나면서 노동자들을 고용해 기계처럼 돌리고 쉽게 다른 노동자들로 대체할 수 있었기 때문에 관리자들은 노동자들을 잘 대우해주거나 작업 환경을 개선해줄 필요를 거의 느끼지 못했다.당근과 채찍 방식은 비효율적이고 창의적인 사람의 생산성을 떨어뜨린다는 연구는 수도 없다. 그럼에도 오늘날까지 완전히 사라지지는 않았다.5.3.2 오늘날의 엔지니어링 관리자겸손, 존중, 신뢰의 틀에서 생각해보면 관리자가 직원들을 신뢰한다는 분명한 신호를 주면 직원들은 신뢰에 부응해야 한다는 긍정적인 압박을 느낀다.전통적인 관리자는 일을 어떻게 처리할지를 고민하는 반면, 훌륭한 관리자는 무슨 일을 처리할지를 고민한다. 그리고 어떻게는 팀을 믿고 맡긴다.실패는 선택이다 : 팀원들이 안전하다고 느끼게 해주는 일 역시 팀을 촉진하는 좋은 방법이다. 심리적 안전을 확보해주면 사람들은 더 큰 위험도 기꺼이 감수할 것이다. 구글에서는 이렇게 말한다. ‘불가능한 목표에 도전하면 실패할 가능성은 그만큼 크다. 하지만 불가능에 도전해 실패하면 성공이 확실하리라 생각한 일을 성취했을 때보다 십중팔구 훨씬 큰 것을 얻는다.’ 팀이 위험을 감수하는 문화를 조성하는 멋진 방법은 바로 실패해도 괜찮음을 알게 하는 것이다.개인의 성공과 실패는 조금 다른 문제이다. 성공에 기여한 개인을 축하해주는 것은 좋지만 실패시 비난할 누군가를 찾으려 해서는 안된다. 실패해도 괜찮지만 팀으로서 함께 실패하고, 실패로부터 배워야 한다.5.4 안티패턴5.4.1 안티패턴 : 만만한 사람 고용하기관리자가 어떤 이유에서든 자리 보전이 여의치 않다고 느끼고 있다면 효과적인 해법으로 좌지우지할 수 있는 사람들을 고용해서 누구든 나의 권위와 위치를 위협하지 못하게 하는 것이다. 하지만 그렇게 되면 내가 직접 처리해야 할 일은 그만큼 늘어나게 된다. 내가 나서지 않으면 팀도 움직이지 않게 된다.반대로 나보다 똑똑하고 나를 대체할 역량을 갖춘 사람들 적극적으로 뽑으면 나의 위치를 시시때때로 위협하겠지만 이 사람들은 나에게 강렬한 자극과 함께 멋진 일들도 안겨줄 것이다. 일이 잘 진행되고 있는지 매일 같이 확인할 필요 없고, 또 스스로 배우고 성장할 멋진 기회일 수도 있다. 나보다 똑똑한 사람들로 주변을 채우면 자신의 전문성을 확장하는 데도 훨씬 유리하다.5.4.2 안티패턴 : 저성과자 방치하기소프트웨어 개발에서 사람이라는 요인이 가장 다루기 어렵다는 건 다들 이해할 것이다. 그중에서도 기대를 충족해주지 못하는 사람들 다루는 것이 가장 고난도 과제이다.대부분의 팀 리더는 이를 악물고 눈을 가린 채, 저성과자가 마법처럼 환골탈태하거나 알아서 어디론가 사라지기를 그저 희망한다. 저성과자의 역량이 높아지기를 혹은 어디론가 떠나기를 희망하는 사이, 팀의 다른 고성과자들은 저성과자들을 밀고 당겨주느라 귀중한 에너지를 낭비하고 팀의 사기는 서서히 떨어져간다.저성과자를 방치하는 일은 새로운 고성과자가 팀에 합류하는 걸 막기도 하며, 그나마 있던 팀내 고성과자를 떠나게도 한다. 띠라서 저성과자 문제에 가능한 한 빠르게 대처하면 여러분은 팀원을 돕는다는 본분에 더 충실할 수 있다. 저성과자에 적극적으로 대응하다 보면 의외로 작은 격려와 방향 제시가 필요했을 뿐인 경우도 많다.저성과자들을 지도하는 효과적인 방법에는 뭐가 있을까? 짧은 기간의 마이크로매니징을 피하기는 어렵지만 전체적으로 역시 겸손, 존중, 신뢰가 바탕이 되어야 한다. 특히 존중이 중요하다. 기간을 정하고 아주 구체적인 목표를 제시하라. 작고 점진적으로 측정할 수 있는 목표여야 한다. 그래야 작은 성공들을 많이 경험할 기회가 생긴다.5.4.3 안티패턴 : 사람 문제 무시하기사례) 146p5.4.4 안티패턴 : 만인의 친구되기대부분 자신이 속한 팀의 관리자나 테크 리드로 승진하면서 리더가 된다. 이렇게 역할이 바뀌더라도 팀원들과 쌓아온 그간의 우정을 잃고 싶어 하지 않는게 인지사정이다. 그렇다 하더라도 부드럽게 끌어주는 리딩과 우정을 혼동하지 말라 리더의 손에 팀원들의 경력을 좌지우지할 힘이 있기 때문에 인위적이고 낯선 행동에서 팀원들은 오히려 압박을 느낄 수 있다.팀과의 친밀한 우정 없이도 혹은 완고한 독불장군이 되지 않고서도 팀을 이끌고 합의를 끌어낼 수 있음을 기억하라 마찬가지로 기존의 우정을 잃지 않고도 냉철한 리더가 될 수 있다. 연구결과 팀과 점심식사를 함께하는 것도 좋은 방법이다. 팀원들을 불편하게 하지 않으면서 업무 외적인 대화를 나누며 사회적 유대를 유지하는 데 효과가 크다.5.4.5 안티패턴 : 채용 기준 타협하기A급 인재는 A급 인재를 뽑고, B급 인재는 C급 인재를 뽑는다.사람을 시급히 채용해야 할 때 위 격언의 희생양이 되기 쉽다. 예) 팀원 다섯명을 확충해야할 때 보통 회사에서는 먼저 공고를 내고 다수의 지원자를 받은 후 그중 가장 나은 다섯명을 뽑느다. 채용기준에 미달하더라도..적합한 사람을 찾는 데 드는 비용은 애초에 뽑지 말았어야 할 직원을 관리하는 비용에 비하면 아무것도 아니다. 적합하지 못한 사람을 채용하면 팀 생산성 손실, 팀 스트레스, 직원 관리에 허비되는 시간, 마지막으로 해고 서류 작업과 스트레스 등의 비용을 치러야 한다.5.4.6 안티패턴 : 팀을 어린이처럼 대하기팀을 신뢰하지 못함을 보여주는 가장 대표적인 예가 팀원들을 어린이처럼 대하는 것이다. 사람들을 자신을 대하는 방식대로 행동하는 경향이 있다.구체적으로 어떻게 할 때 팀원들이 이렇게 행동할까? 1)마이크로매니징하기, 2)단순히 팀원들의 능력을 존중하지 않고 자신의 일에 책임질 기회를 주지 않기가 있다.5.5 올바른 패턴5.5.1 자존심 버리기자존심 버리기는 팀 리더에게는 특히 더 중요한 덕목이다. 어느 팀이든 자존심이 너무 강한 사람은 다루기 어렵다. 그 사람이 하필 리더라면 더욱 골치아픈 일이 된다. 팀이라는 집단으로서의 자존심과 정체성을 강화해야 한다.신뢰는 자존심 버리기의 한 축이다. 팀을 믿고 팀원들의 능력과 기존에 이룬 성과들을 존중해야 한다. 누가 내가 내린 결정에 질문을 던진다면 감사해야 한다. 질문하기를 장려한다면 건설적인 비판이 이루어지는 더 나은 팀의 더 나은 리더가 될 가능성이 훨씬 커진다. 피드백을 수용하고 비판에 마음을 열어라, 자존심을 지키려는 충동을 이겨내야 한다.자존심 버리기의 마지막은 바로 실수 했다면 사과하기이다. 스스로 인정하든 안 하든 팀원들은 리더가 실수한 것을 알게 된다. 팀원 누구도 리더에게 말하지 않았더라도 이 사실은 변하지 않는다. 사람들은 무언가를 망쳤으면 사과할 줄 아는 리더를 존경한다. 왜냐하면 사과 한다는 것은 리더가 성숙하고 상황을 판단할 줄 알며 겸손하다는 증거로 받아들여지기 때문이다.5.5.2 마음 다스리기업무와 관련된 복잡한 세부 내용과 장애물들을 리더가 인지하고 있음을 팀도 알게 하되 덜 회의적인 태도를 취하는 것이 좋다. 더 많은 사람들을 이끌수록 감정은 억누르고 평점심을 유지해야 한다.마음을 다스리는 하나의 요령으로 ‘질문하기’가 있다. 팀원이 리더에게 조언을 구한다는 것은 마침내 무언가를 해결해줄 기회가 찾아온 것이다. 하지만 직접 해결하기는 가장 마지막에 택해야 하는 전략이다. 조언을 구하는 사람은 보통 나서서 해결해주기를 원하는 것이 아니라 스스로 문제를 해결하는 걸 도와주기 바라는 거다. 이때 스스로 해결하도록 이끄는 가장 쉬운 방법은 바로 질문하기 이다. 겸손, 존중, 신뢰를 담아서 조언을 청한 사람이 자기 힘으로 문제를 해결하도록 도와주려 노력해야 한다.5.5.3 촉매자 되기팀 리더가 하는 가장 일반적인 일은 합의를 이끌어내는 것이다. 팀 합의 이루기는 비공식 리더가 자주 사용하는 리더십 스킬이기도 하다. 실질적인 권한 없이도 이끌 수 있는 방법이기 때문이다.5.5.4 장애물 치우기해야할 일이 무엇인지는 팀 내 합의를 이뤘지만 장애물에 막혀 꼼짝달싹 못하는 경우가 있다. 기술적인 문제일 수도, 조직 차원의 문제일 때도 있다. 이 때 스스로 모든 해법을 알고 있을 필요는 없다. 하지만 누가 해결해줄 수 있는지 알고 있다면 큰 도움이 된다. 많은 경우 정확한 답을 알고 있기보다 올바른 사람을 알고 있을 때의 가치가 더 크다.5.5.5 선생이자 멘토 되기테크 리더로서 가장 실천하기 어려운 일을 뽑으라면 ‘내가 하면 20분이면 끝날 일을 세 시간씩 매달려 있는 주니어 팀원 지켜보기’를 빼놓을 수 없다. 스스로 배울 기회를 주는 일은 훌륭한 리더십에서 빠질 수 없는 요소이지만 특히 처음에는 매우 고통스럽다.멘토가 되는 데 많은 정규 교육이나 준비가 필요하지는 않다. 기본적으로 다음의 세 가지를 요구한다. 팀의 프로세스와 체계에 대한 경험 다른 이에게 무언가를 설명해주는 능력 멘티에게 도움이 얼마나 필요한지를 측정하는 능력 (가장 중요!!)5.5.6 명확한 목표 세우기팀이 한 방향으로 빠르게 전진하기를 원한다면 리더가 설정한 방향을 모든 팀원이 이해하고 동의해야 한다. 목표를 명확히 세우고 팀이 제품을 한 방향으로 끌게 하는 가장 쉬운 방법은 팀이 이루어야 할 임무를 구체적인 문장으로 적어놓는 것이다. 팀이 방향과 목표를 정하도록 도왔다면 한 걸음 물러서서 더 많은 자율권을 준 뒤 모두가 올바르게 가고 있는지 주기적으로 확인하라5.5.7 정직하기팀원이 찾아와 터놓을 수 없는 것에 대해 묻는다면 답은 알지만 내 마음대로 얘기해 줄 수는 없다. 정도로 답하는 것은 괜찮다. 팀원이 던진 질문에 답을 모른다면 그냥 모른다고 이야기하면 된다. 팀원이 사고를 쳤다거나 기대한 만큼 일을 해내지 못했음을 처음 이야기 할 때 어려울 수 있다. 이때 ‘칭찬 샌드위치’ 방식으로 칭찬을 앞에 적절히 섞는 방식으로 충격을 완화하라는 말이 있다. 하지만 칭찬 샌드위치를 사용하지 말 것을 강하게 권한다. 겉에 둘러진 칭찬 때문에 핵심 메시지, 즉 실제로는 고쳐야할 점을 지적한 것임을 제대로 인식하지 못하는 사람이 대부분이기 때문이다.칭찬 샌드위치 없이 건설적인 비판을 전할 때는 상대방과 공감하고 따뜻하게 이야기해야 한다. 상대가 비판을 듣자마자 방어적으로 변하지 않길 원한다면 친절과 공감이 아주 중요하다.직접적인 피드백이나 비판을 전할 때는 메시지를 정확하게 왜곡 없이 전달하는 게 핵심이다.5.5.8 행복한지 확인하기리더로서 팀의 생산성을 장기적으로 더욱 끌어올리려면 팀원들이 행복해하는지를 확인하는 데도 시간을 써야 한다.팀이 행복한지를 추적하는 간단한 방법을 소개하자면 팀원들과의 일대일 면담 마지막에 뭐 필요한거 없어요? 라고 묻는 것이다. 간단한 질문이지만 팀원들의 생산성과 행복 증진에 필요한 것을 갖춰주는 데 아주 효과적인 마무리 멘트이다.5.6 예상 못한 질문리더라면 회사 밖에서도 팀의 행복에 신경 써주는 게 좋다. 팀원들의 사생활까지 파고들라는 이야기가 아니라 그저 어떤 상황에 처해 있는지를 인지하고 있다면 특정 직원이 특정 기간에 왜 생산성이 평소보다 떨어지는지, 혹은 더 열심히 일하는지가 눈에 들어올 것이다.경력 관리 챙겨주기도 팀원 행복 추적에 큰 비중을 차지한다.5.7 그 외 조언과 요령 위임하되, 곤란한 일은 직접 처리하자 - 이제 막 리더로 부임했다면 일거리를 팀원들에게 위임하려는 노력을 더 해야하고, 팀을 이끈지 오래됐다면 오히려 리더가 직접 일을 처리하는 것이 팀원들의 존경을 이끌어내고 팀의 업무 속도를 높이는 가장 손쉬운 방법이다. 특히 아무도 하려 들지 않는 지저분한 일을 떠맡으라 여러분을 대신할 사람을 찾자 - 여러분을 대신할 팀원을 원한다면 그럴만한 역량을 갖춘 사람을 채용해야 한다. 그리고 적합한 팀원을 구했다면 그 사람에게 더 많은 책임을 질 기회를, 팀을 이끌어볼 기회를 줘야 한다. 단, 개인 기여자로 남고 싶어하는 사람도 있으며 그를 원치않는 관리자로 내모는 것은 피하도록 하자 파도를 일으켜야 할 타이밍을 알자 - ‘놔두면 곧 괜찮아 질거야’, ‘저절로 풀리는 일도 있어’라며 자기합리화에 빠지지 말자 직접 나서서 가장 거센 파도를 일으켜야 할 때이다. 이런 문제들은 저절로 해결될 가능성이 극히 희박하다. 혼란으로부터 팀을 보호하자 팀에 공중 엄호를 해주자 팀이 잘하고 있으면 칭찬하자 실패해도 쉽게 되돌릴 수 있는 일에는 ‘해보세요’라고 말하자5.8 사람은 식물과 같다누구에게는 더 많은 햇빛이, 다른 이에게는 더 많은 물 혹은 비료가 필요하다. 누구에게 무엇이 필요한지 결정하고 제공하는 것이 리더로서 해야할 일이다. 물론 팀에는 물, 비료가 아닌 동기부여와 방향지시가 필요하다. 정체되어 있는 팀원에게는 동기를 부여하고, 산만하거나 무얼 해야 할지 몰라하는 팀원에게는 더 강하게 지시해야 한다.5.8.1 내적 동기와 외적 동기동기네는 금전적 보상처럼 바깥에서 기인하는 외적 동기와 안에서부터 샘솟는 내적 동기 이렇게 두 가지가 있다.다니엘 핑크는 저서에서 사람들을 가장 행복하고 생산적이게 만드는 비법은 내면으로부터의 동기를 북돋아주는 것이라고 한다. 내적 동기부여 방법은 자율성, 숙련, 목적 이 있다. 자율성 : 다른 사람의 마이크로매니징 없이 스스로 행동할 수 있는 것, 대략적인 방향만 알려주면 어떻게 도달할지는 스스로 결정한다. 숙련 : 현재 기술 수준을 높이고, 새로운 것을 배울 기회를 제공하는 것이다. 목적 : 제품의 영향력과 상관없이 팀원들의 노력에서 의미를 찾고 그 의미를 분명하게 인식시켜주는 형태로 동기를 부여할 수 있다.5.9 마치며유능한 관리자에게 무엇보다 중요한 자질은 사회적 스킬임을 구글은 깨우쳤다. 좋은 관리자는 팀이 일을 스스로 잘하도록 돕고, 올바른 목표에 집중하게 하고, 조직 외부의 방해요소를 차단해 준다.5.10 전통적인 의미에서의 관리를 하지 말고 리더십, 영향력, 팀을 위한 봉사에 집중하라 가능하면 위임하라 방향과 속도에 특히 신경 쓰라" }, { "title": "04. 공정 사회를 위한 엔지니어링", "url": "/posts/04.%EA%B3%B5%EC%A0%95-%EC%82%AC%ED%9A%8C%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-10-22 22:59:51 +0900", "snippet": "프로그래밍은 당면한 문제에 집중하여 코드를 생성하고, 소프트웨어 엔지니어링은 수십년 혹은 평생에 걸친 유동적이고 모호한 문제에 대응하기 위해 코드, 도구, 정책, 프로세스 등을 응용하는 더 폭 넓은 개념이다.이번 장에서는 다양한 계층의 사용자를 위한 제품을 설계할 때 엔지니어가 짊어져야 할 책임에 관해 이야기한다.4.1 편견은 피할 수 없다.사용자의 국적, 민족, 인종, 성별, 연령, 사회 경제적 위치, 장애 여부, 신념 체계 등에 신경쓰지 않는다면 가장 우수한 엔지니어라 할지라도 의도와 달리 사용자에게 피해를 줄 수 있다. 모든 사람은 편견을 가지고 있다. 무의식적인 편견은 교묘하여 의도적인 배척 행위보다 물리치기 어려울 때가 많다.사례) 구글에서 이미지 인식 알고리즘이 흑인을 고릴라로 분류한다는 것을 발견했다. 이런 실수를 일으킨 원인으로 이미지 인식 알고리즘은 학습 데이터셋에 의존하기 때문에 적절한 데이터셋이 필요하다. 구글의 이미지 인식 알고리즘에 제공된 사진 데이터는 명백히 불완전했다. 구글 자체 흑인을 충분히 대변하지 못했다. 이 사실이 알고리즘을 설계하거나 데이터셋을 수집하는 데 영향을 주었다. 구글 이미지 인식의 타깃 시장에 대표성이 낮은 그룹이 제대로 포함되지 못해 자체 테스트에서 이런 실수를 발견하지 못했다.4.2 다양성이 필요한 이유 이해하기구글은 뛰어난 엔지니어가 되려면 제품 설계와 구현에 다양한 관점을 포용해야 한다고 믿는다. 모두를 위한 제품을 개발하려면 먼저 우리가 어떤 사람들을 대표하는지를 이해해야 한다. 이를 위해 엔지니어들이 폭 넓은 주제의 교육과 훈련을 받도록 장려해야 한다.사업에 성공하려면 컴퓨터 과학 학위나 업무 경험만으로 훌륭한 엔지니어가 될 수 있다는 통념에서 벗어나는 일부터 출발해야 한다. 엔지니어는 타깃 생태계 전체의 틀을 잡는 데서 모든 일을 시작해야 한다. 자신과 다른 사람들, 특히 제품을 사용하여 해를 입을 수도 있는 사람들에 초점을 맞춰야 한다.4.3 다문화 역량 갖추기뛰어난 엔지니어라면 제품이 어떻게 다른 그룹의 사람들에게 유리하게 혹은 불리하게 작용하는지 이해하는 능력이 있어야 한다. 엔지니어가 되려면 기술이 적성에 맞아야 함은 물론 무언가를 만들어야 할 때와 아닐 때를 구분하는 안목도 갖춰야 한다.뛰어난 엔지니어가 되려면 힘을 발휘하되 해를 끼치지 않아야 할 책임도 함께 있음을 이해해야 한다. 첫 번째로 여러분에게 심어진 편견의 현재 상태를 인식하는 것이다. 이를 인식하고 나면 종종 망각되는 쓰임새나 여러분이 만든 제품으로 인해 득을 보거나 피해를 입을 수 있는 사람들을 비로소 고려할 수 있게 될 것이다.4.4 다양성 실천하기다문화 역량을 뿌리내리려면 사회의 불평등 시스템이 직장에, 특히 기술 분야의 일터에 미치는 영향을 더 포괄적으로 이해해야 한다.대표성이 적은 그룹 출신의 엔지니어를 더 많이 고용해야하는 관리자라면 전 세계에 걸친 차별의 역사와 그 영향을 파고드는 건 학문적으로는 의미있는 싸움일것이다. 하지만 학문적인 것을 넘어서 형평성과 공정성을 심어주는 수량화할 수 있고, 실행 가능한 일에는 뭐가 있는지를 고민하는 게 더 중요하다.4.5 단일한 접근 방식 거부하기기술 분야의 불평등을 해소하는 데 단 하나의 철학이나 방법론을 고집할 수는 없다. 우리의 문제는 복잡하며 여러 요인이 복합적으로 작용한다. 따라서 직장에서의 대표성을 높이려면 단일한 접근 방식에서 탈피해야 한다.기술 업계에서는 소수 집단에 속한 수많은 사람들이 매일매일 성장의 기회를 놓친다. 변화를 이끌고 대표성을 개선하려면 꿈이 있는 모든 엔지니어와 기술 전문가가 훌륭이 성장할 수 있는 생태계를 만들고 있는지를 스스로 평가해봐야 한다.예) 여성을 더 많이 채용하려는 엔지니어링 관리자라면 단순히 채용 프로세스 개선에만 신경 써서는 부족하다. 채용 후 고용 유지와 승진 등 시스템의 다른 측면에서도 여성을 공정하게 대우하는지 깊이 살펴봐야 한다.대표성이 낮은 사용자를 위한 제품을 개발하려는 기술자가 수행해야 할 다음 단계는 더 포괄적인 사용자 경험을 연구하는 것이다. 다양한 언어와 문화, 여러 국가에 걸친 사회 경제적 계층, 장애 여부, 연령대를 아우르는 사용자 그룹을 대상으로 진행해야 한다. 가장 소외된 사용 사례를 최우선으로 살펴보라4.6 확립된 프로세스에 도전하기구글의 일부 엔지니어링 팀에서 글로벌 채용 요청 시스템을 구축했다. 외부 채용과 사내 이동 모두를 지원하는 시스템이였으나 한 뛰어난 엔지니어가 과거의 성과로 미래의 성과를 예측할 수 있는지 의문을 제기했고, 구글은 이를 심층분석 했다.그 결과 낮은 평가를 받은 많은 직원이 팀 이동 후 평가가 좋아졌음을 알아냈다. 즉 성과 등급은 해당 평가 시점에 그 사람이 맡고 있던 역할을 얼마나 잘 수행했느냐를 말해줄 뿐 미래의 성과를 예견해주지는 못 했다. 그래서 앞으로 맡길 역할에 준비되어 있느냐를 평가하거나 팀 이동시 자격을 논하는 데 이용해서는 안된다. 이 심층 분석은 상당 기간 소요됐지만 사내 이동 프로세스의 공정성을 개선하는 데 기여했다.4.7 가치 VS 결과구글은 채용에 상당한 투자를 해왔다. 공정성과 포용력을 개선하기 위해 내부 프로세스를 끊임없이 평가해왔다. 하지만 전 세계 사용자를 대표하게끔 채용하려는 목표는 매년 미달하고 있다. 실패의 원인은 회사가 추구하는 가치, 의도, 투자보다는 현실에 적용하는 과정에서 정책들을 어떻게 응용하느냐에 달린 것 같다. 그렇다면 우리가 나아갸아 할 방법은 어디일까? 자신을 솔직하게 바라보고 성찰하자 모두를 위해 만들지 말자 모두와 함께 만들자 제품을 이용하기 가장 어려운 이들을 위해 설계하자 가정하지 말고, 시스템 전반의 공정성을 측정하자 변할 수 있다.4.8 관심을 잃지 말고 전진하자공정 사회로 가는 길은 길고 험난하다. 하지만 단순히 도구와 서비스를 구축하는 데서 벗어나 우리가 만든 제품이 인류에 어떤 영향을 주는지를 더 깊이 이해해야 한다. 미래의 훌륭한 엔지니어로서 우리는 편견과 차별 때문에 가장 고통받는 사용자들에게 최우선으로 관심을 기울여야 한다. 엔지니어가 되려면 함께 그리고 멈추지 말고 전지해야 한다. 우리 목표는 불합리함을 겪는 사람들을 더이상 소외시키지 않고 인류를 더 나은 길로 이끄는 변화를 만들어내는 것이다.4.9 마치며소프트웨어 그리고 소프트웨어 조직은 팀이 하나 되어 만들어가는 것이다. 지금 우리는 전세계의 모두가 연결된 세상에 살고 있기 때문에 소프트웨어 조직이 커질수록 사용자들의 목소리에 응답할 수 있도록 설계해야 한다. 엔지니어링 조직의 규모를 늘리려면 소수 집단을 무시해서는 안 된다.4.10 핵심정리 우리는 편견에서 벗어날 수 없다. 다양한 사용자층을 포용하도록 설계하려면 조직 구성 측면에서도 반드시 다양성을 갖추어야 한다. 포용성은 소수 집단 채용 프로세스 개선에 반드시 필요하다. 포용성은 모든 직원을 차별없이 지원하는 근무 환경을 조성하는 데 에도 아주 중요하다. 제품 개발 속도는 모든 사용자에게 진정 유용해야 한다는 관점에서 평가되어야 한다. 일부 사용자에게 해를 끼칠 수 있는 제품이라면 차라리 출시를 늦추는 편이 낫다." }, { "title": "03. 지식 공유", "url": "/posts/03.%EC%A7%80%EC%8B%9D-%EA%B3%B5%EC%9C%A0/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-10-20 17:37:08 +0900", "snippet": "조직에는 배움의 문화가 자리 잡혀 있어야 하고, 그러려면 사람들에게 모르는 걸 인정할 수 있도록 돕는 심리적 안전을 제공해야 한다.3.1 배움을 가로막는 장애물 심리적 안전 부족 - 불이익이 두려워서 스스로 위험을 감수하거나 실수를 드러내기 꺼리는 환경 정보 섬 - 조직의 각 부서가 서로 소통하거나 자원을 공유하지 않아서 지식이 파편화(정보 파편화, 정보 중복, 정보 왜곡) 단일 장애점 - 중요한 정보를 한 사람이 독점하면 병목이 생긴다. 좋은 의도에서 ‘내가 다 처리하지’라는 마음은 단기 효율은 높여줄지 몰라도 장기 확장성을 희생하는 꼴이다. 전부 아니면 전무 전문성 - 조직 구성원이 모든 것을 아는 사람과 아무것도 모르는 초심자로 나뉜다. 이렇게 되면 지식과 책임은 계속 이미 전문가가 된 사람들에게 집중되고, 새로운 팀원이나 초심자들은 그들만의 울타리에 같혀 드리게 성장하게 된다. 앵무새처럼 흉내내기 - 이해하지 못한 상태로 흉내만 내는 것 유령의 묘지 - 무언가 잘못될 게 두려워서 아무도 손대지 않는 영역을 말한다.3.2 철학소프트웨어 엔지니어링을 여러 버전의 프로그램을 여러 사람이 참여해 개발하는 일이라고도 정의할 수 있다. 소프트웨어 엔지니어링에서 가장 중요한 요소는 사람이다. 조직의 성패는 인력에 얼마나 투자해서 잘 키워내는냐에 달려 있다. 전문가가 일대일로 해주는 조언 - 어떤 측면에서는 매우 효과적이지만 확장성이 부족하여 팀이 커지면 그리 유용하지 못하다. 문서화된 지식 - 조직 전체로 퍼뜨릴 수 있고, 확장성이 좋으나 개별 학습자가 처한 특수한 상황에는 다소 적합하지 않고, 유지보수 비용이 많이 든다. 현장 지식현장 지식과 문서화된 지식은 서로를 보완해준다. 심지어 모두가 전문가로 구성되고 완벽한 문서로 무장한 팀이라 해도 서로 소통하고 다른 팀과 협력하고 때로는 다른 팀의 전략을 수용해야 한다.3.3 판 깔아주기: 심리적 안전심리적 안전은 학습 환경을 조성하는 데 매우 중요하다. 먼저 자신이 이해하지 못한 게 있음을 인정해야 무언가를 배울 수 있다.배움에는 무언가를 시도하다가 실패해도 안전하다는 인식이 엄청나게 중요하다. 건강한 환경에서라면 사람들은 질문을 던지고, 틀리고, 새로운 지식을 얻는 걸 편안하게 생각한다.3.3.1 멘토 제도멘토 제도는 신규 입사자에게 심리적 안전을 심어주는 효과적인 방법이다. 멘토는 멘티가 누구에게 조언을 구해야 할지 알 수 없을 때 찾아갈 수 있는 안전망이 되어 준다.3.3.2 큰 그룹에서의 심리적 안전대부분의 사람은 낯선 이들로 구성된 큰 그룹을 찾기보다는 바로 옆 동료에게 도움을 요청하는 걸 더 편하게 생각한다. 하지만 일대일 방식은 확장하기 어렵다. 그룹 방식은 일대일보다 확장성이 좋지만 두려움은 더 크게 느낀다. 그래서 큰 그룹에서는 심리적 안전이 더욱 중요해진다. 그룹의 모든 구성원이 안전한 환경을 만들고 유지하는 역할을 함께 해줘야 한다. 신규 입사자는 부담없이 질문할 수 있게 해주고, 성장 중인 전문가는 기존 전문가들이 자신의 답변에서 허점을 찾아 공격할지 모른다는 두려움 없이 도움의 손길을 내밀 수 있도록 해야 한다이처럼 안전하고 편안한 근무 환경을 조성하기 위해 가장 필요한 것은 적대적이지 않고 협조적으로 일하는 문화이다.[그룹내 안티패턴] 기초적인 질문이나 실수를 가려내서 질문한 사람을 꾸짖는다. 자신의 지식을 뽐낼 목적으로 설명한다. 잘난 체하고 비난하며 건설적이지 못한 방식으로 대응한다. 승자와 패자를 가리는 논쟁 형식으로 상호작용이 이루어진다.3.4 내 지식 키우기3.4.1 질문하기항상 배우고 항상 질문하라 초심자가 저지르는 가장 큰 실수는 무언가 막혔을 때 질문하지 않는 것이다. 동료들이 가장 훌륭한 정보 소스일 경우가 많으니 이 귀중한 자원을 충분히 활용하도록 하자, 또 모르는 분야가 나오면 두려워하지 말고 성장하는 기회로 받아들이자팀의 리더든 새로운 멤버든 항상 무언가 배울 게 있는 환경에서 살아야 한다. 그렇지 않으면 더 이상 성장하지 못할 것이다.3.4.2 맥락 이해하기새로운 것을 이해하는 것 뿐만 아니라 기존 설계와 구현을 뒷받침하는 결정 사항들을 더 깊이 이해하는 일도 배움에 포함된다.엔지니어들은 너무 성급하게 ‘이건 잘못됐어’라고 결론 짓는 경향이 있다. 생소한 코드, 언어, 패러다임을 접했을 때는 더욱 심하다. 정상이 아니라고 보이는 결정에 대해서는 먼저 맥락을 찾아 이해해야 한다. 우선 코드의 목적과 맥락을 이해하고, 그런 다음 변경하려는 방향이 여전히 더 나은지 고민해야 한다.3.5 질문 확장하기: 커뮤니티에 묻기무언가를 일대일로 배울 때는 기록하는 습관을 기르자, 개인이 기록해둔 지식을 공유하는 것도 유익하지만 더 큰 커뮤니티에 도움을 청하는 것도 좋다.3.5.1 그룹 채팅질문은 있는데 적합한 사람으로부터 도움을 받기 어려울 때가 있다. 누구에게 물어봐야할지 모르겠거나 물어보려는 사람이 바빠서일 경우도 있다. 이런 상황이라면 그룹 채팅이 효과적이다. 동시에 여러 사람에게 질문을 던질 수 있고 시간이 허락되는 사람들끼리 빠르게 대화를 주고 받으며 답을 찾기 때문이다.그룹 채팅은 간단한 질문에 적합하다. 체계화된 구조가 있는 게 아니라서 본인이 적극적으로 참여하지 않는 대화에서는 의미 있는 정보를 뽑아내기 어려울 수 있다.3.5.2 메일링 리스트공개 메일링 리스트에 질문을 던지는 건 그룹 채팅에 질문하는 것과 상당히 비슷하다. 잠재적으로 답을 줄 수 있는 수많은 사람에게 질문이 전달되고, 해당 메일링 리스트를 구독하는 모두가 그 질문으로부터 배울 수 있다. 그룹 채팅과 다른 점은 더 많은 사람과 공유하기 쉽다는 점이다. 메일 내용은 검색 가능한 아카이브로 보관되고 그룹 채팅보다 구조가 잘 갖춰져 있다.메일링 리스트는 맥락 정보가 많이 필요한 복잡한 질문이 적합하고, 그룹 채팅처럼 빠르게 주고 받는 대화에는 취약하다.3.5.3 YAQS:질의응답 플랫폼YAQS는 구글 내부에서 사용하는 스택오퍼플로와 유사한 플랫폼이다.3.6 지식 확장하기: 누구나 가르칠 게 있다.가르친다는 건 전문가의 전유물이 아니다. 전문성은 다차원 벡터이다. 누구나 영역별로 다양한 수준의 전문성을 갖추고 있다. 구글 엔지니어들은 다음과 같이 다양한 방식으로 다른 사람들 가르친다.3.6.1 오피스 아워오피스 아워는 누군가가 특정 주제에 관한 질문에 답해줄 목적으로 시간을 비워 둔 정기적인 이벤트이다. 당장 급한데 오피스 아워까지 기다리는건 고문이기 때문에 지식 공유를 목적으로 오피스 아워를 최우선으로 활용하는 경우는 거의 없다. 그래도 전문가와 직접 대면할 기회를 제공하기 때문에 문제가 불명확하여 어떻게 질문해야 할지 모를 때나 문서화되지 않은 특수한 문제에 맞닥뜨렸을 때 특히 유용하다.3.6.2 기술 강연과 수업구글의 engEDU팀은 구글 엔지니어부터 전 세계의 학생들을 포함한 다양한 청중에게 컴퓨터 과학을 교육하는 데 중점을 두고 있다. 또 g2g프로그램을 운영하여 구글러라면 누구든 가입하여 동료 직원들을 위한 수업을 개설하거나 참석할 수 있게 했다.[수업의 결과를 극대화하는 조건] 자주 복잡한 주제를 다뤄야 한다. 수업은 개설 비용이 크므로 해결해야 할 분명한 요구가 있을 때 만들어져야 한다. 주제가 비교적 안정적이어야 한다. 내용이 자주 바뀌면 수업 교제를 고치는 데 시간이 많이 든다. 직접적인 도움없이 학생 혼자 쉽게 익힐 수 있는 주제라면 혼자석 학습할 수 있는 매체가 더욱 효과적이므로 질문에 답해주고 일대일로 도와줄 수 있는 교사가 있어야 효과적이다. 수업을 정기적으로 개설해도 될 만큼 수요가 많아야 한다.3.6.3 문서 자료문서자료는 독자가 무언가를 배우도록 돕는 것을 최우선 목표로 하는 기록된 지식이다. 문서자료 갱신하기 - 무언가를 막 배운 순간이 기존 문서자료에서 개선점을 찾기에 가장 좋은 때이다. 처음 배우는 단계에서 문서자료의 실수나 빠진 부분을 발견한다면 곧바로 고쳐라 새로운 문서자료 작성하기 - 숙달되면 자신만의 문서자료를 작성하고 기존 문서자료들을 갱신해봐라. 그리고 피드백할 방법이 있어야 한다. 문서화 촉진하기 - 문서자료를 작성하려면 시간과 노력이 드는데, 코딩할 시간에서 뺏어와야 하기 때문이다. 문서화는 팀과 조직의 규모를 키우는 데도 보탬이 된다.3.6.4 코드코드도 지식이라는 사실을 인지하느냐 여부가 코드 가독성과 명확성에 간접적으로 영향을 줄 때가 많다.코드 문서화는 또 다른 형태의 지식 공유 수단이다. 깔끔한 문서자료는 라이브러리 이용자는 물론 향후 라이브러리를 유지보수하는 이들에게도 큰 혜택을 준다. 또 코드 리뷰는 코드 작성자와 리뷰어 모두에게 배움의 기회를 준다. 구글은 가독성 프로세스라는 것을 두어 코드 리뷰를 통한 멘토링 제도를 표준화했다.3.7 조직의 지식 확장하기조직이 커질수록 전문 지식을 조직 전반에 제대로 공유하기가 어렵다. 가령 표준 정보 소스 같은 것들은 조직이 커질수록 혜택도 커진다.3.7.1 지식 공유 문화 일구기많은 회사에서 조직 문화를 사람 사이의 문제로 치부한다. 하지만 구글은 산출물보다 문화와 환경을 첫 번째로 두고 생각해야 더 나은 결과를 얻는다고 믿는다. 존중 - 몇몇 개인의 나쁜 행동 때문에 팀 혹은 커뮤니티 전체가 초심자에게 버티기 가혹한 환경으로 변하기도 한다. 지식을 공유할 때는 상냥함과 존중을 담아야 하고, 또 그래야만 가능하다. 기술 업계에서는 뛰어난 괴짜를 용인하는 경향이 있지만 이는 해로운 현상이다. 상냥한 전문가도 얼마든지 가능하다. 보상과 인정 - 구글은 회사 표준의 성과 검토와 승진 기준부터 동료 사이에서 주고 받는 상에 이르기까지 다양한 성과 인정 제도를 운영한다.예) 동료 상여 제도, 쿠도스(공개칭찬)제도가 있다.3.7.2 표준 정보 소스 구축하기표준 정보 소스는 회사 차원의 중앙집중적 정보 원천으로 전문가의 지식을 표준화하고 전파하는 수단이다. 조직 내 모든 엔지니어에게 공통으로 필요한 정보를 담아두는 최선의 도구이기도 하다. 개별 부서나 개인들이 각자의 정보를 생성해 활용하다 보면 서로 충돌하거나 파편화되기 마련인데 표준 정보 소스로 이런 문제를 막을 수 있다.그리고 표준 정보는 조직 차원에서 합의한 내용을 제공하고 눈에 잘 띄기 때문에 해당 분야 전문가들이 적극적으로 관리하고 감독해야 한다.중앙의 표준 정보 소스를 만들고 관리하는 일에는 비용과 시간이 많이 들며 모든 정보가 조직 차원에서 공유될 필요는 없다. 그래서 이 일에 얼마나 투자할지를 계산할 때는 누구를 위한 정보인지를 고려해야 한다. 개발자 가이드 - 가이드에 익숙한 전문가가 후임 엔지니어에게 적시에 알맞은 링크를 보내줄 수 있다. 전문가는 개인적으로 설명해줄 필요가 없어 시간이 절약되고 배우는 사람도 필요하면 언제든 신뢰 가는 정보를 찾아볼 수 있는 정보 소스가 있음을 알게 된다. go/ 링크 - 구글 내에서 쓰는 URL 단축 서비스이다. 구글 내부의 참조 대부분은 하나 이상의 내부 go/ 링크를 가지고 있다. 코드랩 - 코드랩은 동작하는 예시 코드, 설명, 코딩 연습 문제등을 활용해 엔지니어에게 새로운 개념이나 프로세스를 가르치는 실습형 튜토리얼이다. 정적 분석 - 정적 분석 도구는 검사 로직을 자동화할 수 있는 모범 사례들을 공유하는 강력한 수단이다.3.7.3 소외되지 않기업무를 수행하려면 반드시 필요한 정보들이 있다. 또 상대적으로 덜 중요한 정보도 있다. 이런 전달하려는 지식의 중요도에 따라 정보 공유 매체가 얼마나 공식적이어야 하는가에 대한 기대치가 다르다. 뉴스레터 - 뉴스레터는 업무에 꼭 필요하지는 않지만 엔지니어들이 관심을 가질만한 정보를 유통하는 괜찮은 수단이다. 이런 종류의 정보는 제공 빈도를 높이기 보다는 내용을 더 유용하고 흥미롭게 채워야 효과적이다. 커뮤니티 - 커뮤니티를 통한 소통은 열린 소통 채널이라 수많은 전문가로부터 무언가를 배우기가 더 수월하다.3.8 가독성 제도 : 코드 리뷰를 통한 표준 멘토 제도구글에서 가독성 제도는 단순한 코드 가독성 이상을 의미한다. 전사 차원의 표준 멘토링 프로세스를 지칭하는 것으로써 언어 이디엄, 코드 구조, API 설계, 공통 라이브러리의 올바른 사용법, 문서화, 테스트 커버리지 등의 전문 지식을 광범위하게 다룬다.3.8.1 가독성 인증 프로세스란?구글에서 코드 리뷰는 필수이다. 모든 변경 목록(CL)은 가독성 승인을 얻어야 한다. 가독성 승인이란 해당 언어의 가독성 자격증이 있는 누군가가 해당 CL을 승인했다는 표시이다.가독성 자격증을 받은 엔지니어라 함은 특정 프로그래밍 언어를 사용하여 구글의 모범 사례와 코딩 스타일에 맞는 명확하고 관용적이고 유지보수하기 쉬운 코드를 일관되게 작성하는 사람이라는 뜻이 된다.리뷰어는 특정 언어를 깊이 이해하고, 다른 사람의 코드를 검토하며 가르쳐야 하므로 항상 최고 수준을 유지해야 한다. 또 가독성 제도는 공격용 무기가 아닌, 가장 우선시되고 중요한 멘토링 수단이자 협업 수단으로 생각하고 행동해야 한다.3.8.2 가독성 인증 프로세스를 두는 이유코드는 작성되는 횟수보다 훨씬 많이 읽히며, 구글의 규모와 구글이 매우 큰 모노리포를 이용한다는 점을 감안하면 그 차이는 훨씬 커진다.가독성 제도는 엔지니어들에게 소속 팀에서 통용되는 현장 지식 이상을 전달하는 매우 큰 장점을 선사한다. 또 일관성을 강화하고 정보 섬을 없애고 확립된 표준에서 벗어나는 일을 막기 쉽다는 게 장점이다. 코드베이스 전체가 일관될 때 얻는 가치는 아무리 강조해도 부족한다.가독성 제도는 코드 리뷰가 길어진다는 단기적인 비용과 코드 품질 개선, 리포지터리 차원의 코드 일관성 향상, 엔지니어 전문성 향상에서 절약하는 장기적인 비용을 의식적으로 맞바꾸는 제도이다.3.9 마치며지식은 형태는 없을지라도 많은 측면에서 소프트웨어 엔지니어링 조직의 가장 중용한 자산이다. 개방적이고 정직한 지식 공유를 장려하는 문화는 지식을 조직 전반에 효율적으로 전파하여 날이 갈수록 조식이 더 확장되도록 해준다. 대부분 지식을 쉽게 공유하는 데 투자한 노력은 회사의 생애 동안 그 몇 배로 돌려받는다.3.10 핵심 정리 심리적 안전은 지식 공유 환경을 조성하기 위한 토대이다. 작게 시작하라 질문하고 기록하라 직원들이 전문가와 문서화된 자료 모두로부터 필요한 도움을 쉽게 얻을 수 있도록 하라 자신의 전문 지식을 가르치고 전파하는 사람들을 격려하고 보상하는 체계적인 제도를 마련하라" }, { "title": "02. 팀워크 이끌어내기", "url": "/posts/02.%ED%8C%80%EC%9B%8C%ED%81%AC-%EC%9D%B4%EB%81%8C%EC%96%B4%EB%82%B4%EA%B8%B0/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-10-19 17:53:23 +0900", "snippet": "이번 장의 핵심 주제는 소프트웨어 개발은 팀의 단합된 노력의 결실이라는 점이다. 그래서 엔지니어링팀이 성공하려면 겸손, 존중, 신뢰라는 핵심 원칙에 맞게 자신의 행동을 바로잡아야 한다.2.1 내 코드를 숨기고 싶어요사람들은 자신이 진행 중인 작업물을 다른 사람이 보고 판단하는 걸 두려워 한다. 이러한 불안감은 소프트웨어 개발에서의 더 큰 문제의 징후임을 찾아냈다.2.2 천재 신화리눅스를 개발한 라누스, 파이썬을 개발한 귀도 반 로섬 등 처음 시작을 한 것은 맞지만 궁극적으로 수백, 수천명의 인재들이 함께 개발을 진행하며 지금의 자리에 올 수 있었다.인간은 본능적으로 리더와 롤모델을 찾고, 그들을 우상화하고 흉내내려 한다. 프로그래밍 세계에서도 기술 전문가 셀럽 현상이 거의 신화화되어 가고 있다. 천재라고 해서 괴짜처럼 행동하는 게 용서 받는 시대는 지났다. 천재든 아니든 사회성이 부족한 사람은 팀원으로 적합하지 않기 때문이다. 구글에서의 업무의 대부분은 천재 수준의 지능을 요구하지 않는 반면, 모든 업무가 최소한의 사회성을 요구한다. 핵심은 다른 사람과 얼마나 잘 협력하느냐 이다.2.3 숨기는 건 해롭다오롯이 홀로 일한다면 실패할 위험성을 불필요하게 키우고 자신의 성장 잠재력을 속이는 것이다.2.3.1 조기 감지위대한 아이디어를 세상으로부터 숨기고 완벽히 다듬어질 때까지 아무도 들여다보지 못하게 하는 건 엄청난 도박이다. 초기 설계에는 근본적인 실수가 스며 있기 쉽다. 그래서 피드백을 조기에 받을수록 위험이 크게 줄어든다. 일찍 실패하고, 빨리 실패하고, 자주 실패하라2.3.2 버스 지수버스 지수 : 몇 명의 팀원이 버스에 치어서 일을 할 수 없게 될 때 프로젝트가 망하게 되는지를 나타내는 지수프로젝트에서 필요한 지식과 동작 원리를 이해한 사람이 나뿐이라면 내가 해고될 가능성은 극히 낮다. 하지만 내가 버스에 치인다면 프로젝트는 망할 것이다. 내 지식을 동료 한 명과 공유한다면 버스 지수는 두 배가 된다. 최소한 각 책임 영역마다 2차 소유자를 두고, 제대로 된 문서를 갖춰 둔다면 프로젝트의 미래를 보장하고 버스 지수를 높이는 데 도움이 된다.혼자 일하게 되면 버스 지수 외에 전반적인 진행 속도에도 해롭다. 혼자 일하는 것은 고된 싸움이며 사람들의 기대보다 훨씬 느리다는 점을 잊기 쉽다. 다른 이들과 함께 어울려 일하면 개인의 노력만으로는 깨우치기 어려운 공동의 지혜라는 이점을 얻을 수 있다.2.3.3 진척 속도현재의 데브옵스 철학은 가능한 한 일찍 피드백하고, 가능한 한 일찍 테스트하고, 보안과 프로덕션 환경을 가능한 한 초기부터 고려한다. 라는 목표를 천명하고 있다. 즉 문제를 빨리 찾을수록 고치는 비용이 낮아진다.계획이나 설계 변경이 필요한 시점을 즉시 알려줄 피드백 루프를 어떻게 마련할 것인가? 정답은 팀 플레이이다. ‘눈이 많아야 버그가 줄어든다 -&gt; 눈이 많아야 프로젝트가 탈선하지 않고 옳은 방향으로 나아간다.’**오늘날의 소프트웨어는 개인이 아닌 팀이 만들어내므로 팀원들과의 즉각적이고 원활한 소통이 무엇보다 중요하다.2.3.4 결론은 숨기지 말자2.4 모든 건 팀에 달렸다.프로그래밍 세계에서는 고독한 장인은 매우 드물고, 존재하더라도 초월적인 업적을 홀로 이루지는 않는다는 것이다.소프트웨어 엔지니어링은 팀의 단합된 노력이다. ‘다른 사람과 함께 일해야 한다, 비전을 공유해라, 역할을 나누어라, 다른 이로부터 배우자, 멋진 팀을 만들자’2.4.1 사회적 상호작용의 세 기둥협업의 열반에 들어가려면 ‘사회적 스킬의 세기둥’을 배우고 익혀야 한다. 겸손 존중 신뢰2.4.2 세 기둥이 중요한 이유사회적 관계의 힘을 과소평가하지 말라 관계는 언제나 프로젝트보다 오래 지속된다. 동료들과 끈끈해지면 필요할 때 기꺼이 자신들의 수고를 마다하지 않을 것이다.2.4.3 겸손, 존중, 신뢰 실천하기 자존심 버리기 비평하고 비평받는 법 배우기 : 전문적인 소프트웨어 엔지니어링 환경이라면 비평에 개인적인 감정이 실리는 경우는 거의 없다. 단순히 더 나은 프로젝트를 만드는 과정일 뿐이다. 스스로 비평을 잘 수용할 줄 알아야 한다. 자신의 기술에 겸손해야 함은 물론, 상대는 내 최우선 관심사를 진심으로 생각하며 절대 나를 어리석다고 생각하는 게 아님을 믿어야 한다. 우리 자존감을 우리가 작성한 코드와 동일시해서는 안 된다. 상대의 코드에 대해 피드백 할 때는 상대가 아닌 자신을 겸손하게 낮춰서 말하자, 상대가 틀린 것이 아니라 내가 코드를 이해하는 데 문제를 겪고 있는 것이다. 빠르게 실패하고 반복하기 : 구글에서는 ‘가끔씩 실패하지 않는다면 충분히 혁신적이지 않거나 위험을 충분히 감수하지 않은 것이다’ 라는 믿음이 널리 통용된다.2.4.4 비난 없는 포스트모템 문화실패한 근본 원인을 분석하여 문서로 남기는 것이 실수로부터 배우는 핵심이다. 이를 구글은 포스트모템이라고 한다.제대로 된 포스트모템에는 무엇을 배웠는지와 배운 것을 토대로 앞으로 무엇을 바꿀지가 담겨야 한다. 그런 다음 포스트모템을 쉽게 열람할 수 있고, 포스트모템에서 제안한 변화를 팀이 실천하는지 확인해야 한다. 실패를 제대로 기록해두면 다른 이들도 무슨 일이 있었는지 알 수 있고, 똑같은 실수를 반복하는 일을 피할 수 있다.다음의 내용을 담자 사건의 개요 사건을 인지하고 해결에 이르기까지의 타임라인 사건의 근본 원인 영향과 피해 평가 문제를 즉시 해결하기 위한 조치 항목(소유자 명시) 재발 방지를 위한 조치 항목 해당 경험에서 얻은 교훈인내심을 기르자 : 서로 맞지 않더라도 인내심을 잃지 않고 새로운 협업 방식등을 찾아서 상황을 해결할 수 있다.마음을 열고 받아들이자 : 결점이 많은 사람이 모른다고 바로 시인해버리면 주변의 누가 신뢰할까 싶다. 하지만 실수를 했거나 자기 역량을 넘어선 일임을 인정하면 장기적으로 지위를 확고히 해줄 것이다. 결점을 드러내는 것은 겸손을 겉으로 표현하는 일이며, 책임을 지고 의무를 다 하려는 의지의 표출이다.2.4.5 구글답게 하기구글만의 겸손, 존중, 신뢰 원칙이 있다. 구글은 구글 다움이 갖춰야할 기준을 명확히 정의했다. 모호함을 뚫고 번창한다. 피드백을 소중히 한다. 저항(항상성)을 극복한다. 사용자를 우선한다. 팀에 관심을 기울인다. 옳은 일을 한다.2.5 마치며소프트웨어를 떠받드는 토대는 제대로 작동하는 팀(고기능 팀)이다. 소프트웨어 조직이 오래 지속되려면 겸손과 신뢰, 그리고 팀을 중심으로 한 존중에 뿌리를 둔 건강한 문화를 갖춰야 한다.2.6 핵심정리 고립되어 일할 때의 트레이드 오프에 유의하라 팀원들 사이의 소통, 대인 관계 충돌 때문에 낭비한 시간이 얼마나 많은지 생각하자 그리고 다른 사람들의 성향과 일하는 방식을 이해하는 데 조금만 투자하면 생산성을 크게 끌어올릴 수 있다. 팀 또는 더 큰 조직 안에서 효과적으로 일하고 싶다면 자신이 선호하는 업무 방식은 물론 다른 사람들이 선호하는 방식도 알아야 한다." }, { "title": "01. 소프트웨어 엔지니어링이란?", "url": "/posts/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81%EC%9D%B4%EB%9E%80/", "categories": "BOOK, 구글 엔지니어는 이렇게 일한다", "tags": "software_engineering", "date": "2022-10-14 23:40:02 +0900", "snippet": "프로그래밍과 소프트웨어 엔지니어링의 가장 큰 차이는 시간, (규모)확장, 실전에서의 트레이드오프 이다. 소프트웨어 엔지니어링 프로젝트에서 엔지니어는 시간의 흐름과 언젠가 변경될 가능성에 더 신경 써야 한다. 만들어낼 소프트웨어 자체뿐 아니라, 제작하는 조직까지 양 측면 모두에서의 확장과 효율에 더 집중해야 한다.소프트웨어 엔지니어링은 흐르는 시간 위에서 순간순간의 프로그래밍을 모두 합산한 것이다. 시간이 프로그램에 미치는 영향 : ‘이 코드의 예상 수명은?’ 수명이 길어질수록 변경이라는 요소가 점점 중요해진다. 규모 관점에서 바라본다 : 몇 명이 참여하는가, 시간의 흐름에 따라 엔지니어들은 개발과 유지보수의 어느 부분에 관여하는가? 소프트웨어 엔지니어링은 팀 업무이다. 소프트웨어 엔지니어링과 프로그래밍은 시간과 참여 인원 면에서 차이가 난다. 협업은 그 자체로 새로운 문제를 유발하지만, 한 명이 개발하는 것보다 가치 있는 시스템을 만들어낼 잠재력 또한 가진다. 프로젝트나 조직 규모가 확장되며 딸려오는 문제는 흔히 정책에 영향을 주며 소프트웨어의 지속 가능성을 묻는 질문에 답하는 기초가 된다. 트레이드 오프 평가 : 소프트웨어 엔지니어링에서는 주기적으로 여러 선택지 사이(유지보수에 도움이 되는 변경을 연기하거나 확장성이 떨어지는 정책을 받아들여야 하는 경우 등등)의 트레이드 오프를 평가해야 하고, 합리적인 결정을 내려야 한다.1.1 시간과 변경초심자가 프로그래밍을 배우는 과정에서 작성한 코드의 수명은 보통 몇 시간에서 며칠 정도일 것이다. 또 초기 스타트업에서 일하는 엔지니어들도 바로 눈앞의 목표에 집중하려 할 것이다. 그래서 줄곧 스타트업들에서만 일해왔다면 10년차 개발자라도 소프트웨어를 1~2년 이상 유지보수해본 경험이 전무할 수 있다.반대편에서는 반 영구적으로 살아남은 프로젝트도 있다. 구글 검색, 리눅스 커널, 아파치 HTTP 서버의 수명은 언제 다할지 예측할 수 없다.기대 수명이 수십년이 될 수록 업그레이드의 중요도도 높아진다. 이때 기대 수명의 최저점, 최고점 사이의 어디에서 전환이 일어나는데 이 기점으로 프로젝트는 외부 환경의 변화에 대비하기 시작해야 한다. 초기부터 업그레이드를 계획하지 않은 프로젝트라면 이 전환이 아주 고통스러울 것이다. 해당 프로젝트에서 수행해본 적 없는 작업을 진행해야 한다. 업그레이드 담당 엔지니어들이 이런 종류의 작업을 경험해보지 못했을 가능성이 크다. 일반적인 업그레이드보다 작업 규모가 큰 경우가 많다.(점진적X, 수년치 업그레이드를 한 번에 진행)이러한 고통 때문에 기존 코드를 버리고 새로 작성하거나 업그레이드를 완전히 포기해버릴 수 있다.첫 대규모 업그레이드를 성공적으로 마치는 일뿐 아니라 현재 상태를 안정되게 유지할 수도 있어야만 프로젝트가 오래 지속 가능할 확률이 높다. 지속 가능하게 하려면 요구되는 변경들의 영향을 계획하고 관리해야 한다.1.1.1 하이럼의 법칙다른 엔지니어들이 사용 중인 프로젝트를 유지보수하고 있다면 동작한다 / 유지보수 가능하다 를 구분 짓는 가장 중요한 요인은 하이럼의 법칙일 것이다.하이럼의 법칙 : API 사용자가 충분히 많다면 API 명세에 적힌 내용은 중요하지 않다. 시스템에서 눈에 보이는 모든 행위를 누군가는 이용하게 될 것이기 때문이다.시간의 흐름에 따른 변경과 유지보수를 논하려면 하이럼의 법칙을 알아야 한다. 하이럼의 법칙은 최선의 의도, 최고의 엔지니어, 꼼꼼한 코드 리뷰가 뒷받침되더라도 공표한 계약(명세)이나 모범 사례를 완벽하게 구현해냈다고 단정할 수 없다는 현실을 표현한 말이다.현실에서는 API 사용자가 명세에는 없는 기능을 찾아서 활용하기도 하며 그 기능이 유용해 널리 쓰이게 되면 추후 API를 변경하기 어렵게 된다. 따라서 변경이 얼마나 유용한지를 분석할 때는 충돌을 조사, 식별, 해결하는 데 따르는 비용도 고려해야 한다.1.1.2 사례:해시 순서해시 테이블의 원소 순서는 나름의 알고리즘에 의해 정해진다. 그로인해 해시 테이블을 사용하면 다음과 같은 일이 발생하는 것을 경험했다. 해시 플러딩 공격(DoS의 하나로 해시 함수의 구조를 아는 사용자가 일부러 해시 테이블이 느려지도록 구성한 데이터를 제공하는 공격) 때문에 해시 반복 순서가 비결정적이어야 할 필요가 커졌다. 개선된 해시 알고리즘과 해시 컨테이너 연구로 얻은 효율 개선 효과를 보려면 해시 반복 순서에 변화를 줘야 한다. 하이럼의 법칙에 따라 해시 테이블의 순회 순서에 의존하는 프로그램을 작성하는 프로그래머가 나타날 것이다.해시 컨테이너의 반복 순서에 의존하더라도 프로그램의 수명이 짧다면 기술적 문제를 전혀 겪지 않을 것이다. 소프트웨어 엔지니어링 프로젝트에서는 이런 의존성은 위험 요인에 해당한다.프로그래밍 스타일 분류 이용하는 API의 명세에 명시되지 않은, 즉 언제든 변할 수 있는 기능을 사용하는 코드는 임시방편적인 혹은 기발한 코드이다. ===&gt; 프로그래밍 모범 사례를 따르고 미래에 대비한 코드는 클린하고, 유지보수 가능한 코드이다. ===&gt; 소프트웨어 엔지니어링1.1.3 변하지 않기를 목표로 하지 않는 이유시간과 변경에 대처해야 하는 이유의 밑바탕은 변경은 피할 수 없다라는 가정이 깔려 있다. 오래전에 만들어둔 알고리즘과 데이터 구조는 최신 장비에서 효율이 떨어지기도 한다. 그래서 소프트웨어 설계도 제때 변경해주지 않으면 최신 하드웨어를 도입하는 효과가 퇴색된다. 하위 호환되는 하드웨어라서 오래된 시스템도 여전히 구동되지만 그 시절 최적화 기법이 지금도 여전히 유효할지는 불확실하다. 그래서 최신 장비의 잠재력을 최대한 끌어 쓸 의지와 역량이 없다면 지불한 비용만큼의 효과를 얻지 못할지도 모른다. (적절한 변경이 뒷받침되어야 새로운 선택지의 도입 효과가 극대화된다.)변경은 본질적으로 좋지 않으므로 변경을 위한 변경은 삼가야 하지만 변화에 대응할 수는 있어야 한다.1.2 규모 확장과 효율성코드베이스의 지속 가능성은 ‘코드 베이스의 수명이 다할 때까지 직면하는 변화가 몰고 오는 모든 변경을 안전하게 처리할 수 있다면 그 코드베이스는 지속 가능하다.’라는 의미이다. 여기에는 비용이라는 요소가 숨어 있다. 비용이 너무 많이 드는 변경은 지연되기 쉽다. 변경 비용이 시간 흐름보다 가파르게 상승하는 시스템은 분명 확장 가능하지 않다.인건비 외에도 확장 가능해야하는 것은 더 있다. 소프트웨어 자체는 연산, 메모리, 스토리지, 대역폭 같은 전통적인 자원을 더 추가할수록 비례하여 속도나 처리량이 확장되어야 한다. 마지막으로 소프트웨어 조직에서 가장 중요한 자산인 코드베이스 자체도 확장 가능해야 한다. 코드가 많아지고 변경 이력이 쌓이는 등의 이유로 빌드 시스템이나 버전 관리 시스템이 점점 느려진다면 어느 순간 더는 정상 운영할 수 없는 시점이 온다.전체 빌드에 걸리는 시간, 리포지토리에서 전체를 새로 내려받는 시간, 프로그래밍 언어 버전을 업그레이드 하는 비용 같은 지표는 적극적으로 관리하지 않으면 천천히 악화된다.조직에서 코드를 작성하고 관리하는 데 활용하는 모든 것이 총비용과 자원 소비 측면에서 확장 가능해야 한다. 특히 반복적으로 수행하는 일이라면 모두 인적 비용 측면에서 확장 가능해야 한다.1.2.1 확장하기 어려운 정책들시스템을 폐기시키는 전통적인 방법이 확장성 문제의 예로 적합하다. 예) 새로운 위젯을 개발했다고 할때 모두가 기존 것을 버리고 새 위젯을 쓰기로 결정했다. 전환을 독려하기 위해 기존 위젝은 며칠뒤에 삭제할 것이라고 공지를 내렸다. ==&gt; 이런 방식은 작은 조직에서는 통할지 몰라도 의존성 그래프가 조금만 깊고 넓어지면 곧바로 실패하고 만다.‘갈아타기 규칙 정책’ - 마이그레이션 책임 소재를 달리하는 새 규칙으로 인프라 팀은 사내 사용자들이 새 버전으로 옮기도록 돕거나 직접 업데이트를 하되, 하위 호환성을 유지해야 한다. 사용자 입장에서는 새 인프라로 바꿔서 당장 얻는 이익이 눈에 보이지 않음에도 자신들 보고 바꾸라고 하면 의욕이 떨어져서 적극적으로 움직이지 않기 때문이다.1.2.2 확장 가능한 정책들구글 내부 정책 중 인프라 팀이 인프라 변경을 안전하게 진행하게끔 보호해주는 정책이 하나 있다. 바로 ‘인프라를 변경하여 서비스가 중단되는 등의 문제가 발생하더라도, 같은 문제가 지속적 통합(CI) 시스템의 자동 테스트에서 발견되지 않는다면 인프라팀의 책임이 아니다’ 라는 정책이다. ==&gt; 비욘세 규칙(코드를 짰으면 자기 코드에 대한 테스트도 자기가 제대로 만들었어야지 란 뜻으로 해석)전문성과 공유 포럼이 조직 확장에 기여하는 바가 크다는 사실을 깨달았다. 엔지니어들이 포럼에 질문하고 답하는 과정에서 지식이 전파되고 새로운 전문가가 성장한다.1.2.3 사례: 컴파일러 업그레이드하위 호환성이 좋다고 알려진 경우라도 언어와 컴파일러 업그레이드는 섬세하고 어려운 과제이다. 컴파일러가 업그레이드될 때는 거의 항상 어딘가 미묘하게 다르게 동작하는 곳이 있기 마련이다. 구글에서도 컴파일러를 5년간 업그레이드 하지 않아 대부분의 엔지니어가 컴파일러를 변경해본 경험이 없고, 작성된 코드들도 단 하나의 컴파일러 버전만 겪어본 상태였다. 이 때 굉장히 고통스러운 업그레이드 경험을 하게 된다.인프라는 더 자주 변경할수록 변경하기가 오히려 쉬워진다. 컴파일러 업그레이드등의 목적으로 코드를 한 번 수정해두면 거의 예외 없이 코드가 더 견고해지고 다음번 업그레이드를 하기도 쉬워진다는 것을 깨달았다. 이런 수정을 여러 차례 거치고 나면 하부 구현의 미묘한 차이에 의존하는 일이 없어지고, 대신 언어나 OS 차원에서 보장하는 추상 개념을 활용하도록 바뀐다.[코드베이스의 유연성에 영향을 주는 여러 요인] 전문성 : 여러 방법에 대한 충분한 지식과 경험 안정성 : 규칙적으로 릴리스 하여 릴리스 사이의 변경량을 줄였다. 순응 : 규칙적인 업그레이드 익숙함 : 업그레이드를 정기적으로 수행하여 중복되는 작업을 찾고 자동화 하도록 노력 정책 : 유용한 정책과 절차를 갖춘다.1.2.4 원점 회귀(왼쪽으로 옮기기)위 그림에서 보듯 문제 발견 시점을 왼쪽으로 이동시킬수록 수정 비용이 줄어든다. 왼쪽으로 옮기는 행위를 원점 회귀라고 하는데 보안성 점검을 개발 프로세스의 마지막으로 연기하면 안 된다고 호소하며 보안을 고려하는 시점을 왼쪽으로 이동시켜라 라고 한 말에서 유래되었다.제품을 고객에게 배포한 후에야 취약점이 발견되면 해결하는 데 막대한 비용이 들 것이다. 코드 커밋 전에 정적 검사나 코드 리뷰로 찾아낸 버그는 프로덕션 이후에 발견한 버그보다 훨씬 싸게 고칠 수 있다.1.3 트레이드오프와 비용소프트웨어 엔지니어링에서도 좋은 선택이 대체로 좋은 결과로 이어진다.[비용의 종류] 금융 비용 (돈) 리소스 비용 (CPU시간) 인적 비용 (엔지니어링 노력) 거래 비용 (조치를 취하는 비용) 기회 비용 (조치를 취하지 않는 비용) 사회적 비용 (선택이 사회 전체에 미치는 영향)위에 나열된 비용 외에도 현상 유지 편향과 손실 회피같은 치우침도 존재한다. 비용을 평가할 때는 모든 비용을 염두해 두어야 한다. 은행 잔고뿐 아니라 구성원들이 스스로의 가치를 느끼고 생산적인 일을 하고 있다고 생각하는지까지 포함된다.1.3.1 사례:화이트보드 마커회의때 제대로 나오는 마커가 부족해서 방해된 적이 몇 번인가? 마커가 나오다 말아서 사고의 흐름이 끊겨본 경험은?구글에서는 사무용품과 일상적인 개발시 드는 경비부터 글로벌 규모의 서비스를 준비하고 운영하는 방법에 이르기까지 모든 일과 관련된 비용/이윤 트레이트 오프에 동일한 수준의 관심을 두고 명확이 계량하려고 한다.종종 구글의 문화는 데이터 주도적이다라고 하는데 데이터가 없을 때조차 근거, 선례, 논증을 거쳐 결정을 내리곤 한다. 좋은 엔지니어링적 결정이란 결국 가용한 모든 근거 자료에 적절한 가중치를 부여하고, 이러한 풍부한 지식을 바탕으로 균형점을 잡는 일이다. 반드시 해야 하는일(법적 요구사항, 고객 요구사항) 근거에 기반하여 당시 내릴 수 있는 최선의 선택(적절한 결정권자가 확정)1.3.2 의사결정을 위한 근거 자료근거의 가중치를 정하는 시나리오 관련한 정량적 데이터를 모두 측정할 수 있거나 최소한 추정이라도 할 수 있는 경우 : 결함이 파고들 여지가 적다 측정하기 어렵거나 측정 방법을 모르는 정량적 데이터 : 쉬운 답이 나오기 어렵다. 그래서 절충안을 찾기 위해 경험, 리더십, 선례에 기대야 한다.1.3.3 사례: 분산 빌드소프트웨어가 거대해진 오늘날에도 약 60~70%의 개발자가 빌드를 로컬에서 실행한다고 한다. 구글에서도 2000년대 중반까지 로컬 빌드에 의존했다. 그리고 코드베이스가 커져가면서 컴파일 시간도 꾸준히 늘어났다. 그로인해 더 크고 강력한 로컬 머신을 구입하는 지출도 커졌다.결국 구글은 자체 분산 빌드 시스템을 개발했다. 비용이 많이 들고 많은 엔지니어 시간이 투입됐다. 그래도 전체적으로는 절약되는 비용이 훨씬 컸음이 명백했다.시간이 흐르면서 분산 빌드 자체가 폭발적으로 커졌고, 비대해진 빌드에는 불필요한 의존성이 넘쳐나게 됐다. 그래도 종합적으로 분산 빌드 시스템을 도입하여 절약한 비용이 시스템을 구축하고 유지보수하는데 드는 부정적인 비용보다 훨씬 컸다.1.3.4 사례: 시간과 규모 확장 사이에서 결정하기“우리 팀에만 해당하는 문제가 생겼어 해결하려면 의존성을 추가하는 게 좋을까, 아니면 포크하거나 다시 구현하는게 좋을까?”이 질문은 소프트웨어 스택의 여러 계층에서 등장한다. 당면한 문제에만 최적화한 해법이 모든 가능성에 대비하는 범용적인 해법보다 성능이 뛰어날 가능성이 크기 때문이다. 그래서 유틸리티 코드를 포크하거나 다시 구현하여 주어진 문제만을 풀도록 하면 사용성을 개선하거나 더 확실하게 최적화할 수 있다.그렇다고 모든 개발자가 기존 솔루션을 재활용하는 대신 전부 포크해버린다면 확장성과 지속 가능성이 위협 받는다. 프로젝트의 수명이 짧거나 포크한 코드의 영향 범위가 제한적인게 확실할 때 포크하는 게 유리하다. 반면 데이터 구조, 직렬화 포맷, 네트워크 프로토콜처럼 프로젝트의 수명에 종속되지 않는 인터페이스라면 포크를 피하는 게 좋다.1.3.5 결정 재고하기와 잘못 인정하기잘 드러나지는 않지만 잘못했음을 인정할 수 있게 해주는 능력 역시 데이터 중심 문화가 주는 커다란 장점이다. 제대로된 데이터이고 가정의 수는 가능한 한 적어야 좋겠지만 결정 시점에 가용한 데이터만을 활용해야 한다는 한계가 있다. 그래서 새로운 데이터를 얻어 상황이 바뀌거나 가정이 무너진다면 기존 결정에 오류가 있었음이 밝혀질 수 있다.데이터 자체도 시간이 지나면 변하고 새로운 데이터가 나타날 수 있음을 안다. 그러니 시스템의 생애 동안 과거에 내린 결정을 수시로 재고해봐야 한다.1.4 소프트웨어 엔지니어링 VS 프로그래밍소프트웨어 엔지니어링이 프로그래밍보다 우수하다는 게 아니다. 단지 이 둘에게 적용되는 제약 사항, 가치, 모범 사례가 서로 다르다는 뜻이다.서로 관련은 깊지만 상이한 두 용어인 ‘프로그래밍’과 ‘소프트웨어 엔지니어링’을 구별해야 한다. 그 차이 대부분은 시간 흐름에 따른 코드관리, 시간 흐름에 따른 규모 확장의 영향, 이런 관점에서의 의사결정 방식에 있다. 프로그래밍은 코드를 생산하는 즉각적인 행위이다. 소프트웨어 엔지니어링은 활용 가치가 남아 있는 한 오랫동안 코드를 유용하게 관리하고 팀 간 협업을 가능케 하는 정책, 관례, 도구 모두를 아우르는 종합적인 개념이다.1.5 마치며1.6 핵심 정리 프로그래밍은 코드 생산에 관한 것이다. 반면 소프트웨어 엔지니어링은 프로그래밍을 확장하여 소프트웨어의 수명이 다할 때까지 코드를 유지보수하는 문제까지 고려한다. 단명하는 코드와 장수하는 코드의 수명은 적어도 10만 배는 될 것이다. 두 프로젝트에 똑같이 적용하려는 건 너무 안일한 생각이다. 코드의 기대 수명 동안 의존성, 기술, 제품 요구사항 변경에 대응할 역량이 갖춰져야 지속 가능한 소프트웨어이다. 변경을 받아들이지 않기로 선택하더라도 변경할 수 있는 역량 자체는 필요하다. 하이럼의 법칙 조직에서 반복적으로 수행하는 모든 작업은 필요 인력 측면에서 확장 가능해야 한다. 끓는 물 속의 개구리가 되지 않도록 주의하자 의사결정을 데이터 주도로 하겠다는 생각은 좋은 출발이다. 데이터 주도 방식은 시간이 흘러 데이터가 변하면 프로젝트의 방향도 바뀔 수 있음을 뜻한다." }, { "title": "01.문자찾기, 대소문자 변환, 문장속 단어", "url": "/posts/01.%EB%AC%B8%EC%9E%90%EC%B0%BE%EA%B8%B0,-%EB%8C%80%EC%86%8C%EB%AC%B8%EC%9E%90-%EB%B3%80%ED%99%98,-%EB%AC%B8%EC%9E%A5%EC%86%8D-%EB%8B%A8%EC%96%B4/", "categories": "Algorithm, inflearn", "tags": "String", "date": "2022-09-11 17:27:39 +0900", "snippet": "1-1. 문자 찾기설명 :한 개의 문자열을 입력받고, 특정 문자를 입력받아 해당 특정문자가 입력받은 문자열에 몇 개 존재하는지 알아내는 프로그램을 작성하세요.대소문자를 구분하지 않습니다.문자열의 길이는 100을 넘지 않습니다.입력 :첫 줄에 문자열이 주어지고, 두 번째 줄에 문자가 주어진다.출력 :첫 줄에 해당 문자의 개수를 출력한다.입력 예시 :Computercoolerc출력 예시 :2나의 풀이import java.util.*;public class Main { public static int solution(String input1, char input2) { char[] c = input1.toLowerCase().toCharArray(); int cnt = 0; for(int i=0; i &lt; c.length; i++) { if(input2 == c[i]) { cnt++; } } return cnt; } public static void main(String[] args){ Scanner in=new Scanner(System.in); String input1 = in.nextLine(); String input2 = in.nextLine().toLowerCase(); char c = input2.charAt(0); System.out.println(solution(input1,c)); }}정답 풀이import java.util.*;public class Main { public static int solution(String input1, char input2) { int answer = 0; input1 = input1.toUpperCase(); input2 = Character.toUpperCase(input2); for(chae x : input1.toCharArray()) { if(x == input2) answer++; } return answer; } public static void main(String[] args){ Scanner in = new Scanner(System.in); String input1 = in.next(); char input2 = in.next().charAt(0); System.out.println(solution(input1,input2)); }1-2. 대소문자 변환설명 :대문자와 소문자가 같이 존재하는 문자열을 입력받아 대문자는 소문자로 소문자는 대문자로 변환하여 출력하는 프로그램을 작성하세요.입력 :첫 줄에 문자열이 입력된다. 문자열의 길이는 100을 넘지 않습니다.문자열은 영어 알파벳으로만 구성되어 있습니다.출력 :첫 줄에 대문자는 소문자로, 소문자는 대문자로 변환된 문자열을 출력합니다.입력 예시 :StuDY출력 예시 :sTUdy나의 풀이import java.util.*;public class Main { public static String solution(String input) { String output = \"\"; for(int i = 0; i &lt; input.length(); i++) { \t//대문자에 +32 하면 소문자 변환 if((input.charAt(i) &gt;= 65) &amp;&amp; (input.charAt(i) &lt;= 90)) { output += (char)(input.charAt(i) + 32); //소문자에 -32 하면 대문자 변환 }else{ output += (char)(input.charAt(i) - 32); } } return output; } public static void main(String[] args){ Scanner in=new Scanner(System.in); String input1 = in.nextLine(); System.out.println(solution(input1)); }}정답 풀이import java.util.*;public class Main { public static String solution(String input) { String output = \"\"; for(char x : input.toCharArray()) { //Character.isLowerCase() : 소문자인지 확인 if(Character.isLowerCase(x)) output += Character.toUpperCase(x); else output += Character.toLowerCase(x); } return output; } public static void main(String[] args){ Scanner in=new Scanner(System.in); String input1 = in.next(); System.out.println(solution(input1)); }}1-3. 문장 속 단어설명 :한 개의 문장이 주어지면 그 문장 속에서 가장 긴 단어를 출력하는 프로그램을 작성하세요.문장속의 각 단어는 공백으로 구분됩니다.입력 :첫 줄에 길이가 100을 넘지 않는 한 개의 문장이 주어집니다. 문장은 영어 알파벳으로만 구성되어 있습니다.출력 :첫 줄에 가장 긴 단어를 출력한다. 가장 길이가 긴 단어가 여러개일 경우 문장속에서 가장 앞쪽에 위치한단어를 답으로 합니다.입력 예시 :it is time to study출력 예시 :study나의 풀이import java.util.*;public class Main { public static String solution(String input) { String[] tmpArr = input.split(\" \"); String result = \"\"; for(int i = 0; i &lt; tmpArr.length; i++) { if(result.length() &lt; tmpArr[i].length()) { result = tmpArr[i]; } } return result; } public static void main(String[] args){ Scanner in=new Scanner(System.in); String input1 = in.nextLine(); System.out.println(solution(input1)); }}정답 풀이//1. split 사용import java.util.*;public class Main { public static String solution(String input) { String answer = \"\"; int m = Integer.MIN_VALUE; //작은 값으로 초기화 String[] s = input.split(\" \"); for(String x : input) { int len = x.length(); if(len &gt; m) { m = len; answer = x; } } return answer; } public static void main(String[] args){ Scanner in=new Scanner(System.in); String input1 = in.nextLine(); System.out.println(solution(input1)); }}//2. indexOf, substring 사용import java.util.*;public class Main { public static String solution(String input) { String answer = \"\"; int m = Integer.MIN_VALUE, pos; while((pos = input.indexOf(' ') != -1) { String tmp = input.substring(0, pos); //문장을 공백에서 잘라서 각각 단어를 tmp에 담는다. int len = input.length(); if(len &gt; m) { m = len; answer = tmp; } input = input.substring(pos+1); //한 단어의 비교를 끝냈으면 다음 단어부터 시작하도록 문장을 자른다. } //문장의 마지막 단어는 공백으로 자를 수 없으므로 while문 밖에서 처리한다. if(input.length() &gt; m) answer = input; return answer; } public static void main(String[] args){ Scanner in=new Scanner(System.in); String input1 = in.nextLine(); System.out.println(solution(input1)); }}" }, { "title": "05. 전체탐색", "url": "/posts/05.%EC%A0%84%EC%B2%B4%ED%83%90%EC%83%89/", "categories": "BOOK, TopCoder알고리즘 트레이닝", "tags": "algorithm", "date": "2022-08-22 22:20:00 +0900", "snippet": "전체 탐색과 시뮬레이션의 차이 시뮬레이션은 수행해야 하는 과정이 모두 나와있는 문제 전체 탐색은 모든 패턴을 조사해야 하는 것과 그것을 필요로 하는 문제전체 탐색의 형태로 다음과 같은 것이 있다. 모든 패턴을 찾고 가장 좋은 답을 찾는 것 모든 패턴을 찾고 조건을 충족하는 패턴이 몇 개인지 찾는 것답이 같은 두 문제여도 어떠한 작업을 수행할지 적혀있으면 시뮬레이션 문제이고, 없으면 전체 탐색 문제이다.5-1. 즐거운 파티화이트씨는 다재다능한 사람입니다. 그래서 그에게는 친구가 많습니다. 하지만 불행하게도 그의 친구들은 다재다능하지 않습니다. 각각의 친구는 2가지 주제에만 관심이 있고 다른 주제로 이야기하는 것을 싫어합니다.그래서 파티를 개최할 때마다 모두가 즐겁게 파티를 보내려면 어떤 친구를 초대할지가 큰 문제입니다. 화이트씨는 그 동안의 경험으로 초대된 친구 모두가 공통의 흥미 있는 화제가 있을 때 파티를 즐긴다는 것을 알았습니다.문자열 배열 first, second가 주어집니다. 화이트씨의 i번째 친구가 흥미 있는 화제는 first[i]와 second[i]입니다. 즐거운 파티가 되려면 화이트씨가 초대할 수 있는 친구는 최대 몇 명인지 리턴하세요[클래스와 함수 정의]class : InterestingPartymethod : public int bestInvitation(String[] first, String[] second)[제약조건]* first : 1~50개의 요소를 갖는 배열이다.* second : first와 같은 크기의 배열이다.* first, second 공통 : 각 요소는 1~15개의 문자이며, 각 문자는 영어 소문자이고, i번째 요소 first[i]와 second[i]의 내용은 다르다.[입력데이터와 출력 데이터]//0.String[] first = {\"fishing\", \"gardening\", \"swimming\", \"fishing\"};String[] second = {\"hunting\", \"fishing\", \"fishing\", \"biting\"};//1.String[] first = new String[]{\"variety\", \"diversity\", \"loquacity\", \"courtesy\"};String[] second = new String[]{\"talking\", \"speaking\", \"discussion\", \"meeting\"};//2.String[] first = new String[]{\"snakes\", \"programming\", \"cobra\", \"monty\"};String[] second = new String[]{\"python\", \"python\", \"anaconda\", \"python\"};//3.String[] first = new String[]{\"t\", \"o\", \"p\", \"c\", \"o\", \"d\", \"e\", \"r\", \"s\", \"i\", \"n\", \"g\", \"l\", \"e\", \"r\", \"o\", \"u\", \"n\", \"d\", \"m\", \"a\", \"t\", \"c\", \"h\", \"f\", \"o\", \"u\", \"r\", \"n\", \"i\"};String[] second = new String[]{\"n\", \"e\", \"f\", \"o\", \"u\", \"r\", \"j\", \"a\", \"n\", \"u\", \"a\", \"r\", \"y\", \"t\", \"w\", \"e\", \"n\", \"t\", \"y\", \"t\", \"w\", \"o\", \"s\", \"a\", \"t\", \"u\", \"r\", \"d\", \"a\", \"y\"};나의 답public class InterestingParty { public int bestInvitation(String[] first, String[] second){ //두 배열을 하나로 합친 배열을 만든다 String[] result = new String[first.length + second.length]; System.arraycopy(first, 0, result, 0, first.length); System.arraycopy(second, 0, result, first.length, second.length); //배열에서 중복되는 값에 대해 그룹핑하여 카운트를 value로 담은 map을 반환한다. Map&lt;String, Long&gt; map = Arrays.stream(result).collect(Collectors.groupingBy(f -&gt; f, Collectors.counting())); //map의 value중 가장 큰 값을 추출한다. return Collections.max(map.values()).intValue(); }}import ex2.InterestingParty;import java.util.Arrays;public class Main { public static void main(String[] args) { //1. String[] first = {\"fishing\", \"gardening\", \"swimming\", \"fishing\"}; String[] second = {\"hunting\", \"fishing\", \"fishing\", \"biting\"}; //2. first = new String[]{\"variety\", \"diversity\", \"loquacity\", \"courtesy\"}; second = new String[]{\"talking\", \"speaking\", \"discussion\", \"meeting\"}; //3. first = new String[]{\"snakes\", \"programming\", \"cobra\", \"monty\"}; second = new String[]{\"python\", \"python\", \"anaconda\", \"python\"}; //4. first = new String[]{\"t\", \"o\", \"p\", \"c\", \"o\", \"d\", \"e\", \"r\", \"s\", \"i\", \"n\", \"g\", \"l\", \"e\", \"r\", \"o\", \"u\", \"n\", \"d\", \"m\", \"a\", \"t\", \"c\", \"h\", \"f\", \"o\", \"u\", \"r\", \"n\", \"i\"}; second = new String[]{\"n\", \"e\", \"f\", \"o\", \"u\", \"r\", \"j\", \"a\", \"n\", \"u\", \"a\", \"r\", \"y\", \"t\", \"w\", \"e\", \"n\", \"t\", \"y\", \"t\", \"w\", \"o\", \"s\", \"a\", \"t\", \"u\", \"r\", \"d\", \"a\", \"y\"}; InterestingParty interestingParty = new InterestingParty(); System.out.println(interestingParty.bestInvitation(first,second)); }}문제 해설위 문제는 모든 주제에 대해 몇 명의 사람이 관심을 갖고 있는지 확인하고 최댓값을 리턴한다. 화재를 순서대로 선택한다. 해당 화제에 몇 명이 흥미가 있는지 조사한다.public class InterestingParty { public int bestInvitation(String[] first, String[] second){ int i, j; int ans = 0; for(i = 0; i &lt; first.length; i++) { int f = 0; int s = 0; for(j = 0; j &lt; first.length; j++) { if(first[i].equals(first[j])) f++; if(first[i].equals(second[j])) f++; if(second[i].equals(first[j])) s++; if(second[i].equals(second[j])) s++; } ans = Math.max(f, ans); ans = Math.max(s, ans); } return ans; }}응용기술 - 불필요한 반복문 삭제public class InterestingParty { public int bestInvitation(String[] first, String[] second){ HashMap&lt;String, Integer&gt; dic = new HashMap&lt;String, Integer&gt;(); for(int i = 0; i &lt; first.length; i++) { dic.put(first[i], 0); dic.put(second[i], 0); } for(int i = 0; i &lt; first.length; i++) { dic.put(first[i], dic.get(first[i])+1; dic.put(second[i], dic.get(second[i])+1; } int ans = 0; for(String key: dic.keySet()) { ans = Math.max(ans, dic.get(key)); } return ans; }}5-2. 암호TSA는 새로운 암호화 시스템을 개발했습니다. 이 시스템은 암호화하려고 숫자 리스트를 입력받습니다.여러분은 TSA의 비밀 정보 수사원입니다. 암호화 과정에서 중요한 부분을 구현하는 것이 여러분의 일입니다. 여러분은 입력 리스트에서 1개의 값을 선택하고 값을 1 증가시킵니다. 이때 리스트 내부의 모든 숫자 곱이 가장 커져야 합니다.int[] numbers 형태로 숫자 배열 주어질 때 곱의 최댓값을 리턴하세요. 리턴 값이 2⁶²를 넘는 문제는 나오지 않을 것을 보장합니다.[클래스와 함수 정의]class : Cryptographymethod : public long encrypt(int[] numbers)[제약조건]* numbers : 2~50개의 요소가 있는 배열이며 각 요소의 값은 1~1000이다.* 리턴값 : 2⁶²를 넘지 않는다.[입력데이터와 출력 데이터]//0.int[] numbers = {1,2,3}//1.numbers = new int[]{1,3,2,1,1,3}//2.numbers = new int[]{1000, 999, 998, 997, 996, 995}//3.numbers = new int[]{1, 1, 1, 1}나의 답public class Cryptography { public long encrypt(int[] numbers) { //배열을 정렬한다. Arrays.sort(numbers); //가장 작은 값에 1을 더하고, 배열의 모든 요소를 곱한다. long result = numbers[0] + 1; for (int i = 1; i &lt; numbers.length; i++){ result *= numbers[i]; } return result; }}public class Main { public static void main(String[] args) { //0. 결과 12 int[] numbers = {1,2,3}; //1. 결과 36 numbers = new int[]{1,3,2,1,1,3}; //2. 결과 986074810223904000 numbers = new int[]{1000, 999, 998, 997, 996, 995}; //3. 결과 2 numbers = new int[]{1, 1, 1, 1}; Cryptography cryptography = new Cryptography(); System.out.println(cryptography.encrypt(numbers)); }}문제 해설 +1 하는 숫자를 정한다. 모든 곱을 계산하고 최댓값을 선택한다.public class Cryptography { public long encrypt(int[] numbers) { long ans = 0; for(int i = 0; i &lt; numbers.length; i++) { long temp = 1; for(int j = 0; j &lt; numbers.length; j++) { if(i == j) temp *= (numbers[j] + 1); else temp *= numbers[j]; } ans = Math.max(ans, temp); } return ans; }}응용 기술이번 문제는 가장 작은 숫자에 +1 하면 된다. 최솟값은 정렬을 사용하여 간단히 구할 수 있다.public class Cryptography { public long encrypt(int[] numbers) { long ret = 1; Arrays.sort(numbers); numbers[0]++; for(int i = 0; i &lt; numbers.length; i++) { ret *= numbers[i]; } return ret; }}" }, { "title": "04. 시뮬레이션", "url": "/posts/04.%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/", "categories": "BOOK, TopCoder알고리즘 트레이닝", "tags": "algorithm", "date": "2022-08-07 21:10:10 +0900", "snippet": "시뮬레이션은 프로그래밍 대회에서 가장 쉬운 문제이며 초기 상태와 어떤 작업을 수행할지 제공하고 최종 결과가 어떻게 될지 답하는 문제이다. 이런 문제는 무엇을 해야할 지 문제에 모두 쓰여있다.4-1. 키위 주스타로는 맛있는 키위 주스를 준비했습니다. 타로는 0부터 N-1이라는 이름을 붙인 N개의 병에 키위주스를 넣었습니다. 이때 i번째의 병의 용량은 capacities[i] 리터이며 타로가 i번째 병에 넣은 키위 주스의 양을 bottles[i] 리터라고 합니다.타로는 병에 키위 주스를 재분배하려고 하며, 0부터 M-1까지 M회 조작합니다. i번째의 조작은 타로가 병 fromId[i]부터 병 toId[i]에 키위 주스를 넣는 것을 의미합니다.병 fromId[i]가 비어있거나 병 toId[i]가 꽉 차 있는 순간, 타로는 더이상 키위 주스를 넣지 않습니다.N개의 요소를 가진 정수 배열 int[]를 리턴해주세요. 배열의 i번째 요소는 모든 주스를 쏟는 작업이 완료되고 i번째 병에 남아 있는 키위 주스의 양입니다.[클래스와 함수 정의]Class : KiwiJuiceEasymethod : public int[] thePouring(int[] capacities, int[] bottles, int[] fromId, int[] toId)[제약조건]* capacities : 2~50개의 요소가 있는 배열이고, 각 요소는 1~1000000 사이의 값을 갖는다.* bottles : capacities와 같은 수의 요소가 있는 배열이고 bottles[i]는 capacities[i]에 들어있는 주스를 의미한다.* fromId : 1~50개의 요소가 있는 배열이다.* toId : fromId와 같은 수의 요소가 있는 배열이다.변수 fromId와 toId는 0~(N-1) 사이의 값이다. 이때 N은 변수 capacities의 항목 개수이다. fromId[i]와 toId[i]는 서로 다른 값을 갖는다.나의 답package ex1;public class KiwiJuiceEasy { public int[] thePouring(int[] capacities, int[] bottles, int[] fromId, int[] toId){ for (int i = 0; i &lt; fromId.length; i++) { //키위 주스를 옮긴다 bottles[toId[i]] += bottles[fromId[i]]; //옮긴 주스가 병의 용량보다 많다면 용량만큼 담는다. if(bottles[toId[i]] &gt; capacities[toId[i]]) { bottles[fromId[i]] = bottles[toId[i]] - capacities[toId[i]]; bottles[toId[i]] = capacities[toId[i]]; }else { bottles[fromId[i]] = 0; } } return bottles; }}import ex1.KiwiJuiceEasy;import java.util.Arrays;public class Main { public static void main(String[] args) { //0. 결과 [0, 13] int[] capacities = {20, 20}; int[] bottles = {5, 8}; int[] fromId = {0}; int[] toId = {1}; //1. 결과 [3, 10] capacities = new int[]{10,10}; bottles = new int[]{5, 8}; fromId = new int[]{0}; toId = new int[]{1}; //2. 결과 [10, 10, 0] capacities = new int[]{30, 20,10}; bottles = new int[]{10, 5, 5}; fromId = new int[]{0, 1, 2}; toId = new int[]{1, 2, 0}; //3. 결과 [0, 14, 65, 35, 25, 35] capacities = new int[]{14, 35, 86, 58, 25, 62}; bottles = new int[]{6, 34, 27, 38, 9, 60}; fromId = new int[]{1,2,4,5,3,3,1,0}; toId = new int[]{0,1,2,4,2,5,3,1}; //4. 결과 [0, 156956, 900000, 856956] capacities = new int[]{700000, 800000, 900000, 1000000}; bottles = new int[]{478478, 478478, 478478, 478478}; fromId = new int[]{2,3,2,0,1}; toId = new int[]{0,1,1,3,2}; KiwiJuiceEasy kiwiJuiceEasy = new KiwiJuiceEasy(); int[] returns = kiwiJuiceEasy.thePouring(capacities, bottles, fromId, toId); System.out.println(Arrays.toString(returns)); }}문제 해설예시 0, 1을 보면 주스를 옮기는 작업은 두 가지로 구분된다. 주스를 모두 옮겼는데 넘치지 않고 전부 들어간 경우 : 옮길 주스의 양 &lt;= 기존 주스 병의 남은 용량 (모든 주스를 옮길 수 있다.) 주스를 모두 옮겼는데 넘쳐버린 경우 : 옮길 주스의 양 &gt; 기존 주스 병의 남은 용량 (옮길 주스의 양은 기존 주스 병의 남은 용령 만큼이다.)public class KiwiJuiceEasy { public int[] thePouring(int[] capacities, int[] bottles, int[] fromId, int[] toId){ for (int i = 0; i &lt; fromId.length; i++) { int f = fromId[i]; int t = toId[i]; int space = capacities[t] - bottles[t]; //기존 주스병의 남은 용량 //옮길 주스의 양 &lt;= 기존 주스 병의 남은 용량 if(bottles[f] &lt;= space) { int vol = bottles[f]; bottles[t] += vol; bottles[f] = 0; //옮길 주스의 양 &gt; 기존 주스 병의 남은 용량 } else { int vol = space; bottles[t] += vol; bottles[f] -= vol; } } return bottles; }}응용기술 1 - 조건문을 조금만 사용하기if문 대신 min, Math.min 등의 최솟값 함수를 사용하여 코드를 간단히 한다.public class KiwiJuiceEasy { public int[] thePouring(int[] capacities, int[] bottles, int[] fromId, int[] toId){ for (int i = 0; i &lt; fromId.length; i++) { int f = fromId[i]; int t = toId[i]; //옮길 주스의 양과 기존 주스 병의 남은 용량 중 적은 값을 가져온다. int vol = Math.min(bottles[f], capacities[t] - bottles[t]); bottles[f] -= vol; bottles[t] += vol; } return bottles; }}응용기술 2필자는 이동량을 무시하고 옮길 주스와 기존 주스의 양의 총합이 일정하다는 것과 옮길 주스는 주스 총량과 기존 주스 병의 용량 중에 작은 값이 된다는 것을 이용하기로 했다. 기존 주스 : 옮길 주스와 기존 주스의 총합, 기존 주스 병의 용량 중 작은 값 옮길 주스 : 옮길 주스와 기존 주스의 총합에서 위의 값을 제외한 값public class KiwiJuiceEasy { public int[] thePouring(int[] capacities, int[] bottles, int[] fromId, int[] toId){ for (int i = 0; i &lt; fromId.length; i++) { //옮길 주스와 기존 주스의 총합 int sum = bottles[fromId[i]] + bottles[toId[i]]; //옮길 주스와 기존 주스의 총합, 기존 주스 병의 용량 중 작은 값 bottles[toId[i]] = Math.min(sum, capacities[toId[i]]); //옮길 주스와 기존 주스의 총합에서 위의 값을 제외한 값 bottles[fromId[i]] = sum - bottles[toId[i]]; } return bottles; }}정리 문제를 이해했다면 손으로 계산하라 코딩이 오래 걸린다면 다시 한 번 손으로 생각하라 조건문은 되도록 조금 사용하라" }, { "title": "03. 기본 프로그래밍 지식", "url": "/posts/03.%EA%B8%B0%EB%B3%B8%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%A7%80%EC%8B%9D/", "categories": "BOOK, TopCoder알고리즘 트레이닝", "tags": "algorithm", "date": "2022-08-07 20:48:32 +0900", "snippet": "3-1. 반드시 필요한 프로그래밍 지식 if-else for 배열/* 문제 : int 형의 매개변수 a, b가 주어질 때 a+b를 리턴하세요 class : AplusBProblem method : public int calc(int a, int b)*/public class AplusBProblem { public int calc(int a, int b) { return a + b; }}3-2. 추가적인 프로그래밍 지식 정렬 : import java.util.*; Arrays.sort(array); 문자열 처리```javaString s = “abc”;//동일 판정if(s.equals(“abc”)) System.out.println(“equals”);//문자 하나 추출char c = s.charAt(1); //’b’//문자열 연결s = “def” + s + “ghi”; //defabcghi//문자열 자르기s = s.substring(3,3); //”abc”* 연관 배열```javaimport java.util.*;void countStrings(String[] s) { Map&lt;String, Integer&gt; hm = new HashMap&lt;String, Integer&gt;(); for(int i = 0; i &lt; s.length; i++) { if(!hm.containsKey(s[i])) hm.put(s[i], 0); hm.put(s[i], hm.get(s[i]) + 1); } for(String key : hm.keySet() { System.out.println(key + \" \" + hm.get(key)); }}*" }, { "title": "8장 성능 향상을 위한 인프라 구조", "url": "/posts/8%EC%9E%A5-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9D%B8%ED%94%84%EB%9D%BC-%EA%B5%AC%EC%A1%B0/", "categories": "BOOK, 그림으로 공부하는 IT 인프라 구조", "tags": "infra", "date": "2022-07-20 20:54:45 +0900", "snippet": "8.1 응답과 처리량8.1.1 성능 문제의 두 가지 원인시스템 성능을 가리킬 땐 응답과 처리량이라는 지표가 자주 사용된다. 응답은 처리 하나당 소요시간을 의미하며 처리량은 단위 시간당 처리하는 양을 의미한다.편의점을 예로 들면 계산대가 두 개 있고, 고객이 균등하게 계산대에 줄을 섰을 때, 이때 줄의 끝에 선 후 계산이 끝나기까지 걸리는 시간이 응답시간이고, 계산대에서 한 명당 1분이 걸린다고 하면 계산대가 두 개이기 때문에 1분당 두 명분을 정산할 수 있다. 이것을 처리량이라고 한다.8.1.2 응답 문제응답 문제가 발생하는 위치는 로그나 실제 장비 시험 등을 통해서 구체적으로 어떤 계층에서 응답 지연이 발생하고 있는지 파악해야 한다.8.1.3 처리량 문제대량의 데이터를 교환하고 싶은데 영역이 부족한 경우에 처리량 문제가 발생한다. 물리적으로 데이터를 통과시킬 수 없을 때 처리량 관점의 병목 현상이 발생하게 된다.일반적으로 CPU에서 멀수록 처리량이 낮아진다. 따라서 CPU, 메모리 주변 처리량은 높지만 디스크, 네트워크 통신 대역은 낮아서 병목 현상이 발생하기 쉽다.응답과 처리량은 밀접한 관계가 있다. 응답이 매우 느린 시스템에서는 다수의 사용자 요청이 시스템 내에 누적되므로 전체 처리량도 낮아진다.8.2 병목 현상이란?8.2.1 처리 속도의 제한 요소가 되는 병목 현상인프라 아키텍처 용어로서 병목 현상이란 처리량을 제한하고 있는 요인을 가리킨다. 예를 들어 AP 서버에서 CPU 사용률이 높아져서 처리량이 한계에 다다르고 있다고 할 때 처리량이 포화상태 이기 때문에 AP 서버의 응답 시간도 악화된다.이때 AP 서버가 병목 지점이 된다고 할 수 있다.8.2.2 병목 현상은 어떻게 해결하는가?성능 분석의 시작은 먼저 병목 현상이 발생하고 있는 위치를 정확히 파악하는 것이다.병목 현상 해결방법 병목 위치를 파악해서 어떻게든 해결하는 것이다(튜닝), 튜닝시에는 병목 위치를 작은 단위로 세분화해서 병목 영역을 더 집중적으로 파헤치는 접근법이 유효하다. 시스템 이용자 수를 제한하는 것(유량 제어)8.2.3 병목 지점은 반드시 존재한다.예) AP 서버가 병목 지점이 되어 AP 서버를 추가한 경우 웹 서버는 두 대의 AP 서버에 대해 요청을 균등하게 분산한다. AP 서버의 병목 현상이 해결되고 처리량이 개선되었지만 DB 서버에는 두 대의 AP 서버에서 요청이 날라오면서 새로운 병목 지점이 된다.이처럼 하나의 계층에서 병목 현상이 해결되면 반드시 다른 위치에서 병목 현상이 발생한다. 성능 개선시 반드시 시스템 전체 관점에서 목표를 만드는 것이 중요하다.8.3 3계층형 시스템 그림을 통해 본 병목 현상8.3.1 CPU 병목 현상 예반드시 CPU 사용률이 높다 = 나쁘다가 아니다. CPU 사용률은 처리 효율성을 나타내는 것으로 병목 현상 유무와는 관계가 없다.프로세스가 효율적으로 처리를 진행하다 보면 CPU 사용률이 100%가 될 수 있다. 시스템 관점에서는 비효율적인 상태가 아니라 그 반대다. CPU 사용률이 급증해서 문제가 있는지 없는지를 판단하려면 사용자 관점의 응답 속도나 시스템 전체 처리량을 확인해야 한다.대기 행렬의 병목 현상CPU 사용률이 높고 OS상에서 가동하고 있는 프로세스 수가 많으면 대기 행렬에서 병목 현상이 발생한다. 대기 행렬은 CPU가 순조롭게 처리를 진행하고 있다면 언젠가는 해결된다. 대기 행렬의 병목 현상은 처리량 측면의 문제를 의미한다.시스템에서 CPU를 코어 수가 많은 것으로 변경하거나 서브를 추가해서 병렬 처리하면 처리량이 증가한다. 이 방법들 중 하드웨어의 CPU 코어 수를 늘리거나 수평 분할에 따른 서버 수를 늘리거나 하는 튜닝을 스케일 아웃이라고 부른다.응답의 병목 현상대기 행렬을 튜닝하면 처리량 문제는 해결된다. 하지만 처리량 문제를 해결해도 반드시 응답 문제가 해결되는 것은 아니다. 응답 시간을 개선하는 방법은 다음과 같이 있다. 처리 능력을 향상시킨다 : 스케일업이라고도 한다. CPU에서 클럭 수 단위는 헤르츠로 이것은 1초당 명령 처리 수를 가리킨다. 병렬로 처리한다 : 처리를 분할해서 다수의 CPU 코어에게 동시 처리를 시키는 것이다.CPU 사용률이 오르지 않는다대부분 CPU 사용률이 100%에 도달하는 경우가 거의 없다. 그전에 디스크 I/O나 네트워크 I/O에서 막히는 경우가 많다. 데이터베이스는 I/O가 많아서 상태를 개선할 방법으로 다음이 있다. 처리 다중화 : 처리를 다중화 해서 CPU를 적절하게 활용 I/O 비동기화 : 비동기 I/O를 이용하면 프로세스는 I/O 처리 완료를 기다리지 않고 다음으로 넘어갈 수 있다.8.3.2 메모리 병목 현상 예 영역 부족 동일 영역의 경합영역 부족에 의한 병목 현상프로세스가 가동해서 어떤 처리를 하려면 반드시 전용 메모리 영역이 필요하다. 하지만 서버상의 메모리 영역은 유한하다. 메모리 영역이 부족하지 않도록 OS 커널 측에서 페이징 또는 스와핑이라는 처리를 해서 빈 메모리를 확보하는 구조가 있다.(가상메모리)동일 데이터에 대한 병목 현상디스크 I/O 시간을 단축하기 위해서는 메모리에 캐시로 데이터를 배치해 두는 것도 일례가 될 수 있다. 또 애초에 경합이 발생하지 않도록 복수의 프로세스나 스레드가 같은 메모리 영역을 참조하지 않도록 만들면 된다.8.3.3 디스트 I/O 병목 현상 예I/O가 병목 지점이 될 때는 CPU 수를 늘리거나 클럭 주파수를 높여도 효과가 없다. I/O 효율을 높이든가 I/O를 줄이는 방법을 고민해야 한다. 외부저장소 : SAN, NAS 저장소 등을 사용하는 경우가 많다. 순차 I/O와 랜덤 I/O : 순차는 선두부터 차례로 액세스하는 방식, 랜덤은 헤드가 움직이면서 해당 위치로 바로 건너뛰는 방식이다.8.3.4 네트워크 I/O 병목 현상네트워크를 경유한 I/O는 CPU 버스나 메모리 간 I/O 보다도 응답 시간 오버헤드가 크다.통신 프로세스의 병목 현상하나의 프로세스로 처리하는 경우 높은 처리량을 실현하는 것이 매우 어렵다. 또 통신이 고속화되면 CPU에서 병목 현상이 발생할 수도 있다. 통신에서 대역을 모두 사용하려면 처리를 다중화해서 병렬화할 필요가 있다. 다중화할수록 통신량이 많아지므로 대역폭이 최대치에 가까운 처리량을 실현할 수 있다.네트워크 경로의 병목 현상 328~329p8.3.5 애플리케이션 병목 현상 예330~334p" }, { "title": "7장 무정지를 위한 인프라 구조", "url": "/posts/7%EC%9E%A5-%EB%AC%B4%EC%A0%95%EC%A7%80%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9D%B8%ED%94%84%EB%9D%BC-%EA%B5%AC%EC%A1%B0/", "categories": "BOOK, 그림으로 공부하는 IT 인프라 구조", "tags": "infra", "date": "2022-07-14 01:05:27 +0900", "snippet": "7.1 안정성 및 이중화7.1.1 안정성이란?상용 웹 시스템에서는 미들웨어 기능이나 구조로 이중화, 감시, 백업의 세 가지 수단을 구현해서 목표를 실현하고 있다.7.1.2 이중화란?하나의 기능을 병렬로 여러 개 나열해서 하나의 장애가 발생해도 다른 것을 이용해서 서비스를 계속할 수 있는 것을 가리킨다. H/W 컴포넌트 계층 : 일반적인 서버에서는 CPU와 메모리를 여러 개 가지고 있지만, 어디까지나 처리 성능을 향상시키는 것이 목적이다. 즉 특정 CPU가 실행하고 있던 처리를 해당 CPU가 고장 났다고 다른 CPU로 인계할 수 없다. 시스템 계층 : 여러 서버에서 동일한 처리를 실행하는 서버 이중화 물리적 위치 계층 : 시스템을 서로 다른 위치에서 운영하는 이중화다. 비용이 많이든다.CPU 이중화가 수요가 없는 이유가 CPU에 돈을 들이는 것보다 시스템 이중화가 더 싸고 효과적이기 때문이다.7.2 서버 내 이중화7.2.1 전원, 장치 등의 이중화Rack 뒤쪽 양쪽 끝에는 전원 탭이 붙어 있다. 안정성을 고려할 때 양쪽 전원 탭의 전력 합계를 최대로 사용하는 것이 아니라 한쪽 전원 탭 전력만으로 서버가 가동될 수 있도록 소비 전력 합계를 낮추는 것이다.7.2.2 네트워크 인터페이스 이중화PCI 슬롯에 꽂은 카드도 이중화가 가능하다. 여러개의 카드에 복수의 포트가 탑재되는 구성으로 카드 장애 및 포트 장애에 대응할 수 있다.장애가 발생하면 어떻게 하나?네트워크 인터페이스 이중화는 일반적으로 액티브-스탠바이 구성이다. 스탠바이 측은 보통 서비스를 제공하지 않고 액티브 측에 어떤 문제가 발생하면 스탠바이 장비로 교체돼서 스탠바이가 액티브로 변경된다. 이렇게 교체하는 것을 Failover라고 한다.실제 예로 리눅스 OS의 본딩이라는 구조가 있다. 본딩이 이중화된 인터페이스를 감시하는 방식에는 두 가지가 있다. MII 감시(현재 주류)와 ARP 감시다. MII 감시는 링크업이 동작하고 있다면 정상이라고 판단한다.ARP는 특정 IP 주소로 ARP 요청을 보내서 돌아오는 응답 유무에 따라 정상적인지를 확인하는 방법이다.MII 감시가 선호되는 주된 이유는 불필요한 폴링 패킷이 전송되지 않는다. 폴링 위치로 지정한 IP 주소를 가진 장비에 대해서는 유지관리나 장애를 의식하지 않아도 된다.하지만 ARP 감시로만 인지할 수 있는 장애도 있다. ARP 감시는 요청을 정기적으로 실행해서 응답이 있으면 정상이라 판단한다. ARP 요청은 MAC 주소를 확인하는 브로드캐스트(동일 네트워크 내의 모든 주소에 패킷을 전송하는 것)다.단점으로 폴링되는 ARP 요청이 동일 네트워크 내의 브로드캐스트이기 때문에 불필요한 트래픽이 증가한다는 것이다. 따라서 불필요한 트래픽을 고려해서 감시 빈도를 높게 설정하지 않는 것이 중요하다.ARP 감시에서는 임의의 IP 주소에 대해 ARP 요청을 보낼 수 있고, MII 감시는 인터페이스의 링크 상태를 확인하기 때문에 접속돼 있는 스위치만 감시할 수 있다. 즉 ARP 감시가 더 넓은 범위를 감시한다는 것을 알 수 있다.7.3 저장소 이중화7.3.1 HDD 이중화예전에는 서버 저장소를 FC로 연결하고 SAN이라는 네트워크를 구축하는 방법이 유행했다. 하지만 높은 비용과 변경에 시간이 걸려 잘 사용하지 않았다. 요즘은 TCP/IP 프로토콜 상에 저장소 네트워크를 구축하는 방식이 늘고 있으나 구조가 많이 복잡하다.SAN은 구조가 간단하기 때문에 이를 전제로 한 기술이 다시 개발되고 있다.저장소 내부 구조와 RAIDHDD 자체 이중화는 RAID로 한다. RAID는 여러 HDD를 묶어서 그룹으로 만들고 이것을 논리적인 HDD로 인식하는 기술이다. 논리적 HDD를 LU라고 한다. 서버가 인식하는 HDD는 LU이다.RAID의 장점 안정성 확보 : 데이터 기록을 이중화한다. 성능 향상 : 복수의 HDD에 대해 병렬로 I/O처리를 하기 때문에 I/O 처리 성능이 높아진다. 용량 확장RAID 구성 패턴 RAID5 : 이중화 확보를 위해 패리티라는 오류 수정 부호를 기록한다. 패리티를 하나의 HDD에 집중시키지 않고 분산하는 것이 특징이다. RAID1 : 일반적으로 OS 디스크 이중화에 사용된다. RAID10 : RAID0(이중화 없이 HDD에 기록하는 방식) + RAID1(복수의 HDD에 병렬로 이중 기록을 하는 방식)장애가 발생하면 어떻게 되나?HDD가 고장나면 RAID 구성에 포함된 데이터는 망가지지 않지만 이중화 구조가 망가진다. 이중화 회복을 위해 핫 스페어라는 디스크를 사용한다. 핫 스페어가 고갈되고 HDD까지 파손된 RAID에서는 데이터 손실이 발생하기 때문에 주의가 필요하다.7.3.2 버스 이중화244~245p7.4 웹 서버 이중화7.4.1 웹 서버의 서버 내 이중화대표적인 오픈 소스 웹 서버인 Apache는 요청 접수시 프로세스 또는 스레드를 선택할 수 있다.7.4.2 서버 이중화웹 서버를 이중화하는 방법 중 하나가 DNS를 이용해서 하나의 호스트명에 대해 복수의 IP 주소를 반환하는 것이다. 이러한 기법을 DNS 라운드 로빈이라고 한다.주의사항으로 DNS가 서버 상태를 감시해서 파악하지 않기 때문에 서버가 정지된 경우에도 그 서버의 주소를 반환한다. 또 세션 상태를 파악하지 않기 때문에 다음 접속 시에 동일 서버에 접속해야 하는 경우에도 부적합하다.부하분산 장치를 이용한 웹 서버 이중화DNS 라운드 로빈을 고도화한 이중화 방식이 부하분산 장치 로드 밸런서다. 부하분산 장치가 이전에 어느 웹서버에 요청을 할당했는지 쿠키에 저장하고 있어 이 쿠키를 읽어 같은 서버에 요청을 할당한다. 이를 통해 세션 상태를 저장할 수 있다.세션 상태 저장을 실현하는 기능을 부하분산 장치에서는 Persistence 라고 부른다.[부하분산 장치의 할당 알고리즘] 알고리즘 내용 라운드로빈 서버에 IP 주소에 순서대로 요청을 할당 최소 연결 현재 활성 세션 수보다 세션 수가 가장 적은 서버의 IP주소에 요청을 할당 응답시간 서버의 CPU 사용률이나 응답시간 등을 고려해서 가장 부하가 적은 서버의 IP 주소에 요청을 할당 장애 발생시부하분산 장치는 웹 서버의 가동 상태를 감시할 수 있다. 장애를 감지한 경우는 클라이언트 요청을 동적으로 다른 서버에 할당(페일오버)할 수 있다. 정적 콘텐츠의 경우라면 괜찮지만 동적 콘텐츠라면 페일 오버와 세션 정보가 사라지기 때문에 세션 상태가 초기화 된다.할당 알고리즘 선택시에는 복잡한 알고리즘은 피하자 복잡할수록 데이터가 알고리즘을 통과할 때 높은 부하가 발생한다.7.5 AP 서버 이중화7.5.1 서버 이중화AP 서버 이중화는 두 가지 기능을 이용해서 구현한다. 웹 서버와 같이 부하분산 장치를 이용하거나 AP 서버가 가진 웹 서버 요청 이중화 기능을 이용해서 AP 서버 요청을 분산시키는 것이다. 세션 정보 이중화, 세션 정보란 애플리케이션의 상태를 가리킨다. 애플리케이션 상태를 일시적으로 기억하는 구조라 보면 된다.장애 발생시 쿠키 정보를 가지고 보조 세션 정보에 접속해 세션이 계속 유지되는 것을 알 수 있다.7.5.2 DB 연결 이중화AP 서버에는 DB 서버에 접속 시에 사용할 연결을 사전에 여러 개 생성해 두는 기능이 있다. 이것을 연결 풀링이라고 하며 웹로직의 데이터 소스를 설정해서 이용한다.원래 데이터 소스는 여러 연결을 만들어서 데이터베이스 처리를 병렬로 실행할 수 있게 하는 구조다. 장점은 애플리케이션이 DB 서버의 IP나 포트 등을 몰라도 된다는 점이다. 애플리케이션은 데이터 소스 명만 알면 된다.장애 발생시 최솟값과 최대값을 동일하게 설정한다 : 연결을 생성하거나 제거시 발생하는 오버헤드를 가능한 한 경감시키기 위해서다. 방화벽 유무를 확인해 둔다 : 방화벽이 있다면 오랫동안 사용하지 않은 세션을 자동으로 제거하는 경우가 있기 때문에 방화벽 유무를 확인해 두어야 한다.7.6 DB 서버 이중화7.6.1 서버 이중화(액티브-스탠바이)DB 서버 이중화 방법으로는 액티브-스탠바이 클러스터 구성이 있다. 클러스터 구성은 하드웨어로도 구현이 가능하고 일반적으로는 클러스터 소프트웨어를 이용한다.클러스터 구성은 HA(고가용성) 구성이라고 부르고 클러스터의 노드나 서비스 관계는 마스터-워커 개념을 기반으로 하고 있다. 서버가 정상 동작하는지 확인하기 위한 구조로 하트비트, 투표 장치 같은 기능이 존재한다.장애 발생시 ? 클러스터 소프트웨어는 등록된 서비스가 정상 동작하고 있는지 정기적으로 확인한다. 이상이 발생하면 서비스를 정지하고 대기하고 있던 스탠바이 측 서비스를 시작해서 서비스를 유지시킨다.클러스터 소프트웨어를 이용할 때 주의할 점은 클러스터 소프트웨어도 OS에서 실행되는 소프트웨어이기 때문에 오동작할 가능성이 있다는 것이다. 반드시 중요한 데이터는 백업해 두고, 이중 안전 장치가 필요한 경우는 원격 복제 기능 등을 이용하도록 한다.7.6.2 서버 이중화(액티브-액티브)DB 서버의 데이터 참조, 갱신 부분은 시스템의 병목 지점이 되기 쉬워서 항상 높은 확장성이 요구된다.Shared Nothing형은 대량의 데이터를 검색하는 경우 유리하고, 확장이나 갱신의 경우에는 좋지 않다. 가용성 면에서는 Shared Everything형이 어떤 노드에서건 같은 데이터에 액세스할 수 있기 때문에 유리하다.클라우드상에 구현할 때는 쉐어드 낫씽형이 압도적으로 많다.캐시 전송Shared Everything형의 중요 구조인 캐시 전송를 살펴보자 Oracle Real Appilcation Clusters(RAC) 예를 보면 RAC는 캐시의 데이터를 네트워크 경유로 받아서 디스크 액세스를 줄이고 데이터 취득을 고속화하고 있다. 이것을 RAC에서는 캐시 퓨전이라고 부른다.캐시 퓨전은 디스크 액세스보다 빠르지만 같은 블록이 몇 번이고 네트워크를 통해 교환되는 경우에 응답 속도가 저하된다는 점을 주의해야 한다. 이것을 블록 경합이라고 한다.Shared Nothing형의 데이터 보호 기능을 보면 데이터 분산 배치로 인해 장애 발생시 데이터 손실 가능서이 있어 이를 방지하기 위한 기능으로 오라클의 MySQL 클러스터가 있다. 데이터 보호는 데이터 노드 간 복제 기능에 의해 구현된다.7.7 네트워크 장비 이중화7.7.1 L2 스위치 이중화서버를 서로 연결하는 장치를 스위치라 한다. L2 스위치 이중화를 살펴보면, 스위치를 크로스 케이블 등으로 연결하면 서로 다른 스위치 간 통신이 가능하다. 이것을 ‘Casecade’라고 한다.위 그림처럼 트렁크 포트를 사용하면 포트를 복수의 VLAN에 소속시킬 수 있다.트렁크 포트 이용 시에 필요한 대책 268p7.7.2 L3 스위치 이중화L3 스위치 이중화는 기본적으로 액티브-스탠바이다. 웹 시스템에서는 게이트웨이가 다운되면 시스템 서비스가 거의 모두 정지된다. 따라서 L3 스위치 이중화가 매우 중요하다.7.7.3 네트워크 토폴로지네트워크에서 중요한 것은 특정 시점에 출발지부터 목적지까지 경로가 하나가 되는 것이다. 경로가 다수 존재하면 안정성 측면에서 좋지 않다. 이것을 해결하기 위한 수단으로 Spanning Tree Protocol (STP)를 이용할 수 있다.STP를 이용하면 논리적으로 포트를 절단할 수 있다. 장애가 밣생하면 STP에 의해 재계산이 이루어지고 논리적으로 절단돼 있는 포트를 개통해서 통신이 가능해진다.네트워크 구성의 대표적인 패턴7.8 사이트 이중화7.8.1 사이트 내 이중화 전체 구성도7.8.2 사이트 간 이중화DNS가 반환하는 IP주소를 동적으로 변경하여 사이트 장애에 대비할 수 있다. 원격지에 데이터 전송시 중요한 것은 동기/비동기 여부다. 데이터를 완전히 지키고 싶을 때는 데이터가 원격지에도 기록될 필요가 있기 때문에 동기화 시킨다. 하지만 동기화시 오버헤드가 많이 걸려 응답속도가 느려진다.비동기는 응답은 좋지만 데이터를 완전히 지킬 수 없다.7.9 감시7.9.1 감시란?감시는 시스템 컴포넌트가 정상 동작하는지 확인하는 기능이다. 감시에서 중요한 것은 어떤 목적으로 감시 기능이 필요한지, 특정 컴포넌트에 감시가 너무 중복돼 있지 않은지 등을 고려하는 것이다.7.9.2 생존 감시ping 명령을 정기적으로 실행해서 서버 인터페이스에 대한 통신을 확인하는 감시로 구현이 매우 쉽다. ping 감시는 가능한 모든 장비에 설정할 것을 권장한다.프로세스 감시는 OS의 ps 명령을 이용해서 확인한다. 실행 중인 프로세스 모두 감시하는 것이 아니라 중요한 것만 추려서 감시하는 것이 좋다.7.9.3 로그 감시로그 파일에는 시스템 유지를 위한 중요 정보가 포함돼 있다. 미들웨어 오류나 영역 고갈 등 생존 감시로는 알 수 없는 정보가 로그 파일로 출력된다. 또 장애 원인 분석에도 도움이 된다.7.9.4 성능 감시성능 감시는 위 두 감시보다 감시 내용이 복잡하다. 디스크 사용률이나 메모리 사용 현황, 디스크 고갈 등의 리소스 상태 파악과 네트워크 액세스 지연, 디스크 액세스 시간 등의 응답 상태를 파악하는 것이다.df 명령 등의 OS 명령을 정기적으로 실행하거나 vmstat 명령이나 sar 명령 등의 통계 정보를 취득해서 상황을 통계적으로 판단하는 등 다양한 방식이 가능하다.7.9.5 SNMPSNMP를 이용해서 감시할 수 있는 주요 내용은 다음과 같다. 네트워크 장비나 서버 가동 상태 서비스 가동 상태 시스템 리소스 네트워크 트래픽SNMP는 네트워크 장비와 서버를 일괄 감시해서 관리할 수 있는 것이 특징이다.감시 경로에는 매니저가 정기적으로 질의하는 폴링, 이상 발생시 에이전트가 통지하는 트랩 등 두 가지가 있다. 주요 특징으로는 MIB(관리 정보 기반)이라는 것이 있다. 에이전트는 MIB에 규정된 정보를 수집해서 매니저에게 통지한다.MIB는 데이터베이스 형태와 비슷하다. MIB는 트리 구조로 만들어져 있다.SNMP는 감시에 특화된 프로토콜이다. 주의점은 SNMP 트랩은 원칙적으로 재전송하지 않으며, 장애로 트랩을 수신하지 못한 경우에는 그 트랩을 잃어버린다. 따라서 모든 통지를 수신해야 한다면 메일을 사용할 수 있다.7.9.6 콘텐츠 감시콘텐츠 감시는 부하분산 장치가 담당한다. 감시대상 URL을 등록하고 HTTP의 GET 요청을 해서 정상적으로 응답이 있으면 해당 웹 서버 또는 웹 서버 + AP 서버가 정상 가동되고 있다고 판단한다.7.10 백업7.10.1 백업이란?백업이 이중화와 다른 점은 데이터를 복제해서 별도 장소에 보관한다는 것이다. 그래서 복원, 복구를 이용해 데이터를 원래 장소로 되돌리는 과정이 필요하다.복구지표 RTO : 복구 목표 시간 - 복구에 어느 정도 시간이 걸리나? RPO : 복구 기준 시점 - 어느 시점으로 복구할 것인가?RTO가 짧을수록 설계 난이도가 높고 백업 시스템 가격도 비싸진다.시스템에서 백업해야하는 대상은 두 가지다 ‘시스템 백업’, ‘데이터 백업’7.10.2 시스템 백업시스템 백업은 OS나 미들웨어 등 일반 서버 로컬 디스트 영역을 백업하는 것이다. OS나 미들웨어는 한번 설치해서 설정이 끝난 후에는 많은 변경이 발생하지 않는다.주로 시스템 백업은 다음과 같은 시점에 실시한다. 초기 구축 후 일괄 처리 적용시 대규모 구성 변경시시스템 백업 취득시 유의점은 서버의 서비스를 정지할 필요가 있다는 것이다. 가동중인 서비스는 백업할 수 없다.7.10.3 데이터 백업시스템 백업과 달리 데이터 백업은 매일 변경되는 데이터가 손실되지 않도록 하는 것으로 취득 빈도가 높다. 따라서 서비스가 가동중인 상태라도 백업이 가능한 구조가 필요하다. 이런 시스템일수록 확실하게 데이터 일치성을 보장해야한다." }, { "title": "6장 시스템을 연결하는 네트워크 구조", "url": "/posts/6%EC%9E%A5-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EC%97%B0%EA%B2%B0%ED%95%98%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B5%AC%EC%A1%B0/", "categories": "BOOK, 그림으로 공부하는 IT 인프라 구조", "tags": "infra", "date": "2022-07-11 22:28:31 +0900", "snippet": "6.1 네트워크 구조서로 다른 장비 간 데이터를 교환할 때 기본적으로는 네트워크를 경유해서 데이터를 송수신할 필요가 있다. 실제 네트워크 구조를 구체적으로 도식화하는 것은 어려울 것이다. 그 이유중 하나로 현재 네트워크 자체가 그 구조를 알지 못해도 사용할 수 있도록 돼 있기 때문이다.네트워크에서 발생하는 데이터 처리나 교환에는 다양한 구조가 존재한다. 대부분 TCP/IP 구조를 사용하고 있다.6.2 계층 구조6.2.1 회사를 계층 구조에 비유예) 회사 외부로 편지를 보낼 때 영업부는 A사에 영업 자료를 인사부는 채용 모집 안내서를 보내려 할 때 각 부서는 문서를 총무부에 의뢰하고 총무부는 우편실에 의뢰한다. 그리고 우편실은 편지를 우체통에 넣고 편지 전달을 완료한다.6.2.2 계층 구조는 역할 분담계층 구조에서는 계층 간 역할이 나누어진다. 역할이 나누어져 있기 때문에 각 층은 자신이 담당하는 일만 책임을 지며 다른 일은 다른 계층이 책임을 진다. 또 계층 구조로 나눔으로써 계층 간 서로 영향을 주지 않고 독립적으로 동작할 수 있다.단점으로는 작업 효율을 희생해야 한다는 점을 들 수 있다.6.2.3 계층 모델의 대표적인 예 - OSI 7계층OSI는 통신 규격을 만들 때 고안된 것으로 통신기능을 7계층으로 나눈 것이다. 현재는 사용되지 않고 있고 이 계층 구조의 개념이 다양한 분야에서 공통적으로 참조할 수 있는 참조 모델로서 현재도 사용되고 있다.6.2.4 계층 구조는 네트워크 외에도 존재서버 한 대의 내부를 살펴봐도 계층 구조, OS, 애플리케이션 하드웨어 조합도 계층 구조라고 할 수 있다.6.3 프로토콜프로토콜은 컴퓨터 용어로는 컴퓨터가 서로 소통하기 위해 정한 규약을 가리킨다.6.3.1 사람끼리의 의사소통도 프로토콜사람끼리도 대화에 사용하는 언어가 일치하지 않으면 의미가 통하지 않는다. 또 대화할 때 소리를 사용하는 경우가 많은데 이것은 음성이라는 통신 프로토콜 위에 한국어라는 통신 프로토콜을 올려 놓은 것과 같다.의미를 전달하는 부분인 언어 프로토콜이 일치한다고 해도 그것을 전달하는 프로토콜이 다르면 통신이 불가능하다.6.3.2 컴퓨터에서는 프로토콜이 필수 불가결브라우저로 웹 페이지를 볼 때 HTTP라고 불리는 프로토콜을 사용해서 서버에게 웹 페이지를 달라고 요청한다. 이 통신은 전기 신호나 전파를 이용해서 전달된다. 즉 프로토콜은 같은 계층 간의 약속이라고 할 수 있다.컴퓨터도 만들어진 제조사가 다르면 서로 대화하는 언어를 일치 시켜야 통신이 가능하다. 때문에 네트워크 업계에서는 공통 프로토콜 선정을 위한 IEEE, IETF 같은 표준화 단체가 존재한다.6.3.3 프로토콜은 서버 내부에도 존재어떤 장비라도 서로 통신하기 위해서는 프로토콜이 필요하다. 예) 마우스를 PC에 연결할 때 사용하는 USB가 있다. 이것도 USB 프로토콜이 존재한다. 또 저장소도 마찬가지다. 저장소에서 데이터를 꺼낼때도 프로토콜이 정해져 있다.그리고 CPU 안에도 프로토콜이 존재한다.6.4 TCP/IP를 이용하고 있는 현재의 네트워크인터넷을 포함해 현재 네트워크를 지탱하는 것은 TCP/IP 및 관련 프로토콜이다. 이들 프로토콜 집합을 모아서 TCP/IP 프로토콜 스위트라고 한다.6.4.1 인터넷의 발전과 TCP/IP 프로토콜6.4.2 TCP/IP 계층 구조TCP/IP에서는 반드시 7계층으로 분명하게 나누어지는 것은 아니다. TCP/IP 4계층 모델 등으로도 불린다.TCP/IP 4계층 모델과 시스템 대응관계TCP/IP 각 계층의 명칭실제 계층을 숫자로 부를때는 OSI 참조 모델의 7계층 방식으로 부르는 경우가 많다. 링크계층, 레이어2 또는 L2 IP계층을 레이어3 또는 L3 등등으로 부른다.6.5 [레이어7] 애플리케이션 계층의 프로토콜 HTTP6.5.1 HTTP의 처리 흐름애플리케이션이 사용하는 프로토콜을 모두 애플리케이션 계층 프로토콜이라 부른다. 통신 자체는 모두 OS, 즉 TCP/IP에 맡긴다.6.5.2 요청과 응답의 구체적인 내용요청시 중요한 것은 서버에 던지는 명령이다. 예) GET은 파일 요구, POST는 데이터 전송, 헤더 부분에는 다양한 부가 정보가 들어가며 세밀한 제어를 위해 사용한다.응답은 요청에 대한 결과와 그에 대한 상태 정보를 가지고 있다. 메시지 바디에 실제 데이터를 저장한다.HTTP는 명령을 보내거나 통신 제어를 하지는 않는다. 그래서 매우 간단한 구조라는 것으 알 수 있다.6.5.3 애플리케이션 프로토콜은 사용자 공간을 처리애플리케이션은 소켓을 사용하여 통신을 한다. 따라서 애플리케이션 자체가 통신구조를 갖고 있지 않고도 통신할 수 있다.6.5.4 소켓 이하는 커널 공간에서 처리애플리케이션 프로세스가 네트워크 통신을 하는 경우, 커널에 통신 의뢰를 한다. 의뢰 방법은 시스템 콜, 이때 접속 대상 서버의 IP주소와, TCP 포트의 정보가 필요하다.의뢰를 받은 커널은 소켓을 만들어 주고 위의 정보를 시스템 콜 경유로 커널에 전달되면 접속 대상 서버와의 연결이 생성된다.6.6 [레이어4] 전송 계층 프로토콜 TCP6.6.1 TCP의 역할TCP의 역할은 애플리케이션이 보낸 데이터를 그 형태 그대로 상대방에게 확실하게 전달하는 것이다.TCP가 담당하는 것은 어디까지나 서버가 송신할 때와 서버가 수신한 후 애플리케이션에게 전달할 때로 상대 서버까지 전송하는 부분은 하위 계층인 IP에 모두 위임한다. IP 만으로도 통신할 수 있지만 IP에는 데이터가 상대방에게 확실히 전달됐는지 확인하는 기능이나 도착한 순서를 확인하는 기능 등이 없다.[주요기능] 포트 번호를 이용해서 데이터 전송 연결 생성 데이터 보증과 재전송 제어 흐름 제어와 폭주 제어6.6.2 커널 공간의 TCP 처리 흐름6.6.3 포트 번호를 이용한 데이터 전송TCP에서는 포트 번호를 사용해서 어떤 애플리케이션에 데이터를 전달할지 판단한다. 포트번호는 0~65535까지의 숫자를 사용한다.6.6.4 연결 생성6.6.5 데이터 보증과 재전송 제어데이터 손실을 방지하는 구조 : 수신 측에 TCP 세그먼트가 도착하면 수신 측은 송신 측에게 도착했다는 것을 알린다. 이때 반환하는 것을 ACK라고 한다. 송신측은 ACK가 돌아오는 것을 보고 전송한 세그먼트가 무사히 도착했다는 것을 알 수 있다.데이터 순서를 보증하는 구조 : TCP 세그먼트에 시퀀스 번호라고 하는 숫자를 붙여수 구현한다. 수신 측은 이 시퀀스 번호를 사용해서 원래 순서대로 데이터를 조립한다.TCP 재전송 제어 : 순차적 조합을 위해 수신 측은 ACK를 반환할 때 다음에 필요한 TCP 세그먼트의 시퀀스 번호도 ACK 번호로 전달한다. ACK가 오지 않으면 재전송 한다고 했다 기준은 1.일정 기간내에 돌아오지 않은 경우 2.한번 받은 ACK 번호와 같은 것이 3회 중복돼서 도착한 경우(중복ACK)6.6.6 흐름 제어와 폭주 제어흐름제어 : 동기로 통신을 하면 효율이 나쁘지 않기 때문에 ACK를 기다리지 않고 전송하는 것이 좋다. ACK 번호가 돌아오기 전에 이미 시퀀스 번호를 전송한다. TCP는 어느 정도의 세그먼트 수라면 ACK를 기다리지 않고 전송하는 윈도우라는 개념을 가지고 있다.윈도우에는 수신 윈도우, 폭주 윈도우가 있다. 수신측이 폭주 윈도우 크기를 조정해서 폭주 윈도우와 수신 윈도우 중 작은 쪽을 송신 윈도우로 채택하며 이 범위 내에서는 ACK를 기다리지 않고 전송한다.폭주제어 : 송신측 윈도우 크기는 네트워크 폭주 상태에 맞추어 변경시킨다.6.7 [레이어3] 네트워크 계층의 프로토콜 IP6.7.1 IP의 역할IP의 역할은 지정한 대상 서버까지 전달받은 데이터를 전해 주는 것이라 할 수 있다. 단 IP에서는 반드시 전달된다고 보장하지 않는다.주요 기능 IP 주소를 이용해서 최종 목적지에 데이터 전송 라우팅6.7.2 커널 공간의 IP 처리 흐름**헤더는 기본적으로 20바이트이다.6.7.3 IP 주소를 이용한 최종 목적지로의 데이터 전송IP에서는 최종 목적지 서버까지 복수의 네트워크를 경유해서 데이터를 전송한다. 이때 이용되는 것이 대상 서버를 나타내는 IP 주소다.IP 주소는 32비트로 표현된 숫자 집합이다. 사람이 읽기 쉽도록 8비트 단위로 마침표를 찍어서 표현한다. IP 주소는 네트워크부(어떤 네트워크인지)와 호스트부(네트워크내에 있는 컴퓨터)로 나뉜다.IP 주소에서 어디까지가 네트워크부인지 표시하기 위해서 ‘/24’와 같은 CIDR표기를 사용한다. 또는 서브넷 마스크 255.255.255.0과 같이 표현하기도 한다. 같은 네트워크 내 컴퓨터의 IP 주소는 네트워크부를 동일 값으로 설정해야 한다.IP주소 중 호스트부의 비트가 모두 0인 것을 네트워크 주소, 모두 1인 것을 브로드캐스트 주소라고 한다. 이것은 호스트에 할당해서는 안 되는 특별한 IP 주소다. 참고로 브로드캐스트 주소로 보낸 패킷은 같은 네트워크의 모든 호스트에 전달된다.6.7.4 사설 네트워크와 IP 주소IP 주소란 목적지를 식별하기 위한 것이다. 가정이나 회사에서 사용하는 네트워크 즉 사설 네트워크에서도 사용할 수 있는 주소도 RFC 1918에서 정하고 있다. 10.0.0.0/8 (10.0.0.0 ~ 10.255.255.255) 172.16.0.0/12 (172.16.0.0 ~ 172.31.255.255) 192.168.0.0/16 (192.168.0.0 ~ 192.168.255.255)사설 주소의 반대 개념으로 인터넷상에서 통신이 가능한 IP 주소를 공공 IP 주소라고 한다. 사설 주소는 자유롭게 사용가능 하지만 인터넷상의 호스트등과 통신이 불가능하다. 따라서 공공 주소와 사설 주소가 모두 할당된 호스트를 준비해야 한다.6.7.5 라우팅IP에서 최종 목적지로 데이터를 전송할 때 목적지까지 도착할 때까지 목적지를 알고 있는 라우터에 전송을 부탁한다. IP 패킷을 받은 라우터는 헤더에서 목적지를 확인해 어디로 보내야할 지를 확인한다. 이때 사용하는 것이 라우팅 테이블이라는 것이다.외부와 접속하는 네트워크는 보통 기본 게이트웨이라는 라우터가 설치돼 있다.또 IP 헤더에는 TTL이라는 생존 시간 정보를 가지고 있다. 예) TTL=64 로 시작하면 라우터를 하나 경유할 때마다 라우터가 IP 헤더 TTL을 1씩 줄여서 전송한다. 따라서 계속 전송하면 TTL이 줄어서 언젠가 0이되고 이 시점에 패킷 생존 시간이 끝나 파기한다.이처럼 TTL을 이용해서 패킷이 좀비가 되어 배회하는 것을 방지할 수 있다.6.8 [레이어2] 데이터 링크 계층의 프로토콜 이더넷IP 패킷이 만들어지면 계속해서 링크 계층의 처리가 시작된다. 링크 계층에서 사용되는 대표적인 프로토콜은 이더넷이다.6.8.1 이더넷의 역할동일 네트워크 내의 네트워크 장비까지 전달받은 데이터를 운반한다. 이더넷은 케이블 통신에서 사용되기 때문에 전기 신호로 전송된다.이더넷은 동일 네트워크 내, 즉 자신이 포함된 링크 내에서만 데이터를 전송할 수 있다. 이때 사용되는 주소가 MAC 주소다.6.8.2 커널 공간의 이더넷 처리 흐름IP 계층에서 라우팅 테이블을 확인하기 때문에 어떤 링크가 패킷을 보낼지는 정해져 있다. 최종적인 통신 상태가 동일 네트워크 내에 있으면 해당 서버에 직접 전송하지만 다른 네트워크에 있으면 기본 게이트웨이에 패킷을 보내야 한다.MAC 주소라 불리는 링크 계층 주소를 사용해서 첫 번째 목적지로 보낸다.215~218p6.8.3 동일 네트워크 내의 데이터 전송MAC 주소는 네트워크 통신을 하는 하드웨어에 할당된 주소로 48비트로 표현하고 보통 16진수로 표기한다.이더넷 프레임이 L2 스위치에 도착하면 프레임을 받은 L2 스위치는 MAC 주소를 보면서 적절한 포트에서 프레임을 꺼낸다. 하지만 다른 네트워크를 거치는 경우 MAC 주소를 사용한 통신이 불가능하다.6.8.4 VLANVLAN은 물리 구성에 의존하지 않고 가상적인 네트워크를 나누는 구조다.219~221p6.9 TCP/IP를 이용한 통신 이후6.9.1 네트워크 스위치 중계처리221~222p6.9.2 최종 목적지의 수신 확인223~224p" }, { "title": "5장 인프라를 지탱하는 응용 이론", "url": "/posts/5%EC%9E%A5-%EC%9D%B8%ED%94%84%EB%9D%BC%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EC%9D%91%EC%9A%A9-%EC%9D%B4%EB%A1%A0/", "categories": "BOOK, 그림으로 공부하는 IT 인프라 구조", "tags": "infra", "date": "2022-07-08 23:04:59 +0900", "snippet": "5.1 캐시5.1.1 캐시란?캐시(cache)는 숨기는 장소 라는 의미를 가지고 있다. 컴퓨터 세계에서 캐시는 사용 빈도가 높은 데이터를 고속으로 액세스할 수 있는 위치에 두는 것을 의미한다.CPU의 1차캐시나 2차캐시, 저장소 캐시, OS 페이지 캐시, 데이터베이스 버퍼 캐시 등 광범위하게 캐시 기술이 사용되고 있다.[특징] 일부 데이터를 데이터 출력 위치와 가까운 지점에 일시적으로 저장한다. 데이터 재사용을 전제로 한다.5.1.2 어디에 사용되나?브라우저 캐시는 웹 브라우저가 접속한 페이지를 캐시하는 것이다. 이를 통해 웹 서버 접속을 줄이고 브라우저 표시를 고속화할 수 있다.또 웹 서버와 클라이언트 사이에 캐시 서버를 배치하는 방법이 있다. 요즘에는 CDN에 웹 콘텐츠 캐시를 배치하는 구조를 이용하기도 한다.5.2.3 정리캐시의 주요 장점 데이터에 고속으로 액세스할 수 있다. 실제 데이터에 대한 액세스 부하를 줄일 수 있다.주의할 점으로는 캐시는 고속으로 액세스할 수 있지만 데이터를 잃을 위험이 있어서 캐시 데이터가 손실돼도 괜찮은 경우에 주로 사용한다.케시가 적합한 시스템은 1.참조 빈도가 높은 데이터 2.캐시의 데이터가 손실돼도 문제가 없는 시스템캐시가 부적합한 시스템은 1.데이터 갱신 빈도가 높은 시스템, 2.대량의 데이터에 액세스하는 시스템5.2 끼어들기5.2.1 끼어들기란?어떤 원인으로 인해 지금 하고 있는 일을 중단하고 급히 다른 일을 하는 것을 끼어들기라고 한다. 방해한다라는 뉘앙스가 들 수 있지만 급한 일을 먼저 하도록 CPU에 알리는 중요한 역할을 한다.예) PC에서 애플리케이션이 처리를 하고 있는 동안에도 키보드를 누르면 문자가 입력된다., 사람의 경우 문서작업 도중 고객이 전화를 한 경우 문서작업을 일단 중지하고 전화를 받아 고객 문의를 처리한다.5.2.2 자세히 보자CPU에서 애플리케이션 프로세스나 스레드 처리를 하고 있더라도 키보드로 정보가 입력되면 끼어들기가 발생해서 CPU가 짧은 순간 다른 처리를 한 후 다시 원래 처리를 진행한다.끼어들기에는 다양한 종류가 있다. 정기적으로 해야 할 일을 알려 주는 타이머 끼어들기, 데이터를 메모리에 모두 읽었다는 것을 CPU에게 알려 주는 끼어들기, 현재 동작중인 프로그램에 중대한 에러가 발생했을 때 급하게 프로그램 프로세스를 정지시키는 예외 처리 등이 있다.5.2.3 어디에 사용되나?브라우저가 웹 사이트에 접속하면 서버의 NIC에 이더넷 프레임이 도착하고, NIC를 통해 CPU에 끼어들기가 발생한다. 입출력 장치가 CPU에게 통지하는 끼어들기를 하드웨어 끼어들기라고 한다.프로세스나 스레드가 허가되지 않은 메모리 위치에 액세스하려고 하면 조각화(Segmentation) 위반이라 불리는 예외가 발생해서 OS에 의해 프로세스가 강제 종료된다. 이것도 끼어들기의 일종으로 예외나 소프트웨어 끼어들기 등으로 불린다.5.2.4 정리끼어들기는 어떤 일이 발생하면 연락하는 이벤트 주도 구조다. CPU가 정기적으로 Polling을 해서 입출력 장치 상태를 확인하는 방법도 있지만 간격이 길면 디스크 I/O가 완료되도 금방 알아차리지 못하고, 반대로 간격을 짧게 하면 CPU를 쓸데 없이 많이 사용하게 된다.따라서 폴링보다 끼어들기를 이용해 제어하는 것이 효율적이다.5.3 폴링5.3.1 폴링이란?폴링은 정기적으로 질의하는 것을 가리킨다. 정기적으로 질의함으로써 상대가 어떤 상태인지, 어떤 요구를 가지고 있는지 등을 알 수 있다.[특징] 질의 방향이 단방향이다. 질의는 일정 간격을 따라 정기적으로 발생한다.[주요 장점] 반복만 하면 되기 때문에 프로그래밍이 쉽다. 상대가 응답하는지 확인할 수 있다. 모아서 일괄적으로 처리할 수 있다.반대되는 구조로 이벤트 주도 또는 끼어들기가 있다.5.3.2 어디에 사용되나?웹 로직 서버의 내부 감시기능으로 MBean이라는 자바 객체를 이용해 구현되어 있다. 미리 생성된 연결이 정상인지를 웹로직이 정기적으로 감시한다.또 다른 예로 NTP(시간동기) 처리다. 정기적으로 실시해서 자신의 시간이 맞는지를 확인하는 구조다.5.3.3 정리적철한 처리 1.일정 간격으로 처리를 실행하면 좋은 처리로 일련의 처리를 할 때 전처리와 후처리가 연계되지 않는 경우에 적합, 2.감시부적합한 처리 1.상태가 아닌 입력 내용에 따라 실행 내용을 변경하는 처리, 2.처리 우선순위를 정해야 하는 처리5.4 I/O 크기5.4.1 I/O크기란?I/O 크기는 1회의 I/O에 필요한 사이즈, 즉 데이터를 주고 받을 때 사용되는 I/O의 크기를 의미한다. I/O 크기는 인프라 설계나 성능 튜닝에 있어 중요한 개념이다.[특징] 물건을 운반할 때는 상자에 넣으면 효율적으로 관리할 수 있다. 운반하는 양에 따라 상자 크기를 선택하면 효율적으로 운반할 수 있다.5.4.2 어디에 사용되나?오라클 DB 예오라클 DB가 데이터 파일을 읽기/쓰기하는 최소 단위를 데이터 블록이라고 한다. 블록 크기가 8KB이면 1바이트의 데이터를 읽는 경우에도 8KB를 읽는다. 따라서 I/O 크기가 작을 때는 블록 크기를 작게, I/O 크기가 크면 블록 크기를 크게 해야 I/O 효율이 좋아진다.오라클에서 파일 시스템 블록 크기가 7KB이고 오라클 DB의 블록 크기가 8KB라고 가정하면, 오라클 DB가 1블록(8KB)을 읽으면 디스크에서 14KB를 읽어서 그중 6KB는 사용하지 않는다. 반대로 DB 블록 크기보다 파일 시스템 블록 크기가 큰 경우도 마찬가지이다.네트워크 예145~147p5.4.3 정리큰 상자는 대량의 데이터를 빠르게 운반할 수 있고, 작은 상자는 소량의 데이터를 빠르게 운반할 수 있다.5.5 저널링5.5.1 저널링이란?저널은 트랜잭션이나 매일 갱신되는 데이터의 변경 이력을 가리킨다. 그리고 저널을 남겨두는 것을 저널링이라고 한다.[특징] 데이터 자체가 아닌 처리(트랜잭션) 내용을 기록한다. 데이터 일관성이나 일치성이 확보되면 필요 없어진다. 데이터 복구 시 롤백, 롤포워드에 이용된다.5.5.2 어디에 사용되나?리눅스의 ext3 파일 시스템ext3 파일 시스템은 저널링 기능을 갖추고 있고, 파일 I/O도 트랜잭션으로 간주된다.오라클 DB오라클 DB의 저널은 REDO 로그라 불린다. 트랜잭션 종료시에 버퍼가 디스크에 기록되지만 기록중인 REDO 로그가 파손된 경우에는 데이터를 최신 상태로 복원할 수 없다.5.5.3 정리 시스템 장애 시 복구가 빠르다 데이터 복제보다도 적은 리소스를 소비해서 데이터를 보호할 수 있다.적합한 시스템 1.데이터 갱신이 발생하는 시스템부적합한 시스템 1.데이터 안전성보다 성능을 요구하는 시스템저널은 사용한 복구 방법으로 롤백: 저널을 읽어서 실제 데이터 정보를 과거로 되돌리는 처리, 롤 포워드: 저널을 읽어서 실제 데이터 정보를 앞으로 진행시키는 처리이다. 이 처리는 트랜잭션 단위로 실행된다.주의점으로 저널 데이터는 메모히의 버퍼에 일단 저장되어 디스크에 기록되지 않은 경우 장애 발생시 잃을 수 있다. 또 트랜잭션 단위로 일치성을 보증하기 때문에 트랜잭션 도중에 장애가 발생하면 종료되지 않은 트랜잭션은 파괴된다.5.6 복제5.6.1 복제란?복제는 DB나 저장소 등에서 자주 사용되는 기술이다. 대규모 웹 서비스에서는 대량의 사용자 접속에 대비해서 동일 데이터를 여러 서버에 복제해서 부하분산을 하기도 한다.[특징] 장애 시 데이터 손실을 예방할 수 있다. 복제를 이용한 부하 분산이 가능하다.[장점] 사용자가 데이터에 액세스할 때 복제한 것이라는 것을 의식할 필요가 없다. 복제 데이터를 캐시처럼 사용할 수 있다.5.6.2 어디에 사용되나? 저장소 복제 : 블록 단위로 증감 데이터만 복제 위치에 반영해서 데이터 전송량을 줄인다. MySQL 복제 : 데이터 추가, 갱신, 삭제 등의 변경 처리를 복제 측으로 보낸다. 복제를 통해 데이터의 최종 복사본이 다른 곳에 생성되며, 이 복사본을 캐시처럼 사용할 수도 있다.5.6.3 정리적합한 시스템 데이터 손실을 허용하지 않고 장애시 복구 속도가 빨라야 하는 시스템 데이터 참조와 갱신 부분이 나뉘어져 있으며 참조가 많은 시스템부적합한 시스템 데이터 갱신이 많은 시스템5.7 마스터-워커5.7.1 마스터-워커란?마스터-워커는 주종 관계를 가리킨다. 이 구조에서는 한 명이 관리자가 돼서 다른 모든 것을 제어하게 된다. 반대로 상호 관리라는 의미에서 피어 투 피어 관계도 성립한다.유한한 리소스를 관리할 때는 어떤 한 사람이 관리하는 것이 효율적이다. 같은 리소스를 여러 사람이 분담해서 관리할 때는 ‘누가’, ‘어디까지’ 감시하고 있는가에 대한 정보를 알 필요가 있다.[특징] 마스터-워커는 상호 접속 관계의 일종으로, 한 사람이 관리자가 돼서 모든 것을 제어한다. 마스터-워커의 반대가 피어 투 피어다.5.7.2 어디에 사용되나?오라클 Real Application Clusters오라클 RAC의 마스터-워커 구성을 살펴보면 RAC에서는 여러 대의 물리 서버가 클러스터 구성으로 연결돼 있다. 특정 서버가 마스터가 되는 것이 아니라 모두가 대등한 관계라서 특정 서버가 다운돼도 데이터베이스 전체 가용성에는 영향을 주지 않는다.5.7.3 정리장점 관리자가 한 명이기 때문에 구현이 쉽다. 워커 간 처리를 동기화할 필요가 없기 때문에 통신량이 줄어든다.단점 마스터가 없어지면 관리를 할 수 없다. 마스터의 부하가 높아진다.5.8 압축5.8.1 압축이란?디지털 데이터는 압축을 할 수 있다. 압축 기술은 이미지 파일이나 음악 파일, 그리고 대부분의 통신 기술 등 거의 모든 곳에 사용되고 있다. 이불 정리를 할때 공기로 인해 부피가 커져 불편하다. 수납 시에 이런 낭비된 공간을 제거함으로써 이불을 압축할 수 있다.그리고 디지털 데이터도 이런 쓸데 없는 공간을 줄이기 위해 압축을 사용하고 있다.5.8.2 자세히 보자디지털 데이터 압축의 기본은 중복 패턴 인식과 그것을 변경하는 것이다. zip 파일로 압축시 어떤 파일은 크기가 작아지지만 어떤 파일은 그대로인 것을 볼 수 있다. 이것은 같은 패턴이 어느 정도 있느냐에 따라 압축률이 달라지기 때문이다.같은 패턴이 많을수록 압축률이 높아진다. 압축의 장점은 데이터 크기를 줄이는 것이고, 단점은 처리 시간이 걸린다는 것이다.가역 압축과 비가역 압축원래 상태로 복구할 수 있는 가역 압축, 원래 상태로 복구할 수 없는 대신 압축률을 높이는 방식인 비가역 압축이 있다. 가역 압축은 이미 알고 있는 정보를 제거하는 압축 방식이고, 비가역 압축은 자신에게 필요 없는 정보를 제거 즉 최소 필요 정보만 남겨두는 압축 방식이다.5.8.3 어디에 사용되나?zip파일, 자바의 jar, war 등등5.9 오류 검출5.9.1 오류 검출이란?컴퓨터 세계에서는 다양한 곳에서 데이터 교환이 발생한다. 그러다 의도치 않은 때에 데이터가 망가질 수도 있다. 이것을 방지하기 위해 오류 검출이라 불리는 구조가 있다.5.9.2 자세히 보자 통신 중에 데이터 파손 : 경로 도중에 낙뢰로 전기적인 잡음 등이 발생하면 데이터가 파손될 수 있다. 칩에서의 데이터 파손5.9.3 오류를 검출하려면몇 가지 방법이 있는데 간단한 방법으로 패리티 비트라는 이중화 비트를 부여하는 패리티 체크 방식이 있다.5.9.4 어디에 사용되나?서버용 메모리에는 오류 수정 기능이 있는 ECC 메모리라는 것이 있다. 네트워크 통시에서는 프로토콜에 따라 각 계층의 오류 검출용 구조를 갖추고 있다.5.9.5 정리오류 검출이란 데이터의 파손 여부를 확인하는 기법으로 파손된 경우에는 데이터를 다시 읽어 재처리할 수 있다. 또 검출과 동시에 파손된 데이터를 복구하는 기법도 있다." }, { "title": "4장 인프라를 지탱하는 기본 이론", "url": "/posts/4%EC%9E%A5-%EC%9D%B8%ED%94%84%EB%9D%BC%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EA%B8%B0%EB%B3%B8-%EC%9D%B4%EB%A1%A0/", "categories": "BOOK, 그림으로 공부하는 IT 인프라 구조", "tags": "infra", "date": "2022-07-05 23:36:39 +0900", "snippet": "4.1 직렬/병렬4.1.1 직렬 병렬이란?대규모 웹 서비스는 방대한 수의 사용자 요청을 처리해야 하므로 수많은 서버를 배치해서 병렬로 처리하고 있음을 알 수 있다. 주변에 병렬로 처리하는 경우가 많지만 무조건 병렬로 처리한다고 해서 성능이 향상되는 것은 아니다.예) 여러 개의 물건이 일직선으로 나열돼 있는 것을 직렬, 두 줄 이상으로 나열돼 있는 것을 병렬이라고 한다.위 그림에서 3차선 도로가 도중에 합류해서 1차선이 되고, 다시 3차선으로 분기하고 있다. 합류점부터 시작되는 1차산 구간은 혼잡해지기 쉽고 사고가 발생하기 쉽다. 1차선 구간은 전체 흐름을 느리게 만드는 병목 지점 이 된다.이러한 혼잡상황을 해결하는 방법으로는 1차선 구간을 3차선으로 만드는 것이다. 이것은 컴퓨터 세계에서도 마찬가지이다.특정기간 내에 하나의 CPU로 처리할 수 있는 양에는 한계가 있지만 여러 개의 CPU를 배치하면 처리량을 늘릴 수 있다. 단 다수의 CPU를 이용할 수 있는 처리여야 한다는 전제 조건이 있다. 분담해서 병렬화할 수 없는 처리는 CPU 코어를 아무리 늘려도 효과가 없다.병렬 처리에서는 합류점, 직렬화 구간, 분기점이 병목지점이 되기 싶다. 병렬 처리를 할 때는 가능한 한 병렬화해서 직렬 부분을 줄이고 어쩔 수 없이 직렬화해야 하는 경우에는 효율성을 높이는 것이 중요하다. 또 병렬화에서는 분담해서 일을 진행한 것을 다시 한 곳에 모으는 데 오버헤드가 걸린다. 무리해서 병렬화하면 직렬 처리에 의해 속도가 느려질 수 있다.4.1.2 어디에 사용되나?웹 서버와 AP 서버에서의 병렬화웹 서버에서는 다수의 이용자가 접속하기 때문에 복수의 프로세스가 분담해서 병렬 처리를 하고 있다. AP 서버에서는 JVM 프로세스가 하나이지만 복수의 스레드가 병렬로 처리하고 있다. Apach HTTP Server에서는 멀티 프로세스 모델 외에도 멀티 프로세스와 멀티 스레드를 모두 이용하는 하이브리드형도 있다.아파치는 1프로세스 1스레드, JVM은 1프로세스 4 스레드이지만 하나의 CPU 코어를 동시에 사용할 수 있는 것은 1스레드다.예) 하나의 CPU 코어 밖에 없는 서버에서는 아파치 프로세스를 아무리 늘려도 동시에 실행할 수 있는 것은 1프로세스뿐이다. 프로세스나 스레드 수를 조정할 때는 CPU 코어 수도 함께 고려해야 한다DB 서버에서의 병렬화오라클 DB에서는 클라이언트 요청을 접수하는 서버 프로세스가 클라이언트 접속 수만큼 생성된다. 서버 프로세스에는 공유 서버형이라 불리는 하이브리드형도 있어서 멀티 프로세스, 멀티 스레드를 모두 사용할 수 있다.또 데이터 파일 생성 시 병목 현상이 발생하는 경우 메모리에 캐시된 갱신 완료 데이터를 HDD에 기록하는 DBWR 프로세스 수를 늘려서 병렬화할 수도 있다. 그 외에도 비동기 I/O를 사용해서 OS 측에서 쓰기 처리를 병렬화하는 방법도 있다.4.1.3 정리   직렬 병렬 장점 구조가 간단, 설계 구현 난이도가 낮음 복수의 리소스를 유용하게 이용가능, 동일 시간당 처리할 수 있는 양 증가 단점 복수의 리소스를 유용하게 이용할 수 없음 오버헤드 발생, 구조가 복잡해서 설계 구현 난이도 증가 [병렬화시 주의점] 직렬 처리 성능은 향상되지 않지만 단위 시간당 처리량을 늘릴 수 있다. 합류점, 직렬화 구간, 분기점이 병목 지점이 되기 쉽다. 병렬화가 유효한 부분을 파악해서 병렬화하지 않으면 효과가 없다. 오버헤드, 구조 복잡성 등의 단점을 고려하고 단점 이상의 효과를 얻을 수 있는 경우 병렬화한다.4.2 동기/비동기4.2.1 동기/비동기란?누군가에게 일을 부탁하고 그 일이 끝나기까지 잠자코 기다리는 것이 동기, 끝나면 말해 라고 말해두고 다른 일을 하는 것이 비동기다.[특징] 동기는 일이 끝날 때까지 아무것도 하지 않고 기다리기 때문에 그 사이에 다른 일을 할 수 없다. 하지만 일이 끝났는지 여부를 확실하게 확인할 수 있다. 비동기는 끝날 때까지 기다리지 않기 때문에 병렬로 다른 일을 할 수 있다. 하지만 일이 끝났는지 여부 확인은 별도의 방법을 이용해야 한다.4.2.2 어디에 사용되나?Ajax를 사용하면 비동기 통신을 이용한 병렬 처리가 가능하다. Ajax를 사용한 웹 페이지에서는 비동기 통신이 가능해져서 화면을 보거나 입력하면서 필요한 부분만 갱신할 수 있게 됐다.예) 구글에 검색어를 일부 입력하면 검색어 후보가 표시된다 -&gt; 구글 검색 엔진 서버에 전송해서 키워드 후보 데이터를 얻어 브라우저에 표시DBMS에서 사용되는 비동기 I/O : DBMS는 HDD 등의 저장소에 비동기로 쓰기 처리를 할 수 있다. 이것을 비동기 I/O라고 한다. 공유 메모리에 있는 다수의 데이터를 프로세스가 HDD에 기록하는 경우, 비동기 I/O라면 하나의 I/O가 끝나기까지 기다리지 않고 다음 I/O를 발행할 수 있기 때문에 저장소 성능을 충분히 활용할 수 있다.DBMS에서 비동기로 처리하면 쓰기가 끝났는지 확인하지 않고 다음 처리를 진행해서 위험하지 않는지 걱정할 수 있다. DBMS에서는 비동기로 I/O를 요구한 후에 I/O가 끝났는지 여부를 확인하고 있다.4.2.3 정리비동기의 본질은 병렬이다. 비동기를 사용시 주의할 점은 처리가 끝나지 않은 상태에서 다른 처리를 진행해도 문제가 없는가, 처리가 끝났는지 확인할 필요가 있는가를 고려해야한다.4.3 큐4.3.1 큐란?Queue는 우리말로 대기 행렬이라 표현할 수 있다. 컴퓨터 세계에서는 여러 곳에 행렬이 존재하고, 하드웨어, OS, 데이터베이스, 애플리케이션 등 거의 모든 곳에서 이 구조가 사용되고 있어 설계나 성능 튜닝 시에 빠질 수 없는 지식이라 할 수 있다.그리고 큐는 FIFO 구조로 먼저 들어온 요청이 차례대로 처리된다.4.3.2 어디에 사용되나? CPU 처리를 기다리고 있는 프로세스나 스레드 행렬 하드 디스크 등의 저장소 읽기 처리를 기다리고 있는 I/O 요구 행렬 네트워크 접속 성립을 기다리고 있는 접속 요구 행렬컴퓨터에서 CPU를 기다리고 있는 프로세스 행렬을 Run Queue라고 한다. 참고로 CPU에서 처리 중인 프로세스를 런큐로 인식할지는 OS 종류에 따라 달라진다.데이터베이스의 디스크 I/O프로세스나 스레드가 사용하는 대상이 HDD라는 점이 CPU와 다르다.오라클 DB의 동작을 보면 두 개의 서버 프로세스와 DBWR 프로세스는 왼쪽 HDD에 I/O를 실시하고 있고, LGWR 프로세스는 오른쪽 HDD에 I/O를 실시하고 있다. 전자는 왼쪽 HDD 데이터에 액세스하고, 후자는 오른쪽 HDD에 액세스 한다.HDD는 데이터가 기록돼 있는 특정 위치에 액세스해야 하기 때문에 CPU처럼 비어 있다는 이유로 다른 것을 사용할 수 없다. 이 점이 HDD와 CPU의 차이점이다.4.3.3 정리큐의 특징은 선두에서부터 순서대로 처리된다는 점이다. 여러 처리가 동시에 진행되는 경우에 이 큐가 자주 사용되며 다양한 계층의 여러 부분에서 이 큐가 이용되고 있다.CPU나 저장소와 같이 복수의 처리가 동시에 진행되는 부분에서는 큐를 많이 이용하기 때문에 성능 문제가 발생하기 쉽다. 성능 문제가 발생하면 큐의 길이(행렬의 길이)를 확인하는 것이 중요하다.4.4 배타적 제어4.4.1 배타적 제어란?배타적 제어는 다른 것을 배제하는 제어다. 여러 사람이 공유하는 물건일 경우 누군가가 그 물건을 사용하고 있으면 다른 사람은 그것을 사용할 수 없다. 컴퓨터 세계에서는 직렬 처리에서는 배타적 제어가 필요 없지만 병렬 처리에서는 필요하다. 배타적 제어를 하는 부분은 병목 현상이 발생하기 쉽다.예) 회의를 하고 있을 때 회의실 안내문을 ‘사용중’ 이라고 해 두어 다른 사람이 사용할 수 없다는 것을 알린다. 반대로 회의가 끝나면 안내문을 ‘공실’로 바꿔서 다른 사람이 이용할 수 있게 한다. 이것이 바로 배타적 제어다.일반적으로 OS나 DBMS는 병렬 처리를 위해 배타적 제어를 사용한다. 그리고 병렬 처리 관련 성능 문제에 배타적 제어가 영향을 주는 경우가 꽤 있다. 병렬 처리시 서로 관계없는 동작시에는 필요없지만 대부분 공유 데이터를 이용하고 부분적으로 직렬 처리를 사용해야 하는 경우에 배타적 제어가 필요하다. 복수 처리가 공유 자원에 동시에 액세스하면 불일치가 발생할 수 있어 배타적 제어로 보호해 주어야 한다. 배타적 제어에서는 특정 처리가 공유 자원을 이용하고 있는 동안 다른 처리가 이용할 수 없게 해서 불일치가 발생하지 않도록 한다.4.4.2 어디에 사용되나?DBMS에 사용되는 배타적 제어오라클 DB에서는 여러 프로세스가 동시에 병행으로 처리를 하고 있지만, 특정 프로세스가 공유 데이터를 변경하고 있는 도중 다른 프로세스가 해당 공유 데이터를 읽거나 동시에 변경하지 못하도록 배타적 제어를 하고 있다.배타적 제어에는 짧은 시간 동안만 락을 유지하는 래치라는 것이 있어 CPU에서 의미가 없는 처리를 하면서 대기하는 방식이 있다.(스핀락), 또 장시간 락을 유지하도록 큐를 이용해서 관리하는 방식인 슬립락이라는 것도 있다.OS 커널에 사용되는 배타적 제어리눅스 커널은 빅 커널락(BKL)이라 불리는 하나의 스핀락으로 유지된다. BKL이 이용되는 부분에서는 처리가 직렬화돼서 동시에 하나의 CPU만 커널 코드를 실행할 수 있다. 따라서 이 부분이 병목 지점이 되기 쉽다. 컴퓨터가 여러 CPU를 활용해서 병렬 실행 가능한 처리를 늘리기 위해 리눅스 커널에서는 BKL로 보호된 커널 코드를 수정했다.4.4.3 정리[배타적 제어의 장단점]   배타적 제어를 사용하는 경우 배타적 제어를 사용하지 않는 경우 장점 공유 데이터의 일관성을 유지할 수 있다 병렬로 빠르게 처리할 수 있다 단점 병렬 처리가 안 된다 데이터 불일치가 발생할 가능성이 있다 4.5 상태 저장/상태 비저장4.5.1 상태 저장/상태 비저장이란?정보를 많이 가지고 있는 상태 저장은 세분화된 제어가 가능한 반면에 구조가 복잡하다. 반면 상태 비저장은 고기능은 아니지만 간단하다.4.5.2 자세히 살펴보자상태 저장은 부여된 정보에 따라 상태가 전이된다. 이점은 과거 정보를 가져올 수 있어서 정보에 따른 복잡한 처리를할 수 있다는 것이다. 단점은 약간이나마 시스템 복잡성이 커진다.상태 비저장의 장점은 구조가 간단하다는 것이다. 이런 구조 때문에 성능이나 안정성을 쉽게 향상시킬 수 있다. 단점으로는 복잡한 처리가 어렵다는 점이 있다.4.5.3 어디에 사용되나?컴퓨터 내부구조컴퓨터 내에서는 거의 모든 것에 상태 저장이 사용되고 있다.네트워크 통신구조HTTP는 기본적으로 상태 비저장 프로토콜이다. 따라서 매번 같은 데이터를 반환한다. 그래서 HTTP에서는 세션이라는 개념을 사용해서 상태유지 구조를 구현하고 있다.4.6 가변길이/고정길이4.6.1 가변길이/고정길이란?데이터를 저장할 때 해당 데이터를 담을 상자의 크기가 정해져 있는지 여부가 매우 중요하다. 이때 미리 크기가 정해져 있는 경우를 고정 길이, 정해져 있지 않은 경우를 가변 길이라고 한다. 가변 길이는 공간을 유용하게 활용할 수 있지만 성능 면에서는 불안정하다. 또 원하는 데이터를 찾으려면 고정 길이에 비해 많은 시간이 걸린다. 고정 길이는 쓸데없는 공간이 생기지만 성능 면에서는 안정적이다. 또 크기가 정해져 있어 원하는 것에 쉽게 액세스할 수 있다.4.6.2 어디에 사용되나?윈도우즈에는 일반적으로 NTFS라 불리는 파일 시스템이 사용되고 있는데 이 파일 시스템에서는 각종 파일을 고정 길이로 저장하고 있다.예) memo.txt 는 크기 12byte, 디스크 할당 크기 4096byte 라고 표시된다. 이것은 실제로 12byte 데이터이지만 저장시에는 4096byte를 사용하고 있다는 것을 의미한다.네트워크는 데이터를 교환할 때 일반적인 이더넷은 1500byte로 TCP/IP 헤더 합계가 40byte이기 때문에 MSS는 1460byte가 된다. 그래서 TCP/IP로 데이터를 전송시 1460byte 정도의 세그먼트로 분할하고, 마지막 남은 것은 1~1460byte 크기로 전송된다.4.6.3 정리가변 길이는 데이터 크기를 매번 변경하기 때문에 데이터 전체 양이 줄어든다는 장점이 있으며, 고정 길이는 모두 같은 크기를 이용해서 처리한다. 크기가 균일하기 때문에 관리가 수월하다는 장점이 있다.4.7 데이터 구조(배열과 연결 리스트)4.7.1 데이터 구조(배열과 연결 리스트)란?배열과 연결 리스트는 모두 데이터를 순차적으로 처리하는 구조이지만 구조가 다르기 때문에 성능 측면의 특징도 많이 다르다.[특징] 배열은 데이터를 빈틈없이 순서대로 나열한 데이터 구조 연결 리스트는 데이터를 선으로 연결한 데이터 구조 탐색이 빠른 것은 배열이고, 느린 것은 연결 리스트 데이터 추가, 삭제가 빠른 것은 연결 리스트, 느린 것은 배열4.7.2 어디에 사용되나?해시 테이블 구현에는 배열과 연결 리스트가 사용되고 있다. 데이터 추가, 삭제가 빠른 연결 리스트와 탐색이 빠른 배열을 조합한 하이브리드형 데이터 구조가 해시 테이블이다.예) 오라클 DB에서 SQL을 실행하면 SQL을 Parse한 후 실행해서 결과를 반환하지만 한번 실행된 SQL 관련 정보는 메모리에 저장된다. 그리고 똑같은 SQL이 실행되는 경우 처음부터 파스하는 것이 아니라 이전 실행 시의 정보를 재사용한다.이렇게 SQL 관련 정보를 관리할 때 사용하는 것이 해시 테이블 구조다. 파스한 SQL을 재사용함으로써 CPU 사용 시간을 절약할 수 있다.처음 실행된 SQL은 파스를 거쳐 실행된 후에도 메모리에 남는다. 똑같은 SQL이 실행되면 메모리에 있는 것이 재사용된다. 그리고 메모리가 부족하면 실행되고 있지 않은 SQL을 해제한다.4.7.3 정리   배열 연결리스트 장점 N번째 요소 탐색이 빠르다 데이터 추가, 삭제가 빠르다 단점 데이터 추가, 삭제가 느리다 N번째 요소 탐색이 느리다 해시 테이블은 배열과 연결 리스트의 상호 장점만 조합해서 약점을 보완한 데이터 구조라고 할 수 있다. 이외에도 Queue, Stack 등의 데이터 구조도 배열이나 연결 리스트로 구현돼 있다.4.8 탐색 알고리즘(해시/트리 등)4.8.1 탐색 알고리즘(해시/트리 등)이란?책이나 사전에서 무언가를 찾을 때 원하는 키워드를 알고 있으면 색인을 찾거나 특정 주제에 대해 읽고 싶다면 차례를 찾거나 할 것이다. 만약 차례나 색인이 없다면 특정 페이지를 찾기 위해 모든 페이지를 열어봐야 하기 때문에 엄청난 노력이 필요하다.컴퓨터에서도 데이터를 찾기 쉽도록 정리해 두면 원하는 데이터를 빨리 찾을 수 있다. 데이터 정리 방법을 ‘데이터 구조’, 찾는 방법을 ‘탐색 알고리즘’이라고 한다.4.8.2 어디에 사용되나?DBMS에서 SQL 튜닝시에 full scan으로 되어 있어 느린데 인덱스를 생성해서 index scan을 하니깐 빨라졌다는 이야기를 들어봤을 것이다.인덱스가 없는 경우SQL을 발행해서 한 건의 데이터를 취득하는 경우라도 인덱스가 없으면 디스크에서 테이블 데이터를 모두 읽어서 조사해야 한다.(full scan)인덱스가 있는 경우인덱스가 있으면 최소한의 필요 블록만 읽으면 된다. 인덱스가 있다고 무조건 좋은 것은 아니다. 검색이 빨라지는 대신 데이터의 추가, 갱신, 삭제 시에 테이블뿐만 아니라 인덱스 데이터도 갱신해야 한다.인덱스의 구조 - B 트리 인덱스DBMS의 풀 스캔은 색인을 보지 않고 책을 처음부터 읽어가는 것과 같다. 인덱스 스캔을 통한 모든 데이터 취득은 책을 처음부터 읽지만 색인을 보면서 읽어나가는 것이다.B 트리 인덱스가 DBMS에서 자주 사용되는 것은 트리 구조 계층이 깊어지지 않도록 디스크 I/O를 최소한으로 제어하기 때문이다.해시 테이블해시 테이블은 등포 검색에 큰 강점을 보인다. 해시 테이블은 키와 값 조합으로 표를 구성한 데이터 구성이다. 키는 해시 함수를 통해 해시 값으로 변환된다. 해시 값은 고정 길이 데이터라 조합 표의 데이터 구조가 간단해서 검색이 빠르다는 장점이 있다.그리고 아무리 데이터 양이 많아진다고 해도 기본적인 등호 검색의 속도는 변하지 않는다. 하지만 범위 검색이 약하다는 문제가 있다.4.8.3 정리등호 검색에 강한 해시 테이블을 사용한 탐색, 등호 검색과 범위 검색에도 강한 만능형 B 트리등이 있다.full scan 처럼 100건의 데이터가 있을 때 100건 모두 보는 것을 선형 탐색이라고 한다.또 HDD 같은 2차 기록 장치의 데이터 탐색에 적합한 B트리와 메모리의 데이터 탐색에 적합한 T트리 등이 있어 데이터 저장 장치에 따라서 데이터 구조도 달라진다." }, { "title": "3장 3계층형 시스템을 살펴보자", "url": "/posts/3%EC%9E%A5-3%EA%B3%84%EC%B8%B5%ED%98%95-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EC%82%B4%ED%8E%B4%EB%B3%B4%EC%9E%90/", "categories": "BOOK, 그림으로 공부하는 IT 인프라 구조", "tags": "infra", "date": "2022-07-03 21:24:39 +0900", "snippet": "3.1 3계층형 시스템의 구성도가장 아래에 서버가 배열되어 있고 서버끼리는 스위치를 경유해 연결되어 있다. 각각의 서버 안에는 CPU, 메모리, 디스크 등의 하드웨어 부품이 나열돼 있다. 그리고 그림에서 논리 구성에 해당하는 부분은 OS 영역을 보여주고 있다.3.2 주요 개념 설명3.2.1 프로세스와 스레드예) 인터넷에서 다운 받은 프로그램을 더블클릭해서 실행시키면 창이 뜬다. 다시 한 번 프로그램 아이콘을 더블클릭 하면 별도의 창이 열린다. 이것이 프로세스나 스레드로 불리는 것이다.프로세스 및 스레드는 프로그램 실행 파일 자체가 아니라 OS상에서 실행돼서 어느 정도 독립성을 가지고 동작하는 것이다. 프로세스 및 스레드가 활동하려면 메모리 공간이 필요하다. 이것은 커널에 의해 메모리 상에 확보된다.**메모리 공간을 가지는 것이 ‘프로세스’, 하나의 프로세스가 동작하고 있으면 내부에서는 메모리 공간을 점유하는 스레드 하나가 동작하고 있다. 각 스레드는 메모리 공간을 공유하고 있다.그림에서 웹 서버에 있는 막대 인간이 프로세스다. 그 주변을 감싸고 있는 하얀 영역이 프로세스의 메모리 공간을 나타낸다. AP 서버에서는 막대인간이 스레드이다. 프로세스는 전용 메모리 공간을 이용해 동작하지만 스레드는 다른 스레드와 메모리 공간을 공유하고 있는 운명 공동체다.   프로세스 스레드 장점 개별 처리 독립성이 높다. 생성 시 부하가 낮다. 단점 생성 시 CPU 부하가 높다. 메모리 공간 공유로 의도치 않은 데이터 읽기,쓰기 발생 3.2.2 OS 커널OS에서 커널이 본질이다. 커널 자체가 OS의 인프라라고 생각하면 된다. OS 처리는 원칙적으로 커널을 통해 이루어 진다. 시스템 콜 인터페이스 : 프로세스/스레드에서 커널로 연결되는 인터페이스이다. 애플리케이션이 OS를 통해 어떤 처리를 할 때 시스템 콜 명령을 이용해 커널에 명령을 내린다. 프로세스 관리 : 언제 어떤 프로세스가 어느 정도의 CPU 코어를 이용할 수 있는지 처리 우선순위를 어떻게 결정할 것이지 등을 관리한다. 메모리 관리 : 물리 메모리 공간의 최대치를 고려한다. 프로세스가 이용하는 독립 메모리 공간을 확보하거나 상호 간의 참조 영역을 지키기 위해 독립성을 관리하는 등의 메모리 관리 역할을 한다. 네트워크 스택 파일 시스템 관리 : 물리 디스크에 제공되는 데이터를 관리하는 기능이다. 문서파일이나 엑셀파일에 해당한다. 주요 관리 기능으로 디렉터리 구조 제공, 액세스 관리, 고속화, 안전성 향상 등이 있다. 장치 드라이버3.3 웹 데이터 흐름3.3.1 클라이언트 PC부터 웹 서버까지PC에서의 처리 흐름은 디스크에서 프로그램을 읽어 프로세스를 시작하고, 메모리 공간을 확보한다. 주소창에 ‘http://abcd.com’을 입력하면 이름의 해석이 이루어진 후에 웹 브라우저로 접속하게 된다.이름의 해석이 필요한 이유는 인터넷상의 주소는 IP라는 숫자로 표현돼 있어서 문자열인 URL과 IP를 연결시키지 않으면 통신이 되지 않기 때문이다.웹 서버에 도착하게 되면 웹 서버는 HTTP 요청에 대해 적절한 파일이나 콘텐츠를 반환한다. 요청에 대한 응답은 HTML 파일이라는 텍스트 데이터나 이미지, 동영상 등의 바이너리 데이터로 구성된다.그리고 이 데이터는 정적 콘텐츠(실시간으로 변경할 필요가 없는), 동적 콘텐츠(높은 빈도로 변경되는 데이터)로 구분된다.동적 콘텐츠의 경우 데이터를 서버 내부의 디스크에 저장하면 갱신 빈도가 높기 때문에 디스크 성능이 병목 현상의 원인이 될 수 있다. 그래서 일반적으로 AP 서버가 HTML을 동적으로 생성한다.3.3.2 웹 서버부터 AP 서버까지동적 콘텐츠에 대한 요청을 처리하는 것이 AP 서버다. 예) 자바를 이용한 AP 서버에서는 JVM 가상 머신이 동작하고 있다.대량의 데이터 관리 목적인 경우 DB 서버가 적합하다. 이 경우 AP 서버의 스레드는 DB 서버에 질의하고 그 결과를 HTML 등으로 정리해서 반환한다.그리고 AP서버가 DB서버에 접속하려면 드라이버가 필요하다.DB 서버 이외의 옵션 : 규모가 작고 갱신 빈도가 낮은 정보는 JVM 내부에 캐시로 저장해 두었다가 반환하는 것이 좋다. 반대로 규모가 큰 정적 데이터 전송 시에는 DB 서버 이외에 CND(Content Delivery Network)라 불리는 데이터 전송 전용 서버를 이용하는 경우도 있다.**대부분의 웹 시스템에서는 CND를 이용하고 기업형 시스템에서는 CND 구조를 잘 사용하지 않는다. CND는 대량의 데이터 전송에 특화된 것으로 전 세계에 있는 데이터 복사본(캐시)을 배치하는 기술과 병렬 기술을 활용해서 처리를 효율화하고 있다.3.3.3 AP 서버부터 DB 서버까지DB 서버에서는 오라클 DB인 경우 서버가 요청을 접수한다. 요청은 SQL 언어 형태로 이루어진다. SQL을 해석해서 액세스 방식을 결정하고, 디스크나 메모리에서 필요한 데이터만 수집해 오는 것이 데이터베이스의 주요 역할이다.DB 서버는 데이터 저장 창고다. 관리 대상 데이터가 방대하기 때문에 얼마나 효율적으로 액세스하는가가 중요하다. 대부분은 서버 메모리에 캐시가 있는지 먼저 확인한다. 캐시가 없으면 디스크에 액세스해서 필요한 데이터를 가지고 온다.또 인메모리 DB 등에서는 디스크 자체를 사용하지 않고 모든 처리를 메모리 내에서 완료하는 구조라서 고속화를 실현할 수 있다.DB 서버 내부의 디스크는 이중화 관점에서 뒤떨어지기 때문에 직접 사용하는 경우는 드물다. 대부분 별도의 저장장치를 이용한다.3.3.4 AP 서버부터 웹 서버까지3.3.5 웹 서버부터 클라이언트 PC까지요청 기반 아키텍처이기 때문에 각 서버는 문을 열고 기다리고 있는 상태다. 어느정도 요청이 올지는 실제 요청이 오기 전까지는 알 수 없다. =&gt; IT 인프라에서 성능 문제가 발생하는 이유임3.4 가상화3.4.1 가상화란?최근에는 온프레미스(서버를 클라우드 같은 원격 환경에서 운영하는 것이 아닌 전산실 서버에 직접 설치해 운영하는 방식)에서 가상화 기술을 사용하는 경우가 많다.가상화란 컴퓨터 시스템에서 물리 리소스를 추상화하는 것이라고 할 수 있다.3.4.2 OS도 가상화 기술의 하나OS는 가상화 기술 중 하나이다. OS 커널에 의해 하드웨어가 추상화되면서 컴퓨터에 연결된 기억 장치나 네트워크를 통한 데이터 교환이 하드웨어를 인식하지 않고 이루어지고 있다.OS는 하나의 컴퓨터 내에서 동시에 다수의 프로그램이 움직일 수 있게 해준다. OS는 가상 메모리를 사용해서 프로세스 및 OS 커널의 메모리 공간을 분리하므로 하나의 프로그램이 실패한다고 해도 시스템 전체에 영향을 끼치지 않는다.3.4.3 가상 머신 호스트 OS형 : 윈도우, 리눅스 등의 호스트 OS 상에 가상화 소프트웨어를 설치해서 이용하는 것 하이퍼바이저형 : 하드웨어상에서 직접 가상화 소프트웨어를 실행하고 그 위에 가상 머신을 동작시키는 기술이다.a. 완전 가상화 : 물리 머신상에서 동작하는 OS나 드라이버를 그대로 게스트로 이용할 수 있는 장점이 있지만 소프트웨어로 애뮬레이션하기 때문에 성능이 저하된다.b. 준가상화 : 가상 환경용 가상 하드웨어를 소프트웨어적으로 에뮬레이션한다.호스트 OS형보다 하이퍼바이저형이 성능이 우수하다.3.4.4 컨테이너의 역사컨테이너는 그릇, 용기 등의 의미로 즉 리소스가 격리된 프로세스다. 하나의 OS에서 여러 개를 동시에 가동할 수 있고, 각각 독립된 루트 파일 시스템, CPU/메모리, 프로세스 공간 등을 사용할 수 있다는 점이 가상 머신과의 차이다.3.4.5 도커의 등장2013년 파일 시스템과 프로세스를 분리하는 기능이 추가 됐다. 이를 통해 파일 시스템 이미지의 패키징과 버저닝이 가능해졌고 컨테이너 이미지를 공유할 수 있는 도커가 등장함으로써 컨테이너 기술이 주목을 받기 시작했다.애플리케이션 관련 프레임워크나 라이브러리 등의 버전이 일치하지 않아서 로컬에서 실행된 프로그램이 클라우드에서는 실행되지 않는 문제가 빈번하게 발생했다. 따라서 원래 클라우드 내부 구조로 개발했던 애플리케이션 실행 환경을 자동 구축해주는 도커 이미지라는 기술을 클라우드 이외의 환경에서도 사용할 수 있게 오픈 소스로 공개했다.[도커의 장점] 컨테이너는 호스트 OS와 OS 커널을 공유하므로 컨테이너 실행이나 정지 속도가 빠르다. 호스트 OS 커널을 공유하므로 한 대의 호스트 머신상에서 많은 컨테이너를 실행할 수 있다. 따라서 리소스를 한 곳에서 쉽게 관리할 수 있다. 라이브러리나 프레임워크 등을 도커 이미지로 묶어서 공유할 수 있는 것으로 버그를 효율적으로 수정할 수 있다.3.4.6 클라우드와 가상화 기술하이퍼바이저 및 컨테이너 등의 가상화 기술은 구글, 페이스북, 아마존 등의 대규모 웹 서비스에서 사용되고 있다. 클라우드 서비스에서는 가상 머신 서비스, 컨테이너 서비스 FaaS 서비스나 다른 기타 서비스를 지탱하는 기술로 이용되고 있다." }, { "title": "2장 서버를 열어 보자", "url": "/posts/2%EC%9E%A5-%EC%84%9C%EB%B2%84%EB%A5%BC-%EC%97%B4%EC%96%B4%EB%B3%B4%EC%9E%90/", "categories": "BOOK, 그림으로 공부하는 IT 인프라 구조", "tags": "infra", "date": "2022-07-01 23:43:48 +0900", "snippet": "2.1 물리 서버2.1.1 서버 외관과 설치 장소서버는 Rack 이라는 것에 장착된다. 랙에는 서버 외에도 HDD가 가득 장착돼 있는 저장소나 인터넷 및 LAN을 연결하기 위한 네트워크 스위치 등도 탑재돼 있다.[랙 구성][서버]2.1.2 서버 내부 구성컴포넌트를 연결하는 선을 Bus라고 한다. CPU 옆에 메모리가 배치되어 있고, CPU와 메모리는 물리적으로 직접 연결되는 것을 알 수 있다.PCI Express 슬롯은 외부 장치를 연결하는 곳이다. BMC 컴포넌트는 서버의 H/W 상태를 감시하며 독립적으로 움직인다. 이렇게 서버의 구성을 보면 서버와 PC가 물리적으로는 구성이 같다는 것을 알 수 있다.2.2 CPUCentral Processing Unit의 약자로 서버 중심에 위치해서 연산 처리를 실시한다. CPU는 명령을 받아서 연산을 실행하고, 결과를 반환한다. 명령과 데이터는 기억장치나 입출력 장치를 통해 전달된다.CPU는 core 라고 부르고 현재는 멀티 코어화가 진행되고 있다. 명령은 OS가 내리고 OS에 명령을 내리는 것은 사용자 키보드, 마우스 등을 통한 입력이다.2.3 메모리메모리는 CPU 옆에 위치하고 CPU에 전달하는 내용이나 데이터를 저장하거나 처리 결과를 받는다. 메모리에 저장되는 정보는 영구성이 없다. 이는 서버를 재시작시 없어지는 정보임을 나타낸다.메모리는 전기적인 처리만으로도 데이터를 저장하기 때문에 메모리 액세스가 매우 빠르게 이루어진다.CPU 자체도 메모리를 가지고 있는데 이를 레지스터, 1L, 2L캐시 라고 불린다. 일반적으로 캐시 메모리가 커질수록 액세스 속도가 느려진다. 가능한 CPU 가까운 곳에 많은 캐시를 두기위해 캐시를 여러 단계로 배치해서 초고속으로 액세스하고 싶은 데이터는 L1,준고속으로 액세스하고 싶은 데이터는 L2 캐시에 두는 형태로 만든다.2.4 I/O 장치2.4.1 하드 디스크 드라이브(HDD)기록 영역인 하드디스크는 주로 장기 저장 목적의 데이터 저장 장소로 사용한다. 메모리는 전지가 흐르지 않으면 데이터가 사라지지만 디스크는 전기가 없어도 데이터가 사라지지 않는다.하드디스크의 내부는 자기 원반이 여러개 들어있고, 이것이 고속으로 회전해서 읽기/쓰기 처리를 한다. 이 회전 구조 때문에 속도가 물리 법칙에 좌우되며 메모리처럼 순식간에 액세스할 수 없다.최근에는 기술이 발전해서 SSD(Solid State Disk)라는 물리적인 회전 요소를 사용하지 않는 디스크가 사용되고 있다. SSD는 반도체로 만들어졌지만 전기가 없어도 데이터가 사라지지 않는다.서버와 I/O시에 하드 디스크가 직접 데이터 교환을 하는 것이 아니라 캐시를 통해서 한다.위 그림에서 두 종류의 I/O를 사용하고 있다. 읽기/쓰기 시에 캐시라는 메모리 영역에 액세스하는 방법 : 읽기 캐시의 경우 캐시상에 데이터 복사본만 있으면 되지만 쓰기 시에는 캐시에만 데이터를 기록하고 완료했다고 간주하는 경우 데이터를 잃을 가능성이 있음을 의미한다. 장점은 캐시에 저장해서 쓰기 처리가 종료되기 때문에 고속 I/O를 실현할 수 있다. 이런 쓰기를 Write Back이라고 함 캐시와 HDD에 모두 액세스 하는 I/O : 읽기 시에 캐시에 데이터가 없으면 읽기 처리를 위해 액세스한다. 쓰기 시에는 캐시와 디스크를 모두 읽어서 Write Back과 비교하고, 더 확실한 쪽을 쓰기 처리를 실시하기 위해 액세스 한다. 이런 쓰기를 Write Through라고 한다.2.4.2 네트워크 인터페이스네트워크 인터페이스는 서버와 외부 장비를 연결하기 위한 것으로 외부 접속용 인터페이스다.2.4.3 I/O 제어35~37p2.5 버스버스는 서버 내부에 있는 컴포넌트들을 서로 연결시키는 회선을 가리킨다.2.5.1 대역대역은 주파수 대역을 가리키지만 IT 인프라에서는 데이터 전송능력을 의미한다. 대역 = 한번에 데이터를 보낼 수 있는 데이터의 폭(전송폭) X 1초에 전송할 수 있는 횟수 로 결정된다.2.5.2 버스 대역CPU에 가까운 쪽이 1초당 전송량이 크다. 버스 흐름에서 중요한 것은 CPU와 장치 사이에 병목현상이 없어야 한다는 것이다. 병목현상은 데이터 전송이 어떤 이유로 막혀 있는 상태를 의미한다.[하드디스크 데이터가 CPU에 이르기까지 여정]" }, { "title": "1장 인프라 아키텍처를 살펴보자", "url": "/posts/1%EC%9E%A5-%EC%9D%B8%ED%94%84%EB%9D%BC-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%A5%BC-%EC%82%B4%ED%8E%B4%EB%B3%B4%EC%9E%90/", "categories": "BOOK, 그림으로 공부하는 IT 인프라 구조", "tags": "infra", "date": "2022-06-30 22:58:02 +0900", "snippet": "1.1 인프라란 무엇일까?인프라는 기반이라는 뜻으로 인프라 구조 자체는 복잡하지만 전문가에 의해 관리되고 있어서 사용자는 그 구조를 이해하지 않고도 간단히 이용할 수 있다는 특징이 있다.인프라 아키텍처는 IT 인프라의 구조를 의미한다. 인터넷 검색 시스템이나 항공 회사 티켓 발권 시스템, 편의점 계산대 등 모두가 이용 방법이나 사용자가 다르지만 IT 인프라 위에서 동작하고 있다.1.2 집약형과 분할형 아키텍처1.2.1 집약형 아키텍처IT 시스템 여명기에는 대형 컴퓨터를 이용해서 모든 업무를 처리하는 형태가 대부분이었다. 시스템 아키텍처라는 관점에서 하나의 컴퓨터로 모든 처리를 하기 때문에 집약형이라고 할 수 있다. 집약형의 최대 장점은 구성이 간단하다는 것이다.컴퓨터를 구성하는 주요 부품은 모두 다중화돼 있어서 하나가 고장나더라도 업무를 계속할 수 있다. 또 복수의 서로 다른 업무 처리를 동시에 실행할 수 있도록 유한 리소스 관리를 한다.[장점] 한 대의 대형 컴퓨터만 있으면 되므로 구성이 간단하다. 대형 컴퓨터의 리소스 관리나 이중화에 의해 안정성이 높고 고성능이다.[단점] 대형 컴퓨터의 도입 비용과 유지 비용이 비싸다. 확장성에 한계가 있다.1.2.2 분할형 아키텍처여러 대의 컴퓨터를 조합해서 하나의 시스템을 구축하는 구조다. 대형 컴퓨터는 안정성이 높고 고성능이지만 현재는 소형 컴퓨터라도 충분한 성능을 낼 수 있다. 또 구입비용이 압도적으로 저렴하다.분할형의 장점은 개별 컴퓨터의 안전성이 낮아도 괜찮기 때문에 저가 장비를 이용해서 전체적인 비용을 줄일 수 있다는 것이다. 또 더 많은 컴퓨터를 이용해서 시스템 전체 성능을 향상시킬 수 있어서 확장성이 좋다는 특징도 가졌다.하지만 서버 수가 늘어나면 이를 운영하기 위한 구조가 복잡해지는 경향이 있다.[장점] 낮은 비용으로 시스템을 구축할 수 있다. 서버 대수를 늘릴 수 있어서 확장성이 높다.[단점] 대수가 늘어나면 관리 구조가 복잡해진다. 한 대가 망가지면 영향 범위를 최소화하기 위한 구조를 검토해야 한다.물리 서버와 논리 서버의 차이분할형 아키텍처에서 이용되는 컴퓨터를 서버라고 한다. 서버라는 용어는 컴퓨터 자체를 가리키는 경우도 있고(물리서버), 컴퓨터에서 동작하고 있는 소프트웨어를 가리키는 경우도 있다.예) 인터넷에 접속했을 때 사용자 입력 및 HTML 생성을 담당하는 것은 서버에서 동작하는 소프트웨어인 ‘웹 서버’, 대량의 데이터를 저장해서 요청에 따라 데이터를 제공하는 것은 데이터베이스 기능을 제공하는 ‘DB 서버’다.1.3 수직 분할형 아키텍처분할형에서는 서버 분할 방식, 즉 역할 분담을 고려해야 한다.1.3.1 클라이언트-서버형 아키텍처업무 애플리케이션, 미들웨어, 데이터베이스 등의 소프트웨어를 물리 서버 상에서 운영하고 있다. 특징으로 클라이언트 측에 전용 소프트웨어를 설치해야 한다는 것읻.[장점] 클라이언트 측에서 많은 처리를 실행할 수 있어서 소수의 서버로 다수의 클라이언트를 처리할 수 있다.[단점] 클라이언트 측의 소프트웨어 정기 업데이트가 필요하다. 서버 확장성에 한계가 발생할 수 있다.1.3.2 3계층형 아키텍처프레젠테이션 계층(사용자의 입력을 받는다), 애플리케이션 계층(사용자 요청에 따라 업무 처리를 한다), 데이터 계층(요청에 따라 데이터 입출력을 한다)의 3층 구조로 분할돼 있어서 3계층형이라고 부른다.클라이언트-서버형에 비해 특정 서버에 부하가 집중되는 문제가 해결된다는 것이 장점이다. 또 이 아키텍처에서는 모든 처리가 AP 서버나 DB 서버를 이용하지 않아도 된다. 예를 들어 이미지 파일만 읽으면 되는 경우라면 웹 서버만으로도 처리를 완료해서 결과를 반환할 수 있다.[장점] 서버 부하 집중 개선 클라이언트 단말의 정기 업데이트가 불필요 ‘처리 반환’에 의한 서버 부하 저감[단점] 구조가 클라이언트-서버 구성보다 복잡하다1.4 수평 분할형 아키텍처수평 분할형 아키텍처의 용도는 같은 서버를 늘려나가는 방식이다. 서버 대수가 늘어나면 한 대가 시스템에 주는 영향력이 낮아져서 안정성이 향상되고, 처리를 담당하는 서버 대수가 늘어나면 전체적인 성능 향상도 실현할 수 있다.1.4.1 단순 수평 분할형 아키텍처수평 분할을 sharding, partitioning이라 부르기도 한다. 이 구조는 거래상으로 멀리 떨어진 시스템에 자주 이용되고, 공장처럼 각 거점이 완전히 독립된 운영을 하고 있는 경우에도 적합하다.[장점] 수평으로 서버를 늘리기 때문에 확장성이 향상된다. 분할한 시스템이 독립적으로 운영되므로 서로 영향을 주지 않는다.[단점] 데이터를 일원화해서 볼 수 없다. 애플리케이션 업데이트는 양쪽을 동시에 해 주어야 한다. 처리량이 균등하게 분할돼 있지 않으면 서버별 처리량에 치우침이 생긴다.1.4.2 공유형 아키텍처공유형에서는 단순 분할형과 달리 일부 계층에서 상호 접속이 이루어진다.[장점] 수평으로 서버를 늘리기 때문에 확장성이 향상된다. 분할한 시스템이 서로 다른 시스템의 데이터를 참조할 수 있다.[단점] 분할한 시스템 간 독립성이 낮아진다. 공유한 계층의 확장성이 낮아진다.**엣지 컴퓨팅 : 가상화를 사용해 데이터 센터를 통합하거나 클라우드로 이전하면서 네트워크 대역과 비용이 크게 증가했다. 그래서 지리적으로 가까운 위치에 있는 서버로 처리를 분산하고 처리 결과만 중앙으로 보내는 아키텍처가 각광받고 있다. 이것이 바로 ‘Edge Computing’ 이다.1.5 지리 분할형 아키텍처1.5.1 스탠바이형 아키텍처물리 서버를 최소 두 대를 준비하여 한 대가 고장 나면 가동 중인 소프트웨어를 다른 한 대로 옮겨서 운영하는 방식이다. 이때 소프트웨어 재시작을 자동으로 하는 구조를 ‘Failover’(F/O)라고 한다.이 방식은 물리 서버 고장에 대처할 수는 있지만 보통 때는 페일오버 대상 서비스가 놀고 있는 상태가 되기 때문에 리소스 측면에서 낭비가 발생한다.1.5.2 재해 대책형 아키텍처특정 데이터 센터에 있는 상용 환경에 고장이 발생하면 다른 사이트에 있는 재해 대책 환경에서 업무 처리를 재개하는 것을 가리킨다. 서버 장비를 최소 구성 및 동시 구성으로 별도 사이트에 배치하고, 소프트웨어도 상용 환경과 동일하게 설정한다.문제점은 애플리케이션 최신화와 데이터 최신화이다. 특히 데이터는 매일 갱신되기 때문에 어느 정도 실시간성을 유지해서 사이트간 동기 처리를 해야한다." }, { "title": "15장 훌륭한 프로그래머가 되기 위한 팁과 경험담", "url": "/posts/15%EC%9E%A5-%ED%9B%8C%EB%A5%AD%ED%95%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EA%B0%80-%EB%90%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%ED%8C%81%EA%B3%BC-%EA%B2%BD%ED%97%98%EB%8B%B4/", "categories": "BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍", "tags": "computer", "date": "2022-06-27 22:41:13 +0900", "snippet": "가치 제안다양한 기술을 잘 배워두면 자신에게 가치를 더할 수 있다. 경험을 쌓는 방법으로는 가외 프로젝트가 자주 쓰인다. 또 자신의 가치를 높이는 고전적인 방법은 도구를 만드는 것이다.사람들은 자신에게 필요한 기능이 현재 사용중인 도구에 없다고 생각해서 새 도구를 만들어내곤 한다. 결국 서로 호환되지 않는 방식으로 비슷한 일을 수행하는 수많은 도구가 생겼다. 이런 프로젝트는 가치를 추가하지 않는다.고로 자기중심적으로 행동해 남에게 민폐끼치는 프로그래머가 되어서는 안 된다. 생태계에 순응하고 대항하지 마라소프트웨어 개발의 발자취1) 간추린 역사유닉스 운영체제 탄생, 첫 번째 이식 가능한 운영체제가 됐다.(여러 종류의 컴퓨터에서 실행 가능)개인용 PC가 보급되면서 소프트웨어를 작성하는 사람과 컴퓨터를 파는 사람이 구분되기 시작했다. 그리고 빌 게이츠가 등장하면서 경향이 바뀌었다. 게이츠는 금전적 이익에 초점을 맞췄고 우선순위가 산업계에 속한 다른 사람들과는 달랐다.소프트웨어 개발이 정치가나 변호사에 의해 관리되기 시작하면서 뛰어난 엔지니어링보다는 공정하지 못한 방식에 의해 주도되기 시작했다. 예) MS-DOS는 MS가 개발한 것이 아니라 팀 패터슨이 개발한 운영체제를 산 것이다. MS는 MS-DOS로 돈을 버는 동안 이를 개선하지 않았다.윈도우가 실행되는 PC가 더 저렴하다는 이유로 PC를 교육에 활용하기 시작했다. 사람들은 자신이 사용하는 시스템의 소스 코드를 볼 수 없었다. 이런 반작용으로 리처드 스톨먼은 GNU 프로젝트를 시작했다. 이것의 목표는 자유롭게 사용가능하고 법적으로 방해받을 걱정이 없는 유닉스 버전을 만드는 것이었다.(오픈소스)대기업들은 오픈소스 소프트웨어 사용에 회의적이었다. 누가 버그를 고칠까? 이후 오픈소스 소프트웨어를 상업적으로 지원하기 위한 시그너스 서포트가 만들어졌고 이것의 등장으로 회사들이 오픈소스 소프트웨어를 사용하려는 의향이 늘어났다.2) 오픈소스 소프트웨어오픈소스 소프트웨어의 주된 장점은 더 많은 사람이 코드를 살펴보기 때문에 안전성이나 신뢰성이 더 높아진다는 점이다. 또 다른 장점은 프로그래머가 모든 것을 완전히 새로 만들지 않고도 다른 사람들이 작업해둔 것을 바탕으로 작업할 수 있다는 점이다.인터넷과 클라우드 서비스로 인해 오픈소스 소프트웨어 개발은 아주 많이 향상됐다.하지만 수많은 오픈소스 프로젝트는 학생들의 프로젝트에서 나왔다. 대부분 마무리가 되지 않았거나 문서화가 제대로 되지 않는 등 새로 작성하는 게 편한 경우가 많다. 그래도 다른 사람의 코드를 살펴보면 무엇을 해야할지를 배우는 것만큼 무엇을 하지 말아야 할지도 배울 수 있다.프로젝트가 한 사람 이상의 기여자에 의해 활발히 개발되고 있다는 사실은 긍정적 지표다.3) 크리에이티브 커먼즈4) 이식성의 발전이식성은 소프트웨어에서 특별한 의미를 지닌다. 이식성 있는 코드는 처음 개발된 환경뿐만 아니라 여러 다양한 환경에서 실행될 수 있다.5) 패키지 관리오픈소스 소프트웨어, 특히 리눅스는 소프트웨어 배포 문제를 상당히 악화시켰다. 데스크톱, 안드로이드 폰, 태블릿 등에서 실행되는 여러 가지 설정의 리눅스가 존재한다. 그래서 패키지 관리가 활성화 됐다. 패키지 관리 도구는 프로그램을 의존관계 목록이 포함된 패키지로 묶게 해준다.6) 컨테이너컨테이너는 패키지 관리 문제를 해결하는 방법으로 최근에 등장한 새로운 접근 방법이다. 애플리케이션과 모든 의존관계를 컨테이너에 한꺼번에 담는다. 이렇게 담긴 데이터 파일 등의 모든 내용물이 들어 있는 환경에서 프로그램을 실행해주되 시스템의 나머지와는 격리된 상태에서 실행해준다. 그래서 소프트웨어의 deploy(배포)를 단순화해준다.7) 자바자바의 새로운 아이디어 중 하나는 모든 대상 기계에 대해 코드를 재컴파일하는 대신 대상 기계에서 실행될 자바 인터프리터만 누군가 재컴파일하면 프로그래머가 자바 코드를 재컴파일할 필요는 없다는 것이다.교육에 자바가 쓰인 이유 중 하나는 자바가 가비지 컬렉션을 통해 메모리를 관리하기 때문에 초보자에게 복잡한 메모리 관리를 가르치지 않아도 되기 때문이다. 자바의 단점으로는 자바를 중심으로 확장된 프로그래밍 문화를 들 수 있다. 아름다운 클래스 계층을 유지하는 것에 대한 강박관념이 있어서때로 어떤 목표를 달성하는 것보다 클래스 계층 유지에 더 우선순위를 두곤 한다.좋은 예로 자바 데이터베이스 도구인 하이버네이트를 들 수 있다. 하이버네이트는 자바 클래스와 하위 클래스로 데이터 은닉의 목표를 달성하려 한다. 또 HQL(하이버네이트 질의 언어)라는 추상화를 일반적으로 SQL인 기반 데이터베이스 API 위에 제공하는 것이다.8) 노드제이에스 (Nodejs)Node.js는 자바스크립트가 브라우저 밖에서 실행되게 해주는 최근에 나온 환경이다. 가장 큰 매력은 클라이언트와 서버 쪽 애플리케이션을 하나의 프로그래밍 언어로 작성할 수 있다는 점이다.단점으로 노드는 자신만의 패키지 관리자를 만들었다. 사람들에게 필요하지만 호환되지 않는 방법으로 만들었기 때문에 시스템을 유지보수하기 더 어려워졌다. 의존성이 꼬인 노드 패키지가 수천가지가 있고 상당수는 심각한 작업에 적당하지 않다.9) 클라우드 컴퓨팅클라우드 컴퓨팅은 네트워크를 통해 다른 누군가의 컴퓨터를 쓴다는 뜻이다. 클라우드 컴퓨팅은 컴퓨팅 자원을 빌려준다는 새로운 비즈니스 모델을 만들었다.10) 가상머신과거에는 프로그램이 한 컴퓨터에서 하나씩만 실행됐다. 운영체제는 시분할을 통해 여러 프로그램을 실행할 수 있게 해준다.운영체제가 물리적 기계 하드웨어 위에서 바로 실행될 필요가 없으므로 이런 시스템을 가상 머신이라고 부른다. 가상 머신은 특정 운영체제에 종속되는 것을 방지한다는 면 외에도 여러 가지 장점을 제공한다.가상 머신은 클라우드 컴퓨팅 세계의 주류다. 클라우드상에서 공간을 빌리고 원하는 운영체제를 조합해 실행할 수 있다. 가상 머신을 운영하는 시스템을 하이퍼바이저라고 부르기도 한다.11) 이동식 장치프로그래밍 환경1) 초보 프로그래머도 경험을 얻는 방법어떻게 하면 필요한 기술을 갖출 수 있을까? 어떻게 해야 경험을 잘 정의할 수 있을까? 무엇보다 기본이 탄탄해야 한다. 경험은 무엇을 할 수 있고 무엇을 할 수 없는지를 아는 것이다. 해보지도 않은 일을 할 수 있을지 어떻게 알 수 있을까?추정을 통해 배울 수 있다. 추정은 단순한 추측이 아니라 경험을 바탕으로 하는 직관적인 어림짐작이다.2) 추정하는 방법 배우기팀원으로써 가장 파괴적인 행위는 아무 경고도 없이 결과물을 제때 전달하지 않는 것이다. 어떻게 하면 추정을 할 수 있을까? 연습을 통해 추정하는 방법을 배울 수 있다.숙제등의 작업을 시작하기 전 그 작업이 얼마나 걸릴지 추정한 값을 적어두고 그 후 실제 작업이 얼마나 걸렸는지 추적해보자 이런 연습을 통해 추정이 나아지고 있음을 발견하게 된다.3) 프로젝트 스케줄링4) 의사결정5) 성향이 다른 사람들과 함께 일하기6) 직장 내 문화 다루기사람들은 직업에서 금전적 보상을 받고, 경력에서 향상을 원하며 소명에서 즐거움을 얻는다. 이런 성격 분류에 따라 직접이나 경력에 주안을 두는 사람은 사람 중심 문화에서 더 잘 일할 수 있고, 이는 원만한 개인 관계라는 보상을 제공한다.소명과 결과 중심 문화는 서로 잘 어울리고 최선의 결과를 이룰 수만 있다면 그 과정에서 불꽃튀는 설전이 오가고 강렬한 비판이 이뤄져도 사람들이 만족스러워 한다.7) 정보를 얻은 상태에서 선택하기개발 방법론노력이 이뤄지는 모든 분야는 결국 방법론 전문가를 양산하는 것 같다. 프로그래밍도 다르지 않다. 다만 방법론이라고 부르는 것보다 이데올로기라고 부르는 편이 더 어울릴법한 열혈분자가 있다는 점이 다르다.이데올로기와 방법론 사이의 차이는 사용자의 역할에 있다. 실패 비용이 높은 경우에는 어떤 일을 해야 할지 정확히 아는 것이 중요하다. 실패 비용이 낮은 경우에는 명확한 정의를 미리 작성해야 할 인센티브가 상대적으로 작아진다. 그래서 만들어서 봐야 우리가 원하는 건지 알 수 있어 라는 접근 방법을 더 많이 선택한다.프로젝트 설계1) 생각을 글로 써보자아이디어를 글로 써보자 문서를 올바른 수준까지 작성하는 것이 중요하다. 일을 처리할 방법을 적지 말고 하고 싶은 일을 적어야 한다.2) 빠른 프로토타이핑빠른 프로토타이핑은 부분적으로 작동하는 프로젝트 결과물을 사람들에게 내보이는 것이 포함된 것으로 문서를 작성하는 것처럼 프로토타이핑도 아이디어를 더 깊이 이해하는 데 도움이 된다.주의사항 프로토타입을 프로덕션 코드와 혼동하지 마라 억지로 프로토타입 작성에 빡빡한 스케줄을 부여하지 않게 하라 관리자가 프로토타입을 외부에 배포할 수 있는 제품으로 착각하지 않도록 주의하라프로토타입 코드를 외부로 배포할 경우 드러나는 전형적인 특징은 응집도가 떨어진다는 점이다. 프로토타이핑은 주로 블록을 가지고 작업한다. 프로토타입의 동작을 관장하는 원칙을 관찰하고 이런 원칙을 일관성 있게 적용하면서 새로 코드를 재구현해야 한다.3) 인터페이스 설계우리의 프로젝트는 소프트웨어 스택에서 어느 위치를 차지하고 있을 것이다. 소프트웨어는 샌트위치의 속처럼 자기 위아래와 통신하며 스택안에 존재한다. 애플리케이션의 인터페이스는 샌드위치의 아래쪽 빵을 사용해 결정되므로 위쪽 인터페이스를 결정해야 한다.시스템 프로그래밍은 하드웨어와 애플리케이션 사이에 위치한다. 소프트웨어 스택에서 한 스택과 다른 스택 사이의 선을 애플리케이션 프로그램 인터페이스(API)라고 부른다. API가 프로그램이 아닌 사람을 대상으로 하면 사용자 인터페이스(UI)라고 부른다.[API 설계] API는 자세한 내부 구현을 노출해서는 안 되고, 특정 구현에 의존해서도 안 된다. API는 응집도가 높아야 한다. (좋은 추상화를 제공해야 한다) API는 확장 가능해야 한다. API는 최소화해야 한다.(같은 일을 처리하는 방법을 여러 가지로 제공하지 말아야한다.) 모듈화가 잘 되어 있으면 좋다. API가 연관된 기능을 제공한다면 이들을 가능한한 서로 독립적으로 만들어라 기능은 합성 가능해야 한다.(조합하기 쉬워야 한다)4) 코드를 재활용 할 것인가, 직접 작성할 것인가보통 라이브러리가 차지하는 메모리 크기가 직접 작성한 코드가 차지하는 메모리 크기보다 크면 라이브러리를 쓰지 말라고 말한다.프로젝트 개발2) 이식성이 있는 코드3) 소스 코드 제어프로그램은 바뀐다. 기능 추가나 버그 수정을 위해 변경하는 등의 일이 자주 벌어진다. 따라서 새로운 버전에 버그를 수정한 경우 어떤 부분이 변경됐는지 확인해야 하기 때문에 소스 코드를 과거로 돌릴 수 있는게 아주 중요하다.두 파일을 비교해서 달라진 부분의 목록을 생성해내는 diff라는 프로그램이 있다. 이 프로그램의 옵션 중 출력을 텍스트 편집기 파이프로 연결해 넣으면 변경 목록을 활용해 한 파일을 변경된 파일로 바꿔주는 기능이 있었다. 이런 diff의 아이디어를 바탕으로 소스 코드 제어 시스템(SCCS) 을 만들었다.SCCS는 파일이 바뀌면 원본과 각 버전의 변경 목록을 저장했다. 그리고 사용자가 어떤 버전의 파일을 요구하면 원본에 모든 변경 버전을 적용해서 그 자리에서 만든 원하는 버전의 파일을 얻을 수 있었다.SCCS의 단점을 보안한 변경 제어 시스템(RCS)가 나왔고 RCS는 더 나은 사용자 인터페이스를 제공하고 후방 변경 이력을 사용함으로써 가장 최신 버전을 저장하고 최신 버전으로부터 옛 버전을 만들어 냈다. 따라서 속도도 빨라졌다.이후 동시성 버전 제어 시스템(CVS)는 RCS와 비슷한 기능을 네트워크로 접근할 수 있게 해주면서 최초로 파일 잠금 대신 병합을 사용한 시스템이다.이후 serversion, Git, 등의 분산 시스템이 만들어졌다.4) 테스트테스트를 하지 않으면 프로그램이 잘 작동하는지 실제로 알 수가 없다. 프로그램을 작성할 때 테스트 집합도 만들어야 한다.5) 버그 보고와 추적6) 리팩토링리팩토링은 코드의 인터페이스나 동작은 바꾸지 않고 코드 내부를 재작성해 개선하는 과정을 말한다. 리팩토링을 하는 이유는 코드가 완전히 구체화되면 지저분해지거나 좀 더 낫게 문제를 처리하는 방법을 알게 되는 경우가 있기 때문이다. 리팩토링을 하면 유지보수 비용을 줄일 수 있다. 하지만 리팩토링 전과 후가 똑같이 작동한다는 사실을 확인하려면 좋은 테스트 집합이 필요하다.**리팩토링 과정중 새로운 기능을 추가하고 싶은 욕구가 느껴지더라도 절대 그 기능을 집어 넣지 마라!7) 유지보수진지한 코드의 경우 개발에 드는 비용보다 유지보수에 드는 비용이 훨씬 더 크다. 동료들이 감탄할 만큼 멋지게 비틀어 작성한 코드는 피하자 유지보수 하는 사람이 똑똑하지 못하면 코드를 보고 유지보수를 하는 것이 아니라 코드를 새로 설계하게 된다.스타일을 지켜라소프트웨어는 깔끔하게 작성하고 문서도 잘 작성하자 코드에서 벌어지는 일을 다른 사람이 잘 이해할 수 있게 하지 않으면 아무도 나를 도와줄 수 없다.기존 프로젝트를 활용하라" }, { "title": "14장 세상을 바꾸는 기계 지능", "url": "/posts/14%EC%9E%A5-%EC%84%B8%EC%83%81%EC%9D%84-%EB%B0%94%EA%BE%B8%EB%8A%94-%EA%B8%B0%EA%B3%84-%EC%A7%80%EB%8A%A5/", "categories": "BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍", "tags": "computer", "date": "2022-06-24 13:23:25 +0900", "snippet": "기계지능은 머신러닝, 인공지능, 빅데이터 등의 연관 분야가 포함된 고급 주제다. 오늘날 두 가지 경향으로 인해 머신러닝이 널리 성공하고 있다. 기술적 발전으로 인해 저장장치의 크기는 늘고 가격은 저렴해졌다. 그리고 기술 발전으로 인해 프로세서와 네트워크도 더 빨라졌다. 인터넷으로 인해 엄청난 양의 데이터를 쉽게 수집할 수 있게 됐다.개요머신러닝어떤 수준의 머신러닝을 사용하든 통계학을 만나게될 확률이 아주 높다.1) 베이즈영국 목사인 토머스 베이즈가 자기 이름과 똑같은 베이스 정리를 증명했다.540p~541p2) 가우스독일 수학자인 가우스는 종모양 곡선, 정규 분포나 가우시안 분포라고 불리는 확률 분포에 대해 만들었다.예를 들어 농구선수의 키를 측정할때 선수 중 68%는 평균에서 표준 편차안에 들어가고 키의 분포도 모양은 종모양 곡선에 더 가까워진다.542p~544p3) 소벨545p~550p4) 캐니소벨의 결과에 몇 가지 단계를 추가해서 테두리 감지를 개선했다. 비최댓값 억제 -&gt; 이미지의 테두리 중 일부가 두껍고 모호하다. 테두리가 가늘면 나중에 이미지의 특성을 더 쉽게 알아낼 수 있다. 즉 비최대값 억제는 테두리를 가늘게 하는 기법이다. 이력을 활용한 테두리 추적 -&gt; 약한 테두리를 없애고 강한 테두리를 남긴다.5) 특성 추출특성 추출 알고리즘은 아주 많다. 그중 ‘휴 변환’ 같은 것은 선이나 원 같은 기하학적인 모양을 추출하기에 좋다.특성을 찾았으면 이 특성들을 분류기에 넣어서 분류기 입력에서 +는 특성이 있는 이미지가 결과에 부합하는 특성이란 뜻이고, -는 이런 특성이 있는 이미지는 결과에 반하는 특성이라는 뜻이며, 0은 아무 도움도 되지 않는 특성이라는 뜻이다.6) 인공 신경망인공지능에서 사용해온 접근 방법 중에는 인간의 행동을 흉내 내려는 노력이 있었다. 인간의 경우 뉴런이 큰 역할을 한다는 사실을 잘 알고 있다. 인간에게는 860억 개나 되는 뉴런이 있다.뉴런은 간단하다는 점에서 게이트와 비슷하고, 더 복잡한 회로, 즉 신경망을 이룰 수 있다는 점에서도 비슷하다. 뉴런의 핵심은 입력의 가중치를 더한 값에 따라 활성화된다는 점이다. 따라서 여러가지 입력 조합이 뉴런을 활성화할 수 있다.최초로 인공 뉴런을 만들려는 시도로 퍼셉트론 이었다. 퍼셉트론은 입력과 줄력이 2진수이다. 그래서 입력과 출력은 0 아니면 1 밖에 올 수 없다.퍼셉트론은 AI 분야에서 활용됐다. 특히 다중 계층 신경망이 생기고 여러가지 문제를 해결할 수 있게 되었다. 퍼셉트론의 2진법적인 특성으로 인해 가중치 결정이 어려웠다. 퍼셉트론의 비교기를 시그모이드 함수로 바꿔서 이런 문제를 해결한 시그모이드 뉴런이 탄생한다.시그모이드 뉴런에서는 역전파 기법을 사용해 신경망의 가중치를 결정할 수 있다.인공 신경망의 큰 문제는 나쁜 훈련 데이터에 의해 신경망이 중독될 수 있다는 점이다. 아이일때 TV를 너무 많이 본 어른이 나중에 어떤 이상 행동을 할지 모르는것처럼 머신러닝 시스템도 마찬가지다.7) 머신러닝 데이터의 활용인공지능561p~564p빅데이터빅데이터는 움직이는 표적이다. 빅데이터라는 말은 너무 크고 복잡해서 오늘날의 기술로 마구잡이식으로 처리하면 처리가 불가능한 데이터를 뜻한다. 빅데이터라는 용어는 분석뿐만 아니라 데이터 수집, 저장, 관리에도 적용된다.565p~568p" }, { "title": "13장 컴퓨터 보안", "url": "/posts/13%EC%9E%A5-%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%B3%B4%EC%95%88/", "categories": "BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍", "tags": "computer", "date": "2022-06-22 21:02:25 +0900", "snippet": "컴퓨터 네트워크 발달은 작은 아파트 보안 문제에서 큰 성의 보안 문제로 변화시켰다. 큰 성은 지켜야할 출입구가 많고 성이 커질수록 더 많은 쓰레가 쌓이고 버그가 숨을 공간도 많아진다.보안의 핵심은 우리가 정의한 안전함에 따라 유지하는 것이다. 그리고 안전함의 정의는 다른 사람들이 정한 정의와도 균형을 맞춰야 한다.보안과 프라이버시 개요1) 위협 모델보안은 위협 모델에 따라 상대적이다. 위협 모델은 보안이 필요한 대상 목록과 각 보안 대상에 가해질 수 있는 공격을 열거해서 이런 공격을 방어하는 방법을 설계할 수 있게 한다.위협 모델을 이해하는 것이 중요하고 모델에 따라 적합한 방어를 설계해아 한다.2) 신뢰위협 모델을 정할 때 가장 어려운 부분은 신뢰할 대상을 정하는 것이다. 네트워크로 연결된 컴퓨터 세계에서 신뢰할 대상을 선택하는 것은 아주 제한적이다. 컴퓨터 보안 세계에서 신뢰는 선택할 수 없지만 의존해야 하는 대상을 가리킨다. 즉 보안은 이런 구성요소의 보안에 달려 있다.컴퓨터를 사용하면 수많은 하드웨어, 소프트웨어에 의존해야 한다. 이들의 소스 코드를 볼 수 없어도 의존할 수밖에 없다.[신뢰 위반] 의도적 : 예) 소니가 고객 컴퓨터에 설치했던 루트킷(시스템의 보호를 우회시킴), 레노보가 랩톱에 설치한 광고를 표시하는 멀웨어(악의적인 소프트웨어)가 있다. 무능 : 암호화 되지 않은 비밀번호 사용 등 부정직 : 예) 미국 국립 표준 기술 연구소가 미국 국가안보국(NSA)에서 온 전문가의 도움을 받아 만든 암호 표준 -&gt; NSA 전문가들이 의도적으로 표준을 강화하지 않고 악화시켰음이 드러남투명성이나 개방성에서 더 나은 보안을 얻을 수 있다. 더 많은 사람이 현재 사용 중인 보안 기술에 대해 교육받으면 받을수록 보안 기술의 약점에 대해 더 많이 토의하고 약점을 더 잘 발견하게 된다.3) 물리적 보안학교 사물함을 예를 들어 생각해 보면 사물함의 문은 공격 표면이다. 사물함 문에 달린 번호 자물쇠는 올바른 번호와 순서로 열어야 열리며 자물쇠의 주인은 이를 알고 있어야 한다. 학교가 이 조합을 알려주는 것은 특정 사물함을 열 수 있는 권한을 부여하는 것이다. 번호 자물쇠 가운데이는 열쇠 구멍이 있고보안 전문가들은 이를 백도어 라고 부른다. 이 구멍은 내가 제어할 수 없지만 누군가 사물함을 열 수 있는 또 다른 방법이다. 백도어는 학교에서 모든 학생의 사물함을 빠르게 열 수 있도록 편의상 만든 것이고 이로 인해 모두의 보안이 나빠진다.4) 통신 보안예를 들어 오늘까지 숙제 제출 마감인데 병원 예약 때문에 직접 제출할 수 없어 친구에게 부탁한다고 가정하면 첫 번째 인증 단계를 거친다. 숙제를 부탁할 대상이 진짜 나의 친구인지 성격 나쁜 쌍둥이 동생일 수도 있다.그리고 내 손을 떠난 순간부터 온갖 일이 벌어질 수 있다. 친구가 숙제 제출을 까먹을 수도 있고 숙제를 고쳐서 답을 틀리게 하던가 나쁜 짓을 할 수도 있다. 이 경우 친구가 나의 숙제를 그대로 제출했음을 증명할 방법이 없다.(진봉성)만약 숙제를 우편으로 제출해도 되는 경우 불특정 다수가 편지를 다룰 수 있기 때문에 중간자 공격이 가능해진다. 이 경우에는 cryptography를 통해 해결할 수 있다. 메시지를 받을 수신자만 아는 비밀 코드를 사용해 암호화하여 보내면 수신자는 비밀 코드를 사용해 메시지를 복호화 한다.제대로 설계된 암호 시스템은 당사자 사이에 신뢰하는 요소의 수를 감소시킨다.5) 모던 타임즈연결된 컴퓨터 시대는 물리적 보안 문제를 통신 보안 문제와 결합시켰다. 컴퓨터와 전화는 전 지구적인 인터넷에 연결되어 있고 인터넷은 너무 큰 공격 표면이기 때문에 적어도 어느 한 곳에서는 신뢰가 깨질 것이라 예상해야 한다. 그리고 인터넷을 통한 공격자는 근본적으로 눈으로 볼 수 없다.그리고 요즘엔 공격자가 프로그램이기 더이상 사람이 아니다. 예를 들어 초인종을 누르고 도망가는 사람이 있다. 이 사람이 충분히 지속성이 있다면 이들로 인해 다른 사람이 대문의 초인종을 누르지 못할 수도 있다. 정당한 고객들이 서비스를 박지 못하게 방해하기 때문에 이런 형태의 공격을 ‘서비스 거부 공격(DoS)’이라고 부른다.오늘날 대부분 ‘분산 서비스 거부 공격(DDOS)’으로 이뤄진다. 이는 엄청나게 많은 사람이 협력해서 초인종을 누르는 상황과 비슷하다.공격자의 추적을 어렵게 하는 요인중 하나로 공격자가 proxy를 사용한다는 점이다. 몇몇 기계에 침입해서 자신의 소프트웨어를 설치하고 그 기계로 하여금 더러운 일을 하게 만든다.공격에는 주로 두 가지 유형이 있다. 1)크립토그래피 시스템 공격은 상대적으로 드물고 잘 설계된 시스템을 공격하기는 어렵다. 2)트릭을 써서 사용자가 자신의 컴퓨터에 소프트웨어를 직접 설치하게 만드는 사회적 공격현대에 생긴 또 다른 문제로는 비트를 조작하면 물리적인 반향을 일으킬 수 있게 됐다는 점이있다. 예)집에 보일러를 꺼버리거나 진공 청소기를 프로그래밍 해서 집의 고양이에게 테러를 가하거나 침입 경보기를 끄는 경우를 들 수 있다.6) 메타데이터와 감시암호화가 통신 내용을 비밀로 유지할 수 있다고 해도 단지 통신 패턴을 관찰하는 것만으로도 많은 정보를 얻을 수 있다. 편지를 보낸다고 할 때 편지 봉투의 누구에게 편지를 쓰고 누가 보내는지에 대한 정보를 메타데이터라고 한다. 이 정보는 데이터에 대한 데이터이다.누군가는 이 정보를 통해 친구의 정보를 얻을 수 있다. 현대에는 SNS를 통해 친구들의 정보를 가져가는 것이 쉬워졌다.7) 사회적 맥락보안에는 두 가지 축이 있는데 1)튼튼한 보안을 구축하기 위한 기술 2)개인의 보안과 사회 전체의 보안 사이의 트레이드 오프보안은 사회적 문제일 뿐만 아니라 각기 다른 관습과 법으로 인해 나라마다 다른 문제이기도 하다.미국 정부는 1998년 데이터 암호화 표준 (DES) 암호를 사용하라고 장려했다. 그러나 DES를 깨기 위한 Deep Crack이라는 기계가 만들어졌고 이는 정부 기관이 무능하거나 알고리즘 안전성에 대해 거짓말을 하고 있다고 증명하려는 의도에서였다.이들의 노력은 어느정도 효과가 있었다. 정부 기관의 행동을 바꾸지는 못 했지만 향상된 암호화 표준 개발의 기폭제가 되었다.8) 인증과 권한 부여인증은 어떤 사람이나 대상이 실제로 그 사람이나 대상임을 증명하는 과정이며 권한부여는 제대로 된 자격증명을 제공하지 않는 사람에게 접근을 제한하는 것이다.크립토그래피크립토그래피를 사용하면 송신자가 통신 내용을 뒤죽박죽으로 만들어서 정해진 수신자만 디코딩하도록 송신할 수 있다. 크립토그래피는 보안과 프라이버시 뿐만 아니라 암호 서명을 사용하면 데이터의 진실성을 증명할 수 있다.1) 스테가노그래피어떤 내용을 다른 내용 속에 감추는 방식을 스테가노그래피라고 부른다. 스테가노그래피는 송신자와 수신자 사이에 연결의 자취가 남지 않기 때문에 비밀리에 통신하기 좋은 방법이다.예) 영화 제작사에서 영화 리뷰어에게 개봉전 영화를 보낼 때 누구에게 보낸 영화인지 식별할 수 있는 표시를 비디오에 넣어 이를 통해 영화가 유출되면 어디서 유출됐는지를 파악할 수 있다.2) 치환 암호각 문자를 다른 문자로 변환하는 표를 만들고 이 표를 보고 메시지에서 원래의 문자를 그에 대응하는 다른 문자로 바꿔치기 하면 메시지를 암호화할 수 있다.그리고 표를 참조해 역방향으로 참조하면 암호화된 메시지를 복호화할 수 있다.치환 암호는 통계를 사용해 쉽게 깰 수 있어 좋은 방법이 아니다.3) 전치 암호메시지를 인코딩하는 또 다른 방법으로 문자 위치를 뒤섞는 것이 있다. 글자를 뒤섞는 암호 시스템을 ‘scytale’이라고 부르고, 이런 암호법을 ‘전치 암호’라고 한다.4) 더 복잡한 암호5) 일회용 패드일회용 패드는 중복되지 않는 유일한 치환 암호들의 모음으로 각 치환 암호 코드를 단 한 번만 사용했다. 일회용 패드는 제대로 사용하면 완전히 안전하지만 몇 가지 문제점이 있다. 양 당사자가 똑같은 패드를 써야 한다. 양 당사자가 서로 동기화 돼야 한다. 어떤 방식을 쓰든 수신자와 송신자는 패드에서 같은 페이지에 있는 암호를 사용해야 한다. 패턴 반복을 피하려면 패드가 메시지만큼 길어야 한다.6) 키 교환 문제점대칭 암호 시스템에는 통신의 양 당사자가 같은 열쇠를 사용해야 한다는 문제점이 있다. 즉 대칭 암호 시스템은 중간자 공격에 취약하다.7) 공개키 암호공개키 암호에서는 서로 연관된 키 쌍을 사용한다. 대칭키 암호에서는 암호화와 복호화에 모두 같은 암호를 사용했지만 공개키 암호에서는 누구에게나 알려져 있는 키를 공개키라고 부르고, 나만 알고 있어야 하는 키를 비밀키라고 부른다. 공개키 암호화 방식에서는 암호화와 복호화 키가 다르기 때문에 비대칭키 시스템이다.8) 전방향 안전성대칭키 암호 세션 키를 실제 통신에 사용할 경우 키를 발견하면 모든 메시지를 읽을 수 있다는 문제가 있다. 이를 피할 방법으로 전방향 안전성이 있다. 이는 각 메시지마다 세션 키를 새로 만들어 키를 알아내게 되도 메시지를 단 하나만 풀 수 있게 된다.9) 암호학적 해시 함수암호학적 해시 함수도 임의의 입력을 미리 정해진 범위 안의 수로 변환한다. 암호학적 해시 함수의 핵심 특성은 단방향 함수 라는 점이다. 단방향이라는 말은 입력에서 해시값을 만들어내기는 쉬워도 해시에서 입력을 만들어낼 수는 없거나 만들어내려면 비용이나 시간이 많이 들어서 비실용적이라는 뜻이다.또 암호학적 해시 함수는 도용하기가 어려워야 한다. 해시를 만들어내는 입력 데이터를 알아내기가 아주 어려워야 한다. 다시 말해 해시 충돌을 만들어내기가 아주 어려워야 한다는 뜻이다. 오랫동안 MD5 해시 함수가 널리 쓰였으나 현재는 SHA 알고리즘을 변형한 다른 해시 알고리즘이 대신 쓰이고 있다.10) 디지털 서명크립토그래피를 사용하면 디지털 서명을 통해 데이터가 진본임을 검증할 수 있다. 디지털 서명은 정합성, 부인방지, 인증을 제공한다.정합성 검증은 메시지가 변조 됐는지 검증할 수 있다는 뜻이다. 데이터의 암호학적 해시값을 계산해 데이터 뒤에 추가함으로써 이뤄지나 누구나 메시지 뒤에 해시를 붙일 수 있다. 따라서 송신자는 해시를 자신의 비밀키로 암호화해서 메시지 뒤에 덧붙인다. 수신자는 공개키를 통해 해시를 복호화할 수 있다.부인 방지는 메시지를 보낸 사람이 자기가 그런 메시지를 보낸 적이 없다고 주장할 수 없다는 뜻이다. 비밀키로 메시지에 서명을 하기 때문에 보낸 사람이 자신이 서명했음을 부인하기 어렵다.11) 공개키 인프라오늘날 HTTPS에서는 공개키를 브라우저에 저송하고 브라우저는 인증된 사용자만 복호화할 수 있도록 데이터를 암호화한다. 이런 인프라에는 신뢰할 수 있는 제 3자인 인증기관이 있어 키가 어떤 당사자의 것임을 인증해준다. 하지만 인증기관이 해킹될 수도 있고, 실수로 비밀키를 공개할 수도 있다는 문제점이 있다.12) 블록체인블록체인은 복잡한 수학으로 뒷받침된 아주 간단한 아이디어에서 비롯됐다. 블록체인은 은행 계좌와 비슷한 장부를 관리하는 매커니즘으로 생각할 수 있다. 장부의 문제점은 위조하기 쉽다는데 있다.블록 n의 내용을 변경하면 그 블록의 해시가 바뀌기 때문에 블록 n+1에 저장된 해시와 일치하지 않게 된다. 암호학적 해시의 특성으로 인해 블록이 해시를 유지하면서 쓸모 있게 블록 정보를 변조할 가능성은 거의 없다.13) 패스워드 관리예전에는 컴퓨터 안에 있는 패스워드 파일에 패스워드가 평문으로 저장됐다. 패스워드가 노출되기 쉬워 보안에 취약했다. 해법은 패스워드를 암호학적 해시와 같은 암호화된 형태로 저장하는 것이다. 로그인 시도시 패스워드를 암호학적 해시로 변환해서 파일에 있는 해시와 비교한다.오늘날 은행, 학교, 여러 온라인 상점 등에 대해 수없이 많은 패스워드를 기억해야 한다. 대부분의 사람들은 똑같은 패스워드를 모든 곳에 사용해서 이런 문제를 해결한다. 그래서 한 사이트가 공격에 함락당하면 다른 사이트에서도 같은 패스워드를 사용할 수 있게 된다.보안을 위한 소프트웨어 예방 조치1) 올바른 대상을 보호하라모든 대상을 안전하게 유지하고픈 유횩에 빠지기가 쉽다. 하지만 모든 대상을 안전하게 하는 것은 좋은 생각이 아니다. 예) 안전할 필요가 없는 것을 보는 경우에도 사용자의 로그인이 필요한 경우, 밖에서 로그인하고 자리를 비웠을때 다른 사람이 안전한 정보에도 접근하기 쉬워진다.2) 로직은 세 번 체크하라로직에 있는 오류를 공격에 활용할 수 있다. 특히 공격자가 소스 코드를 볼 수 있고 내가 찾지 못한 버그를 찾을 수 있다면 공격에 성공할 가능성이 더 커진다.3) 오류를 검사하라작성한 코드는 시스템 콜이나 라이브러리 함수를 호출한다. 이런 호출이 잘못되면 대부분의 경우 오류 코드를 반환받는다. 이것을 무시하지 말자 조용히 실패하거나 메모리 경계를 넘기는 라이브러리를 피하자4) 공격 표면을 최소화 하라5) 경계 내부에 머물러라6) 좋은 난수를 생성하기는 힘들다크립토그래피에는 좋은 난수가 중요하다. 가장 흔히 쓰이는 난수 생성기는 실제로는 의사 난수를 생성한다. 의사 난수는 같은 숫자에서 시작하면 같은 순서로 난수가 생성된다.보안 전문가들은 하드웨어 난수 생성기를 신뢰할 수 없다는 사실을 발견했다. 그래서 프로그램과 무관한 키보드를 누르는 시간의 차이, 디스크 접근 속도, 마우스 움직임 같은 임의의 이벤트에서 엔트로피를 수집한다.보안이 좋은 난수에 의존해야 한다면 난수를 생성하는 시스템을 반드시 이해해야만 한다.7) 네 코드를 알라큰 프로젝트에서는 서드파티 코드가 들어가는 경우가 자주 있다. 서드파티 코드는 프로젝트 팀이 아닌 제 3자가 작성한 코드를 말한다. 그리고 이때 서드파티 코드의 소스 코드에 접근할 수 없는 경우가 많다.서드파티 코드를 사용하면 제품에 쓰이지 않는 코드가 꽤 많이 제품에 포함된다. 이로인해 많은 문제가 발생할 수 있다. 서드파티 코드를 사용해도 안전한 경우는 오픈소스가 나을 수 있다. 누구나 실제 코드를 들여다 볼 수 있어 버그를 발견할 가능성이 더 높다. 제3자 패키지에서 실제로 사용하는 코드의 크기와 전체 패키지 크기 사이의 비율을 주시하자8) 극단적인 영리함은 여러분의 적이다서드파티 코드를 사용한다면 이상하고 영리한 기능은 피하라 많은 고객이 쓰지 않는 기능을 벤더가 더 이상 지원하지 않을 수도 있다.9) 눈에 보이는 것을 이해하라민감한 데이터를 다른 프로그램이 접근할 수 있는지 생각해보자 이 부분은 위협 모델을 정의할 때 중요한 부분이다.코드를 안전하게 하는 일 외에 사이드 채널 공격에 주의를 기울여야 한다. 사이드 채널 공격은 프로그램 구현의 메타데이터나 부작용에 기반을 둔 공격 방법이다. 예) 은행 자동 입출금기에서 키패드를 향하고 있는 카메라가 있는 경우 사이드 채널 공격일 수 있다.10) 과다수집하지 마라정말 필요한 경우가 아니라면 민감한 정보를 수집하지 마라11) 모아두지 마라민감한 정보를 수집했다면 가능한한 빨리 민감한 정보를 없애라12) 동적 메모리 할당은 여러분의 친구가 아니다13) 가비지 컬렉션도 여러분의 친구가 아니다14) 코드 역할을 하는 데이터데이터를 실행할 수 있는 프로그램은 보호 장치가 없기 때문에 직접 이런 보호를 제공해야 한다.예로 SQL injection 공격이 있다." }, { "title": "12장 병렬성과 비동기성", "url": "/posts/12%EC%9E%A5-%EB%B3%91%EB%A0%AC%EC%84%B1%EA%B3%BC-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%84%B1/", "categories": "BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍", "tags": "computer", "date": "2022-06-20 23:17:33 +0900", "snippet": "경합 조건이란 무엇인가경합 조건은 2개의 프로그램이 같은 자원에 동시에 접근하고, 자원 사용 순서에 따라 결과가 달라지는 경우를 뜻한다. 예를 들어 은행 계좌에 돈을 입금하는 경우 공유자원은 계좌 잔고다.공유 자원메모리는 항상 공유 문제와 연관된다. 공유 대상이 메모리가 아닌 경우에도 메모리가 관련된 경우가 많다.I/O 장치를 서로 공유하는 경우는 흔하다. 한 예로 프린터기기가 있다. 그리고 FPGA가 새로운 공유 대상 자원으로 떠오르고 있다.프로세스와 스레드운영체제는 프로세스를 관리하고, 프로세스는 사용자 공간에서 실행되는 프로그램이다. 멀티 코어 시스템에서는 여러 프로그램이 병렬로 실행될 수 있다. 자원을 공유하는 프로세스들은 어떤 방식으로든 서로 통신을 해야 한다.때로 프로세스가 여러 가지 일에 신경써야 할 수도 있다. 예를 들면 프린트 서버는 프린터 문서 출력을 처리하는 동시에 다른 프로그램이 자신에게 통신하는 것도 신경을 써야 한다.1980년대 더 쉽게 컴퓨터끼리 통신이 가능하게 해주는 네트워크 관련 코드가 개발 됐다. 핵심은 프로그램이 여러 곳에서 들어오는 활동이나 동작을 기다리며 대기하가 적절한 핸들러를 호출할 수 있게 된 것이다.하지만 GUI를 통한 대화식 프로그램으로 인해 상황이 달라졌다. 중간에 사용자의 입력을 기다리느라 핸들러가 중간에 대기해야 하는 경우가 많이 생겼다.필요한 것은 핸들러를 인터럽트할 수 있게 만드는 것이다. 핸들러가 실행하는 중간에 잠시 실행을 중단하고 상태를 저장하고, 나중에 그 위치로 돌아와 실행을 재개할 수 있다는 뜻이다. 저장할 상태는 스택에 있다.하지만 프로세스당 스택은 하나만 있다.스레드는 정적인 데이터와 힙을 공유하지만 자체적으로 스택을 갖는 프로그램의 일부분을 말한다. 한 스레드에서 다른 스레드로 실행이 넘어갈 때는 스레드 스케줄러가 CPU 레지스터를 저장해야 한다.스레드를 사용하면 한 프로세스 안에서 경합 조건을 만들 수 있기 때문에 흥미롭다. 하지만 스레드를 남용하면 여러가지 나쁜 경험을 야기할 수 있다. 스레드는 데이터를 공유하여 보안문제가 발생할 수 있다. 한 탭에서 문제가 발생하면 전체 프로세스가 멈춰버린다. 어떤 스레드가 작업을 완료하는 데 너무 오랜 시간이 걸리면 다른 모든 스레드가 실행되지 못해서 문제가 생길 수 있다.락코드에서 중요한 부분을 상호 배제 메커니즘을 통해 원자적으로 처리하게 만들어야 한다. 이런 목표를 프로그램이 충돌을 피하기 위해 따르는 어드바이저리 락을 만들어서 달성한다. 어느 쪽이 락을 먼저 얻었다면 다음 프로그램은 락이 해제될 때까지 기다려야 한다.1) 트랜잭션과 작업 크기성능을 향상할 가장 좋은 방법은 여러 연산을 한 트랜잭션에 넣는 것이다. 트랜잭션에 들어 있는 모든 연산은 모두 다 성공하거나 모두 다 실패한다.2) 락 대기블로킹이라는 말은 시스템이 락을 할당할 수 있을 때까지 락을 요청한 프로그램을 일시중단 시킨다는 뜻이다. 논블로킹이라는 말은 프로그램이 계속 실행되고 나중에 락을 얻었는지 여부를 어떤 방식으로든 통지 받게 된다는 뜻이다.3) 교착상태교착상태의 원인 상호 배제 : 공유 자원을 함께 사용할 수 없어서 어느 한 프로세스가 독점적으로 사용해야만 한다. 점유 대기 : 프로세스들은 어느 자원을 점유한 상태에서 다른 자원을 요청한다. 비선점 : 프로세스가 할당받은 자원을 강제로 빼앗을 수 없다. 순환 대기 : 각 프로세스가 서로 순환적으로 다른 프로세스가 갖고 있는 자원을 요구한다.4) 단기 락 구현여러 프로세서가 락게 사용하기 위한 ‘검사 후 설정’ 이라는 명령어를 제공한다. 이 명령어는 어떤 메모리 위치에 들어 있는 값을 1로 설정하고, 원래 그 위치에 들어 있던 값을 돌려준다. 처음 이 메모리에는 0이 들어있어야 한다. 둘 이상의 프로세서가 이 명령어를 사용하게 되면 한 프로세서는 0을 반환하지만 나머지 프로세서는 1을 반환한다. 따라서 이 명령어는 락을 직접 구현해 준다.다른 방법으로 비교 후 바꾸기가 있다. 이는 명령어를 호출하는 쪽에서 예전 값과 새 값을 모두 제공한다. 예전 값이 메모리 위치에 들어 있는 현재 값과 일치하면 메모리의 값을 새로운 값으로 바꾸고 프로세스는 락을 얻는다.5) 장기 락 구현아주 오랫동안 락을 소유하고 싶을 때 장기간 락은 메모리보다 좀 더 영구적인 저장소에 저장돼야 한다. 이런 락은 파일을 사용해 구현되는 경우가 자주 있다.브라우저 자바스크립트자바스크립트는 사용자 이벤트에 응답하는 짧은 프로그램을 실행하기 위해 만들어졌기 때문에 자바스크립트 구현은 이벤트 루프 모델을 사용한다. 실행할 작업을 이벤트 큐에 추가하고 큐에서 한 번에 하나씩 꺼내서 실행한다.자바스크립트가 처음 등장했을 당시 비동기 통신을 언어 설계에 포함하지 않았다. 그러나 문서객체모텔(DOM)의 등장과 XHR(AJAX의 기반)의 등장으로 기존의 페이지 로드 모델에서 벗어나 백그라운드에서 브라우저와 서버가 통신할 수 있게 됐다.비동기 통신을 하게되면 프로그램이 순서대로 실행되지 않는다.비동기 함수와 프로미스자바 스크립트의 프로미스는 비동기 콜백 매커니즘을 언어 고유 기능으로 넣어서 라이브러리가 잘못 비동기 연산을 구현하지 못하게 한다.프로미스에 비동기 연산을 수행하는 함수를 넘긴다. 이 함수는 두 함수를 인자로 받고 첫 번째 함수는 비동기 연산이 성공적으로 종료하면 호출하는 함수(resolve), 두 번째 함수는 비동기 연산이 실패하면 호출해야하는 함수(reject)이다.프로미스에 넘기는 함수는 비동기 연산을 수행하고, 수행 성공이나 실패에 따라 resolve, reject를 호출하면 자바스크립트가 이를 이벤트 큐에 넣는다. 그러면 then 메서드를 사용하여 프로미스를 실행한다.프로미스를 사용하는 이점은 프로미스는 체이닝이 가능해서 someting().then().then()…. 스타일의 코드를 작성할 수 있다.또 다른 비동기 방법으로 async, await이 있다." }, { "title": "11장 성능 향상을 위한 알고리즘 기법", "url": "/posts/11%EC%9E%A5-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B8%B0%EB%B2%95/", "categories": "BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍", "tags": "computer", "date": "2022-06-18 22:57:22 +0900", "snippet": "계산을 효율적으로 하는 것보다 더 나은 방법이 바로 계산을 전혀 하지 않는 것이다. 계산을 피하는 방법으로는 지름길(shortcut)와 근사값 계산 (approximating)표 찾기1) 변환2) 텍스처 매핑비디오 게임이나 영화 등에서 진짜처럼 보이는 이미지를 만들기 위해 사용하는 텍스처 매핑에서 표 찾기 기법이 중요한 역할을 한다. 텍스처 매핑의 문제점은 벽을 표현한다고 했을 때 벽돌 모양은 벽에서 플레이어가 얼마나 멀리 떨어져 있느냐에 따라 바뀔 필요가 있다.거리에 따라 텍스처를 조정하는 일은 복잡하다.3) 문자 종류 판별표 찾기 방식은 프로그래밍 언어의 라이브러리 추가에도 큰 영향을 끼쳤다. 어떤 글자가 숫자, 문자 등 어떤 분류에 속하는지 판별하는 문제인 문자 종류 판별이 어휘 분석에서 중요한 부분이라는 사실을 설명했다.정수를 사용한 계산 방법정수의 덧셈이나 뺄셈은 비용이 싸다. 그리고 곱셈이나 나눗셈, 부동소수점의 연산은 비싸다고 여겨진다.1) 직선416p~422p2) 곡선 다루기423p~426p3) 다항식재귀적 분할1) 나선수학에서 각도를 도 단위로 측정하는데 다른 방법으로 radian이 있다. 360도 원은 2𝛑라디안이 들어있다. 180도는 𝛑라디안, 90도는 𝛑/2라디안 … 이다. 자바스크립트 등에서 제공하는 수학 라이브러리에 있는 삼각 함수는 라디안 단위로 각도를 입력받는다.나선을 그리는 코드를 작성해보면 중심 근처에서는 그림이 좋아보이지만 밖으로 나감에 따라 상태가 나빠진다. 필요에 따라 더 많은 점을 계산할 방법이 필요하고 여기서 재귀적 분할이 제 역할을 할 수 있다.두 각도 사이에 선을 그리는데 두 점이 가깝지 않다면 각도 차이를 반으로 줄여서 재시도하는 과정을 두 점이 충분히 가까워질 때까지 재귀적으로 수행한다.2) 구성적인 기하쿼드트리는 공간을 분할하는 계층적 매커니즘이기 때문에 재귀를 활용한 데이터 구조다.431p~439p3) 시프트와 마스크439p~441p계산을 회피하는 그 밖의 수학적 기법들1) 멱급수 근사값 계산441p~442p2) CORDIC 알고리즘좌표 회전 디지털 컴퓨터 (CORDIC) 알고리즘은 B-58 폭격기 항법 시스템의 아날로그 부품을 좀 더 정확한 것으로 대신하기 위해 만들어졌다.442p~448p무작위성과 관련 있는 예제들컴퓨터에서 완전한 난수를 계산하기는 아주 어렵다 난수를 만들려면 어떤 공식을 기반으로 생성해야 하는데 정해진 공식으로 생성한 난수는 반복적일 수밖에 없다.1) 공간을 채우는 곡선이탈리아 수학자인 주세페 페아노는 최초로 공간을 채우는 곡선의 예제를 제시했다.2) L 시스템매치될 패턴을 기술하는 대신 힐베르트 곡선 규칙에 사용한 규칙은 어떤 패턴을 만들어 낼지 기술한다. 이런 규칙을 L 시스템, 린덴마이어 시스템 또는 어떤 것이 생성될지를 기술하기 때문에 생성 문법이라고 부른다.3) 스토캐스틱 기법스토캐스틱이라는 말은 랜덤이라는 말로는 충분치 않을 때 쓸 수 있는 말이다. 컴퓨터 그래픽에 임의성을 추가하는 방법이 나왔는데 약간의 임의성을 추가하면 다양성이 늘어난다.4) 양자화양자화는 원래 이미지에 있는 색에 대해 변환될 이미지에서 쓸 수 있는 색을 할당해야 한다는 뜻이다. 임계화는 미리 어떤 한계값을 정하고 그보다 더 밝은 값을 흰색으로, 더 어두운 값을 검은색으로 지정하는 방식이다.망점인쇄는 이미지를 여러 크기의 점으로 분해하여 이미지를 축소하면 음영으로 해석된다.454p~464p" }, { "title": "9장 웹 브라우저", "url": "/posts/9%EC%9E%A5-%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80/", "categories": "BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍", "tags": "computer", "date": "2022-06-16 22:42:35 +0900", "snippet": "웹 브라우저는 그 자체가 가상 머신이다. 브라우저는 크고 복잡한 애플리케이션인 동시에 소프트웨어로 구현된 프로그래밍할 수 있는 컴퓨터이다.마크업 언어마크업은 텍스트와 구분할 수 있는 mark를 추가할 수 있는 시스템이다. 마크업 언어는 새로운 개념이 아니고 컴퓨터가 생기기 전부터 마크업 언어가 있어왔다.많은 마크업 언어가 있고 웹 페이지는 이와 같은 그냥 텍스트 파일에 지나지 않는다.확장 가능한 마크업 언어(XML)은 좀 더 실용적인 SGML의 하위 집합이고 브라우저들은 나중에 XML을 지원하게 됐다.균일 자원 위치 지정자브라우저는 균일 자원 지정자(URL)를 사용해 HTTP 프로토콜을 통해 서버에게 문서를 요청한다. 서버는 문서를 브라우저에게 보내고 브라우저는 문서를 표시한다.URL은 일정한 구조를 따르는 텍스트 문자열이다. 스킴은 통신 매커니즘을 표시한다. 그리고 통신하려는 서버가 호스트, 문서는 경로가 가리키는 위치에서 추출된다.HTML 문서최초의 웹 페이지는 HTML로 작성됐고, HTML은 하이퍼텍스트를 활용한다. 그리고 하이퍼텍스트는 웹 페이지 등 다른 대상에 대한 링크가 들어 있는 텍스트를 말한다.HTML에서 부등호 (&lt;)는 특별한 힘을 갖고 있다. 이 부등호는 마크업 엘리먼트를 시작한다. 그리고 시작하는 tag가 있으면 끝나는 /tag도 들어있다.그리고 HTML에는 &lt; 의 특별한 능력을 빼앗을 수 있는 비책이 있다. ‘엔티티 참조’는 문자를 다른 문자열로 표현하는 방법이다.DOM: 문서 객체 모델웹 브라우저는 문서를 DOM에 따라 처리한다. 일련의 엘리먼트들이 다른 엘리먼트를 둘러써고 있는 것으로 웹 페이지를 생각할 수 있다.1) 트리 관련 용어2) DOM 처리문서트리로 할 수 있는 일은 깊이 우선 순회를 하면서 트리를 해석하는 일이다. 종단 노드에 도달할 때까지 순회를 계속하고, 종단 노드의 부모로 돌아가 방문한 적이 없는 다음 자식을 찾는다.방문하는 순서는 HTML을 작성한 순서를 따른다. 그리고 깊이 우선 순회는 스택을 사용하는 또 다른 예이기도 하다.CSS화면의 시각적 효과가 중요해지면서 HTML을 작성하는 사람이 페이지가 표시되는 모습을 더 세밀하게 조정할 수 있도록 갖가지 기능이 추가됐다. 원래 HTML에도 스타일 정보가 들어있었다. 하지만 웹 페이지가 핸드폰, 데스크탑에 이르는 광범위한 장치에 표시될 수 있기 때문에 이런 접근 방법은 제대로 작동하지 않았다.Cascaging Style Sheets(CSS)는 HTML에서 스타일 정보를 분리해서 HTML을 한 번만 작성해도 대상 장치에 따라 여러 스타일을 적용할 수 있게 했다. CSS는 selector라고 하는 DOM의 엘리먼트 위치를 지정하므로 구성요소를 어떻게 구성하느냐가 중요하다.XML 등의 마크업 언어HTML은 웹 페이지라는 구체적인 응용을 위해 만들어지고, XML은 더 일반적인 용도의 마크업 언어로 다양한 응용 분야가 있다.&lt;xml&gt; &lt;garden&gt; &lt;vegetable&gt; &lt;name&gt;tomato&lt;/name&gt; &lt;variety&gt;Cherokee Purple&lt;/variety&gt; &lt;days-until-maturity&gt;80&lt;/days-until-maturity&gt; &lt;/vegetable&gt; &lt;/garden&gt;...&lt;/xml&gt;누구나 원하는 대로 마크업 언어를 작성할 수 있어 충돌이 발생할 수 있다.&lt;xml&gt; &lt;garden&gt; &lt;vegetable&gt; &lt;name&gt;tomato&lt;/name&gt; &lt;variety&gt;Cherokee Purple&lt;/variety&gt; &lt;days-until-maturity&gt;80&lt;/days-until-maturity&gt; &lt;name&gt;Purple Tomato Salad&lt;/name&gt; /* 충돌 발생 */ &lt;/vegetable&gt; &lt;/garden&gt;...&lt;/xml&gt;위 예에서 name 엘리먼트가 채소마크업언어인지 레시피 마크업언어인지 구분할 방법이 없다. 이를 구분하기 위한 방법으로 namespace가 있다.&lt;xml xmlns:vml=\"http://www.garden.org\" xmlns:rml=\"http://www.recipe.org\"&gt; &lt;vml:garden&gt; &lt;vml:vegetable&gt; &lt;vml:name&gt;tomato&lt;/vml:name&gt; &lt;vml:variety&gt;Cherokee Purple&lt;/vml:variety&gt; &lt;vml:days-until-maturity&gt;80&lt;/vml:days-until-maturity&gt; &lt;rml:name&gt;Purple Tomato Salad&lt;/rml:name&gt; &lt;/vml:vegetable&gt; &lt;/vml:garden&gt;...&lt;/xml&gt;XML 등의 마크업 언어HTML은 웹 페이지라는 구체적인 응용을 위해 만들어지고, XML은 더 일반적인 용도의 마크업 언어로 다양한 응용 분야가 있다.&lt;xml&gt; &lt;garden&gt; &lt;vegetable&gt; &lt;name&gt;tomato&lt;/name&gt; &lt;variety&gt;Cherokee Purple&lt;/variety&gt; &lt;days-until-maturity&gt;80&lt;/days-until-maturity&gt; &lt;/vegetable&gt; &lt;/garden&gt;...&lt;/xml&gt;누구나 원하는 대로 마크업 언어를 작성할 수 있어 충돌이 발생할 수 있다.&lt;xml&gt; &lt;garden&gt; &lt;vegetable&gt; &lt;name&gt;tomato&lt;/name&gt; &lt;variety&gt;Cherokee Purple&lt;/variety&gt; &lt;days-until-maturity&gt;80&lt;/days-until-maturity&gt; &lt;name&gt;Purple Tomato Salad&lt;/name&gt; /* 충돌 발생 */ &lt;/vegetable&gt; &lt;/garden&gt;...&lt;/xml&gt;위 예에서 name 엘리먼트가 채소마크업언어인지 레시피 마크업언어인지 구분할 방법이 없다. 이를 구분하기 위한 방법으로 namespace가 있다.&lt;xml xmlns:vml=\"http://www.garden.org\" xmlns:rml=\"http://www.recipe.org\"&gt; &lt;vml:garden&gt; &lt;vml:vegetable&gt; &lt;vml:name&gt;tomato&lt;/vml:name&gt; &lt;vml:variety&gt;Cherokee Purple&lt;/vml:variety&gt; &lt;vml:days-until-maturity&gt;80&lt;/vml:days-until-maturity&gt; &lt;rml:name&gt;Purple Tomato Salad&lt;/rml:name&gt; &lt;/vml:vegetable&gt; &lt;/vml:garden&gt;...&lt;/xml&gt;XML 문서로부터 파스 트리를 만들어주는 라이브러리도 많다. 예로 문서 타입 정의 DTD를 들 수 있다. DTD는 XML처럼 보이는 문서이며 마크업 업어 문법에 맞는 엘리먼트가 어떻게 생겼는지 정의할 수 있다.또 XML 경로 언어(XPath)는 XML 문서에 대한 실렉터를 제공한다. XPath는 확장 가능한 스타일 시트 언어 변환 (XSLT)의 중요한 일부분이기도 하다.자바스크립트HTML로 작성된 웹 페이지는 정적이었다. 그래서 브라우저에 표시중인 내용을 변경하려면 새로운 URL을 웹 서버에 요청해서 새 문서를 받아오는 방법뿐이었다. 1995년 넷스케이프에서 자바스크립트를 소개했고 이후 ECMA-262로 표준화 되었다.자바스크립트는 DOM을 직접 변경하고 직접 웹 서버와 통신할 수 있다. 서버와의 상호작용은 비동기 자바스크립트와 XML 즉 AJAX를 통해 이뤄진다. script 태그를 HTML 문서에 포함시켜 사용할 수 있다.&lt;script&gt; window.onload = function() { var big = document.getElementsByTagName('big'); big[0].style.backgroud = \"green\"; }&lt;/script&gt;jQueryDOM 함수는 2가지 문제점이 있다. 1)DOM 함수 동작이 브라우저마다 다를 수 있다. 2)DOM 함수를 사용하기 상당히 불편하다.jQuery는 위 두 가지 문제를 해결해 준다.&lt;script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-3.2.1.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $(function() { $('big').css('backgroud', 'green'); });&lt;/script&gt;jQuery를 사용하려면 먼저 script 태그에 import를 해주어야 한다.SVG크기변경이 가능한 벡터 그래픽스(SVG)는 브라우저가 지원하는 마크업 언어에 속한다. SVG는 멋진 그래픽과 텍스트를 만들 수 있도록 지원하지만, 브라우저에서 사용 가능한 그 밖의 마크업 언어와는 완전히 다른 언어다.HTML 5HTML5는 HTML의 최신 구현으로 여러 시맨틱 엘리먼트가 추가 됐다. 이런 엘리먼트들은 문서의 구조에 일관성을 더해준다. 또 canvas가 추가 됐고, SVG와 비슷하지만 캔버스는 캔버스를 위해 만들어진 새로운 자바스크립트 함수를 통해 조작해야만 한다는 점이 다르다.또 audio, video 엘리먼트도 추가되어 오디오와 비디오를 다루는 표준적인 매커니즘을 제공한다.JSONJSON은 자바스크립트 객체 표기법을 줄인 말로 자바스크립트 객체를 사람이 읽기 쉬운 방식으로 표현한 것이다." }, { "title": "8장 프로그래밍 언어 처리", "url": "/posts/8%EC%9E%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4-%EC%B2%98%EB%A6%AC/", "categories": "BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍", "tags": "computer", "date": "2022-06-14 22:42:35 +0900", "snippet": "어셈블리 언어초기에는 컴퓨터 프로그래머들이 프로그램의 각 명령에 대한 비트 조합을 하나하나 알아내야 했다. 그래서 프로그램을 작성하는 더 나은 방법을 고안해내기 위해 나타난 것이 어셈블리 언어이다.어셈블리 언어를 사용하면 프로그래머가 모든 비트 조합을 외우지 않고 이해하기 쉬운 mnemonics을 통해 명령어를 쓸 수 있다. 그리고 주소에 이름(label)을 붙일 수 있고, 코드에 주석을 달아서 다른 사람들이 프로그램을 더 쉽게 읽고 이해하도록 도와줄 수 있다.이런 어셈블리 언어를 기계어 코드를 생성해 주는 프로그램을 어셈블러라고 부르고 어셈블러는 레이블이나 심볼의 값을 결정해 채워 넣어준다.고수준 언어고수준 언어는 어셈블리 언어보다 더 높은 추상화 단계에서 작동한다. 고수준 언어의 소스 코드는 컴파일러라는 프로그램에 의해 실행된다. 컴파일러는 소스코드를 기계어로 번역(컴파일)해준다.대표적으로 포트란, 베이직 등이 있다.구조적 프로그래밍포트란, 베이직 언어는 비구조적 언어라고 불린다. 구조적 프로그래밍은 스파게티 코드 문제를 해결하기 위해 개발됐다. 대표적으로 C, 파스칼, 자바 등이 있다.어휘 분석어휘 분석은 코드를 기호로부터 단어와 같은 성격의 토큰으로 변환하는 과정이다.1) 상태기계상태로 이뤄진 집합과 한 상태에서 다른 상태로 전이되는 원인의 목록으로 이뤄진 상태 기계로 만들 수 있다.2) 정규식언어를 지정하기 위한 언어를 정의하는 방법으로 정규식이 나타났다. 정규식은 패턴 매칭에서 중추적 역할을 한다.단어에서 문장으로언어를 처리하려면 어휘 분석만으로 충분하지 않다. 여러 단어를 모아서 어떤 문법에 맞는 문장으로 분석할 필요가 있다. 예를 들어 1+2, a=5는 문법에 맞지만 1+++2는 문법에 맞지 않는다. 패턴 매칭이 필요한데 문자 시퀀스에 대한 패턴 매칭이 아니고 토큰으로 이뤄진 시퀀스에 대한 패턴 매칭이 필요하다.yacc 프로그램은 스택을 사용하는 시프트-리듀스 파서다. 시프트는 토큰을 스택에 넣는다는 뜻이고 리듀스는 스택의 맨 위부터 매치된 토큰들을 스택에 넣는다는 뜻이고, 리듀스는 스택의 맨 위부터 매치된 토큰들을 다른 어떤 것으로 대치한다는 뜻이다.누구나 프로그래밍 언어를 만들 수 있는 시대파스 트리고수준 언어를 실행하는 방법이 컴파일만 있지는 않다. 고수준 언어를 컴파일할 수도 있지만 인터프리트할 수도 있다. 인터프리터는 컴파일과 다르게 실제 기계에 사용할 기계어를 만들어내지 않는다. 대신 가상 머신에서 실행된다.일반적으로 컴파일이 된 코드는 기계어이기 때문에 더 빠르게 실행된다. 마치 영어책을 한국어로 번역하는 것과 같다. 인터프리터에 의해 실행되는 코드는 마치 누군가 영어로된 책을 보면서 한국어로 즉시 번역해 읽어주는 것처럼 수명이 짧다.일반적으로 컴파일러나 인터프리터는 파스 트리를 구성한다.인터프리터컴파일러코드 생성기는 특정 대상 기계에 대한 기계어 코드를 만들어 낸다.최적화대부분의 언어 도구에는 최적화기라는 추가 단계가 파스 트리와 코드 생성기 사이에 들어간다. 최적화기는 파스 트리를 분석하고 이 결과를 활용해 더 효율적인 코드를 생성해내도록 파스 트리를 변환한다.하드웨어를 다룰 때 주의하라" }, { "title": "7장 데이터 구조와 처리", "url": "/posts/7%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%B2%98%EB%A6%AC/", "categories": "BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍", "tags": "computer", "date": "2022-06-11 23:40:35 +0900", "snippet": "기본 데이터 타입프로그래밍 언어에는 다양한 기본 데이터 타입을 제공한다. 이런 타입에는 크기(size)와 해석이라는 두 가지 측면이 존재한다.1964년 포인터를 발명했다. 포인터는 단지 컴퓨터 아키텍처에 따라 결정되는 크기의 부호가 없는 정수에 불과하며 정숫값이 아니라 메모리 주소로 해석된다. 포인터를 통하여 원하는 값이 있는 위치를 알 수 있다.포인터는 C언어가 인기를 끌면서 유명세를 탔고 일부 언어는 잘못된 포인터 사용으로 인한 오류를 막기 위해 참조라는 더 추상적인 개념을 구현하기도 한다.배열프로그래밍 언어는 배열을 지원한다. 배열은 마치 아파트와 같다. 아파트 한 동에는 주소가 있고, 동 안의 각 집에는 번호가 있다. 프로그래머는 이 호수를 인덱스라고 부르고 각각의 집을 원소(element)라고 부른다.일반적인 컴퓨터 개발 규정에는 배열 원소의 타입이 모두 같아야 한다고 정해져 있다.배열에서 각 원소는 0번째 원소의 주소인 기저 주소로부터 얼마나 멀리 떨어져 있는지를 나타내는 오프셋으로 지정할 수 있다. 프로그래밍 언어는 다차원 배열을 지원하기도 한다. 다차원 배열이 메모리에 어떻게 저장되는지 잘 알아야 한다.예) 4 X 3 2차원 아파트 건물 집집마다 전단지를 돌린다고 할때 1)[0,0], [0,1], [0,2], [1,0], [1,1], [1,2]….순으로 방문 2)[0,0], [1,0], [2,0], [0,1], [1,1], [2,1]…순으로 방문두 번째 방식이 첫 번째 방식보다 지역성이 좋고 힘도 덜 든다. 열 인덱스가 1 바뀌면 [0,0] -&gt; [0,1] 인접한 메모리 위치에 있는 원소로 이동하지만 행 인덱스가 1 바뀌면 [0,0] -&gt; [1,0] 인접한 행으로 이동해야 하기 때문에 연속적인 메모리 공간상으로는 배열의 열 개수만큼 떨어져있는 메모리 위치에 있는 원소로 이동해야 한다.따라서 주소 공간상에서는 열 인덱스가 바뀔 때보다 행 인덱스가 바뀔 때 더 많은 이동이 일어난다.비트맵기본 데이터 타입을 사용해 배열을 사용하는 경우 원하는 데이터를 표시하기에는 기본 데이터가 너무 클 때도 있다. 그럴때 비트의 배열인 비트맵을 사용할 수 있다.비트맵에 대해 수행할 수 있는 기본 연산은 1)비트 설정하기(set), 2)비트 지우기(clear), 3)비트가 1인지 검사하기, 4)비트가 0인지 검사하기 네 가지가 있다.정수 나눗셈을 통해 특정 비트가 들어 있는 바이트를 찾을 수 있다. 필요한 연산은 8로 나누는 것 뿐이다. 다음 단계로 비트 위치에 대한 마스크를 만들어야 한다. 마스크는 들여다볼 수 있는 구멍이 있는 비트 패턴을 말한다.배열 인덱스와 비트 마스크를 사용하면 비트맵 기본연산을 쉽게 수행할 수 있다. 또 자원이 사용 가능하거나 사용 중인지 여부를 나타낼ㄷ 때도 비트 맵을 유용하게 사용할 수 있다.문자열여러 문자로 이뤄진 시퀀스를 문자열이라고 한다. 배열과 마찬가지로 문자열을 연산할 때도 그 길이를 알아야 한다. 한 가지 접근 방법은 문자열 안에 길이를 저장하는 것이다. 하지만 이 방법은 잘 작동하지만 문자열 길이가 255자로 제한된다는 단점을 가지고 있다.C언어에서는 다른 접근 방법을 사용한다. 문자열을 위한 전용 데이터 타입을 제공하지 않고 대신 1차원 바이트 배열을 사용한다.(char) C 문자열은 길이를 저장하지 않고 대신 무자 배열에 들어있는 문자열 데이터의 끝에 바이트를 하나 추가하고 문자열의 끝을 표시하는 문자로 NUL(문자열 터미네이터)을 넣는다.이런 문자열 터미네이터를 사용하는 방식에는 장단점이 있는데 중요한 장점으로 저장이 쉽다는 점이 있고, 문자열의 끝까지 각 문자를 출력하는 일을 할 때 부가 비용이 들지 않는다는 점이 있다. 단점으로는 문자열의 길이를 알아내려면 문자열 터미네이터를 발견할 때까지 문자열을 스캔하면서 문자 수를 세야한다. 또 문자열 중간에 NUL 문자를 넣고 싶을때는 이 방법을 사용할 수 없다.복합 데이터 타입현재 대부분의 언어는 우리가 원하는대로 데이터 타입, 즉 suite를 만들 수 있는 방법을 제공한다. 이를 구조체라고 한다. 그리고 구조체 스위트 안에 있는 여러 방을 구조체의 멤버라고 한다.스위트 같은 데이터 구조 이외에 움직일 수 있는 파티션으로 구분한 사무실 같은 데이터 구조를 사용할 수도 있다. 이런 데이터 구조를 C에서는 공용체라고 부른다. 공용체를 사용하면 같은 메모리 공간이나 내용을 여러 가지 관점으로 바라볼 수 있다.구조체와 공용체의 차이점은 구조체 안의 모든 멤버는 각기 다른 메모리를 차지하지만 공용체의 멤버들은 메모리를 공유할 수 있다는 데 있다.단일 연결 리스트데이터 양이 정해져 있지 않은 경우 배열이 적합하지 않다. 배열을 충분히 크게 만들지 않으면 데이터가 늘어난 경우 새로 더 큰 배열을 만들고 기존 배열의 내용을 새 배멸로 복사해야한다. 반대로 배열의 크기를 크게 잡아놓으면 메모리를 너무 낭비하게 된다.연결 리스트는 목록에 들어갈 원소 개수를 모르는 경우 배열보다 더 잘 작동한다.next는 리스트의 다음 원소 주소를 저장하는 포인터고, 리스트에서 맨 앞은 헤드, 마지막은 테일이다. 배열과의 차이점은 배열은 메모리에 연속적으로 위치하지만, 리스트 원소는 메모리에서 아무 위치에나 있을 수 있다는 점이 있다.따라서 리스트에는 원소를 쉽게 추가할 수 있다. 삭제는 조금 복잡한데 삭제할 원소의 바로 앞 원소의 next 포인터가 삭제할 원소의 next 포인터가 가리키는 원소를 가리키게 해야하기 때문이다.동적 메모리 할당별도의 메모리 관리 유닛(MMU)가 없는 컴퓨터라면 Heap 영역이 프로그램에 사용할 수 있는 모든 데이터 메모리다. 배열 등의 변수가 사용하는 메모리는 정적이고 이런 변수에 할당된 주소는 바뀌지 않는다. 리스트 노드와 같은 존재는 동적이다. 이들은 필요에 따라 생기기도 하고 사라지기도 한다.이런 동적인 대상에 사용할 메모리를 힙에서 얻는다.프로그램은 힙을 관리할 수 있어야한다. 사용중인 메모리를 알아야 하고, 사용가능한 메모리도 알아야 한다. 이런 목적에 사용하는 라이브러리 함수가 있어 직접 구현할 필요가 없다. 대표적으로 C에는 malloc과 free 함수가 있다.경험이 적은 프로그래머는 할당하지 않은 메모리를 해제하는 실수를 자주 저지른다. 또 반대로 이미 해제된 메모리를 계속 사용하는 실수도 종종 저지르곤 한다. 할당 받은 메모리 경계 밖에 데이터를 쓰면 size와 next 필드를 오염시킬 수 있다.더 효율적인 메모리 할당텍스트 문자열이 들어있는 연결리스트는 노드에 사용할 메모리는 물론 문자열에 사용할 메모리도 할당해야 한다. 노드와 문자열을 동시에 할당하면 부가비용을 줄일 수 있다. 노드를 할당한 후 문자열을 할당하는 대신에 노드와 문자열의 크기를 합하고, 메모리 경계를 지키기 위해 필요한 패딩을 추가한 크기의 공간을 할당할 수 있다.가비지 컬렉션동적 메모리를 명시적으로 관리하면서 포인터를 잘못 쓰면 두 가지 문제가 생긴다. 1)포인터는 단지 메모리 주소를 나타내는 숫자이지만 모든 숫자가 올바른 메모리 주소는 아니다. 2)포인터를 사용해 존재하지 않은 메모리에 접근하거나 프로세서의 메모리 경계에 맞지 않는 주소에 접근하면 예외가 발생하면서 프로그램이 중단된다.자바나 자바스크립트 언어에는 포인터가 없고 직접 malloc, free를 하지 않고도 동적 메모리 할당을 지원한다. 이런 언어들은 가비지 컬렉션을 구현한다.자바 같은 언어는 포인터 대신 참조를 사용하고 참조는 포인터를 추상화해서 거의 비슷한 기능을 제공하지만 실제 메모리 주소를 노출하지 않는다.가비지 컬럭션은 언어의 런타임 환경이 변수 사용을 추적해서 더이상 사용하지 않는 메모리를 자동으로 해제해준다. 한 가지 문제점으로는 프로그래머가 가비지 컬렉션 시스템을 제어할 수 없다는 점이다. 이로인해 프로그램이 중요한 일을 하는 도중 가비지 컬렉션 시스템이 작동돼서 문제가 생기는 경우도 있다.이중 연결리스트단일 연결리스트는 delete 함수에서는 포인터를 제대로 변경하기 위해 삭제하려는 원소의 바로 앞 원소를 찾아야 한다. 이로 인해 단일 연결리스트의 delete 연산은 상당히 느리다.이중 연결리스트는 노드에 다음 원소에 대한 포인터뿐만 아니라 이전 원소에 대한 포인터도 들어있는 리스트이다. 노드당 부가 비용은 2배가 되지만 delete시 노드를 앞에서부터 방문할 필요가 없어진다.이중 연결 리스트의 장점은 리스트 전체를 방문하지 않아도 원하는 위치에 노드를 추가하거나 삭제할 수 있다는 점이다.계층적인 데이터 구조지금까지는 선형적인 데이터 구조를 살펴봤다. 선형성이 문제가 되는 경우가 있는데 데이터를 효율적으로 가져오고 싶은 경우 연결리스트 같은 경우 리스트를 순회해야만 한다. 리스트의 길이가 n이라면 최대 n번 노드를 순회하면서 원하는 노드인지 비교를 해야한다.간단한 계층적 데이터 구조는 2진 트리다. 2진이라는 말은 노드가 최대 2개의 다른 노드와 연결될 수 있기 때문에 붙은 말이다. 트리의 루트는 연결 리스트의 헤드에 해당한다.2진 트리에서 어떤 대상을 검색하는 연산은 트리 깊이에 의해 정의되는 함수다. 만약 트리가 n계층만큼 아래로 내려간다면 검색시 n번만 원소를 비교하면 된다.대용량 저장장치디스크의 기본 단위는 블록이고 연속적인 블록을 클러스터라고 한다. 클러스터는 한 트랙 안에 있는 연속적인 섹터로 이뤄지므로 데이터를 한 클러스터에만 저장할 수 있으면 좋을 것이다.일반적인 해법으로 한 클러스터에 데이터를 저장하는 방식이 그리 바람직하지 않고 한 클러스터에 들어가기에는 너무 큰 데이터도 있기 마련이다. 대신 데이터는 사용가능한 섹터가 있다면 위치와 관계없이 저장된다.어떤 데이터를 저장하기 위한 저장소 블록을 찾는 대신 어떤 데이터를 저장하기에 충분한 크기가 되도록 고정된 크기의 블록을 여럿 확보해서 데이터를 블록에 나눠 담아야 한다.파일 이름을 디스크에 저장할 방법과 파일 이름과 파일의 데이터가 저장된 디스크 블록을 연결해줄 방법이 필요한다. 블록 중 일부를 아이노드로 따로 지정하는 것이다. 아이노드는 디스크 블록에 대한 인덱스와 노드를 합친 단어다.아이노드에는 여러가지 정보가 들어간다. 그리고 파일의 데이터가 들어 있는 블록에 대한 인덱스도 포함된다.아이노드에는 보통 직접 블록 포인터가 12개 있다. 이를 통해 최대 49,152 바이트까지 데이터를 보관할 수 있다. 파일이 더 커지면 간접 블록을 사용하기 시작한다. 만약 이보다 더 큰 파일을 저장해야 한다면 2중 간접 블록을 통해 4GiB까지 3중 간접 블록을 통해 4PiB까지 지원할 수 있다.아이노드 정보 중에는 블록에 데이터가 있는지 디렉터리 정보가 있는지를 표시하는 것도 있다. 디렉터리는 다른 디렉터리를 참조할 수 있고 이로인해 트리 구조의 계층적 파일 시스템이 생겨났다.데이터베이스데이터베이스는 정해진 방식으로 조직화된 데이터 모음이다. 데이터베이스 관리시스템은 데이터베이스에 정보를 저장하고 읽어올 수 있게 해주는 프로그램이다.데이터베이스는 B 트리 데이터 구조를 활용한 시스템이다. B 트리는 균형 트리이지만 2진 트리는 아니다.인덱스인덱스의 경우 유지보수를 해야 한다는 트레이드 오프가 있다. 데이터가 바뀔 때마다 모든 인덱스를 갱신해야 한다.데이터 이동305~308p벡터를 사용한 I/O시스템 성능에 있어 데이터를 효율적으로 복사하는 것이 중요하다. 하지만 복사를 아예 피할 수 있으면 성능을 더 높일 수 있다.오디오 데이터를 오디오 장치로 보내고자 할 때 크기와 데이터에 대한 포인터로 이뤄진 벡터를 운영체제에 넘기면 된다. 운영체제는 이 벡터를 저장된 데이터를 사용해 순서대로 오디오 프레임을 조합한다.데이터를 쓰는 행위를 ‘수집’, 데이터를 읽는 행위를 ‘분산’이라고 한다.객체지향의 함정객체에는 함수에 해당하는 메서드와 데이터에 해당하는 프로퍼티가 있다. 어떤 객체에 필요한 모든 데이터와 함수는 한 데이터 구조 안에 모여 있다.객체지향 사상가들은 객체가 모든 문제를 해결할 수 있는 해답이라고 생각한다. 하지만 객체와 관련된 부가 비용이 어느정도 존재하고, 객체는 전역적으로 알려진 함수대신 자신이 사용할 메서드에 대한 포인터를 가지고 다녀야 한다.정렬데이터를 정렬해야 하는 이유는 많다. 사람을 더 찾기 쉽게 이름을 가나다 순으로 정렬한 목록을 원하거나 정렬된 형태로 데이터를 저장하고 싶은 경우도 많다. 그렇게 되면 메모리 접근 횟수를 줄여 검색을 빨리 끝낼 수 있다.해시앞선 검색 메서드는 모두 데이터 구조를 순회하면서 비교를 여러번 수행해야 했다. 경우에 따라 성능이 더 좋은 접근 방법으로 해싱이 있다. 일반적으로 검색에 사용할 키에 대해 균일하게 벽에 흩뿌려주는 해시 함수를 적용하는 것이다.해시 함수의 결과값을 사용해 키에 대응하는 데이터를 메모리에 저장할 수 있다. 또 해시 함수의 결과를 배열 인덱스로 활용하는 방법으로 해시 테이블이 있다.좋은 해시함수는 계산하기 쉬워야하고, 키를 골고루 버킷에 뿌려줘야 한다.효율성과 성능성능과 효율이 분리된 상황을 응용하는 방법으로 데이터베이스 샤딩이 있다. 샤딩은 다른말로 수평 파티셔닝이라고도 부른다. 이는 각각 다른 기계에서 실행되는 여러 샤드로 나누는 방식을 말한다.또 샤딩의 변종으로 맵 리듀스가 있다. 맵 리듀스는 근본적으로 컨트롤러가 중간 결과를 모으는 방법을 코드로 직접 작성할 수 있다." }, { "title": "6장 입출력과 네트워킹", "url": "/posts/6%EC%9E%A5-%EC%9E%85%EC%B6%9C%EB%A0%A5%EA%B3%BC-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9/", "categories": "BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍", "tags": "computer", "date": "2022-06-08 22:40:35 +0900", "snippet": "저수준 I/O가장 단순한 I/O는 CPU가 읽거나 쓸 수 있는 비트에 물건을 연결한 형태의 I/O이다.1) I/O 포트2) 버튼을 눌러라3) 빛이 있으라어떤 종류든 디스플레이가 포함된 장치가 많이 있다. (알람 시계나 식기 세척기의 디스플레이 같은) 이런 디스플레이를 제어하기 위한 소프트웨어는 아주 간단하다. 필요한 것은 숫자와 그에 따라 세그먼트의 어느 LED를 켤지 연관시켜주는 표뿐이다.이 디스플레이가 작동하게 하기 위해 사람의 시각의 잔상효과를 활용한다. 사람들이 디스플ㄹ이가 켜져 있는 것으로 인식하게 하기 위해 디스플레이를 계속 켜둘 필요는 없다. 우리의 눈과 두뇌는 1/24초보다 짧은 간격으로 깜빡거리는 경우, 빛이 켜져있는 것으로 인식한다.4) 빛 동작 그리고 상호 연동5) 밝기 조절디스플레이의 듀티 사이클을 조절함으로써 밝기를 조절할 수 있다.6) 그레이의 2ⁿ가지 그림자센서를 읽어서 모터, 바퀴 같은 회전축의 위치를 알아내야 하는 경우가 있다. 이 때 회전축의 스위치를 넣거나 광센서가 읽을 수 있는 흰색과 검은색 점을 사용해 위치를 알아낼 수 있다.어떤 접근 방법을 사용하든 축의 위치를 2진수로 인코딩해야 한다.인코더가 간단해 보이지만 기계적인 내성이 있다. 제대로 그려진 인코더를 사용한다고 해도 여전히 회로가 각 비트를 읽으면서 발생하는 전파지연으로 인한 문제가 생긴다.프랭크 그레이는 이 문제를 살펴보다가 각도가 달라질 때 비트가 하나씩만 달라지는 다른 인코딩 방법을 발명했다. 3비트 인코더에서 그레이의 이름을 딴 ‘그레이 코드’로 각도를 표현하면쉽게 2진 코드로 바꿀 수 있다.7) 쿼드 러처2비트 그레이 코드를 약간 뒤틀면 위치가 변했는지와 어떤 방향으로 변했는지를 알 필요가 있는 경우에 써 먹을 수 있다.이런 변형에는 모두 네 가지 상태가 존재하기 때문에 이를 쿼드러처 인코딩이라고 부른다. 쿼드러처에서는 2비트 그레이 코드 패턴이 여러번 반복된다.8) 병렬 통신병렬 통신은 LED를 켜는 회로를 확장한 것이다. 병렬이라는 말은 LED 컴포넌트 하나하나마다 별도의 선이 있기 때문에 동시에 모든 컴포넌트를 제어할 수 있다는 뜻이다.병렬 인터페이스는 I/O 핀, 커넥터 핀, 선이 많이 필요하기 때문에 가격이 비싸다.9) 직렬 통신1900년대 초 전신이 타자기와 결합하면서 텔레타이프가 생겼다. 텔레타이프는 한 곳에서 타이핑한 내용을 멀리 있는 프린터에서 출력하는 기계를 말한다.전송할 데이터는 직렬 프로토콜을 통해 신호선 하나로 전달되며 돌아오는 선이 하나 더 필요하다.또 반이중 연결이라는 것이 있다. 이는 송신자와 수신자가 같은 선을 공유한다. 어느 한 순간에는 한 쪽만 말할 수 있고, 둘이 동시에 말하면 의미가 통하지 않는 메시지가 생긴다.(예.무전기)반대로 전이중 통신은 선이 2개여서 각기 다른 방향으로 동시에 통신이 가능한 경우를 뜻한다.10) 파동에 올라타라마크-스페이스 방식의 신호에는 큰 문제가 있는데, 이로 인해 장거리 통신에는 마크-스페이스 방식이 적합하지 않다. 우주에는 다양한 파장이 가득 차 있고 가장 근본적인 파장은 사인파다. 다른 모든 파형은 사인파를 조합해 만들 수 있다.사인파의 높이를 진폭이라고 하고, 매초 같은 방향으로 0을 지나치는 횟수를 주파수(헤르츠)라고 한다. 같은 방향으로 0을 지나는 연속된 두 지점 사이의 거리를 파장이라고 부른다.11) 범용 직렬 버스(USB)USB는 좀더 사용하기 어렵고 호환성이 떨어지는 커넥터를 사용하며 데이터 전송보다는 장치 충전에 더 중요한 역할을 한다. 또 음향과 비디오를 등시성 전송을 통해 처리할 수 있다.네트워킹네트워크는 일반적으로 두 가지로 구분한다. 근거리 네트워크(LAN) 집이나 사무실 같이 좁은 지리적 영역을 묶는다, 광역 네트워크(WAN)은 더 넒은 지리적 영역을 묶는다.초기 컴퓨터 네크워크는 반자동 지상환경의 일부분으로 전화 네트워크와 모뎀을 사용해 각 지점 사이의 통신을 수행했다. 벨 연구소에서 개발된 UUCP라는 일련의 컴퓨터 프로그램이 배포되고 이를 사용하여 컴퓨터가 다른 컴퓨터에게 데이터를 전송하거나 원격에서 프로그램을 실행할 수 있었다.그리고 1990년대 인터넷이 진화되었다. 인터넷은 네트워크와 다른 네트워크의 사이라는 뜻으로 인터넷은 네트워크들로 이뤄진 네트워크다. 즉 인터넷은 여러 LAN을 하나로 연결해주는 WAN이다.1) 최근의 LAN들미국의 전기 엔지니어인 밥 멧칼프는 이더넷을 발명했는데, 이는 LAN이다. 최초의 이더넷은 반이중 시스템이었다. 모든 장치가 같은 선에 연결됐다. 각 장치의 네트워크 인터페이스에는 MAC 주소라는 유일한 48비트 주소가 부여됐고 요즘도 여전히 MAC이 쓰인다.이더넷은 요즘도 여전히 쓰이지만 반이중 버전은 아니고 각 장치가 라우터라는 장치에 연결되며 라우터는 어떤 장치가 어떤 선에 연결되어 있는지를 기억하고 패킷을 정확히 배달해준다.2) 인터넷인터넷은 물리적인 네트워크가 아니라 여러 계층으로 이뤄진 프로토콜의 집합이다. TCP/IP - IP는 패킷을 한 곳에서 다른 곳으로 옮겨주며, 이 패킷을 데이터그램이라고 부른다. TCP는 IP 위에 만들어졌고 패킷이 제대로 배달됐는지를 확실히 보장해준다. IP주소 - 인터넷상의 각 컴퓨터에는 IP주소라는 유일한 주소가 할당되어 있다. IP주소는 하드웨어에 묶여 있지 않아서 변경될 수도 있다. 대부분 IPv4에서 이뤄지고 옥텟 표기를 사용한다. 도메인 이름 시스템 - DNS로 불리며 IP주소를 찾아준다. 월드 와이드 웹 - 여러 프로토콜이 있는데 가장 많이 사용하는 프로토콜이 HTTP이다. 이는 하이퍼 텍스트 전송 프로토콜의 약자로 단순 텍스트를 전송하는 것을 뜻한다. HTTP 표준은 웹 브라우저가 웹 서버와 상호작용하는 방법을 정의한다.아날로그 처리 방법우리가 실제로 겪는 소리나 빛은 연속적이지만 컴퓨터에는 연속적인 대상을 저장할 방법이 없다. 그래서 데이터의 샘플을 취해야 한다. 이 말은 시간이나 공간상 일정한 간격으로 값을 읽어야 한다는 뜻이다.1) 디지털을 아날로그로 변환디지털 숫자를 사용해 아날로그 전압을 만들 방법으로는 DA 변환기를 사용하는 것이다.2) 아날로그를 디지털로 변환AD 변환기는 DAC보다 더 복잡하다. 값을 측정할 수 있도록 아날로그 신호의 현재 값을 흔들리지 않게 안정적으로 잡아내는 것이 중요하다.3) 디지털 오디오샘플링을 하면 일정 시간 간격으로 신호의 진폭이나 높이를 측정하여 오디오를 디지털화할 수 있다. 일정한 샘플링 주파수로 사각파를 얻을 수 있고, 상승 에지마다 A/D를 사용해 신호의 높이를 기록할 수 있다.샘플이 있으면 이를 D/A에 공급해서 재구성할 수 있어야 한다.푸리에 변환을 수행하면 주파수에 따른 진폭을 그래프로 그릴 수 있다.푸리에 분석의 응용 중 하나로 해먼드 B-3 오르간이 있다.또 미디어 플레이어의 기능으로 그래픽 이퀄라이저도 있다. 이것을 사용하면 입맛대로 소리를 조절할 수 있다. 그래픽 이퀄라이저는 조절 가능한 필터의 집합이다.필터는 전이 함수와 비슷하지만 전압이나 빛 대신 주파수에 대한 함수라는 점이 다르다. 그리고 필터에는 낮은 주파수를 통과시키는 ‘로우패스’와 높은 주파수를 통과시키는 ‘하이패스’가 있다.이 둘을 조합하면 정해진 최저 주파수와 최대 주파수 사이를 벗어난 나머지 주파수를 모두 무시하는 ‘밴드패스’ 필터나 특정 주파수만 제외시키는 노치를 만들 수 있다.적절히 필터링을 적용하면 샘플링이 작동하는 것처럼 보이게 된다. 스웨덴 전기 엔지니어 해리 나이퀴스트는 신호를 제대로 잡아내기 위해서는 적어도 최고 주파수의 2배의 샘플링 비율로 샘플을 얻어야 한다는 법칙을 발견했다.나이퀴스트 비율에 근접해 샘플링한 신호로부터 원래의 주파수와 진폭을 재구성할 수는 있지만 위상은 재구성할 수 없다. 위상은 시간축 위에서 약간씩 신호가 옮겨간 것처럼 생각하면 된다.위상이 중요한 이유는 위상차는 왼쪽과 오른쪽 귀에 도달하는 신호 사이의 시간차로 인해 발생하며, 사람은 이를 통해 공간에서 소리가 발생한 위치를 인식한다.주파수가 높으면 귀 사이의 거리보다 파장이 더 짧기 때문에 위상차를 더 잘 알아챌 수 있다.스테레오 사운드를 듣는 경우 스피커에서 나오는 두 음이 만들어내는 위상차를 이미지라고 부르며, 이는 연주하는 사람이 공간상 어디에 위치하는지를 볼 수 있는 능력을 뜻한다. 위상이 정확하지 않으면 이미지가 탁해진다.오디오에는 많은 데이터가 들어있고, 따라서 데이터를 압축해서 공간을 적게 차지하게 만들기 위해 압축을 한다. 압축에는 무손실 압축, 손식 압축이 있다. 무손실 압축은 원래 데이터를 그대로 유지해 준다. 유명한 무손실 압축으로 FLAC가 있다.그에 반해 손실 압축은 MP3, AAC 등으로 일부 세부 사항이 사라진다. 이는 연구자들이 사람들이 들을 수 없는 소리가 있다는 사실을 알게 되어 이런 소리를 없애기 때문에 더 높은 압축률을 제공한다.4) 디지털 이미지시각 이미지는 2차원 공간을 샘플링 해야 하기 때문에 오디오보다 더 복잡하다. 디지털 이미지는 그림 요소 또는 픽셀로 이뤄진 직사각형 배열로 표현된다.컬러 이미지에서 각 픽셀은 빨간색, 녹색, 파란색의 조합으로 표현된다. 일반적인 디스플레이에서 각각의 색의 8비트를 사용하고 컴퓨터는 가산 혼합 색 시스템을 사용하여 색을 표현한다.이미지 샘플링 작업은 이미지 앞에 모눈이 달린 창을 놓고 각 네모칸의 색을 기록하는 것과 비슷하다. 더 자세하고 높은 해상도를 사용하면 샘플링한 이미지가 더 보기 좋다. 하지만 해상도가 높아질수록 데이터의 양도 크게 늘어난다.현재 가장 일반적인 이미지 압축 방법은 JPEG로 어려운 수학 변환을 통해 이뤄진다. 손실 오디오 압축 방식과 비슷하게 사람의 인지 방법에 대한 지식을 활용한다.5) 비디오비디오는 2차원 이미지를 일정한 시간 간격으로 샘플링한 시퀀스다. 필요한 시간 간격은 사람의 시각 시스템의 기능에 따라 결정된다.프레임이 변할 때 이미지 중 일부분만 변했음을 알 수 있다. 변경된 영역의 데이터만 필요하다면 더 적은 데이터를 저장하거나 송신할 수 있다. 이런 기법을 움직임 보상 이라고 한다.비디오를 원본 이미지로부터 변화된 내용의 집합으로 표현하는 방식의 문제는 데이터가 왜곡될 수 있다는 문제가 발생한다. 데이터를 복구할 수 있는 방법이 필요한데 정기적으로 데이터에 키프레임을 추가하는 방식으로 이를 해결한다.키프레임은 오염된 데이터가 누적되면서 생긴 이미지가 손상된 경우라도 다음 키프레임에 전체 이미지를 복구할 수 있다.휴먼 인터페이스 장치1) 터미널과거에는 종이에 특별히 정해진 코딩 양식으로 데이터나 프로그램을 기록해야만 컴퓨터와 의사소통 할 수 있었다. 이런 코딩 양식을 키펀치를 사용하여 펀치카드 뭉치로 만들면 그것을 컴퓨터 오퍼레이터에게 건냈고,오퍼레이터는 카드를 카드 리더에 넣어 컴퓨터가 읽게 해서 프로그램을 실행시켰다.시간이 흐르고 사람들은 컴퓨터를 텔레타이프에 연결하기 시작했다. 텔레타이프는 선 끝에 연결됐기 때문에 터미널이라고 불렸다.그리고 이런 작은 컴퓨터를 계속 바쁘게 돌리기 위해 시분할이 발명됐다. 시분할 시스템에는 운영체제가 들어있었고 운영체제는 컴퓨터의 여러 자원을 각 사용자에게 배정해준다.그리고 사용자가 많아서 스레싱이 발생하면 시분할 시스템이 아주 느려진다.2) 그래픽 터미널그래픽 터미널은 흔해 CRT라고 부르는 음극선관이라는 진공관의 변형으로 만들어졌다. 오늘날의 CRT는 액정 디스플레이로 대체되었다.3) 벡터 그래픽벡터 그래픽은 선 또는 벡터로 그림을 그리는 방식이다. 벡터 그래픽은 이리저리 선을 그려서 그림을 만들어낸다. 그림은 디스플레이 목록에 의해 그려진다.이 목록은 그림을 그리는 명령어로 이뤄진 목록이고 마지막 명령어에는 1단계부터 다시 시작이라는 명령어가 있다. 화면상에서는 이미지가 빠르게 사라지기 때문에 계속 그림을 다시 그려야 한다.4) 레스터 그래픽벡터 그래픽과 완전히 다른 접근 법으로 텔레비전이 작동하는 방식이 래스터 방식이다. 래스터는 왼쪽 위에서 출발해 화면을 지난다. 그 후 수평 리트레이스를 통해 다시 화면 왼쪽 다음 줄 위치로 이동한다. 마지막 줄을 그린 다음에는 수직 리트레이스를 통해 그리기를 시작했던 왼쪽 위로 다시 이동한다.5) 키보드와 마우스터미널은 데이터를 출력하는 역할을 할 뿐만 아니라 데이터를 받아들이는 역할도 한다. 키보드의 경우 여러 스위치와 논리 회로를 묶은 것으로 일반적으로 키보드를 만드는 방법은 키 스위치들을 격자상에 놓고 멀티플렉싱하는 것이다.마우스는 쿼드러처 인코더를 사용하면 만들 수 있다. 터치 장치는 키보드와 비슷하게 행 스캐닝과 열 스캐닝을 하되 훨씬 더 미세한 단위로 스캔하는 장치다." }, { "title": "5장 컴퓨터 아키텍처와 운영체제", "url": "/posts/5%EC%9E%A5-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%99%80-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/", "categories": "BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍", "tags": "computer", "date": "2022-06-06 22:40:35 +0900", "snippet": "기본적인 구조 요소들가장 흔한 컴퓨터 구조는 폰 노이만 구조와 하버드 구조이다. 두 구조의 유일한 차이는 메모리 배열이다.메모리에서 동시에 명령어와 데이터를 가져올 수 없기 때문에 폰 노이만 구조가 약간 더 느리다. 하버드 구조는 동시에 명령어와 데이터를 가져올 수 있어 좀 더 빠르지만 두 번째 메모리를 처리하기 위한 버스가 더 필요하다.1) 프로세서 코어처음 만들어진 멀티프로세서 시스템은 단일 CPU보다 훨씬 더 좋은 성능을 얻어내기 위한 방법이다. 하지만 성능을 더 높이는게 그렇게 쉽지는 않았다.CPU를 더 빠르게 만듦으로써 더 나은 성능을 달성할 수 있었지만 기계가 빨라지면 전력을 더 많이 소모하고, 회로 크기는 줄어드는데 기계가 빨라져서 전력을 더 많이 소모하게 되면서 단위 면적당 열 발생은 더 많아졌다.사람들은 작아진 회로 크기를 활용한 새로운 해결책을 찾았고, CPU를 프로세서 코어라고 부른다. 그리고 이런 코어가 여럿 들어가는 멀티코어 프로세서를 일반적으로 쓴다.2) 마이크로프로세서와 마이크로컴퓨터물리적인 패키징 구조에 따라 구분하면 메모리와 I/O가 프로세서 코어와 같은 패키지에 들어 있지 않으면 이런 프로세서를 마이크로프로세서 라고 부르고 모든 요소를 한 칩 안에 패키징 하면 마이크로 컴퓨터 라고 부른다.칩 안에서 메모리가 차지하는 영역이 크기 때문에 일반적으로 마이크로프로세서보다 마이크로 컴퓨터가 덜 강력하다. 따라서 마이크로프로세서는 보통 큰 시스템에 들어가는 부품으로 쓰이고, 마이크로 컴퓨터는 식기세척기 등에서 찾을 수 있는 작은 컴퓨터다.프로시저, 서브루틴, 함수함수, 프로시저, 서브루틴은 코드를 재사용하는 주요 수단이다. 함수를 작성면 같은 코드를 여러 번 작성하지 않아도 함수를 호출함으로써 해당 코드의 행위를 할 수 있다. 이렇게 동작하기 위해서는 함수를 호출하는 부분에서 함수를 실행하고 다시 원래 자리로 돌아올 방법이 필요하다.이러한 과정은 상당히 많은 작업이 필요하다. 따라서 대부분 이런 과정을 돕는 명령어를 제공한다. 예)ARM 프로세서에 링크 레지스터를 사용해 분기처리하는 명령어가 있음스택함수가 자기 자신을 호출하는 경우가 있는데 이를 ‘재귀’라고 하고, 재귀는 아주 쓸모가 많다. 재귀 함수가 제대로 작동하려면 반환 주소를 여럿 저장할 수 있어야 한다. 그리고 함수에서 호출 지점으로 반환할 때 저장된 주소 중 어떤 주소를 사용할지 결정할 수 있어야 한다.예를 들면 식당에 쌓아둔 접시 더미를 생각해보자 함수를 호출할 때는 반환 주소를 접시에 넣어 접시 더매 맨 위에 넣는다. 함수 호출에서 돌아올 때는 접시 더미 맨 위의 접시를 보고 반환 주소를 결정한 다음 접시를 제거한다. 이러한 구조를 스택 이라고 한다.그리고 스택에 물건을 넣을때 더이상 들어갈 공간이 없으면 이를 스택 오버플로우 라고 한다. 또 함수를 호출할 때 해당 지역의 변수값을 그냥 덮어쓰면 안된다. 지역변수도 스택에 같이 저장해야 각각의 함수 호출이 서로 독립적이게 된다.인터럽트집에서 레시피에 따른 요리를 하는 중이라고 할 때 레시피 대로 요리하는 활동을 순서도(작업이 이뤄지는 순서를 표현한 다이어그램)로 표현할 수 있다. 하지만 중간에 소포 배달원이 온다는 등 예외상황이 발생한다면 순서도 중간에 예외를 처리야하 할 것이다.순서도 중간중간에 문 앞에 누가 와있는지 확인하는 것을 넣에 되는 방법을 폴링이라고 부른다. 이러한 방법은 문 앞에 누가 왔는지 검사하는 데 많은 시간을 소모하게 된다.이런 작업을 더 잘 처리하기 위해 실행중인 프로그램을 잠깐 중단 시켜서 주의를 기울여야 하는 외부의 요소에 대응할 수 있게 만들 방법이 필요하다. 그래서 요즘 프로세서 대부분은 인터럽트 시스템이 들어간다.인터럽트 시스템은 적절한 신호가 들어왔을 때 CPU 실행을 잠깐 중단시킬 수 있는 핀이나 전기 연결을 포함한다.인터럽트 시스템이 작동되는 방식은 1)CPU가 주의를 기울여야 하는 주변장치는 인터럽트 요청을 생성한다. 2)프로세서는 현재 실행중인 명령어를 끝까지 실행한다. 3)이후 프로세서는 현재 실행중인 프로그램을 잠시 중단하고 인터럽트 핸들러라는 프로그램을 실행한다.4)인터럽트 핸들러가 작업을 마치면 원래 실행중이던 프로그램이 중단된 위치부터 다시 실행을 계속한다.인터럽트 시스템을 이용할때 고려해야할 사항이 있다. 1)인터럽트에 대한 응답시간 2)인터럽트를 서비스하고 나중에 다시 원래대로 돌아오기 위해서 현재 상태를 저장할 방법이 필요하다.인터럽트 시스템은 서비스 후 돌아올 프로그램 위치를 스택에 저장한다.또 여러가지 종류의 인터럽트 제어가 가능하다. 인터럽트를 중단시킬 수 있는 마스크, 인터럽트 간의 우선순위, 일정 시간이 지나면 인터럽트를 발생시킬 수 있는 내장 타이머 등이 있다.상대 주소 지정여러 프로그램을 동시에 실행할때 각 프로그램을 서로 전환시켜줄 수 있는 일종의 관리자 프로그램이 필요하다. 이런 프로그램을 운영체제 또는 운영체제 커널이라고 부른다.OS는 타이머를 사용해 사용자 프로그램을 전환시켜줄 때가 됐는지 판단한다. 이런식으로 프로그램의 실행 시간을 조절하는 스케줄링 기법을 ‘시분할’이라고 한다.주소 지정 모드에서 절대 주소 지정 모드는 명령어가 특정 메모리 주소를 가리킨다. 그래서 1000번지에서 실행되도록 만들어진 프로그램을 2000번지에 읽어 들이면 제대로 실행되지 않을 수 있다.그래서 어떤 컴퓨터들은 이런 문제를 ‘인덱스 레지스터’를 추가해 해결한다. 이것을 사용하면 인덱스 레지스터에 있는 값을 명령어에 들어있는 주소와 더해서 유효 주소를 계산한다.예)1000번지에서 실행되도록 만들어졌다면 os는 이 프로그램을 3000번지에서 실행하기 위해 인텍스 레지스터를 2000으로 설정할 수 있다.이 문제를 해결하기 위한 또 다른 방법으로 상대 주소 지정을 사용하는 것이다. 이는 명령어에 들어있는 주소를 명령어의 주소를 기준으로 하는 상대적인 주소로 해석한다.메모리 관리 장치오늘날 대부분의 마이크로프로세서에는 메모리 관리 장치(MMU)가 있다. MMU가 들어있는 시스템은 가상 주소와 물리 주소를 구분한다.MMU의 가상 주소 범위는 물리적 메모리 주소보다 큰 경우가 많다. 이는 가상 메모리 주소를 두 부분으로 나뉘어 하위 부분은 물리적 주소 범위와 같고, 상위 부분은 ‘페이지 테이블’이라는 RAM 영역을 통해 주소를 변환한다.페이지 테이블에는 각 페이지가 물리 메모리상에서 차지하는 실제 위치 정보가 들어 있다. 이를 통해 1000번지에서 시작하는 프로그램을 2000번지나 다른 곳에 넣을 수 있다.(단, 모든 내용이 페이지 경계안에 있어야 한다.)그리고 프로그램 입장에서는 가상 메모리가 연속적으로 보이지만 실제 물리 메모리상의 위치는 굳이 연속적일 필요가 없다.현대적 프로세서의 MMU는 페이지 테이블 크기가 정해져 있다. 전체 페이지 테이블 항목은 주 메모리에 저장되거나 주 메모리가 부족한 경우 디스크에 저장된다. MMU는 페이지 테이블 항목 중 일부를 필요할 때만 자신의 페이지 테이블로 읽어 들인다.일부 MMU 설계는 페이지 테이블에 제어 비트를 추가 제공한다. 예로 실행 불가 비트를 들때 이것이 설정되어 있다면 CPU가 이 페이지에 있는 명령어를 실행할 수 없다.프로그램이 물리적 메모리에 연관되지 않은 주소에 접근하면 페이지 폴트 예외가 발생한다. 이런 동작은 스택 오버플로 등이 일어난 경우 유용하다. 스택 오버플로가 발생하면 스택 범위를 벗어난 주소에 접근하므로 페이지 폴트가 발생하고,이 예외가 발생시 OS는 실행 중인 프로그램을 중단시키는 대신 MMU가 추가 메모리를 할당하게 해서 스택 공간을 늘리고 사용자 프로그램 실행을 계속할 수 있다.가상 메모리운영체제는 프로그램들 사이의 자원 분배를 관리한다. 메모리도 역시 OS가 관리하는 자원이다. OS는 MMU를 사용해 사용자 프로그램에게 가상 메모리를 제공한다.요청받은 메모리가 사용 가능한 메모리의 크기보다 큰 경우 OS는 현재 필요하지 않은 메모리 페이지를 더 느리지만 용량이 큰 대용량 저장장치인 디스크로 옮긴다. 이런 과정이 일어나게 되면 시스템 성능이 크게 저하된다.이런 성능 저하를 막기 위해 사용하는 기법 중 최소 최근 사용 LRU 알고리즘이 있다. 이 알고리즘은 최근에 가장 자주 사용된 페이지는 물리 메모리에 그대로 남기고 최근에 가장 덜 사용한 페이지를 디스크로 옮긴다.시스템 공간과 사용자 공간메모리 계층과 성능과거에는 CPU와 메모리가 같은 속도로 작업했으나 CPU가 더더욱 빨라지면서 메모리의 속도가 뒤처지기 시작했다. 메모리 시스템 내부에서 일어나는 일은 시스템 성능에 큰 영향을 끼친다.CPU와 주 메모리 사이에는 작은 덩어리가 오간다. 주 메모리와 디스크 사이에는 더 큰 덩어리가 오간다. CPU가 주 메모리보다 10배 더 빠르게 작동한다면 CPU가 메모리를 기다리느라 많은 시간을 소비하게 된다.이를 해결하기 위해 ‘캐시’라는 하드웨어를 CPU에 추가한다.캐시 메모리에도 몇 가지 계층이 있다. CPU에서 멀어질수록 캐시는 더 느려지고 더 커진다. 이들을 L1, L2, L3 캐시라고 부른다. 그리고 여러가지 크기의 내용물을 채워 넣거나 내용물을 꺼내는 일을 담당하는 아주 큰 논리 회로인 디스패처도 있다.코프로세서프로세서 코어는 아주 복잡한 회로로 이뤄졌다. 몇 가지 연산을 코프로세서라는 더 단순한 회로에 위임하면 프로세서 코어가 일반적인 연산에 활용할 수 있는 공간을 더 확보할 수 있다.주 메모리와 디스크 사이에 단순한 데이터 복사가 자주 일어날 수 있다. 일부 코프로세서는 다른 일은 처리하지 않고, 데이터 복사만 담당한다. 이런 방식을 ‘직접 메모리 접근’이라고 한다.메모리상의 데이터 배치메모리에는 명령어만 담는게 아니라 데이터도 담는다. 이 경우 데이터는 정적 데이터다. 대부분의 프로그램은 동적 데이터를 다뤄야 한다. 동적 데이터는 주로 정적 데이터가 차지하는 영역의 바로 위 영역에 쌓이며 이를 힙이라고 부른다.스택은 아래로 자라나는 반면 힙은 위로 자라난다. 따라서 힙과 스택이 서로 충돌하지 않게 하는 것이 중요하다.프로그램 실행앞서 프로그래머가 함수를 사용해 코드를 재사용한다고 설명했다. 이렇게 관련 함수를 한데 모아서 라이브러리로 만들면 문자열 처리부터 복잡한 수학계산 등 다양하게 활용할 수 있다.본격적인 프로그램은 라이브러리 뿐만 아니라 여러 조각으로 이뤄진다. 여러 파일로 나누게 되면 여러 사람이 한 프로그램의 여러 부분을 동시에 개발할 수 있다는 장점이 있다.하지만 프로그램을 여러 조각으로 나누면 이 모든 조각을 하나로 엮거나 연결할 방법이 필요하다. 과거에넌 라이브러리를 직접 연결해 실행 파일을 만드는 정적 링크 방식을 사용했으나 메모리 낭비로 인하여 공유 라이브러리를 사용하는 동적 링크를 발명했다.메모리 전력 소비데이터를 메모리에서 이리저리 옮기려면 전력이 소비된다. 전력 소비와 성능 사이의 균형을 잡는 일은 아주 어렵다. 따라서 코드를 작성할 때도 이를 염두에 둬야 한다." }, { "title": "4장 컴퓨터 내부 구조", "url": "/posts/4%EC%9E%A5-%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0/", "categories": "BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍", "tags": "computer", "date": "2022-06-04 02:03:08 +0900", "snippet": "전자부품을 다양하게 조합해 비트를 조작하는 회로를 만들 수 있는데 이런 회로를 ‘컴퓨터’리고 한다.현대 컴퓨터는 크게 메모리, 입력과 출력, CPU 라는 세 가지 부분으로 나눌 수 있다.메모리컴퓨터에서는 조작할 비트들을 저장할 장소가 필요하다. 이런 장소를 메모리라고 부른다.메모리는 집이 빈틈없이 늘어선 거리와 같다. 모든 집은 크기가 똑같고 모든 집에는 정해진 개수만큼 비트를 저장할 수 있는 방이 있다. 컴퓨터를 만드는 규칙에는 각 집마다 1바이트를 저장한다고 되어 있고, 각 집에는 주소가 부여된다.메모리의 기본 단위가 바이트라는 것이 꼭 바이트 단위로만 데이터를 읽어야 한다는 뜻은 아니다. 예) 32비트 컴퓨터는 메모리가 4바이트 덩어리, 64비트 컴퓨터는 메모리를 8바이트 덩어리로 구성한다.이는 마치 1차선 도로대신 4차선, 8차선 고속도로를 사용하는 것과 비슷하다.다양한 메모리가 있는데 각 메모리는 서로 가격/성능 비율이 다르다. 또 사용하는 프로세서에 따라 어디에 저장될지가 다르기 때문에 한 시스템에서 다른 시스템으로 데이터를 전송할 때는 이런 점을 염두해 둬야 한다.입력과 출력컴퓨터에서 정보를 전달하거나 컴퓨터에서 정보를 가져올 방법이 필요하다. 이런 방법을 입력(input)/출력(output) 줄여서 I/O라고 부른다. I/O 장치를 컴퓨터의 주변부에 위치하여 주변장치 영어로는 peripheral 이라고 한다.컴퓨터에는 I/O 처리를 위한 별도의 거리가 존재한다. 32비트나 64비트 컴퓨터가 흔해진 요즘은 메모리 거리의 주소 수가 훨씬 많아졌다. 메모리 거리가 길기 때문에 모든 주소에 집이 있기는 않게 되었고, 메모리 거리 중 일부를 I/O 장치에 할당하는 것이 타당해졌다.중앙 처리 장치중앙 처리 장치(CPU)는 실제 계산을 처리하는 컴퓨터 부품이다.1) 산술 논리 장치(ALU)CPU의 핵심 부품으로 산술 계산, 불리언 대수 및 기타 연산을 수행하는 방법을 알고 있는 장치다. 산술 논리 장치의 구조 중 피연산자는 수를 표현하는 비트이고, 연산 코드는 명령코드(어떤 연산자를 적용할지)를 지정한다.조건 코드에는 결과에 대한 추가 정보가 들어간다. 보통 ‘조건 코드 레지스터’라는 레지스터에 조건 코드가 저장된다.2) 시프트왼쪽 시프트는 어떤 숫자의 모든 비트를 왼쪽으로 1비트씩 옮기고 맨 왼쪽 비트는 버리고 비게 되는 가장 오른쪽 비트에 0을 넣는다. (오른쪽 시프트도 마찬가지) 이때 사라지는 왼쪽 비트 또는 오른쪽 비트의 값이 필요할 때가 종종 있다. 그래서 이 비트를 조건 레지스터에 저장한다.순차적인 시프트 레지스터는 1비트를 시프트할 때 한 클록이 필요하기 때문에 느리다. 실렉터와 조합 논리를 사용하는 배럴 시프터를 사용하면 이런 문제를 해결할 수 있다.3) 실행 장치실행 장치는 제어 장치라고도 알려져 있고 컴퓨터의 대장 역할을 한다. 실행 장치는 메모리의 정해진 장소에서 명령코드와 피연산자들을 가져와서 ALU에게 어떤 연산을 수행할지 알려주고, 결과를 메모리에 돌려준다.우리는 실행 장치에게 명령어 목록을 제공한다. 이 명령어는 위치 10에 있는 수를 위치 12에 있는 수와 더해서 결과를 위치 14에 넣어라 같은 내용이다. 실행 장치는 이러한 명령어를 메모리에서 찾을 수 있다.이런 식으로 실행되는 컴퓨터를 ‘프로그램 저장 방식 컴퓨터’라고 부른다.명령어는 컴퓨터에게 어떤 일을 할지 알려주는 비트 패턴이다. 이런 비트 패턴은 CPU 마다 고유한 설계에 속한다. 그리고 실행 장치는 메모리에서 명령어를 가져와야 하는 위치를 어떻게 알까? =&gt; ‘프로그램 카운터’를 사용하여 알 수 있다.프로그램 카운터에는 메모리 주소가 들어있고 메모리 위치를 가리킨다. 그래서 실행 장치는 프로그램 카운터가 가리키는 주소에서 명령어를 읽어온다.명령어 집합1) 명령어176~178p2) 주소 지정 모드주소 지정 방식에는 사용할 주소가 명령어에 직접 들어가 있는 직접 주소 지정 방식, 피연산자의 주소를 얻을 수 있는 메모리 위치를 가리키는 주소로 사용하는 간접 주소 지정 방식이 있다. 간접 주소 지정 방식의 경우 더 많은 메모리를 사용할 수 있다.상수를 지정할 필요가 있는 경우에는 즉시 주소 지정 모드 라는 또 다른 주소 지정 모드를 추가할 수 있다.3) 조건 코드 명령어조건 코드를 다루는 명령어에는 조건 코드 레지스터의 값을 누산기로 복사하는 cca라는 명령어와 누산기의 값을 조건 코드 레지스터에 복사하는 acc라는 명령어를 추가할 수 있다.4) 분기 명령어명령어를 처음부터 끝까지 순서대로 수행하는 상황에서 의사결정을 내리고 코드 중 일부를 선택해서 실행할 수 있는 프로그램이 있으면 정말 좋을 것이다. 이런 명령어를 ‘분기 명령어’라고 부른다.5) 최종 명령어 집합 구성최종 명령어 구성은 모드_명령코드_주소로 되어있다. 주소 지정 모드는 세 가지가 있어 모드 선택을 위해 2비트가 필요하다. 그리고 주소 지정 모드와 명령코드를 디코딩하면 명령어를 얻을 수 있다.마지막 설계1) 명령어 레지스터컴퓨터에서 벌어지는 일을 두 단계로 이뤄진 상태 기계로 설명할 수 있다. 처음에 컴퓨터가 해야 하는 일은 메모리에서 명령어를 가져오는 페치다. 명령어를 가져오고 나면 이 명령어를 어떻게 실행할지 고민해야 한다.명령어를 실행하려면 메모리에 접근해야 할 경우가 많다. 페치한 명령어에 편하게 접근할 수 있도록 저장할 다른 위치가 필요한데 CPU에 명령어 레지스터를 추가해서 현재 실행 중인 명령어를 저장한다.2) 데이터 경로와 제어 신호3) 데이터 흐름 제어186~189pRISC와 CISC 명령어 집합설계자들은 유용한 컴퓨터 명령어를 만들어냈지만 컴퓨터 제어 회로도 복잡해졌다. 미국 컴퓨터 과학자인 버클리의 데이비드 패터슨과 존 헤네시는 여러 프로그램을 통계적으로 분석한 결과, 복잡한 명령어 중 상당 부분이 거의 쓰이지 않는다는 사실을 발견했다.복잡한 명령어를 단순한 명령어로 조합해 처리하는 기계를 RISC기계라고 부른다. 이와 대조적으로 기존 설계 방식으로 만든 컴퓨터를 CISC 기계라고 부른다.RISC 기계의 중요한 특징으로는 적재-저장 구조를 사용한다는 점이다. 이 아키텍쳐는 메모리와 레지스터를 오가는 명령어들과 레지스터 간 명령어로만 이뤄진 구조다.GPU그래픽 처리 장치 GPU를 특정짓는 기능이 두 가지 있다. 1)GPU에는 간단한 처리 장치가 아주 많이 들어 있다. 2)GPU는 CPU보다 메모리 버스의 폭이 더 넓다. 이로인해 메모리에 더 빠르게 접근할 수 있다." }, { "title": "3장 메모리와 디스크의 핵심- 순차 논리", "url": "/posts/3%EC%9E%A5-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%EB%94%94%EC%8A%A4%ED%81%AC%EC%9D%98-%ED%95%B5%EC%8B%AC-%EC%88%9C%EC%B0%A8-%EB%85%BC%EB%A6%AC/", "categories": "BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍", "tags": "computer", "date": "2022-06-02 23:48:08 +0900", "snippet": "조합 논리는 입력에 의해서만 출력이 결정된다. 조합 논리만으로는 흐름의 일부분을 떼어내서 기억해둘 수 없기 때문에 현재 처리중인 수가 어떤 수인지 기억할 수 없다.그래서 조합 논리의 단점을 개선한 순차 논리가 있다. 순차 논리는 입력의 현재 상태와 과거 상태를 함께 고려한다.시간 표현과 상태 기억우리는 주기 함수를 사용해 시간을 측정할 수 있다. 예를 들면 지구의 자전이 바로 주기적 함수이다. 지구가 한 바퀴를 다 돌면 이는 1일이고, 1일을 더 잘게 나눠서 시간, 분, 초 등으로 구분한다.컴퓨터의 경우 전자공학을 사용하기 때문에 주기적인 전기 신호가 필요하다. 진자가 스위치를 때리게 하면 이런 신호를 만들 수 있다.1) 발진자인버터를 사용한 트릭을 보면 인버터의 출력을 입력에 연결할 수 있다. 이런 식의 연결을 ‘되먹임’이라고 한다. 인버터 출력은 다시 인버터 입력으로 들어가며, 이 입력은 다시 출력에 반영된다. 이로 인해 출력이 0과 1 사이를 진동한다.그리고 안정적인 주파수로 진동하는 발진자가 있다면 더 정확한 시간을 측정할 수 있는 기준이 될 것이다.정확한 발진자를 적은 비용으로 효율적으로 만드는 방법은 크리스털을 활용하는 것이다. 전극을 크리스털에 연결하고 크리스털을 압축하면 크리스털이 전기를 만들어 낸다. 그리고 전극에 전기를 가하면 크리스털이 구부러진다. 이런 현상을 ‘피에조 전기’ 효과라고 부른다.또 크리스털은 음성 진동을 잡아낼 수 있어서 마이크를 만들 때 이를 쓸 수 있다. 그리고 음성 진동을 만들어내서 다양한 경보음도 낼 수 있다.입력한 전기로부터 크리스털이 전기를 다시 만들어내는 시간은 예측이 가능하며 매우 정확하다.2) 클록*컴퓨터에서 전자적/기계적 부품에 가까우면 더 저수준, 사용자나 프로그래머에 가까우면 더 고수준이라 한다.발진자를 사용하면 시간을 더 잘 측정할 수 있다. 발진자는 컴퓨터에 시간을 셀 수 있게 해주는 신호인 ‘클록’을 제공한다. 클록은 회로의 페이스를 결정한다. 회로의 최대 클록 속도나 가장 빠른 템포는 회로의 전파 지연 시간에 의해 결정된다.컴퓨터 컴포넌트 제작에는 여러가지 통계가 필요하다. 컴포넌트를 이루는 부품들 사이에 편차가 크기 때문이다. 그래서 비닝 과정에서 부품을 측정하여 특성에 따라 여러 다른 빈이나 무더기로 분류한다.컴퓨터를 오버클로킹 한다는 말을 들어봤을 것이다. 이는 통계적으로 빈의 중간 정도에 위치하는 부품을 부품이 고장나지 않을 범위 안에서 클록을 빠르게 공급하는 도박을 한다는 뜻이다.3) 래치OR 게이트의 출력을 입력에 묶는 방식의 되먹임을 사용하면 정보를 기억할 수 있다.위 사진에서 reset 위에 선을 그어 표현한 것을 유의해라 하드웨어 기호 위에 선을 그으면 반전을 뜻한다. 이 말은 값이 0일 때 참이고, 1일 때 거짓이라는 뜻이다. 이를 액티브 하이에 반대되는 액티브 로우라고 부른다.그리고 이렇게 위에 그은 선을 ‘bar’라고 읽는다. 따라서 reset 기호를 읽을 때 reset bar라고 읽는다.위 사진은 S-R 래치를 보여준다. S-R 래치는 set-reset을 뜻하고, 좀 더 똘똘하게 1비트 메모리를 만드는 방법이다. 이들은 액티브 로우를 입력 받고 보수 출력을 제공한다.보수 출력은 출력의 한쪽은 액티브 하이, 다른 쪽은 액티브 로우라는 뜻이다.set bar, reset bar가 참인 경우는 두 출력이 모두 참이라서 이상하기 때문에 이런 입력은 사용하면 안 된다.4) 게이트가 있는 래치S-R래치 그림에서 gate bar 입력이 거짓인 경우 set bar, reset bar가 어떤 값이든 아무 관계가 없다. S,R 게이트의 입력이 모두 1이기 때문에 출력이 그대로 유지 된다.이 회로를 개선하는 방법으로 set bar, reset bar가 같은 입력에 연결하면서 한 쪽 입력에는 인버터를 추가해서 입력을 1비트(D)만 받게 만든다.이렇게 하면 gate bar가 거짓일 때는 D가 변해도 Q 출력에 아무 변화가 없다.5) 플립플롭데이터 변경으로 인해 잘못된 결과가 생길 수 있는 가능성을 최소화하기 위해 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는 것이다. 이런 전이를 edge라고 부른다.그리고 edge에 의해 데이터 변화가 촉발되는 래치를 ‘플립플롭’이라고 부른다. 플립플롭을 만들 때는 래치를 기본 요소로 사용한다.6) 카운터플립플롭을 응용한 회로 중에 1, 2, 3 순서대로 수를 세는 카운터가 있다. 개수를 센 결과가 왼쪽에서 오른쪽으로 퍼져나가는 것을 리플 카운터라고 한다.그리고 각 비트의 상태가 다른 비트의 상태 변화에 약간의 시차를 두고 바뀌기 때문에 이 회로를 ‘비동기 카운터’라고도 부른다. 따라서 언제 결과를 살펴봐야 맞는지 알기 어렵다는 단점이 있다.이에 반해 동기적 카운터는 상태 변경이 동시에 일어난다. 이는 모든 플립플롭에 같은 클록을 병렬로 연결한다는 사실을 암시한다.7) 레지스터D 플립플롭을 사용하면 값을 쉽게 기억할 수 있다. 이를 응용하여 레지스터 회로를 쉽게 구할 수 있다. 레지스터는 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 것이다.가산기를 예로 들면 가산기 출력을 클록을 사용해 레지스터에 넣고 나면 가산기의 입력을 바꿔도 결과는 바뀌지 않는다.메모리 조직과 주소 지정훨씬 더 많은 정보를 저장해야 한다면 어떻게 해야 할까? 레지스터를 많이 쌓아두는 것부터 시작할 수 있다. 하지만 어떤 레지스터를 사용해야 하는지 지정할 수 있을까?이때 각 레지스터에 번호를 부여하는데 이 번호를 ‘주소’라고 한다. 지정한 주소에 해당하는 레지스터의 출력을 선택할 방법이 필요하다. 그래서 여기에 실렉터를 사용한다.그리고 시스템에서 여러 메모리 컴포넌트의 출력을 한 출력으로 연결해야 할 수도 있다. 이런 경우 트라이 스테이트 출력이라는 또 다른 기본 요소가 필요하다.이 모든 요소를 합하면 메모리 컴포넌트가 만들어 진다.메모리 컴포넌트는 연결지점이 아주 많았다. 32비트 수를 다루고 싶다면 입력과 출력을 32개씩 연결해야 하고, 주소, 제어 신호, 전원도 연결해야 했다. 하지만 메모리를 동시에 읽고 쓸 필요가 있는 경우는 거의 없다는 사실을 활용해 연결을 줄였다.그림에서 주소와 데이터는 개별 신호 대신 큰 화살표를 사용한 것을 볼 수 있다. 이런식으로 연관된 신호를 ‘버스’라고 부른다. 따라서 메모리 칩에는 주소 버스와 데이터 버스가 있다. 버스는 비트를 이동시키는 대량 교통 수단이다.1) 임의 접근 메모리임의 접근 메모리 즉, RAM은 메모리 위치 중 원하는 곳은 어디든 원하는 순서로 쓰거나 읽을 수 있다. 정적 RAM은 비싸지만 아주 빠르다. 각 비트에 트랜지스터가 6개나 들어간다. 따라서 많은 비트를 저장하기에 좋은 선택은 아니다.동적 RAM은 커패시터라는 아주 작은 버킷에 전자를 담고, 트랜지스터를 1개만 사용해 뚜껑을 덮는다. 문제는 이 버킷이 새기 때문에 가끔 메모리를 갱신해야 한다는 점이다. 그래서 버킷에 전자를 채우는 시점과 버킷에 정보를 쓰는 시간이 서로 겹치지 않게 조심해야 한다.정적 RAM이나, 동적 RAM은 모두 휘발성 메모리다. 그래서 전원이 끊어지면 데이터가 사라진다. 반대로 코어 메모리는 오래된 비휘발성 RAM으로 비트를 도넛 모양의 쇳조각에 저장한다.2) 읽기 전용 메모리읽기 전용 메모리 즉 ROM은 한 번 쓰고 나면 여러 번 읽을 수 있다. 가장 초기 형태의 ROM은 홀러리스 카드로 비트들을 종이에 구멍으로 뚫어 표시한다.천공 종이 테이프는 ROM 기술과 관련이 있다. 종이 테이프 롤에 뚫린 구멍은 비트를 표현한다. 순서가 뒤섞여 데이터가 꼬일 수 있는 카드에 비해 테이프는 그런 염려가 없다는 것이 장점이다. 반면 테이프가 찢어지면 수리하기가 힘들다.IBM 카드와 종이 테이프는 순차적인 메모리다. 이는 데이터를 일정한 순서로만 읽을 수 있다는 뜻이다. 그래서 장기적으로 저장해야 하는 데이터를 저장하는 경우에만 유용하다.이후 최초로 상업적으로 팔리기 시작한 마이크로 프로세서인 인텔 4004로 인해 더 나은 프로그램 저장 기술에 대한 수요가 생겼다.그리고 프로그래머들이 직접 프로그래밍할 수 있는 ROM인 프로그래머블 읽기 전용 메모리가 만들어졌다. 단 한 번만 ROM에 프로그램을 적어 넣을 수 있었다. 그 다음으로 지울 수 있는 읽기 전용 메모리가 만들어졌다.그리고 전기로 지울 수 있는 읽기 전용 메모리가 등장하면서 삶이 더 편해졌다.블록 장치대량 저장장치로 알려진 디스크 드라이브는 엄청나게 많은 데이터를 저장하기 아주 좋은 장치다. 하지만 다른 유형의 메모리에 비해 상대적으로 느리다. 또 방금 지나간 데이터가 필요한 경우 회전판이 거의 1바퀴를 돌때까지 기다려야 다시 읽을 수 있다.또 기계 부품이 시간이 지나면서 낡아져서 회전축의 마찰을 줄여주는 베어링의 마모는 디스크 오류를 일으키는 주 원인이 된다.디스크는 바이트 단위로 주소를 지정해 읽는 대신 블록 단위로 주소를 지정해 읽는다. 블록은 디스크에서 읽고 쓰기가 가능한 가장 작은 단위다.플로피 디스크는 더 저렴하고 탈착이 가능한 드라이브로 잘 구부러지는 재질이고, 반대로 단단한 드라이브를 하드 디스크라고 불러서 구분한다. 더 오래된 디스크의 변종으로 ‘자기 드럼’ 저장장치가 있다. 드럼은 회전하는 원통에 헤드가 줄지어 있는 기억장치다.자기테이프는 자화시킨 테이프를 감은 릴을 사용하는 또 다른 비휘발성 저장장치 기술이다. 디스크 드라이브보다 더 느리고 원하는 위치까지 테이프를 감으려면 오랜 시간이 걸린다.광학 디스크는 자기 디스크와 비슷하지만 데이터를 읽고 쓰기 위해 자성 대신 빛을 사용한다는 차이가 있다. CD, DVD가 광학 디스크에 속한다.플래시 메모리와 SSD플래시 메모리는 가장 최근 나타난 EEPROM(전기적으로 DATA를 썼다 지웠다를 할 수 있는 비휘발성 메모리) 유형의 매체다. 플래시 메모리 동적 RAM과 마찬가지로 버킷에 전자를 담는 방식으로 작동한다. 하지만 동적 RAM보다 더 크고 잘 만들어져 있어 전자가 새지 않는다.데이터를 기록하기 위해서는 먼저 0을 채워 넣어야 한다. 0을 1로 바꿀 수 있지만 전체를 지우지 않고 원하는 비트만 0으로 되돌릴 수는 없다.그래서 모든 메모리를 다 지우는 것은 낭비가 심하기 때문에 플래시 메모리 내부는 블록으로 나뉘어서 블록 단위로 지우고 값을 쓸 수 있다. 따라서 플래시 메모리는 읽을 때는 임의 접근 장치이고, 쓸 때는 블록 접근 장치이다.디스크 드라이브는 점차 SSD로 널리 알려진 고체 상태 드라이브로 교체되고 있다.오류 감지와 정정원본 데이터의 완벽한 복사본을 저장하지 않고도 데이터 오류가 발생했는지 알고 싶다. 이런 오류를 감지할 수 있는 것으로 ‘parity’를 사용하면 단 1비트만 데이터가 잘못된 경우를 감지할 수 있다.패리티는 데이터에서 1로 설정된 비트의 개수를 세고, 그 개수가 짝수인지 홀수인지 나타내는 1비트를 데이터에 덧붙이는 것이다. 그래서 전체 비트의 1의 개수가 짝수인지 홀수인지 여부에 따라 오류를 감지한다.패리티의 가장 큰 문제는 오류가 짝수 번 발생하면 오류가 발생하지 않은 경우와 구분이 불가능하다는 점이다. 패리티는 오류가 홀수 번 발생한 경우만 알아낼 수 있다.또 다른 방법으로 ‘해밍 코드’가 있다. 해밍 코드는 더 많은 비트를 사용해 더 많은 오류를 감지할 수 있고, 오류 횟수가 작으면 오류가 일어난 부분을 바로 수정할 수 있다.또 컴퓨터 프로그램과 같이 정적인 데이터 블록을 검증하는 더 값싼 방법으로 ‘체크섬’이 있다.순환 중복 검사는 수학적으로 체크섬보다 더 나은 대체재다. 또는 해시코드도 더 나은 대체재다.하드웨어와 소프트웨어 비교논리를 하드웨어로 만드는 것과 소프트웨어로 만드는 것 사이에 구분은 모호하다. 상당 부분 소프트웨어는 설계에 들어가는 시간이라는 비용을 제외한 어떤 추가 비용도 들지 않기 때문에 소프트웨어가 하드웨어보다 훨씬 만들기 쉽다는 점 빼고는 차이가 거의 없다." }, { "title": "2장 전자회로의 조합 논리", "url": "/posts/2%EC%9E%A5-%EC%A0%84%EC%9E%90%ED%9A%8C%EB%A1%9C%EC%9D%98-%EC%A1%B0%ED%95%A9-%EB%85%BC%EB%A6%AC/", "categories": "BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍", "tags": "computer", "date": "2022-05-29 22:40:52 +0900", "snippet": "디지털 컴퓨터의 사례근대의 톱니바퀴를 사용하는 기계적인 계산 장치를 살펴보면 두 톱니바퀴가 돌아가면 각 톱니바퀴의 톱니 비욜이 두 바퀴의 상대적인 회적 속도를 결정하기 때문에 곱셈, 나눗셈 기타 계산에 유용하다.톱니바퀴를 기반으로 만들어진 계산기로는 그리스 제도에서 발견된 안티키테라, 2차 세계대전 즈음 화기 제어 컴퓨터, 톱니바퀴를 사용하지 않는 기계식 컴퓨터로는 계산자(slide rule)가 있다.또 요즘엔 비행기 조종사들은 비행 컴퓨터라고 부르는 비상용 항법 계산 도구로 사용한다.1) 아날로그와 디지털의 차이계산자는 수학적으로 연속적이기 때문에 실수를 표현할 수 있고, 손가락은 이산적이라고 부르는 성질을 가졌기 때문에 정수만 표현할 수 있다.전자기술에 대해 이야기할 때 아날로그는 연속적인 것을 뜻하며 디지털은 이산적인 것을 뜻한다. 실수를 표현할 수 있기 때문에 아날로그가 계산에 더 적합할 것 같지만 정밀도의 문제가 있다.2) 하드웨어에서 크기가 중요한 이유현대 컴퓨터는 전자를 움직이는데 전기는 빛의 속도로 움직이며 빛의 속도는 초당 3억 미터다. 컴퓨터에서 전자의 여행 시간을 최소화하는 방법은 부품을 가능한 한 가깝게 위치시키는 것 뿐이다.하드웨어를 작게 만들면 필요한 여행 거리가 줄어들고, 여행 거리가 줄어들면 필요한 에너지 양도 줄어든다. 그렇게 되면 저 전력 소모와 열 발생 감소로 드러난다. 하지만 하드웨어를 아주 작게 만들다 보니 여러 가지 문제가 생기게 된다.3) 디지털을 사용하면 더 안정적인 장치를 만들 수 있다하드웨어를 작게 만들면 속도와 효율은 좋아지지만 물체가 너무 작아지면 서로 간섭하기 아주 쉬워진다. 간섭은 내부적인 근원이 존재한다. 전자 기력은 중려고가 마찬가지로 멀리 떨어진 물체에 영향을 끼칠 수 있다.이런 영향은 좋은 것이다. 특히 두 선의 거리가 아주 가까우면 영향이 더 커진다. 그래서 더 높은 판정 기준(이산적인 장치는 판정기준이 있다.)을 통해 잡음 내성을 갖는 디지털 회로를 사용하는 것이 필수적이다.실제로 판정 기준을 도입해 생기는 안정성이 우리가 디지털 컴퓨터를 만드는 주된 이유다.4) 아날로그 세계에서 디지털 만들기전이 함수란 수학시간에 배우는 함수와 같지만 실제 세계에서 벌어지는 현상을 표현한다. 디지털 카메라를 생각해보면 빛의 값이 다르면 전이 함수가 기록하는 빛의 값도 달라진다. 빛이 곡선의 상단부에 많이 닿으면 밝기 값이 서로 모이면서 이미지 노출이 과해진다.반대로 빛의 곡선이 하단부에 많이 닿으면 이미지 노출이 부족해진다. 따라서 카메라의 경우 노출을 조절해서 빛이 직선부에 많이 닿게 만드는 것이다.엔지니어들은 전이 함수를 활용하는 온갖 트릭을 만들었다. 예를 들면 카메라의 셔터 속도나 조리개를 조절하는 장치, 이어폰이나 스피커를 구동하는 증폭 회로도 있다.입력이 조금만 변해도 곡선의 가파른 부분 때문에 출력이 확 달라진다. 이때 판정기준을 ‘문턱값’이라고 부른다.5) 10진 숫자 대신 비트를 사용하는 이유컴퓨터에서 10진 숫자가 아닌 비트를 사용하는 이유는 무엇일까? 분명한 이유는 컴퓨터에는 손가락이 없기 때문이다. 손가락 대신 비트를 사용하면 100배보다 더 효율이 좋아진다. 또 숫자보다 비트가 더 좋은 이유는 숫자를 사용하면 전이 함수를 각기 다른 10가지 문턱값으로 구분할 수 있는 간단한 방법이 없다.또 전이 함수가 아주 가파르기 때문에 출력이 한 값에서 다른 값으로 아주 급하게 바뀐다. 따라서 비트를 사용하면 재량권이 아주 커진다.간단한 전기 이론 가이드1) 전기는 수도 배관과 유사하다전기를 물이라고 생각하면 물이 물탱크에서 나오는 것처럼 전기는 배터리 같은 에너지 근원에서 나온다. 물탱크가 텅 비면 물을 채워 넣어야 하는 것처럼 배터리 에너지가 고갈되면 충전을 해야한다.파이프를 사용하여 AND 연산을 수행하는 모습을 보면 두 벨브가 열려있을 경우에만 물이 흐른다. 이렇게 한 밸브의 출력이 다른 밸브의 입력에 연결될 경우 ‘직렬 연결’이라고 한다.두 밸브의 입력을 한 관에 함께 연결하고 두 밸브의 출력을 다른 관에 함께 연결하면 OR 연산을 수행하는 ‘병렬 연결’이 된다.물이 파이프를 흘러서 전달되는 데 시간이 걸리는 것처럼 전기가 컴퓨터 칩 내부에서 전파되는데도 시간이 걸린다. 이런 효과를 전파지연이라고 부른다.전기는 선을 통해 이동하고, 전기선 내부에 있는 금속을 ‘도체’ 금속 바깥쪽을 둘러싼 부분을 ‘부도체’라고 부른다. 또 전기의 흐름을 제어할 수 있는 밸브 역할을 스위치라 한다.전기에서 수압에 해당하는 존재를 전압이라 하고, 측정 단위는 볼트다. 전기 흐름의 양은 전류이고 측정 단위는 암페어다. 그리고 저항을 측정할 때는 옴을 사용한다.2) 전기 스위치전기에 사용할 스위치를 만드는 일은 도체 사이에 부도체를 삽입하거나 제거하는 문제일 뿐이다. 전등 스위치를 손으로 작동시키는 경우 단추를 누르면 금속이 붙거나 떨어지는 두 조각의 금속으로 구성된다.‘극’이란 한꺼번에 연결되어 이동하는 스위치의 수를 말한다. 위 예에서 나왔던 수도관 밸브는 모두 단극이였다. 밸브 두 쌍의 손잡이를 함께 움직이게 만들면 ‘쌍극’으로 만들 수 있다.‘단투’는 접점이 하나뿐이라는 뜻이다. 단투 스위치로 한쪽은 켜고 반대쪽은 끄는 역할을 하려면 ‘단극쌍투’ 스위치가 필요하다. 예)두 선로 중 한쪽으로 기차를 연결해주는 선로 분기또 원하는 개수만큼 극이나 접점을 사용해 스위치 관련 용어를 확장할 수 있다. ‘쌍극쌍투’ 스위치는 두 극이 서로 연계되어 두 스위치가 함께 움직인다.에너지 근원에서 나온 전기는 회로 구성요소를 지나서 다시 근원으로 돌아간다.비트를 처리하기 위한 하드웨어1) 릴레이선을 둥글게 감아서 코일로 만들고 전기를 흘려보내면 코일이 전자석이 된다. 전자석은 켜고 끌 수 있기 때문에 물건을 움직일 때 이를 활용할 수 있다.그리고 선으로 만든 코일 주변에서 자석을 움직이면 전기가 생긴다. 발전기는 이런 식으로 작동한다.릴레이는 스위치를 움직이기 위해 전자석을 사용하는 장치다. 릴레이를 사용하면 스위치로는 불가능한 일을 할 수 있다.릴레이를 사용하면 NOT 함수를 구현하는 인버터를 만들 수 있다. 또 위쪽의 AND 회로에서 나온 출력을 아래쪽에 OR 회로의 입력 중 하나를 구동하기 위해 연결할 수 있다.이런 능력을 활용하면 스위치가 다른 스위치를 제어하게 만들 수 있고, 컴퓨터에 필요한 복잡한 논리를 만들 수 있다.릴레이는 느리고 전기를 많이 소모하며, 먼지나 벌레가 스위치 접점에 있으면 제대로 작동하지 않는다는 큰 문제가 있다. 또 코일의 전원을 갑자기 끄면 순간적으로 초고압이 발생하고, 이때는 공기에서도 전기가 통한다.여러 단점 때문에 사람들은 릴레이와 같은 일을 하지만 기계적인 부품이 들어있지 않은 다른 물건을 찾기 시작했다.2) 진공관진공관은 물체를 충분히 가열하면 전자가 튀어나오는 열전자 방출이라는 현상을 기반으로 만들어졌다. 진공관 안에는 야구에서 투수 같은 캐소드와 캐소드를 가열하는 히터가 있다.캐소드에서 발생한 전자는 진공속에서 애노드로 날아간다. 이때 서로 다른 극이 서로를 끌어당기고 서로 같은 극이 서로를 밀어낸다는 성질이 발생한다.또 추가로 타자 역할을 하는 그리드가 있는데 그리드는 캐소드에서 나오는 전자를 쫓아내서 애노드에 도착하지 못하게 만든다. 이런 세 요소가 있는 진공관을 ‘삼극관’이라고 부른다.정리) 히터는 캐소드를 가열해 전자가 튀어나가게 한다 &gt; 그리드가 방해하지 않으면 전자가 애노드에 도달 (그리느를 스위치 손잡이로 생각할 수 있음)진공관의 장점은 움직이는 부분이 없어서 릴레이보다 훨씬 더 빠르고 단점은 전구와 마찬가지로 진공관도 아주 뜨겁고 깨지기 쉽다.3) 트랜지스터전송저항이라는 말을 줄인 트랜지스터는 진공관과 비슷하지만 반도체라는 특별한 물질을 사용한다. 반도체는 도체와 부도체 사이를 오갈 수 있는 물질이다.반도체는 쉽게 녹을 수 있기 때문에 트랜지스터에서 열을 제거하는 일은 아주 중요하다. 또 중요한 것은 트랜지스터가 반도체 물질로 이뤄진 기판 또는 슬랩 위에 만들어진다는 점이다.트랜지스터는 실리콘 웨이퍼 위에 투영해서 현상하는 광식각이라는 과정을 통해 만들어진다. 그래서 광식각 과정은 대량 생산에 적합하다.트랜지스터에 가장 중요한 두가지 유형으로 1)쌍극 접합 트랜지스터(BJT), 2)필드 효과 트랜지스터(FET)금속산화물 반도체 전계 효과 트랜지스터는 FET의 일종으로 전력소모가 적기 때문에 현대 컴퓨터 칩에서 가장 널리 쓰이고 있다.4) 집적 회로트랜지스터를 사용하면 AND 함수 같은 간단한 회로를 만들 때 조차도 부품이 너무 많이 필요하다. 그래서 직접 회로가 발명됐는데 직접 회로를 사용하면 복잡한 시스템을 트랜지스터 하나를 만드는 정도의 비용으로 만들 수 있다.이는 ‘칩’이라고 불렸다.논리 게이트텍사스 인스트루먼츠가 5400과 7400 집적회로 패밀리를 발표했다. 이 칩들에는 논리 연산을 수행하는 회로가 미리 들어가 있고 이런 회로를 ‘논리 게이트’라고 한다.게이트를 사용하면 하드웨어 설계자가 밑바닥부터 모든 회로를 설계할 필요 없이 IC를 선으로 연결해 복잡합 회로를 쉽게 만들 수 있다.인버터 기호에서 중요한 부분은 삼각형 꼭짓점에 있는 동그라미 기호이다. 이 기호가 없는 삼각형은 ‘버퍼’라고 하며 버퍼는 단지 입력을 출력으로 전달하기만 한다.인버터 기호는 인버터를 다른 논리 게이트와 별도로 독립적으로 사용할 때만 쓰인다.논리 게이트에서 가장 단순한 회로는 NAND(not and), NOR(not or) 이다. AND, OR은 NAND, NOR 회로 출력에 트랜지스터를 덧붙여서 출력을 반전시켜야 하기 때문에 더 비싸고 반응 속도도 더 느리며, 전력도 더 많이 소모된다.NAND로 만든 인버터를 사용해 입력을 반전시키면 OR을 만들 수 있다. 역으로 NAND의 출력에 NAND로 만든 인버터를 연결하면 AND가 된다. 따라서 NAND만 있으면 OR, AND, NOT으로 표현할 수 있는 모든 논리를 표현할 수 있다.게이트를 사용할 때 발생할 수 있는 복잡한 문제로는 다음과 같은 것이 있다.1) 이력 현상을 활용한 잡음 내성 향상디지털 장치를 사용하면 판정 기준에 의해 잡음 내성을 얻을 수 있다. 실제 현실에서 사용중인 신호 중에는 천천히 변하는 신호가 많다.입력 신호에 잡음이 있는 경우 입력 신호가 문턱값을 여러번 오락가락하기 때문에 출력 신호에 ‘글리치(작은 오류)’가 생긴다. 이런 글리치는 이력 현상을 사용해 방지할 수 있다. (이력현상: 판정기준이 이력에 따라 달라진다는 뜻)2) 차동 신호친구와 함께 길을 걷는데 친구가 나의 왼쪽에 있으면 0, 오른쪽에 있으면 1 이라고 했을 때 여러 방해요소에 의해 인도의 한쪽으로 밀려나게 되도 두 사람이 상대적인 위치를 바꾸지 않았기 때문에 방해요소가 결과값에 영향을 미치지 못한다.그래서 두사람이 함께 연인관계처럼 붙어있으면 강력한 잡음 내성을 만들어 내고 이런 방식을 ‘차동신호’ 라고 한다.연선 케이블링이 발명 됐는데 연선은 한쌍의 선을 서로 꼬아서 전기적으로 연인이 서로 허리에 손을 두르는 것 같은 효과를 만들어 낸다.3) 전파 지연전파지연은 입력의 변화가 출력에 영향을 미칠 때까지 걸리는 시간을 뜻한다. 정확한 값은 아니고 제조 과정과 온도에 따라 생기는 편차와 게이트 출력에 도달하기까지 연결된 구성 부품의 수에 따라 결정되는 통계적인 측정 값 이다.4) 출력 유형토템폴 출력 : 일반적인 게이트 출력은 토템폴이라고 부른다. 트렌지스터가 세로로 나란히 늘어서 있어서 붙은 것이다.오픈 컬렉터 출력 : 오픈 컬렉터나 오픈 트레인 버전은 액티브 풀업이 없기 때문에 출력을 아무 문제 없이 서로 연결할 수 있다. 필요하면 출력을 패시브 풀업에 연결할 수 있다. 패시브 풀업은 단순히 풀업 저항을 논리적인 1 값을 공급해주는 공급 전압에 연결한 것이다.오픈 컬렉터 출력과 패시브 풀업을 사용하면 와이어드 AND를 만들어낼 수 있다. 오픈 컬렉터 입력이 1이면 해당 게이트의 출력과 해당 게이트의 입력 사이는 회로 연결이 끊어진 상태라는 점에서 유의하라.오픈 컬렉터 출력 값 중 0인 값이 있다면 해당 게이트는 오픈 컬렉터 출력과 그라운드를 연결해주는 선로가 생긴다. 따라서 오픈 컬렉터 출력 중 0인 값이 하나 이상 있으면 와이어드 AND의 출력은 0이 된다.이 논리를 부정적인 논리로 해석하면 오픈 컬렉터 출력값 중 출력이 1인 값이 하나라도 있으면 출력이 1이 되는 것과 같기 때문에 이를 ‘와이어드 OR’이라고 부르기도 한다.트라이스테이트 출력 : 오픈 컬렉터 회로를 사용하면 출력을 서로 연결할 수 있지만 액티브 폴업을 사용하는 것만큼 응답이 빠르지 않다는 단점이 있다. 따라서 상태가 세 가지인 트라이스테이트 출력을 사용한다. 이 출력을 사용하면 수많은 장치를 서로 선으로 직접 연결할 수 있다.단점은 한 번에 단 하나의 장치만 활성화해야 한다는점이다.게이트를 조합한 복잡한 회로게이트를 사용하면서 하드웨어 설계 과정이 아주 단순해졌다. 더 이상 개별 부품을 가지고 회로를 설계할 필요가 없다. 하드웨어 설계자들은 SSI 게이트를 사용해 자신들이 개별적인 부품을 사용해 설계할 때와 마찬가지로 어떤 것이든 만들 수 있다.1) 가산기2) 디코더디코더는 인코딩된 수를 개별 비트의 집합으로 만들어진다.3) 디멀티플렉서디코더를 사용해서 디멀티플렉서를 만들 수 있다. 줄여서 디먹스라고도 부른다. 디먹스는 입력을 몇 가지 출력 중 한 곳으로 전달한다.4) 실렉터여러 입력 중 한 입력을 선택하는 기능을 실렉터라고 한다. 예를 들어 토스터 오븐기를 생각했을 때 꺼짐, 토스트, 베이크, 브로일 이라는 기호가 있는데 이 네 가지 선택지가 있는 버튼을 실렉터 스위치이다." }, { "title": "1장 컴퓨터 내부의 언어체계", "url": "/posts/1%EC%9E%A5-%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%82%B4%EB%B6%80%EC%9D%98-%EC%96%B8%EC%96%B4-%EC%B2%B4%EA%B3%84/", "categories": "BOOK, 한 권으로 읽는 컴퓨터 구조와 프로그래밍", "tags": "computer", "date": "2022-05-26 22:28:33 +0900", "snippet": "언어란 무엇인가언어는 편의를 제공하기 위한 지름길이다. 모든 언어의 뜻은 기호의 집합으로 인코딩 된다. 하지만 의미를 기호로 인코딩하는 것으로 충분하지 않다.언어가 제대로 작동하려면 의사소통하는 당사자들이 모두 같은 문맥을 공유해서 같은 기호에 같은 뜻을 부여할 수 있어야 한다.문자 언어문자 언어는 기호를 나열한 것이다. 기호를 정해진 순서대로 나열하면 단어를 만들 수 있다. 언어마다 기호와 기호 유형이 달라질 수 있고 순서도 다를 수 있다.다음의 구성 요소가 문자 언어의 틀을 이루고 컴퓨터 언어에서도 마찬가지이다. 기호가 들어갈 상자 상자에 들어갈 기호 상자의 순서비트자연어에서 상자는 ‘문자’라고 부르고 컴퓨터에서는 ‘비트 bit’라고 부른다. 비트는 binary + digit가 합쳐진 말이다.비트는 2진법을 사용하고 이는 모스 부호의 점(.)과 선(-)처럼 두 가지 기호 중 하나만 담을 수 있다는 뜻이다. 자연어와 마찬가지로 기호의 순서가 중요하다.예) A (.-), B(-…), C(-.-.)논리 연산비트 사용법 중 하나는 날씨가 추운가? 같은 예(true)/아니요(false) 질문에 대한 답을 표현하는 것이다. 자연어에서는 예/아니요 구절을 엮어 한 문장으로 만드는 경우가 자주 있다.‘밖에 비가 내리고 있거나 춥다면 코트를 입어라’ 이처럼 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 이런 동작을 ‘논리 연산’이라고 한다.1) 불리언 대수비트에 대해 사용할 수 있는 연산 규칙의 집합으로 기본적으로 NOT, AND, OR 세 가지의 연산자가 있다. NOT : 논리적 반대를 의미한다. 거짓인 비트에 NOT을 하면 참이 되고 참인 비트에 NOT을 하면 거짓이 된다. AND : 둘 이상의 비트에 작용한다. 모든 비트가 참인 경우 AND 연산의 결과도 참이다. OR : 둘 이상의 비트에 작용한다. 어느 한 비트라도 참이라면 OR 연산의 결과도 참이다. XOR : 첫 번째 비트와 두 번째 비트가 다른 값인 경우에만 참이 된다.2) 드로르간의 법칙불리언 대수에 적용할 수 있는 법칙으로 a AND b == NOT(NOT a OR NOT b) 이다. 즉 NOT을 충분히 사용하면 AND 연산을 OR 연산으로 대신할 수 있다는 의미이다.긍정적인 논리에 더해 부정적인 논리를 기술하는 명제를 사용할 때 드모르간 법칙을 활용할 수 있다.정수를 비트로 표현하는 방법1) 양의 정수 표현우리는 보통 10진수를 사용한다. 10진수 체계에서는 10가지 기호인 숫자를 상자에 담을 수 있고 이때 오른쪽에서 왼쪽으로 상자가 쌓여진다.맨 오른쪽에서부터 일의 자리, 십의 자리, 백의 자리 등등의 이름이 붙는다. 각 이름은 10의 거듭제곱에 해당한다.예) 5028을 계산하면 =&gt; 5 * 1000 + 0 * 100 + 2 * 10 8 * 1비트를 사용할 때도 비슷하게 동작하는데 각 상자에 사용할 수 있는 기호는 1과 0 두가지 밖에 없다. 따라서 각 상자의 자릴수는 2의 거듭제곱이며 2진수 체계는 10을 밑으로 하지 않고 2를 밑으로 하는 수 체계다.예) 2진수에서 가장 오른쪽의 비트를 가장 작은 유효비트(LSB)라고 부르고, 가장 왼쪽의 비트를 가장 큰 유효비트(MSB) 라고 부른다. 그래서 LSB를 변경하면 2진수의 값이 가장 작게 변경되고MSB의 비트를 변경하면 2진수의 값이 가장 크게 변한다.2) 2진수 덧셈2진수에서도 덧셈 연산을 할 때 10진수 처럼 각 비트를 LSB에서 MSB쪽으로 더하며 결과가 1보다 크면 다음 자리에 1을 올린다.덧셈 규칙을 논리 연산을 사용해 다음과 같이 표현할 수도 있다.두 비트를 서로 더한 결과는 두 비트를 XOR 한 값과 같고, 올림은 두 비트를 AND한 값과 같다. 덧셈 결과가 비트의 개수로 표현할 수 있는 범위를 벗어나면 ‘오버플로’가 발생한다.(MSB에서 올림이 발생했다는 뜻)예) 1001 과 1000을 더한 결과는 10001이다. 하지만 MSB 왼쪽에 사용할 수 있는 비트가 없기 때문에 결과가 0001이 된다.컴퓨터에는 조건코드 레지스터라는 것이 있어 몇가지 정보 중 오버플로 비트가 있고, 이 비트에는 MSB에서 발생한 올림값이 들어간다. 따라서 이 비트 값을 보면 오버플로가 발생했는지 알 수 있다.(반대로 MSB 위쪽에서 1을 빌려오는 경우 언더플로라고 한다.)3) 음수 표현 부호와 크기 : 음수와 양수를 구별하기 위해서 흔히 ‘부호’를 사용한다. 이 부호에는 비트를 하나 사용해서 표현하는데 가장 왼쪽 비트를 부호피트로 사용한다. 부호비트가 0이면 양수로 취급하고, 1이면 음수로 취급한다. 이런한 방법을 부호와 크기 표현법이라고 말한다.부호화 크기 표현법은 널리 쓰이지 못하고 있는데 이는 비트를 구성하는데 비용이 낭비되고, XOR, AND를 통한 덧셈 계산을 사용할 수 없다. 1의 보수 : 양수의 모든 비트를 뒤집는 방법이다. NOT 연산을 통해 보수를 얻는다. 예) 0111(+7) -&gt; 1000(-7) 1의 보수 표현법도 덧셈이 쉽지 않다. MSB쪽에서 올림이 발생한 경우 LSB 쪽으로 올림을 전달한다. 이를 순환 올림이라 부른다. 2의 보수 : 어떤 수의 비트를 뒤집고 1을 추가하면 음수를 얻는다. 예) 0001(+1) 을 뒤집으면 1110이고 여기에 1을 더하면 1111(-1)이 된다.**우리가 같은 숫자로 이뤄진 수를 보더라도 문맥에 따라 표현하는 값이 달라질 수 있다는 점을 꼭 염두해둬야 한다. 예를 들어 2진수 1111은 2의 보수에서는 -1이고,부호와 크기 표기로는 -7, 1의 보수에서는 -0이다. 따라서 사용하는 표현법을 반드시 알고 있어야 한다.실수를 표현하는 방법실수 표현은 밑이 10인 실수에는 10진 소수점이 포함되고, 밑이 2인 경우 2진 소수점을 표현할 방법이 필요하다. 여기서도 정수와 마찬가지로 문맥에 따라 실수를 표현하는 방법이 달라질 수 있다.1) 고정소수점 표현법예를 들어 4비트가 있다면 그중 2비트는 2진 소수점의 오른쪽에 있는 분수들을 표현하는데 사용하고 2비트는 왼쪽에 있는 숫지들을 표현하는 데 쓸 수 있다. 소수점의 위치가 항상 일정하기 때문에 이런 방식을 ‘고정소수점 표현법’이라고 한다.다만 2진수의 경우 1/2, 1/4 등 2의 거듭제곱을 분모로 사용한다는 점이 10진수와 다르다.2) 부동소수점 표현법과학적 표기법을 2진수에 적용한다. 과학적 표기법에는 0.0012 대신 1.2 X 10⁻³이라고 쓴다. 2진법으로 표기할 때는 10이 아닌 2를 밑으로 한다는 점이 10진법과 다르다.즉 가수 부분은 2진 소수, 지수 부분은 2의 거듭제곱 횟수를 표현한다. 그리고 이러한 표기법을 부동소수점 표현법이라고 부른다.여기서 지수의 밑인 2라는 숫자를 비트로 표현할 필요는 없다. 부동소수의 정의상 밑 2는 항상 정해져 있다. 부동소수점 표현법은 지수와 가수를 분리함으로써 수를 표현할 때 필요한 0을 모두 저장하지 않고도 큰 수나 작은 수를 표현할 수 있다.3) IEEE 부동소수점 수 표준부동소수점 수 시스템은 컴퓨터에서 계산을 수행할 때 실수를 표현하는 표준 방법이다. 똑같은 비트를 사용하더라도 정밀도를 높이기 위한 트릭으로 정규화가 있다. 정규화는 가수를 조정해서 맨 앞에 0이 없게 만드는 것이다.두 번째 트릭은 가수의 맨 왼쪽 비트가 1이라는 사실을 알고 있으므로 이를 생략하고 이로 인해 가수에 1비트를 더 사용할 수 있다.IEEE 754는 2가지 부동소수점 수가 자주 쓰인다. 1)기본 정밀도 부동소수점 수 2)2배 정밀도 부동소수점 수 이다. 두 가지를 살펴보면 2배 정밀도 수가 기본 정밀도 수보다 지수가 3비트 더 크고, 지수의 범위는 8배가 더 크다.또 가수가 29비트 더 커서 정밀도도 훨씬 더크다. 대신 비트를 2배나 더 많이 사용한다는 비용을 지불하고 얻은 것이다.IEEE 754에서 편리한 점은 0으로 나눴을 때 생길 수 있는 양의 무한대나 음의 무한대를 표현하는 비트 패턴 등 여러 가지 특별한 비트 패턴을 제공하고, 그 중 수가 아님을 뜻하는 NaN을 표현하는 특별한 값도 있다.2진 코드화한 10진수 시스템2진 코드화한 10진수(BCD)는 4비트를 사용해 10진 숫자를 하나 표현한다. 예) 12를 2진수로 표현하면 1100, BCD로 표현하면 0001 0010 이다.오래된 컴퓨터에서는 BCD 수를 처리하는 방법을 알고 있지만 이런 시스템은 더 이상 주류에 남아있지 않다.2진수를 다루는 쉬운 방법1) 8진 표현법8진이라는 말은 밑이 8이라는 뜻이다. 8진 표현법은 2진수 비트들을 3개씩 그룹으로 묶는 아이디어다.예)2진수의 8진 표현법 : 100/101/110/001/010/100 =&gt; 4/5/6/1/2/42) 16진 표현법2진수는 10진수에서 두 가지 0, 1을 사용하고 8진수는 숫자 8개만 사용한다. 하지만 16진수는 숫자 하나를 표현하려면 우리가 갖고 있는 10가지 숫자만으로는 충분하지 않다. 그래서 abcdef 기호가 10부터 15까지의 숫자를 표현한다고 믿기로 했다.여기서는 비트를 4개씩 그룹으로 나눈다.예)2진수의 16진 표현법 : 1101/0011/1111/1100/0001 =&gt; d/3/f/c/13) 프로그래밍 언어의 진법 표기법프로그래밍에서는 0으로 시작하면 8진수 예)017 =&gt; 10진수로 15, 1~9사이의 숫자는 10진수 예)123, 0x가 붙으면 16진수 예)0x12f =&gt; 10진수로 303이다.비트 그룹의 이름비트는 너무 작아서 기본 담위로 사용하기에는 유용성이 떨어진다. 따라서 세계적으로 8비트 덩어리를 기본 단위로 사용하는데 이를 ‘바이트’라고 부른다. 이름 비트 개수 nibble 4 byte 8 half word 16 word 32 double word 64 word는 컴퓨터가 빠르게 처리할 수 있는 가장 큰 덩어리를 뜻한다.큰 수를 표현하는 표준 용어로 미터법에서는 킬로(1천), 메가(100만), 기가(10억), 테라(1조)를 뜻한다. 컴퓨터에서는 약간 바꿔서 밑이 10이 아닌 2인 값을 표현하여 킬로비트, 킬로바이트에서는 1000이 아닌 1024 즉 2¹⁰을 뜻한다.하지만 때때로 밑이 10인 용어를 뜻할 때도 있어 어떤 밑으로 해석할지 문맥을 봐야하는데 IEC 표준 접두사가 만들어지면서 밑이 2인 표현법은 키비(KiB), 메비(MiB), 기비(GiB), 테비(TiB)텍스트 표현1) 아스키 코드텍스트를 표현하는 방법의 경우 정보 교환을 위한 미국 표준 코드 ASCII를 사용한다 이는 키보드에 있는 모든 기호에 대해 7비트 수 값을 할당했다.https://stepbystep1.tistory.com/10아스키 코드 표에서 몇 가지 재밌는 코드도 눈에 띈다. 장치를 제어하기 위해 쓰이는 제어 문자라고 불리는 코드로 NUL(null), ACK(수신확인), NAK(반수신확인) 등등이 있다.2) 다른 표준의 진화아스키코드는 영어를 표현하는데 필요한 모든 문자를 포함하고 있어 상당 기간 표준 역할을 했으나 컴퓨터가 널리 쓰이게 됨에 따라 그 밖의 언어를 지원해야할 필요가 점차 늘어났다.따라서 각 나라에서 자신들의 표준을 만들었으나 비트 가격이 떨어짐에 따라 유니코드라는 새로운 표준이 만들어졌고, 문자에 16비트 코드를 부여했으나 현재는 21비트까지 확장되었다.3) 유니코드 변환 형식 8비트유니코드는 문자 코드에 따라 각기 다른 인코딩을 사용한다. 유니코드 변환 형식 8비트(UTF-8)은 현재 가장 널리 쓰이고 있고, 이는 모든 아스키 문자를 8비트로 표현하기 때문에 아스키 데이터를 인코딩할 때 추가적인 공간이 필요하지 않다.또 아스키가 아닌 문자의 경우 아스키를 받아서 처리하는 프로그램이 깨지지 않는 방법으로 문자를 인코딩 한다.UTF-8은 문자를 8비트 덩어리(옥텟)의 시퀀스로 인코딩한다. UTF-8로 인코딩할 때 7비트 안에 문자의 코드가 범위안에 들어간다면 UTF-8 인코딩에서 덩어리를 하나만 사용하고 MSB는 0으로 설정한다.문자를 사용한 수 표현사람들은 컴퓨터 사이에 송수신시에 2진 데이터를 보내고 싶었다. 하지만 2진 데이터를 직접 보내는 것은 생각처럼 단순하지 않았다. 아스키 코드 중 상당수가 제어 문자로 예약되어 있어고, 이런 제어 문자는 시스템에 따라 처리하는 방식이 달랐기 때문이다.1) 출력 가능하게 변경한 인코딩출력 가능하게 변경한 인코딩(QP인코딩)은 8비트 데이터를 7비트 데이터만 지원하는 통신 경로를 통해 송수신하기 위한 인코딩 방법이다. QP인코딩은 전자우편 첨부를 처리하기 위해 만들어졌다.이 인코딩을 사용하면 = 다음에 바이트의 각 니블을 표현하는 16진 숫자 2개를 추가해 8비트 값을 표현한다.QP 인코딩은 몇 가지 규칙을 가지고 있다. 줄의 맨 끝에 탭과 공백 문자가 온다면 이를 각각 =90, =20으로 표현해야만 한다. 또 인코딩된 데이터는 한 줄이 76자를 넘을 수 없다.그리고 줄의 맨 뒤가 =으로 끝나면 가짜 줄바꿈을 뜻하며 수신쪽에서 QP로 인코딩된 데이터를 디코딩할 때는 이 =을 제거하고 해석한다.2) 베이스64 인코딩QP인코딩이 잘 동작하기는 하나 1바이트를 표현하기 위해 3바이트를 사용하기 때문에 아주 비효율적이다. 베이스64 인코딩이 더 효율적인데 이는 3바이트 데이터를 4문자로 표현한다.3바이트 데이터의 24비트를 네 가지 6비트 덩어리로 나누고 각 덩어리의 6비트 값에 출력 가능한 문자를 할당해 표현한다.3) URL 인코딩웹 페이지 URL에서 %26, %2F 같은 문자 시퀀스를 사용한다. 이런 값이 있는 이유는 URL이라는 문맥에서 몇몇 문자가 특별한 의미를 지니기 때문이다.URL 인코딩은 퍼센트 인코딩이라고도 부르는데, %뒤에 어떤 문자의 16진 표현을 덧붙이는 방식으로 문자를 인코딩한다.예)/는 URL에서 특별한 의미를 지닌다. 그래서 /가 표현하는 특별한 의미를 뜻하고 싶지 않은 경우 /를 %2F라는 문자열로 대신한다.색을 표현하는 방법컴퓨터 그래픽스는 전자 모눈종이에 해당하는 것에 색을 표현하는 점을 찍어서 그림을 만드는 과정이다. 이때 모눈의 각 격자에 짝는 점을 ‘그림 원소’라고 부르고 줄여서 ‘픽셀’이라고 부른다.컴퓨터 모니터는 빨간색, 녹색, 파란색 광선을 섞어서 색을 만들어 내고, 이런 식으로 빛을 혼합해 색을 표현하는 방식을 ‘가산’색 시스템이라고 부른다.현대 컴퓨터들은 색을 표현하는 데 24비트를 사용해 1천만에 가장 가까운 2의 제곱수에 해당하는 색을 표현할 수 있다. 24비트에 해당하는 이름이 없는데 이는 컴퓨터들이 24비트 단위로 계산을 수행하도록 설계되어 있지 않기 때문인다.따라서 24비트에 가까운 표준 크기인 32비트(word)에 색을 넣어서 처리하곤 한다.또 색을 표현할 때 낭비되는 비트들이 많다.그래서 이런 남는 비트를 활용하기 위해 투명도를 표현하는데 사용하게 된다.1) 투명도 추가초기 애니메이션에서는 각 프레임을 손으로 그렸으나 각 프레임의 배경을 정확히 재생산할 방법이 없어 수없이 많은 시각적인 흔들림이 존재했다. 이후 셀 애니메이션을 발명해 움직이는 캐릭터를 투명 셀룰로이드 필름위에 그려서 정적인 배경이미지 위에서 움직일 수 있게 하였다.이처럼 투명도가 있다면 여러 이미지를 하나로 합성하거나 결합할 수 있다.투명도와 합성을 구현하는 새로운 방법이 발명됐고 이 방법은 표준이 되었다. 각 픽셀에 알파라는 투명도 값을 추가했는데 이는 부동소수점을 사용하지 않았기 때문에 1~255까지의 값을 알파 값으로 사용했고, 사용하지 않는 비트들을 활용했다.2) 색 인코딩웹 페이지에서는 주로 사람이 읽을 수 있는 UTF-8 문자의 시퀀스로 이뤄지는 텍스트를 표현하기 때문에 텍스트를 사용해서 색을 표현할 방법이 필요하다.웹에서는 색을 16진 트리플렛으로 표현한다. 이는 # 뒤에 여섯자리의 16진 숫자를 추가해 #rrggbb처럼 표현하는 방식이다." }, { "title": "9장 자주 접하게 되는 질문들, FQA", "url": "/posts/9%EC%9E%A5-%EC%9E%90%EC%A3%BC-%EC%A0%91%ED%95%98%EA%B2%8C-%EB%90%98%EB%8A%94-%EC%A7%88%EB%AC%B8%EB%93%A4,-FAQ/", "categories": "BOOK, TDD 실천법과 도구", "tags": "tdd", "date": "2022-05-25 22:24:18 +0900", "snippet": "이미 충분히 많은 기능 테스트를 하고 있는데 따로 단위 테스트 케이스를 만들 필요가 있을까?기능 테스트와는 별개로 단위 테스트 케이스는 만들어야 한다. 기능 테스트는 사용자 쪽에 더 가깝고, 단위 테스트는 애플리케이션이 동작하는 플랫폼에 더 가깝게 위치한다.기능 테스트는 내부 클래스 동작 자체에는 크게 관여하지 않는다. 기능 테스트는 현상적으로 애플리케이션의 외부 동작 위주로 진행되기 때문이다.개발시 결과값을 미리 예상할 수 없는 경우에는 어떻게 TDD를 진행하나?TDD는 개발자가 특정 메소드를 호출했을 때 어떤 값이 리턴될지 알고 있다는 것이 사전조건으로 가정되어 있다. 질문의 경우 같은 상황이라면 임의의 값을 만들어 실패를 만들고 실패때 나온 값을결과 값으로 만들어서 현재 상태가 올바름을 알 수 밖에 없다.팀 내에 TDD를 통한 단위 테스트를 작성하지 않고도 높은 수준의 코드를 작성하고 있다면?단위 테스트 케이스는 현재 소스코드가 정상적으로 동작함을 보장하는 방법 중 하나다. 현재에만 주목하지 말고 미래에 투자하자단위 테스트 케이스를 작성하기 어렵다 어떻게 해야하나?TDD를 진행할 때, 억지로 테스트를 작성하는 것은 잘못된 접근이다. 테스트를 작성하기 쉽게 코드를 작성하는 것이 맞다. 테스트를 만들기가 어렵다면 기본적으로 만들어진 코드 설계를 다시 살펴보자private 메소드도 테스트 케이스를 만들어야 하나?private 접근 제한자는 외부에 알리고 싶지 않은 부분이라는 전제하에 만든다. 따라서 근래에는 private 메소드는 테스트하지 않아도 무방하다는 것이 주류이고, 굳이 테스트 케이스 수행을원한다면 리플렉션 등을 이용할 수는 있다.TDD를 적용하기 어려운 대표적인 이유는?작성해야할 기능이 있으면 코드를 작성하기 전에 테스트 케이스를 작성해서 진행하는 것이 일반적인 순서이다. 그런데 기능이나 기능 리스트가 명확하지 않으면 테스트 코드를 작성하기가 매우 어려워진다.또 개발자들의 연습이 되어 있지 않으면 예제 코드의 수준이 현업의 업무 상황이나 레벨과 차이가 나는 경우가 많다.따라서 선행 설계는 반드시 필요하고, 요구사항 도출 정련 기법과 기본 설계 개념에 대해서는 미리 어느 정도 이상의 지식이 있어야 한다.SI에서 TDD를 적용하는 것이 바람직 할까?SI는 전통적으로 개발과 유지보수가 분리되어 있다. 대개 개발은 납기일자와 비용이 미리 정해져 있다. 기일을 맞추기만 했다고 해서 성공적인 프로젝트라고 할 수 있을까?TDD는 제품의 품질을 증가시키고 제품 자체의 오류 감소, 변경 비용 감소 같은 비용 감소 효과를 가진다. 이렇듯 TDD가 줄 수 있는 것이 무엇인지 생각해볼 필요가 있다.TDD를 하면 TDD를 하지 않은 경우에 비해 확실히 품질도 높아지고, 개발도 빨라지는 것인가?TDD를 사용하면 확실히 결함이 적은 우수한 품질의 소프트웨어를 만들어낼 수 있고, 지속적으로 개선할 수 있는 바탕을 마련해준다는 데에는 대부분 동의를 하나개발 진척이 다소 늦어지는 거 같다고 말을 한다. 테스트 케이스를 작성하고 유지하는데는 노력이 들어가기 때문이다.TDD 도입시 초반에 어떤 활동을 같이 하면 좋을까?TDD를 도입하면 초반에 개발자들이 익숙해질 때까지는 다 함께 코드 리뷰를 진행할 것을 권장한다. 또 새로운 기능을 추가하거나 버그를 찾을 때 테스트 케이스를 먼저 만들도록 어느정도 강제할 필요가 있다.TDD는 습관이 중요하다.void 메소드를 테스트 가능하게 만들려면 어떻게 해야 할까?void는 리턴 값이 없다는 의미로 로직의 절차를 기술했거나 기능 위임 작업을 목표로 하겠다는 의미이다. 즉 void 메소드의 이름이 의미하는 작업을 그 메소드에서 끝을 내겠다는 뜻이다.이럴땐 행위 기반 테스트를 해야한다. 간단한 방법은 상태를 확인할 수 있는 다른 메소드의 결과를 테스트하는 방법이 있다.TDD와 단위테스트 둘이 같은 뜻인가?TDD는 개발 방식을 의미하고, 단위 테스트는 자동화된 테스트 케이스를 말한다. 보통 단위 테스트는 TDD로 개발한 작업의 부산물이 된다.정리TDD는 소프트웨어 개발에 있어 결코 절대적인 해법은 아니나 소프트웨어 개발 전쟁에서 사용할 수 있는 매우 유용한 무기이다. TDD는 개인에게나 팀에게나 매우 유용한 기술이고 보탬이 되는 기법이다." }, { "title": "8장 TDD에 대한 다양한 시각", "url": "/posts/8%EC%9E%A5-TDD%EC%97%90-%EB%8C%80%ED%95%9C-%EB%8B%A4%EC%96%91%ED%95%9C-%EC%8B%9C%EA%B0%81/", "categories": "BOOK, TDD 실천법과 도구", "tags": "tdd", "date": "2022-05-23 12:55:18 +0900", "snippet": "8.1 TDD와 소프트웨어 디자인TDD가 주는 설계상 이점TDD로 개발하면 TDD 자체가 단위 단위의 작은 설계를 만들어낸다. 입력과 출력, 해당 모듈이 동작하기 위해 필요한 요소 파악 등이 사전에 확실하게 고려되고 테스트된다. 이러한 모습을 ‘강형 마이크로 디자인’이라고 한다.이는 모듈에 대한 의존성이 상대적으로 적고, 각 모듈에 대한 테스트를 독립적으로 수행할 수 있도록 만들기 때문에 자기 완결성이 높은 모듈이 된다. 그래서 소프트웨어의 복잡도가 낮아지고 개발자가 좀 더 일반화되고 추상화된 형태의 디자인에 더 집중할 수 있게 도와준다.TDD와 객체 지향 프로그래밍OOP의 근간이 되는 기초 원칙 중에는 모듈은 높은 응집도를 유지하고 낮은 결합도를 갖도록 만들어야 한다 는 원칙이 있다. TDD로 작성을 하게 되면 기능과 객체의 관계를 스스로 먼저 고민하게 된다.테스트 케이스 코드는 입력과 출력이 명확하고, 사용되는 재료가 적을수록 작성하기가 쉽다. 즉 의존관계가 많은 코드는 테스트 코드 자체를 만들기가 어렵다.TDD는 자신의 모듈에 필요한게 무엇인지를 미리미리 고민하게 만들고 기능위주로 테스트를 하기 때문에 불필요한 속성/필드가 무엇인지도 초반부터 밝혀진다. 따라서 테스트를 작성하다 보면 어떠한 기능이 어떤 클래스에 의존하게 되는지 미리 알 수 있고,해당 기능이 어디에 있어야할지 생각할 수 있다. 이것이 응집도를 높이고 결합도를 낮추는 모습이다.유연한 코드흔히 변화에 쉽게 적응할 수 있는 코드를 유연한 코드라 부른다. 소프트웨어의 변경이 쉬워지려면 코드가 유연해야하는데, 소프트웨어 공학에서 추구하는 유연함이란 때로 개발비용 증가의 또 다른 요소가 되기도 한다.계약에 의한 설계계약이란 로직의 선/후행 조건 같은 단순한 개념에서부터, 개발에 필요한 업무규칙, 고객의 요구사항에 이르기까지의 다양한 경우를 지칭한다.예) 메소드 진행 전 인자로 받은 객체의 null 여부 확인(선행조건), 통장 개설시 최소한 100원 이상을 입금해야 한다.(업무규칙), 회원가입 시 반드시 유효한 이메일 주소를 입력해야한다.(요구사항)public void testAccout() { wrongAccount = new Account(-10000); assertTrue(\"계좌는 반드시 양수 금액으로 생성되어야 함\", wrongAccount.getBalance() &gt; 0);}위 처럼 작성하게 되면 Account 클래스의 생성자를 테스트해주는 것도 아니고, 그렇다고 getBalance() 메소드를 테스트하는 것도 아니다.public void testAccout() { try{ wrongAccount = new Account(-10000); assertTrue(\"계좌는 반드시 양수 금액으로 생성되어야 함\", false); }catch (IllegalArgumentException e) { assertTrue(true); }}public Account(int money) { if(money &lt; 0) { throw new IllegalArgumentException(\"계좌 생성시 money는 양수여야 함, 현재 \" + money); } this.balance = money;}8.2 TDD 유의사항1.테스트 케이스는 이름이 중요한다보통 테스트가 실패하면 실패한 메소드의 이름이 테스트의 기준이 된다. 따라서 테스트의 이름이 잘 작성되어 있어야 실패에 대한 대응을 빠르게 할 수 잇다.또 경우에 따라서는 테스트 메소드의 이름에 한글을 사용하는 것도 도움이 된다. 로직을 살펴보지 않고 메소드 이름만으로도 충분히 의미를 전달할 수 있을 정도로 작성하는 것이 중요하다.2.더 이상 제대로 동작하지 않는 테스트 케이스는 제거한다3.TDD는 자동화된 테스트를 만드는 것이 최종 목표가 아니다TDD는 개발의 목표 지점을 미리 정하기 위해 단위 테스트 케이스를 만들고, 목표 상태 도달 여부를 빨리 확인하기 위해 단위 테스트 케이스를 자동화 시킨다.자동화된 단위 테스트 케이스들은 TDD의 부산물이다. 즉 개발과 설계를 위한 보조 도구이지 목적은 아니다.4.모든 상황에 대한 테스트 케이스를 만들 필요는 없다요구사항에 맞는 현재 필요한 기능에 대한 테스트만 만든다.5.여러 개의 실패하는 테스트 케이스를 한 번에 만들지 않는다개발 중에는 작성하고 있는 하나의 클래스에 대해서는 하나의 실패하는 테스트만 유지한다. 해당 실패를 성공시킨 다음에 다음 실패 케이스를 작성한다.6.하나의 테스트 케이스는 하나만 테스트하도록 작성한다7.전통적인 테스트 기법을 배워두자8. 테스트 케이스는 최대한 고립시킨다단위 테스트는 다른 모듈이나 시스템에 최대한 독립적이고 고립된 형태로 작성될수록 단단한 테스트 케이스가 될 수 있다.가급적 다음과 같은 것들이 테스트에 들어가지 않도록 작성하면 더 좋다. 테스트 케이스가 작성되어 있지 않은 다른 모듈 데이터베이스 연동 외부 시스템 콘솔 출력 네트워크최대한 의존관계를 줄이고, 경우에 따라서는 Mock 객체를 이용해서라도 독립성을 보장해줘야 특정 테스트 실패에 따른 실패 전파현상을 최소한으로 줄일 수 있다.8.3 TDD와 리팩토링TDD에서 리팩토링은 중요한 부분을 차지한다. 리팩토링은 설계를 개선하고 유지하는 것이 목표다. TDD를 할 때 하나의 단계가 끝날 때마다 리팩토링을 하면 대상 코드뿐 아니라 자동화된 테스트 케이스 자체도 사용하기 좋은 코드로 정련이 된다.TDD에서 리팩토링은 매우 중요하다.8.4 TDD와 짝 프로그래밍TDD와 짝 프로그래밍은 잘 어울린다. 보통 사용자 스토리를 완성하기 위한 세부 ToDo 리스트가 만들어진 다음에 짝 프로그래밍으로 TDD를 적용해보면 효과가 더 높다. 팀원 간의 많은 대화로 목표 시스템에 대한 이해 증가 제품에 대한 공동설계와 공동 소유 개발에 효율을 높일 수 있는 작업 방식의 공유 개발 스킬 향상8.5 TDD와 심리학TDD를 실천하기 위해 팀 전체에 도입하고자 할 때 몇 가지 방법이 있다. 앞으로 TDD는 필수다 라고 강제력 있는 발언을 한다. - 개발 자체를 부담스러운 과정으로 만들 위험이 있다. 따라서 좀 더 긍정적이면서 개발과 별개가 아닌 일부라는 인식을 가질 수 있도록 유도할 필요가 있다. TDD로 개발하라고 말한 다음 자율에 맡긴다. - 십중팔구 흐지부지 된다. 테스트 커버리지를 강제화 한다. 매일 체크해서 관리지표로 삼는다. - 꽤 괜찮은 효과를 볼 수 있다.TDD를 어렵게 만드는 요인환경적 요인새로운 것을 배우면 적응돼서 효과를 볼 때까지 소요되는 학습 곡선의 마이너스 영역을 가질 여유가 없고, TDD로 개발하면 단순히 자판을 누르면서 진행해나가는 시행착오 반복 식의 개발보다는 초반에 고민해야 하는 요소가 더 많다.그렇기 때문에 피로는 누적되고 일정은 기다려주지 않는다.산만한 아키텍쳐TDD에서 집중하는건 단위 기능이지만 객체지향 언어에서는 대부분 오브젝트(클래스)로 구성된다. 이는 권한, 위임, 책임등을 갖고 외부와 통신한다. TDD를 통해 만들어진 자동화된 단위 테스트는 그 영역을 커버하지 못한다.그러다보니 단위 테스트들이 한 방향으로 치우치거나 산만하게 흩어져 있는 모습이 될 수 있다.의존성 전파로 인한 연쇄적인 테스트 실패들@Testpublic void testAddAccount() { ... }@Testpublic void testUpdateAccount() { testAddAccount() //......}이런 경우 testAddAccount()가 실패하게 되면 이를 호출한 테스트 케이스들도 실패하게 된다.8.7 행위 주도 개발TDD는 프로그램의 가장 하위 부분인 단위 메소드의 기능에 집중한다. 즉 시스템 안쪽에서부터 시작해서 사용자에 가까운 바깥쪽으로 만들어나가는 방식이다. 그래서 테스트를 어느 정도 작성하면 될 것인가, 어떤것을 테스트하고 어떤 것은 테스트를 안 해도 될까에 대한 적절한 판단도 함께 필요하다.BDD의 정의와 목표책임관계자의 관점에서 보는 애플리케이션의 행위(동작) 중 가치 있는 기능부터 개발하는 방식이다. 애플리케이션의 로직 중에서 특히 업무규칙과 관련된 부분을 밖으로 노출하는 데 집중한다.BDD의 특징 BDD는 사용자에 좀 더 가까운 고수준의 기능영역을 우선적으로 다룬다. 무엇을 테스트할 것인가?에 좀 더 초첨을 맞추고 있다. -&gt; 가장 먼저 구현돼야 하는 기능은 무엇인가? 테스트 메소드 작성에 집중할 수 있는 문장적인 템플릿을 제공한다. Given When Then 주어진 상황이나 조건 기능 수행 예상 결과 BDD 접근 전략개발자는 반드시 알아야 하고 견뎌내야하는 로직을 다룰 때는 TDD가 좋고, 고객 관점에서 이야기하거나 대상 시스템의 최종 형태를 파악하며 개발해야 할 때, BDD를 우선적으로 사용한다.BDD와 TDDTDD가 예제에 의한 개발과 단위 테스트 케이스를 지향한다면 BDD는 사용자 시나리오를 통해 사용자 테스트와 회귀 테스트를 지향한다. 또 TDD가 개발자를 위한 방식이라면 BDD는 책임관계자와 함께 하기 위한 방식이다.BDD 정리BDD는 TDD에서 사용되는 일종의 개발 전략이고 어떤 면에서는 발전형이라고 볼 수도 있다. 또 핵심 업무도메인을 대하는 일종의 대화법이다.public class LoginSteps extends Steps { //.... @Given(\"로그인하지 않은 상태라고 가정하고\") public void logOut() { page.click(\"logout\"); } @When(\"$username과 패스워드 $password로 로그인 했을 때\") public void logIn(String username, String password) { page.click(\"login\"); } @Then(\"다음과 같은 메시지가 보여야한다. \\\"$message\\\"\") public void checkMessage(String message) { ensureThat(page, containsMessage(message)); }}" }, { "title": "7장 개발 영역에 따른 TDD 작성 패턴", "url": "/posts/7%EC%9E%A5-%EA%B0%9C%EB%B0%9C%EC%98%81%EC%97%AD%EC%97%90-%EB%94%B0%EB%A5%B8-TDD-%EC%9E%91%EC%84%B1-%ED%8C%A8%ED%84%B4/", "categories": "BOOK, TDD 실천법과 도구", "tags": "tdd", "date": "2022-05-20 08:33:45 +0900", "snippet": "7.3 일반적인 애플리케이션TDD가 가장 적극적으로 사용되고 효율이 높은 부분은 애플리케이션의 업무 로직을 구현할 때다.생성자 테스트단순 클래스를 생성하기 위한 생성자의 경우 테스트 케이스를 작성하지 않는다. 다만 객체 사용을 위한 필수 값을 설정하는 경우에는 필요에 따라 테스트케이스를 작성한다.또 선행조건이나 업무로직을 직접 기술하는 경우도 있는데 이럴 경우는 테스트 케이스를 작성해야 한다.DTO 스타일의 객체 테스트단순 getter/setter로 이루어진 DTO는 굳이 테스트 케이스를 작성하지 않으나 특정 목적을 가진 불변 객체의 경우에는 테스트 케이스를 작성하기도 한다.닭과 달걀 메소드 테스트메소드가 서로 맞물린 경우 완전히 하나만 독립적으로 테스트하기 어려운 경우가 있다. 좋은 테스트 케이스 작성법 중 하나가 한 번에 실패 케이스를 하나씩 작성하는 것이나이 상황에서는 어느 한쪽만 먼저 구현하기 어려운 상황이 된다. 실패하는 테스트 케이스가 두 개인 상태에서 작업하기(일반적인 방법) 안정성이 검증된 제3의 모듈을 사용하기(가능하다면 권장) 자바 리플렉션을 이용해 강제로 확인하기(대체로 비권장)테스트 케이스를 리플렉션을 통해 해결하는 것은 잘못된 접근 방식이다. 리플렉션은 정말 부득이한 경우가 아니면 사용하지 않는다.예를 들면 private메소드를 부득이 테스트해야 하거나 소스코드 없는 외부 모듈을 받았는데 신뢰도 검증을 위해 해당 모듈의 내부 메소드를 테스트해야 하는 경우 등이 특별한 예외에 해당한다.배열 테스트 JUnit 4의 assertArrayEquals를 이용한다 - 기본적으로 순서를 따지기 때문에 순서를 고려하지 않을 경우 Arrays.sort를 이용하자 Unitils의 assertReflectionEquals나 assertLenientEquals를 이용한다. - JUnit 3의 경우라면 List로 변환해서 비교한다.객체 동치성 테스트객체 비교시 정말 동일한 객체인지를 판별해내야하는 ‘동일성 테스트’인지 아니면 같은 값을 같는 객체인지만 판별하면 되는 ‘동치성 테스트’ 인지 구분해서 생각해야 한다.두 객체를 서로 동치비교하는 방법에는 다음과 같이 있다. 내부 상태(필드값)를 직접 꺼내와서 각각 비교한다. toString을 중첩구현해 놓고, toString 값으로 비교한다. equals 메소드를 중첩 구현한다. (개념적으로 가장 올바른 방법이다.) Unitils의 assertReflectionEquals를 이용한다.컬렉션 테스트 자바 기본형이나 String이 컬렉션에 들어가 있는 경우 - 곧바로 비교 가능 일반 객체가 컬렉션에 들어 있는 경우 - 객체가 equals를 중첩구현 했다면 문제가 없지만, 안했다면 객체의 id값을 비교하기 때문에 값이 서로 다르다고 인식한다.7.2 웹 애플리케이션웹 애플리케이션의 기본 흐름은 HTTP 기반에서의 요청/응답이 전부다. 화면의 브라우저에서 무언가를 요청하면 서버는 적절한 응답을 한다.TDD로 개발하겠다라고 마음을 먹는다면 어떤 개발 영역이 있는지 살펴보고 영역별로 접근 전략을 잘 세워야 한다. 개인 PC의 웹 브라우저 서버 웹 애플리케이션의 구조MVC 아키텍처MVC 아키텍처는 웹 애플리케이션을 모델-뷰-컨트롤러라는 세 개의 영역으로 나누어 구성하는 것을 지칭한다.MVC의 장점은 view와 model의 느슨한 결합, 관심의 분리, 테스트 주도 개발의 용이함, 각 영역의 재사용성이 높아짐이 있다. 뷰 - 웹 애플리케이션의 사용자와 직접적으로 대화가 이뤄지는 부분, 사용자의 동작과 연관되어 있다. 비교적 자주 변경되는 부분이라 많은 시간이 소요된다. 따라서 뷰를 TDD로 개발하려면 쉽지 않다. 컨트롤러 - 모델과 뷰를 분리하기 위해 사용되는 중간 층이다. 컨트롤러에 대한 TDD는 비교적 수월하다. 요청으로부터 적절한 데이터를 발췌해내고, 해당 데이터를 모델로 넘긴다. 그리고 그 결과로 모델로부터 받은 데이터를 응답에 담아서 뷰로 넘기는 구조가 가장 기본적이다. 모델 - 모델은 오로지 무언가의 호출에 응답할 뿐이고, 컨트롤러가 모델을 호출하는 역할을 맡고 있다. 웹 애플리케이션 구성요소 중 가장 TDD가 쉽게 적용되는 부분이고, 또 적용해야하는 부분이다.뷰 TDD HttpUnit : 가상 웹 브라우저를 이용해 웹 페이지의 요소들을 테스트하기 위해 사용하는 프레임워크이다. HttpUnit을 통한 TDD 웹 개발은 거의 불가능에 가깝다. Selenium : Selenium IDE : 브라우저와 통합돼서 녹화/실행/확인 기능을 제공한다. 현재 파이어폭스 브라우저만 지원한다. Selenium RC(Remote Control) : 브라우저를 원격으로 조종해서 웹 페이지에 대한 테스트를 수행한다. Selenium Grid : 여러 개의 Selenium RC 서버를 구동해서 테스트 수행의 스케일업을 지원한다. 위 중 TDD로 뷰를 작성하기 위해 사용할 수 있는 부분은 Selenium RC 이다. Selenium은 테스트 수행시에 웹 브라우저를 실제로 기동시킨다. 그 다음 웹 브라우저를 조종해서 테스트를 수행하기 때문에 실제와 같은 테스트가 가능하다. Cubic Test : 웹 애플리케이션의 기능을 테스트하는 부분에 기능이 집중되어 있다. Cubic Test는 GUI 기반에서 순서도를 작성하듯 웹 애플리케이션에 대한 기능 테스트를 작성할 수 있다. 내부적으로는 Selenium RC가 동작한다.컨트롤러 TDD컨트롤러를 테스트하는 가장 간단한 방법은 뷰로부터 넘어오는 요청을 가상으로 만들어주고, 그 결과에 해당하는 응답이 예상과 일치하는지 판단하는 것이다.@Testpublic void testSearchByEmpid() { MockHttpServletRequst request = new MockHttpServletRequst(); MockHttpServletResponse response = new MockHttpServletResponse(); request.addParameter(\"empid\", \"5874\"); EmployeeSearchServlet searchSevlet = new EmployeeSearchServlet(); searchSevlet.service(request, response); Employee employee = (Employee)request.getAttrubute(\"employee\");}모델 TDD 도메인 모델에 대한 TDD : 대표적인 예가 DTO이고, 대부분의 DTO는 단순하기 때문에 TDD로 작성할 필요가 거의 없다. 서비스 모델에 대한 TDD : 기능 위주로 구성된 클래스들로 애플리케이션의 핵심적인 부분이다. 스쳐 지나가는 서비스 모델 : SQL과 DAO를 연결해주는 것과 결과값을 객체로 받는것이 전부인 서비스 모델이 있다.웹 애플리케이션에 대한 TDD 접근 전략 정리 모델, 뷰, 컨트롤러를 최대한 분리시킨다. 부는 단순히 표현 계층으로 보고 업무 로직이 들어가지 않도록 유지한다. 모델에 대한 TDD는 최대한으로 적용한다.7.3 데이터베이스데이터베이스 관련 테스트는 몇 가지 어려움이 있는데 1)테스트 진행시 데이터베이스에 들어있는 데이터의 상태가 바뀐다. 2)테스트 전,후의 데이터 비교가 쉽지 않다.데이터베이스 상태가 바뀌는 문제의 일반적인 해결방법 트랜잭션을 선언하고 테스트 케이스를 수행한 다음 롤백처리한다. 테스트 케이스 작성 시 ‘입력-&gt;수정-&gt;삭제’ 순서대로 테스트 케이스가 실행되도록 만든다. SQL 스크립트가 테스트 수행시에 실행되도록 만든다. DbUnit을 사용한다.테스트 전후의 데이터베이스 상태를 비교하는 방법 예상 결과를 미리 다른 테이블에 넣어놓고, 대상 테이블과 예상 테이블을 각각 Select문으로 결과를 받아와서 바교한다. 예상 결과를 미리 문자열로 만들어놓고 Select 문을 실행해서 이용해 비교한다. DbUnit과 Unitils를 함께 사용한다.정리데이터베이스와 연관되어 있는 프로그램에 대해 TDD 진행시 가장 효율이 높은 방법으로 1)@BeforeClass를 이용해 트랜잭션을 선언해놓고 ‘입력-&gt;수정-&gt;삭제’ 순으로 동작시켰던 방식 2)DbUnit, Unitils를 함께 사용하는 방식이 있따.7.4 안티패턴, 전통적으로 잘못 인식되어 있는 테스트 메소드의 리팩토링좋은 테스트 케이스는 다음과 같은 규칙을 따른다. 하나의 테스트 케이스는 외부와 독립적이어야 한다. 따라서 다른 테스트 케이스에 영향을 주거나 받지 않아야 한다. 하나의 일관된 시나리오를 갖고 있어야 한다.테스트 메소드는 하나의 일관된 시나리오을 갖고 외부에 독립적이어야 하는데 setUp을 함께 살펴봐야 문맥적으로 하나의 정상적인 테스트 시나리오가 만들어지는 경우가 있다. 중복되는 코드가 존재하면 안된다고 생각할 수 있으나테스트 케이스 코드는 접근이 조금 다르다. 정련시 중복을 제거하는 것은 맞지만 그 중복되는 부분이 테스트 시나리오의 일부라면 조금 고민해볼 필요가 있다." }, { "title": "6장 단위테스트 지원 라이브러리:Unitils", "url": "/posts/6%EC%9E%A5-%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A7%80%EC%9B%90-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-Unitils/", "categories": "BOOK, TDD 실천법과 도구", "tags": "tdd", "date": "2022-05-18 22:28:45 +0900", "snippet": "6.1 Unitils를 사용하기 위한 환경 준비Unitils 라이브러리를 사이트에서 내려 받고, 클래스패스에 포함시켜준다. JUnit4와 마찬가지로 static import를 주로 사용한다.6.2 Unitils의 단위 테스트 지원 기능들객체 동치성 비교테스트 케이스를 작성하다 보면 객체끼리 동치성 비교를 해야하는 경우가 흔히 발생한다.@Testpublic void testBook() { Book abook = new Book(\"사람은 무엇으로 사는가?\", \"톨스토이\", \"9000\"); Book otherBook = new Book(\"사람은 무엇으로 사는가?\", \"톨스토이\", \"9000\"); assertEquals(aBook, otherBook); //fail}객체의 비교는 단순히 참조 비교를 하기 때문에 두 객체는 의도된 객체의 상태 측면에서는 동일하지만 결과는 두 객체가 서로 다르다고 판정한다.그래서 다음과 같이 각 필드를 비교해야 한다.assertEquals(aBook.getName(), otherBook.getName())assertEquals(aBook.getAuthor(), otherBook.getAuthor())assertEquals(aBook.getPrice(), otherBook.getPrice())리플렉션 단정문객체의 필드에 저장되어 있는 값을 알아서 비교해주는 기능이다.assertReflectionEquals(예상객체, 실제객체);, assertReflectionEquals([메시지], 예상객체, 실제객체);@Testpublic void testBook() { Book abook = new Book(\"사람은 무엇으로 사는가?\", \"톨스토이\", \"9000\"); Book otherBook = new Book(\"사람은 무엇으로 사는가?\", \"톨스토이\", \"9000\"); assertReflectionEquals(\"Book 객체 필드 비교\", aBook, otherBook);}리플렉션 단정문의 너그러운 비교리플렉션 단정문에는 몇 가지 옵션을 지정할 수 있는데 대부분 리팩토링이 일어나면서 발생하는 테스트 케이스의 깨짐을 보완하기 위해 사용된다. 이러한 방식을 ‘너그러운 단정문’ 적용 이라고 한다.assertReflectionEquals(예상객체, 실제객체, ReflectionComparatorMode)[ReflectionComparatorMode] - 대상을 비교할 때 좀 더 유연한 비교를 할 수 있도록 세 가지 옵션을 제공한다. LENIENT_ORDER : 컬렉션, 배열을 비교할 때 순서 무시 IGNORE_DEFAULTS : 예상 객체 필드 중 타입 기본값을 갖는 필드에 대해서는 비교하지 않음 단, 필드 기본값을 비교해서 제외하는 것은 예상 객체를 기준으로 한다. LENIENT_DATES : 시간, 날짜 타입은 비교하지 않음**Unitils에는 assertLenientEquals라는 것이 있는데 이는 assertReflectionEquals의 간략화 버전으로 세 개의 옵션 중 LENIENT_DATES을 제외한 두 개를 동시에 적용해서 비교하는 버전이다.프로퍼티 단정문보통 특정 필드에 값이 제대로 할당됐는지 확인하는 가장 간단한 방법은 getter 메소드를 통해서 값을 직접 확인한다. 하지만 경우에 따라서는 getter 메소드가 제공되지 않는 경우도 있다.그럴때는 Unitils의 assertPropertyLenientEquals를 이용하면 된다. assertPropertyLenientEquals(속성이름, 예상되는 속성값, 실제 객체)assertPropertyLenientEquals는 자바빈 규칙을 따르는 식으로 프로퍼티를 비교한다. 추후 getter 메소드가 생기게 되면 assertPropertyLenientEquals는 해당 bean 규약에 맞는 getter 메소드를 이용해 프로퍼티 값을 불러와서 비교를 수행한다.6.3 Unitils 모듈Unitils의 모듈은 다양한 서비스를 제공하는데 테스트 케이스 작성시 해당 모듈을 사용하려면 UnitilsJUnit3, UnitilsJUnit3, UnitilsJUnit4, UnitilsTestNG 등의 Test Listener가 필요하다.Test Listener를 사용하려면 Test Listener를 테스트 클래스가 상속하거나 @RunWith 같은 애노테이션으로 Test Runner로 지정하면 된다.[모듈 종류] DatabaseModule : 데이터베이스 관리와 커넥션 풀 관련 DbUnitModule : DbUnit을 사용할 때 사용하는 테스트 데이터 관리 HibernateModule : 하이버네이트 설정 지원과 DB 매핑 체크 MockModule : Unitils에서 제공하는 Mock 프레임워크 EasyMockModule : EasyMock 지원 기능 InjectModule : 오브젝트를 강제로 할당시켜 버리는 Injection 기능 SpringModule : 스프링의 애플리케이션 컨텍스트 지원과 스프링 빈의 주입 기능6.4 DbUnit과 함께 사용하는 데이터베이스 지원 모듈환경을 위한 Unitils.properties 파일 설정database.driverClassName=org.apache.derby.jdbc.EmbeddedDriverdatabase.url=jdbc:derby:shopdbdatabase.userName=database.password=database.schemaNames=Appdatabase.dialect=derbyDatabaseModule.Transacional.value.default=disabled@DataSet이 어노테이션을 사용하면 클래스이름.xml 파일을 기본 데이터셋으로 인식하고 DB로 읽어들인다. (FlatXmlDataSet 타입이어야 함)클래스 레벨에서 @DataSet 애노테이션이 사용되면 클래스이름.xml 파일을 데이터셋으로 인식한다.@RunWith(UnitilsJUnit4TestClassRunner.class)@DataSetpublic class DatabaseRepositoryTest { @Test public void testFindById() throws Exception { Repository repository = new DatabaseRepository(); Seller actualSeller = repository.findById(\"horichoi\"); assertPropertyLenientEquals(\"id\", \"horichoi\", actualSeller); assertPropertyLenientEquals(\"name\", \"최승호\", actualSeller); assertPropertyLenientEquals(\"email\", \"megaseller@hotmail.com\", actualSeller); }}클래스 이름과 데이터셋 파일 이름이 일치하지 않는다면 직접 지정도 가능하다. @DataSet(\"seller.xml\") 또 메소드 레벨에서도 데이터셋을 지정할 수 있다.@Test@DataSet(\"DatabaseRepositoryTest.testAddNewSeller.xml\")public void testAddNewSeller() throws Exception { Seller seller = new Seller(\"hssm\", \"이동욱\", \"scala@hssm.kr\") Repository repository = new DatabaseRepository(); ...}또 FlatXMLDataSet 외의 데이터셋 타입을 이용하고 싶다면 DataSetFactory인터페이스를 직접 구현한 다음 설정파일에 DbUnitModuleDataSet.factory.default 항목으로 지정하면 된다.데이터셋 로드 전략@DataSet은 CLEAN_INSERT가 기본 동작이지만 원할 경우 다른 동작을 지정할 수 있다. 1)설정 파일에 지정하는 방식, 2)애노테이션 사용시 지정하는 방식//1)DbUnitModule.DataSet.loadStrategy.default=org.unitils.dbunit.datasetloadstrategy.InsertLoadStrategy//2)@DataSet(loadStrategy = InsertLoadStrategy.class) CleanInsertLoadStrategy : 테이블의 내용을 모두 지우고 데이터셋의 내용을 INSERT InsertLoadStrategy : 데이터셋을 INSERT RefreshLoadStrategy : 데이터셋의내용으로 DB 갱신 UpdateLoadStrategy : DB에 존재하는 데이터를 UPDATETestDataSource, 테스트에 사용하는 데이터소스 접근하기Unitils는 설정파일에 지정된 DB 관련 값을 이용해 DataSource를 구성해 자동으로 DB 연결을 만들어 테스트를 진행하도록 설계되어 있다.경우에 따라 DataSource에 직접 접근할 필요가 있는 경우 1)@TestDataSource 애노테이션을 DataSource에 지정해서 Unitils가 자동으로 주입하도록 하는 방법2)DatabaseUnitils.getDataSource() 메소드를 이용하는 방법이다.@TestDataSourceprivate DataSource dataSource;private ShopDAO dao;@Beforepublic void initalize() { this.dao = new ShopDAO; dao.setDataSource(dataSource);}dao.setDataSource(DatabaseUnitils.getDataSource());@ExpectedDataSet, 예상 데이터셋을 이용한 테스트 메소드 레벨의 결과 비교@Test@ExpectedDataSet(\"expected_seller.xml\")public void testAddNewSeller() throws Exception { Seller newSeller = new Seller(\"hssm\", \"이동욱\", \"scala@hssm.kr\"); Repository repository = new DatabaseRepository(); repository.add(newSeller);}직접 예상 데이터셋을 지정하지 않는다면 Unitils는 기본적으로 ‘클래스이름.메소드이름-result.xml’ 이라는 데이터셋 파일을 찾는다.@Transacional, 트랜잭션 처리DB관련 기능을 테스트할 때 트랜잭션 처리가 필요한 경우가 많다. 기본적으로 Unitils의 DB관련 기능을 이용해 테스트를 수행하게 되면 모든 테스트는 트랜잭션이 발생하는 상태로 동작하고, 테스트 마지막에 커밋을 발생시킨다.//1) Unitils.propertiesDatabaseModule.Transacional.value.default = rollback//2) @Transacional 애노테이션으로 지정@Transacional(TransacionModule.ROLLBACK)public class ShopDaoTest extends UnitilsJUnit4{}6.5 DBMaintainer: DB를 자동으로 유지보수해주는 DB 유지보수 관리자Unitils의 DBMaintainer는 개발자 각자의 DB 스키마를 SQL 스크립트를 이용해 자동으로 유지시켜주는 기능이다. 프로젝트 내에 폴더를 만들어서 필요한 DB스크립트를 넣는다. DB 스트립트의 형식은 숫자형식의 버전넘버를 _언더바로 구분지어 이름을 짓는다. 예)001_DROP_ALL_TABLE.sql … Unitils의 DataSource를 이용하는 테스트 클래스를 실행한다. DBMaintainer는 지정된 스크립트 폴더를 모니터링해서 변경된 내용이 있으면 반영한다.DB 구조를 SQL 스크립트로 관리하고, 추가 내용을 덧붙여 반영하도록 만들 때 매우 유용하다. 새로운 스크립트가 추가된 경우라면 해당 스크립트만 실행하고, 기존 스크립트가 변경된 경우라면 스키마를 전체를 리셋하고, 다시 처음부터 스크립트를 실행한다.DBMaintainer 기능 활성화 시키기DBMaintainer의 기능은 기본값으로는 false 상태이기 때문에 사용하기 위해서는 설정파일에 true로 지정해야한다. updateDatabaseSchema.enabled=true 그리고 스크립트 파일들이 존재하는 폴더를 지정한다. dbMaintainer.script.locations=src/dbscriptsdbMaintainer.autoCreateExecuteScriptsTable=true autoCreateExecuteScriptsTable 테이블을 스크립트들을 버전관리하기 위해 사용하는 테이블로 최초에는 자동으로 생성하기 위해 true로 설정한다.또 다음의 기능을 지원한다. 모든 참조키와 Not Null 제약조건을 비활성화시키기 때문에 INSERT 스크립트 실행을 편리하게 만들어준다. 시퀀스 타입들을 높은 숫자로 업데이트 시켜주어 기본키 값을 고정값으로 지정해도 충돌이 나지 않도록 도와준다. 데이터베이스의 구조를 XSD 파일로 만들어준다.6.6 기타 지원 모듈들하이버네이트 지원 모듈 HibernateSessionFactory : SessionFactory를 쉽게 얻을 수 있게 도와준다. 실제 데이터베이스 구조와 하이버네이트 매핑 파일내의 구조가 일치하는지 테스트해준다.스프링 지원 모듈 @SpringApplicationContext, 스프링 애플리케이션 컨텍스트 설정 지원 스프링 빈 주입Mock 지원 모듈" }, { "title": "5장 데이터베이스 테스트 DbUnit", "url": "/posts/5%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8-DbUnit/", "categories": "BOOK, TDD 실천법과 도구", "tags": "tdd", "date": "2022-05-16 11:40:45 +0900", "snippet": "5.1 DbUnit의 장점DB를 사용하는 부분은 프로그래밍 언어 외적인 부분이 상당 부분 포함되기 때문에 TDD를 적용하기가 종종 쉽지 않다. 이럴때 도움을 받을 수 있는 유틸리티로 DbUnit이 있다. 독립적인 데이터베이스 연결 지원 데이터베이스의 특정 시점 상태를 쉽게 내보내거나 읽어들일 수 있다. 테이블이나 데이터셋을 서로 쉽게 비교할 수 있다.DbUnit은 독립적으로 사용하기보다는 JUnit 등의 테스트 프레임워크 등과 함께 사용한다. 따라서 테스트 프레임워크라기 보다는 테스트 지원 라이브러리에 더 가깝다.5.2 데이터셋데이터셋은 데이터베이스나 그 안에 존재하는 테이블 혹은 그 일부를 xml이나 csv 파일로 나타낸 모습이다.예) SELLER table ID NAME EMAIL aaaa 김가가 aaa@naver.com bbbb 고나나 bbb@hanmail.com cccc 황다다 ccc@naver.com &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;dataset&gt; &lt;seller ID=\"aaaa\" NAME=\"김가가\" EMAIL=\"aaa@naver.com\"/&gt; &lt;seller ID=\"bbbb\" NAME=\"고나나\" EMAIL=\"bbb@hanmail.com\"/&gt; &lt;seller ID=\"cccc\" NAME=\"황다다\" EMAIL=\"ccc@naver.com\"/&gt;&lt;/dataset&gt;DbUnit은 이런 데이터셋의 형식을 이용해서 DB의 상태를 저장하거나 변경, 유지한다.데이터베이스 연결과 테이블 초기화현재 가정한 데이터베이스 내의 데이터 내용이 변경된다면 기능 구현에 문제가 없음에도 불구하고 테스트 케이스가 실패할 수 있다. 따라서 현재 가정되어있는 DB안의 데이터 상태가 테스트를 수행하기 전에 가정했던 모습으로 한결같이 유지 됐으면 좋겠다.그래서 테스트 관련 테이블 초기화 -&gt; 테스트 케이스 수행 이라는 전략을 세웠다.public class DatabaseRepositoryTest { //..... //1.DbUnit을 사용하기 위해서는 DbUnit에서 제공하는 DBTestCase를 상속하도록 작성한다. //상속하지 않고 DbUnit에서 제공하는 기능을 이용하려면 IDatabaseTester라는 인터페이스를 사용하면 된다. private IDatabaseTester databaseTester; @Before public void setUp() throws Exception { //2. IDatabaseTester 구현체로 JDBC 연결방식을 이용한다. databaseTester = new JdbcDatabaseTester(driver, protocol+dbName); try { //3. 데이터셋을 지정한다. IDataSet dataSet = new FlaxXmlDataSetBuilder().build(new File(\"seller.xml\")); //4. DB커넥션과 데이터셋을 이용해 DB에 특정 작업을 수행한다. DatabaseOperation.CLEAN_INSERT.execute(databaseTester.getConnection(), dataSet); }finally { databaseTester.getConnection().close(); } }}위 setUp() 메소드는 테스트 메소드가 수행되기 전에 항상 seller.xml에 지정된 상태로 테이블을 초기화한다.데이터셋 비교//1. 현재 데이터베이스의 상태를 데이터 셋으로 추출한다.IDataSet currentDBdataSet = databaseTester.getConnection().createDataSet();//2. 데이터셋에서 특정 테이블을 가져온다.ITable actualTable = currentDBdataSet.getTable(\"seller\");//3.미리 만들어놓은 예상 데이터셋을 읽어들인다.IDataSet expectedDataSet = new FlaxXmlDataSetBuilder().build(new File(\"expected_seller.xml\"));//4. 예상 데이터셋 중에서 비교에 사용할 테이블을 읽어들인다.ITable expectedTable = expectedDataSet.getTable(\"seller\");//5. DbUnit에서 제공하는 Assertion 클래스의 메소드를 이용해 결과를 비교한다.Assert.assertEquals(expectedTable, actualTable);5.3 DbUnit 데이터셋의 종류DbUnit은 DB 데이터의 구조를 나타내기 위해 데이터셋이라는 개념을 사용한다. 데이터셋은 하나의 타입을 나타냄과 동시에 테이블들의 집합체를 표현하는 IDataSet 인터페이스의 구현체를 의미하기도 한다.FlatXmlDataSet 테이블 이름을 XML TAG 구성요소로 적는다. 컬럼 이름은 속성으로 적는다. null 값을 넣을 컬럼은 표현하지 않는다. 자동으로 null 값이 들어간다. XML, DTD를 지정하지 않아도 된다. 데이터셋 중 가장 흔하게 사용된다.&lt;dataset&gt; &lt;EMPLOYEE NO=\"101\" NAME=\"안병현\" EMAIL=\"megan@hssm.kr\"&gt;&lt;/EMPLOYEE&gt;&lt;/dataset&gt;XmlDataSet 다소 장황한 버전 DTD 반드시 포함 잘 사용하지 않음StreamingDataSet 데이터베이스의 커서 개념처럼 단방향으로 동작, 현재 레코드만 메모리에 존재 UPDATE, INSERT, REFRESH 같은 동작을 하는 XML 데이터셋을 읽어들일 때 매우 효율적으로 동작IDataSetProducer producer = new FlatSmlProducer(new InputSource(\"dataset.xml\"));IDataSet dataSet = new StreamingDataSet(producer);DatabaseDataSet 데이터베이스 인스턴스에 대한 접근을 제공한다. 직접 new로 생성하지 않고 팩토리 메소드로 만들어낸다.IDataSet currentDBdataSet = IDatabaseConnection.createDataSet();QueryDataSet 쿼리문으로 데이터셋을 만들어낸다.QueryDataSet dataSet = new QueryDAtaSet(connection);dataSet.addTable(\"NEW_EMPLOYEE\", \"SELECT * FROM EMPLOYEE WHERE EMPNO &gt; 600\");dataSet.addTAble(\"DEPARTMENT\");XlsDataSet MS 엑셀 문서를 데이터셋으로 인식한다. 엑셀 문서 내의 각 시트를 테이블로 인식한다. 시트의 첫 번째 줄을 컬럼으로 인식한다. 나머지 줄은 데이터 값으로 인식한다.ReplacementDataSet 데이터셋에서 특정한 문자열을 치환하기 위해 사용한다. 보통은 null 값을 다르게 표현하고 런타임시에 치환하는 데 많이 사용한다.&lt;dataset&gt; &lt;EMPLOYEE NO=\"101\" NAME=\"안병현\" EMAIL=\"megane@hssm.kr\"&gt;&lt;/EMPLOYEE&gt; &lt;EMPLOYEE NO=\"102\" NAME=\"김상옥\" EMAIL=\"[null]\"&gt;&lt;/EMPLOYEE&gt;&lt;/dataset&gt;ReplacementDataSet dataSet = new ReplacementDataSet(new FlaxXmlDataSet(...));dataSet.addReplacementPbject(\"[NULL]\", null);5.4 DbUnit의 DB 지원 기능DbUnit에서는 데이터셋을 이용한 DB관리 작업을 DataBaseOperation이라는 개념으로 만들어 놓았다.DatabaseOperation.오퍼레이션이름.execute(DB커넥션, 데이터셋)[오퍼레이션의 종류]5.5 DbUnit과 AntAnt를 사용하는 경우 개발툴이나 IDE에 의존하지 않고, 시스템 레벨에서 배치 작업등을 이용해 좀 더 높은 수준의 자동화를 이룰 수 있다.DbUnit에서 Ant를 이용하기 위해서는 dbunit.jar 파일을 추가한다. 그리고 Ant 빌드파일 내에 태스크를 정의한다.&lt;taskdef name=\"dbunit\" classname=\"org.dbunit.ant.DbUnitTask\"/&gt;Ant 적용전@Beforepublic void setUp() throws Exception { databaseTester = new JdbcDatabaseTester(driver, protocol+dbName); IDataSet dataSet = new FlaxXmlDataSetBuilder().build(new File(\"seller.xml\")); DatabaseOperation.CLEAN_INSERT.execute(databaseTester.getConnection(), dataSet);}Ant 적용후&lt;target name=\"sellerdb-init\"&gt; &lt;dbunit driver=\"org.apache.derby.jdbc.EmbeddedDriver\" url=\"jdbc:derby:shopdb\" userid=\"\" password=\"\" &gt; &lt;opration type=\"CLEAN_INSERT\" src=\"seller.xml\"/&gt; &lt;/dbunit&gt;&lt;/target&gt;이처럼 무언가 일괄적으로 DbUnit을 이용해 DB를 조작할 때 Ant를 이용하면 유리하다.5.6 정리데이터셋을 만드는 일은 비용과 노력이 많이 드는 작업이며, DbUnit을 반드시 써야할지는 고민해볼 필요가 있다. 개발자마다 데이터베이스 인스턴스나 스키마를 하나씩 사용하자 나중에 정리할 필요가 없게 setUp 처리를 잘하자 데이터셋의 크기는 작고, 여러개를 만드는네 꼭 필요한 테스트 데이터 위주로 만들자 데이터셋을 너무 많이 만들지 말라 클래스 기반으로 만들고 다른 테스트 클래스와 공유해서 사용하지 말자" }, { "title": "4장 한계 돌파를 위한 노력, Mock을 이용한 TDD", "url": "/posts/4%EC%9E%A5-%ED%95%9C%EA%B3%84-%EB%8F%8C%ED%8C%8C%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%85%B8%EB%A0%A5,-Mock%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-TDD/", "categories": "BOOK, TDD 실천법과 도구", "tags": "tdd", "date": "2022-05-12 00:10:45 +0900", "snippet": "4.1 Mock 객체Mock 객체란 무엇인가?Mock 이란 조각하기 쉬운 재료를 이용하여 추후 만들어질 제춤의 외양을 흉내 낸 모조품을 말한다. 즉 실제 모듈과 비슷하게 보이도록 만든 가짜 객체를 Mock 객체라고 한다.예) 사용자 암호를 변경하는 기능을 구현하기 위해 테스트 케이스를 작성하는데 추가 요구사항으로 사용자의 패스워드를 반드시 암호화한 다음에 저장해야 한다.암호화 모듈의 스펙은 interface로 정해져 있고, 이 모듈은 다른 팀에서 구현하기로 결정한다고 했을 때 다른팀에서 암호화 모듈을 완성할 때까지 테스트를 진행하기가 어렵다.이럴때 스펙이 정해져 있으니 암호화 모듈처럼 보이는 객체를 만들어서 테스트에 사용할 수 있다.정리하자면 우리가 구현하는데 필요하지만 실제로 준비하기엔 여러가지 어려움이 따르는 대상을 필요한 부분만큼만 채워서 만들어진 객체 를 말한다.언제 Mock 객체를 만들 것인가?테스트 케이스 작성이 어려운 상황과 Mock 객체가 필요한 상황은 종종 일치하곤 한다. 대부분의 경우 모듈이 가진 의존성이 근본적인 원인이 된다. 모듈이 필요로 하는 읜존성은 테스트 작성을 어렵게 만든다.그리고 그 의존성을 단절시키기 위해 Mock 객체가 사용된다. 테스트 작성을 위한 환경 구축의 어려운 경우 : 환경 구축을 위한 작업시간이 많이 필요한 경우, 특정 모듈을 아직 갖고 있지 않아서 ,타 부서와의 협의나 정책이 필요한 경우에 Mock이 필요하다. 테스트가 특정 경우나 순간에 의존적인 경우 : 특히 예외처리를 테스트할 때 많이 접한다. Mock을 이용하면 특정 상태를 가상으로 만들어놓을 수 있다. 테스트 시간이 오래 걸리는 경우4.2 Mock에 대한 기본적인 분류 개념, 테스트 더블제라드 메스자로스가 만든 단어로 테스트 더블은 오리지널 객체를 사용해서 테스트를 진행하기 어려울 경우 이를 대신해서 테스트를 진행할 수 있도록 만들어주는 객체를 지칭한다. Mock 객체는 테스트 더블의 하위로 분류되어 있다.예) 고객이 쿠폰을 발급받아 저장하고, 그 내역을 확인할 수 있는 기능 구현public interface ICoupon { public String getName(); //쿠폰 이름 public boolean isValid(); //쿠폰 유효 여부 확인 public int getDiscountPercent(); //할인율 public boolean isAppliable(Item item); //해당 아이템에 적용 가능 여부 public void doExpire(); //사용할 수 없는 쿠폰으로 만듬}public class UserTest{ @Test public void testAddCoupon() throws Exception { User user = new User(\"area88\"); assertEquals(\"쿠폰 수령 전\", 0, user.getTotalCouponCount()); ICoupon coupon = ????? user.addCoupon(coupon); assertEquals(\"쿠폰 수령 후\", 1, user.getTotalCouponCount()); }}위 예제에서 ICoupon은 테스트 대상은 아니고 테스트에 사용되는 일종의 테스트 픽스처이다. 하지만 이 구현 객체가 없으면 정상적인 테스트 케이스를 작성할 수 없다. 이때 테스트 더블을 활용하여 이 상황을 극복할 수 있다.더미 객체더미 객체는 단순한 껍데기에 해당한다. 오로지 인스턴스화될 수 있는 수준으로만 ICoupon 인터페이스를 구현한 객체다.public class DummyCoupon implements ICoupon{ @Override public String getName() { return null; } @Override public boolean isValid() { return false; } @Override public int getDiscountPercent() { return 0; } @Override public boolean isAppliable(Item item) { return false; } @Override public void doExpire() { }}public class UserTest{ @Test public void testAddCoupon() throws Exception { User user = new User(\"area88\"); assertEquals(\"쿠폰 수령 전\", 0, user.getTotalCouponCount()); ICoupon coupon = new DummyCoupon(); user.addCoupon(coupon); assertEquals(\"쿠폰 수령 후\", 1, user.getTotalCouponCount()); }}더미 객체는 단지 인스턴스화된 객체가 필요할 뿐 해당 객체의 기능까지는 필요하지 않은 경우에 사용한다.(정상 동작은 보장되지 않음)테스트 스텁테스트 스텁은 더미 객체가 마치 실제로 동작하는 것처럼 보이게 만들어놓은 객체다. 더미 객체와 다르게 테스트 스텁은 객체의 특정 상태를 가정해서 만들어놓은 단순 구현체다.특정 값을 리턴해주거나 특정 메시지를 출력하는 등의 작업을 한다.public class StubCoupon implements ICoupon{ @Override public String getName() { return \"VIP 고객 한가위 감사쿠폰\"; } @Override public boolean isValid() { return true; } @Override public int getDiscountPercent() { return 7; } @Override public boolean isAppliable(Item item) { return true; } @Override public void doExpire() { }}단지 인스턴스화될 수 있는 객체 수준이면 더미, 인스턴스화된 객체가 특정 상태나 모습을 대표하면 스텁이다.@Testpublic void testGetLastOccupiedCoupone() throws Exception { User user = new User(\"area88\"); ICoupon coupon = new StubCoupone(); user.addCoupon(coupon); ICoupone lastCoupone = user.getLastOccupiedCoupone(); assertEquals(\"쿠폰 할인율\", 7, lastCoupone.getDiscountPercent()); assertEquals(\"쿠폰 이름\", \"VIP 고객 한가위 감사 쿠폰\", userCoupone.getName());}스텁은 특정 객체가 상태를 대신해주고 있긴 하지만 하드코딩된 형태이기 때문에 로직이 들어가는 부분은 테스트할 수 없다.특정 쿠폰이 구매 제품에 적용되는지 여부에 따라 결제액이 바뀌는걸 테스트하는 경우 할인이 적용되는 아이템과 할인이 적용되지 않은 아이템에 대한 테스트가 필요하다. 이런 경우 아이템에 따라 쿠폰이 적용 가능한지 안한지로 판단하여 하드코딩 하여 작성할 수 있다.이렇게 테스트 더블로 만들어진 객체가 발전하면 단순 스텁을 벗어나서 실제 로직이 구현된 것처럼 보이는데 그런 객체를 페이크 객체라고 한다.페이크 객체페이크 객체는 스텁과 경계를 구분짓기 어려우나 스텁은 하나의 인스턴스를 대표하는데 주로 쓰이고, 페이크는 여러 개의 인스턴스를 대표할 수 있는 경우이거나 좀 더 복잡한 구현이 들어가 있는 객체를 지칭한다.public class FakeCoupone implement ICoupone { List&lt;String&gt; categoryList = new ArrayList(); public FakeCoupone() { categoryList.add(\"부엌칼\"); categoryList.add(\"아동 장난감\"); categoryList.add(\"조리기구\"); } @Override public boolean isAppliable(Item item) { if(this.categoryList.contains(item.getCategory()) { return true; } retuen false;}페이크 객체는 복잡한 로직이나 객체 내부에서 필요로 하는 다른 외부 객체들의 동작을, 비교적 단순화하여 구현한 객체다. (복잡도 = 더미 &lt; 테스트 스텁 &lt; 페이크 객체)테스트 스파이테스트에 사용되는 객체에 대해서도 특정 객체가 사용됐는지 그리고 객체의 예상된 메소드가 정상적으로 호출됐는지를 확인해야 하는 상황이 발생한다.보통은 호출 여부를 몰래 감시해서 기록했다가, 나중에 요청이 들어오면 해당 기록 정보를 전달해준다. 그런 목적으로 만들어진 테스트 더블을 테스트 스파이라고 부른다.@Testpublic void testGetOrderPrice_discounableItem() throws Exception { PriceCalculator calculator = new PriceCalculator(); Item item = new Item(\"LightSavor\", \"부엌칼\", 100000); ICoupon coupon = new FakeCoupon(); //getOrderPrice를 구하기 위해서는 isAppliable 메소드가 1번 호출되어야 한다는 것이 가정되어 있다. assertEquals(\"쿠폰으로 인해 할인된 가격\", 93000, calculator.getOrderPrice(item, coupon));} @Override public boolean isAppliable(Item item) { isAppliableCallCount++; //호출되면 증가 if(this.categoryList.contains(item.getCategory()) { return true; }//테스트 스파이public int getIsAppliableCallCount() { return this.isAppliableCallCount;}테스트 스파이는 아주 특수한 경우를 제외하고 잘 쓰이지 않는다. 대부분의 Mock 프레임워크들은 기본적으로 테스트 스파이 기능을 제공해준다.[상태 기반 테스트, 행위 기반 테스트]상태 기반 테스트는 테스트 대상 클래스의 메소드를 호출하고, 그 결과 값과 예상 값을 비교하는 식이다. 특정 메소드를 거친 후, 객체의 상태에 대해 예상값과 비교하는 방식이 상태 기반 테스트이다.행위 기반 테스트는 올바른 로직 수행에 대한 판단의 근거로 특정한 동작의 수행 여부를 이용한다.Mock 객체일반적으로 테스트 더블은 상태 기반으로 테스트 케이스를 작성하고, Mock 객체는 행위를 기반으로 테스트 케이스를 작성한다.행위기반 테스트는 복잡한 시나리오가 사용되는 경우가 많고, 모양이나 작성 등 여러가지 측면에서 어색한 경우가 많기 때문에 만일 상태 기반으로 테스트를 할 수 있는 상황이라면 굳이 행위 기반 테스트 케이스는 만들지 않는 것이 좋다.Mock 객체라는 용어가 주는 혼란스러움 정리Mock 객체는 넓은 의미로 일반적인 가성 임시 구현체의 의미로 사용되는 경우가 많다. 테스트 더블과 거의 동등한 의미로 사용되는 경우가 많았기 때문에 따라서 Mock 객체라는 단어를 테스트 더블과 동일한 의미로 사용할 것이다.**테스트 케이스 작성시 매번 클래스를 구현하는 것은 번거로울 수 있다 그럴땐 명시적인 클래스 보다는 ‘익명 클래스’로 만들어서 사용하4.3 Mock 프레임워크Mock 프레임워크는 동적으로 Mock 객체를 만들어주는 프레임워크를 지칭한다. Mock 프레임워크 종류로는 EasyMock, jMock, Mockito가 있다. 이중 Mockito는 간편함과 기존 Mock 프레임워크들이 지향했던행위 기반 테스트 위주에서 상태 위주 테스트로의 회귀를 전면으로 내세우고 있다.EasyMock스프링 프레임워크에서 테스트로 사용하는 EasyMock 이다. 기본적으로 Recode &amp; Replay라는 메타포를 사용하며 네 단계로 동작한다. createMock : 인터페이스에 해당하는 Mock 객체를 만든다. Record : Mock 객체 메소드의 예상되는 동작을 녹화한다. Replay : 예정된 상태로 재생한다. Verify : 예상했던 행위가 발생했는지 검증한다.//1. createMockList MockList = createMock(List.class)//2. Record//녹화expect(Mock 객체의 메소드).andReturn(예상 결과값);//재생replay(Mock 객체);expect(mockList.add(\"item\")).andReturn(true);expect(mockList.size()).andReturn(0).items(2);mockList.clear();replay(mockList);녹화 및 재생은 Mock 객체가 만들어진 이후부터 재생이 호출되기 전까지 동작이 기록된다. 행위 기록이기 때문에 횟수를 지정할 수도 있다.//3. 검증 verify(Mock_객체);@Testpublic void listMockTest() throws Exception { mockList = createMock(List.class); expect(mockList.add(\"item\")).andReturn(true); expect(mockList.size()).andReturn(0).items(2); mockList.clear(); replay(mockList); verify(mockList);}jMockjMock은 다른 프레임워크와 구별되는 몇 가지 독특한 차이점을 목표로 개발되었는데 특히 테스트의 표현 확대와 가독성 증진에 많은 노력이 들어가 있다.[특징] 연쇄 호출 : 동일 객체에 여러 개의 메시지를 보낼 때 발생하는 번잡스러움을 해결하기 위해 만들어진 스타일이다. 사전에 특정 워크플로를 만들어놓고, 해당 순서에 해당하는 객체를 리턴하는 방식으로 변경한다.//전bookedTicket.setDeparture(A);bookedTicket.setArrival(B);bookedTicket.setDepartureDate(date);bookedTicket.setAdditionalFare(fare);//후bookedTicket.departure(A) .arrival(B) .departureDate(date) .additionalFare(fare); 전용 Matcher 사용 : 기본적으로 Hamcrest Matcher 라이브러리를 사용하고 있다. CreateMock : 인터페이스에 해당하는 Mock 객체를 만든다. Expect : Mock 객체 메소드의 예상되는 동작을 미리 지정 한다. Exercise : 테스트 메소드 내에서 Mock 객체를 사용한다. Verify : 예상했던 행위가 발생했는지 검증한다. 예상 동작 지정 및 테스트 수행 예상값 지정하기 검증 : 프레임워크가 알아서 처리해주기 때문에 명시적으로 검증을 표시할 필요가 없다.//1. 테스트 픽스처 클래스 정의와 Mockery 생성@RunWith(JMock.class)public class PublisherTest { Mockery context = new JUnit4Mockery();}//2. Mock 객체 만들기final Subscriber subscriber = context.mock(Subscriber.class);//3. 예상 동작 지정 및 테스트 수행//\t{{}} 가 연속적으로 사용된 것은 Anonymous 클래스로 만들어지고 있는 Expectation 클래스의 필드 부분에 멤버 블록을 만든 코드다. -&gt; 클래스가 생성과 동시에 호출됨context.checking(new Expectations() {{ //예상 동작들을 지정한다.}});//4. 예상값 지정하기호출횟수지정메소드(Mock_객체).Mock객체메소드(argument_지정);inSequence(sequence-name);when(state-machine.is(state-name));will(action);then(state-machine.is(new-state-name));MockitoMockito는 역사는 오래되지 않았지만 상태 기반 테스트를 지향한다는 점이 인기 요인이 되었다.[특징] 테스트 그 자체에 집중한다. 테스트 스텁을 만드는 것과 검증을 분리시켰다. Mock 만드는 방법을 단일화했다. 테스트 스텁을 만들기 쉽다. API가 간단하다. 프레임워크가 지원해주지 않으면 안되는 코드를 최대한 배제했다. 실패 시에 발생하는 에러추적이 깔끔하다.**Mockito는 EasyMock과 jMock의 단점을 보완하기 위해 나온 Mock 프레임워크라고 생각하면 된다. CreateMock : 인터페이스에 해당하는 Mock 객체를 만든다. Stub : 테스트에 필요한 Mock 객체의 동작을 지정한다. Exercise : 테스트 메소드 내에서 Mock 객체를 사용한다. Verify : 메소드가 예상대로 호출됐는지 검증한다.//1. Mock 객체 만들기Mockito.mock(타깃 인터페이스);List mockedList = mock(List.class);//2. 예상 값 지정 : Mockito는 스텁-&gt;수행-&gt;검증으로 단순화되어 있다. 미리 예상 행동을 고민하지 않고 테스트를 수행 후 결과를 보자는 개념이다.//3. 테스트에 사용할 스텁 만들기when(Mock_객체의_메소드).thenReturn(리턴값);when(Mock_객체의_메소드).thenThrow(예외);mockedList.add(\"item\")mockedList.clear();when(mockedList.get(0)).thenReturn(\"item\");when(mockedList.size(0)).thenReturn(1);when(mockedList.get(1)).thenThrow(new RuntimeException());//4. 검증verify(Mock_객체).Mock_객체의_메소드;verify(Mock_객체, 호출횟수지정_메소드).Mock_객체의_메소드;verift(mockedList).add(\"item\");verift(mockedList, times(1)).add(\"item\"); //times(n) : n번 호출됐는지 확인verift(mockedList, times(2)).add(box);verift(mockedList, never()).add(car); //never : 호출되지 않았어야 함verift(mockedList, atLeastOnce()).removeAll(); //atLeastOnce : 최소 한 번은 호출됐어야 함verift(mockedList, atLeast()).size(); //atLeast(n) : 적어도 n번은 호촐됐어야 함verift(mockedList, atMost(5)).add(box); //atMost(n) : 최대 n번 이상 호출되면 안됨[Mockito의 특징적인 기능] void 메소드를 Stub으로 만들기 - void 메소드에서 예외가 발생하는 경우 Stub으로 구현할 때 doThrow 메소드를 사용한다. 콜백으로 Stub 만들기 : thenAnswer - 특정 Mock 메소드에 대해 실제 로직을 구현하고자 할 때 콜백 기법을 사용, 권장하지 않는 방식이다. 실체 객체를 Stub으로 만들기 : SPY - Mockito는 실 객체도 Mock으로 만들 수 있는데 한정적으로 사용하기를 권장한다. 똑똑한 NULL 처리 : SMART NULLS - mock(List.class, RETURNS_SMART_NULLS); 행위 주도 개발(BDD) 스타일 지원 - //given, //when, //then 식의 행위 주도 개발 스타일로 테스트 케이스 작성을 지원해준다. BDDMockito를 static import한다.4.4 Mock 프레임워크 마무리[Mock 사용시 유의사항] Mock 프레임워크가 정말 필요한지 잘 따져본다. 투자 대비 수익이 확실할 때만 사용한다. 어떤 Mock 프레임워크를 사용하느냐는 핵심적인 문제가 아니다. Mock은 Mock일 뿐이다. - 실제 객체가 끼어들어 왔을 때도 잘 동작하리라는 보장은 없다.**테스트 케이스 작성을 위한 궁극의 템플릿으로 //given(선행조건 기술), //when(기능수행), //then(결과 확인)" }, { "title": "3장 TDD 좀 더 잘하기", "url": "/posts/3%EC%9E%A5-TDD-%EC%A2%80-%EB%8D%94-%EC%9E%98%ED%95%98%EA%B8%B0/", "categories": "BOOK, TDD 실천법과 도구", "tags": "tdd", "date": "2022-05-09 10:52:32 +0900", "snippet": "3.1 테스트 케이스 클래스의 위치단위 테스트 케이스를 소스 구조 안에서 어디에 놓을 것인지 결정해야 한다.1)테스트 대상 소스와 테스트 클래스를 같은 곳에테스트 클래스와 같은 패키지 내에 놓는 가장 기본적인 형태이다. 간단한 테스트 생성시 외에 사용하지 않는다.2)테스트 클래스는 하위 패키지로예) src/bank - 제품코드 클래스, src/bank/test - 테스트 케이스 클래스3)최상위 패키지를 분리제품 클래스는 main 패키지에, test 클래스는 test 패키지에 따로 분리흔히 많이 사용하는 방식으로 최상위 패키지부터 업무 코드와 테스트 코드를 분리해서 작성할 수 있다. 단점으로는 default, protected로 선언된 메소드들에 대해서는 테스트 코드를 작성할 수 없다.4)소스 폴더는 다르게, 패키지는 동일, 컴파일된 클래스는 각각 다른 곳으로장점으로 대상 클래스와 테스트 클래스를 동일한 패키지로 선언할 수 있고, 접근 범위 default, protected로 선언된 메소드도 테스트 케이스로 작성할 수 있다.또 대상 클래스와 테스트 클래스의 위치가 최상위 폴더부터 다르게 만들어지기 때문에 서로 섞일 염려가 없다. 따라서 가장 권장하는 스타일이다.5)테스트를 프로젝트로 분리동일 프로젝트 내에 제품 코드 클래스와 테스트 클래스가 함께 존재하면 각자 사용하는 라이브러리를 클래스패스로 공유하게 된다. 따라서 외부 라이브러리 의존 관계를 좀 더 확실하게 구분하고자 할 때는 프로젝트 단위로 분리해 놓기도 한다.이클립스 기준) Test 프로젝트를 생성하고 Java Build Path 항목의 Project &gt; Add &gt; 참조할 클래스 추가, 이렇게 하면 JUnit 라이브러리조차 필요 없어진다.6)메이븐 스타일 /src/main/java : 제품 코드가 들어가는 위치 /src/main/resource : 제품 코드에서 사용하는 각종 파일, XML 등의 리소스 파일 /src/test/java : 테스트 코드가 들어가는 위치 /src/test/resource : 테스트 코드에서 사용하는 각종 파일, XML 등의 리소스 파일3.2 테스트 메소드 작성 방식1)테스트 대상 메소드와 이름을 1:1로 일치//테스트 대상public int getBalance() {....}//테스트 코드@Testpublic void testGetBalance(){...}테스트 메소드의 숫자가 적어져서 보기 편하고, 1:1로 연관지어 생각할 수 있다는 장점이 있다. 하지만 성공 케이스와 실패 케이스가 중간 중간 섞여 있을 수 있는데 구별이 불가능하다는 단점이 있다.2)테스트 대상 메소드의 이름 뒤에 추가적인 정보를 기재//테스트 대상public void withdraw(int money) {...}//테스트 코드@Testpublic void testWithdraw_마이너스통장인출() {...}@Testpublic void testWithdraw_잔고가0원일때() {...}테스트 대상 코드의 메소드 단위로 작성하게 되고, 케이스 별로 테스트 메소드를 추가하는 방식으로 가장 권장되는 방식이다.3)테스트 시나리오에 집중테스트 시나리오에 집중해서 대상 클래스 자체의 통합적인 기능을 테스트할 때 사용한다. 통합 테스트, 사용자 테스트의 특성상 일반적으로 ‘선조건-&gt;수행-&gt;예상결과’ 식의 테스트 시나리오를 갖는다.public class 환승테스트 { @Test public void 평일_30분이내에_환승_성공한다() {...} @Test public void 평일_30분이후에_환승_실패한다() {...}}3.3 테스트 케이스 작성 접근 방식테스트 클래스의 구성뿐만 아니라 테스트를 작성하는 데 있어서 어떤 형태로 접근할 것인가에 대한 논의가 필요하다. 설계자와 개발자가 분리되어 있는 경우 : 설계자가 설계문서에 테스트 케이스(테스트 시나리오)를 작성해놓아야 한다. 개발자가 설계와 개발을 함께 하는 경우 : 개발자가 고객과 합의가 가능할 정도로 능동적으로 참여할 수 있는 상황이라면 테스트 작성 범위에 대해 크게 고민할 필요가 없다. 무엇을 테스트 케이스로 작성할 것인가? : 시나리오식 접근 방법에는 정상적인 흐름일 때 동작해야 하는 결과값을 선정해놓는 방식인 해피데이 시나리오, 예외나 에러 상황에 대한 결과값을 적은 블루데이 시나리오 등이 있다.3.4 TDD의 한계 동시성 문제 : 동시성이 걸려있는 코드에 대한 테스트 케이스 작성은 테스트 자체를 무결하게 유지하기가 어렵다. 접근제한자 : private으로 되어있는 메소드는 일반적인 방법으로는 테스트가 불가능하다. (public으로 되어있는 메소드만 테스트해도 무방하다는 경향이 대세) GUI : 웹 애플리케이션에 해당하는 영역이 TDD를 적용하기 곤란한 GUI 영역이다. 최선의 전략은 ‘UI 영역에는 비즈니스 로직이 최대한 들어가지 않게 작성한다’ 이다. 의존성 모듈 테스트" }, { "title": "2장 JUnit과 Hamcrest", "url": "/posts/2%EC%9E%A5-JUnit%EA%B3%BC-Hamcrest/", "categories": "BOOK, TDD 실천법과 도구", "tags": "tdd", "date": "2022-05-06 15:27:32 +0900", "snippet": "2.1 JUnitJUnit은 현재 전 세계적으로 가장 널리 사용되는 Java 단위 테스트 프레임워크이다. 기본적으로 다음과 같은 기능을 제공한다. 테스트 결과가 예상과 같은지를 판별해주는 단정문 여러 테스트에서 공용으로 사용할 수 있는 테스트 픽스처 테스트 작업을 수행할 수 있게 해주는 테스트 러너꼭 알아두어야할 개념으로 테스트 픽스처(테스트 기반 환경 또는 테스트를 위한 구조물)라는 개념이다.테스트 픽스처테스트 픽스처는 테스트를 반복적으로 수행할 수 있게 도와주고 매번 동일한 결과를 얻을 수 있게 도와주는 ‘기반이 되는 상태나 환경’을 의미한다. (일관된 테스트 실행환경이라고도 한다.)예) 테스트 케이스에서 사용할 객체의 인스턴스를 만든다, 데이터베이스와 연동할 수 있는 참조를 선언한다 등등그리고 테스트 픽스처를 만들고 정리하는 작업을 수행하는 메소드를 ‘테스트 픽스처 메소드’라고 한다.테스트 케이스와 테스트 메소드테스트 케이스는 테스트 작업에 대한 시나리오적인 의미가 강하고, 테스트 메소드는 JUnit의 메소드를 지칭한다. 하지만 두 단어는 종종 혼용되어 사용되기 때문에 동일한 뜻으로 이해해도 된다.JUnit3JUnit은 junit.org 사이트에서 파일을 내려받아 클래스 경로내에 junit.jar 파일을 포함시켜 놓으면 바로 사용할 수 있다. JUnit3은 크게 두 개의 규칙과 네 개의 구성요소를 갖는다.[규칙] TestCase를 상속받는다. 테스트 메소드의 이름은 반드시 test로 시작해야 한다.[구성요소]1)테스트 픽스처 메소드 setUp() : 각각의 테스트 메소드가 실행되기 전에 공통으로 호출되는 메소드다. 주로 테스트 환경 준비에 해당하는 자원 할당, 객체 생성, DB 연결 등의 작업이 이루어진다. tearDown() : 각각의 테스트 메소드가 실행된 후 수행되는 메소드다. 자원 해제, 연결 해제, 객체 초기화 등 뒷정리 작업을 한다. public class DaoTest extends TestCase{Connection connection;protected void setUp() throws Exception { connection = Connection.getConnection();}public void testA() throws Exception {....}public void testB() throws Exception {....}protected void tearDown() throws Exception { account = Connection.releaseConnection();}} setUp -&gt; testA -&gt; tearDown, setUp -&gt; testB -&gt; tearDown 식으로 실행된다. 2)단정문 assertEquals([message], expected, actual) : 예상 값과 실제 테스트 결과 값이 서로 일치하는지를 비교한단 한다. double, float 형의 경우 정확하게 일치하는 값을 찾기 어려워 delta라는 오차 값을 이용해 적절한 범위내의 값은 동일한 값으로 판단해준다. 단 float 타입끼리 비교는 제공하지 않음 assertSame / assertNotSame([message], expected, actual) : 두 객체가 동일한 객체인지 주소값으로 비교하는 단정문이다. 주로 동일 객체임을 증명하거나 싱글톤으로 만들어진 객체를 비교할 때 쓰이기도 한다. assertTrue / assertFalse([message], expected) : 예상 값의 참, 거짓을 판별하는 단정문이다. assertNull([message], expected) : null 여부를 판단하는 단정문이다. fail([message]) : 호출 즉시 테스트 케이스는 실패한다. 단정문을 사용하지 않으면 예외가 발생하지 않은 이상 무조건 성공하는 테스트 케이스가 되므로 사용한다. 만일 테스트 케이스를 작성 중 완료하지 못한 상태에서 구현을 중단해야 하는 경우 끝 부분에 fail()을 추가해 놓으면 도움이 된다.3)테스트 러너JUnit 프레임워크는 엄연히 독립적인 소프트웨어이고, 때문에 명령행 프롬프트에서 실행하거나 셸 스크립트 등을 이용해 실행할 수도 있다. 이를 위해 JUnit은 테스트 러너라는 테스트 실행 클래스를 제공한다. (Swing UI, 텍스트, AWT UI 제공)junit.swingui.TestRunner.run(Test.Class);junit.textui.TestRunner.run(Test.Class);junit.awtui.TestRunner.run(Test.Class);4)테스트 스위트 여러 개의 테스트 케이스를 한꺼번에 수행하고자 할 때 테스트 스위트는 테스트 케이스와 다른 테스트 스위트를 포함시킬 수 있다. 메소드는 반드시 publid static Test suite() 여야 한다. 테스트 추가는 suite.addTestSuite(테스트 클래스.class) 형식을 갖는다.Class SuiteTest { public static void main(String[] args) { junit.swingui.TestRunner.run(SuiteTest.class); } public static Test suite() { TestSuite suite = new TestSuite(); suite.addTestSuite(SuiteTest.class); // 테스트 케이스 추가 suite.addTestSuite(SuiteTest2.class); // 테스트 케이스 추가 suite.addTest(AnotherSuiteTest.suite()); // 다른 테스트 스위트를 포함 return suite; }}테스트 스위트는 여러 개의 테스트 케이스를 함께 수행할 때 사용하나 현재는 잘 사용하지 않는다.JUnit3으로 테스트 케이스 작성하기public class AccountTest extends TestCase{ Account account; protected void setUp() throws Exception{ account = new Account(10000); } public void testGetBalance() { assertEquals(10000, account.getBalance()); } public void testDeposit() { account.deposit(1000); assertEquals(11000, account.getBalance()); } public void testWithdraw() { account.withdraw(1000); assertEquals(9000, account.getBalance()); }}특징으로 TestCase를 상속한 점과 @로 시작하는 애노테이션이 없다는 점이다.**JUnit 테스트 클래스에는 각 테스트 메소드 별로 생성자가 호출된다. 이는 Java의 리플렉션을 사용해서 테스트 메소드를 실행할 때마다 테스트 클래스를 강제로 인스턴스화 하는 것이다.그 이유는 좋은 테스트 케이스는 기본적으로 다른 테스트 케이스의 수행이나 수행 결과에 영향을 받지 않아야 한다. 이것이 테스트의 기본 원칙이다. 따라서 테스트 케이스를 독립적으로 수행하기 위해 테스트 메소드 수행 전 테스트 클래스 자체를 리셋하는 것이다.JUnit4[특징] Java5 애노테이션 지원 test 로 method 이름을 시작해야 한다는 제약 해소 : @Test 사용 좀 더 유연한 픽스처 : @Before, @After, @BeforeClass, @AfterClass 예외 테스트 : @Test(expected=NumberFormatException.class) 시간 제한 테스트 : @Test(timeout=1000) 테스트 무시 : @Ignore(“this method isn’t working yet”) 배열 지원 : assertArrayEquals([message], expected, actual) @RunWith(클래스이름.class) : 테스트 클래스 실행 전 러너를 명시적으로 지정한다. @SuiteClasses(Class[]) : 여러개의 테스트 클래스를 수행하기 위해 쓰인다. 파라미터를 이용한 테스트1)애노테이션JDK 1.5에서 많은 변화가 있었는데 대표적으로 애노테이션, 제네릭스, 향상된 for문, 타입세이프한 열거형 타입 등이 있다. 애노테이션의 가장 큰 장점은 프레임워크의 내부 모델에 대한 자세한 이해 없이도 각 메소드의 사용 의도를 명확하게 문서화한다는 점이다.JUnit 3버전에서는 애노테이션을 사용할 수 없었으나 TestNG라는 애노테이션 기반의 xUnit 테스트 프레임워크가 JDK 1.4 이하에서도 애노테이션을 쓸 수 있게 해줬다.JUnit 4는 TestNG의 상당 기능을 그대로 차용해왔고, 인지도 측면에서 JUnit이 월등이 높아 JUnit 4가 나오면서 애노테이션을 이용한 테스트 케이스 작성시 JUnit이 주로 사용되게 됐다.2)@Test테스트 케이스에 해당하는 메소드로 지정하기 위해서 메소드 이름을 소문자 test로 시작해야한다는 규칙이 있었으나 JUnit 4에서는 메소드 이름과 상관없이 @Test 애노테이션만 붙이면 테스트 메소드로 인식한다.3)테스트 픽스처 메소드 추가 지원버전3에서는 setUp, tearDown이라는 두 개의 테스트 픽스처 메소드를 제공했는데 버전 4에서는 각각 @Before, @After라는 이름의 애노테이션으로 지원한다. 또 단 한 번만 실행할 수 있는 기능을 제공하지 않았으나@BeforeClass, @AfterClass 라는 두 개의 애노테이션을 이용해 하나의 테스트 클래스 내에서 한 번만 실행하는 메소드를 만들 수 있게 한다.4)예외 테스트3버전에서는 예외를 테스트하는 공식적인 방법을 제공하지 않았다. 대신 try/catch 문과 assert 단정문을 일종의 트릭처럼 사용했으나 4에서는 애노테이션을 이용해 작성한다.@Test(expected=NumberFormatException.class) expected 값으로 예외 클래스를 지정했을 때, 테스트 메소드 내에서 해당 예외가 발생하지 않는다면 테스트 메소드를 실패로 간주하낟.5)테스트 시간 제한@Test(timeout=5000) 밀리초 단위의 시간을 정해준 후 해당 시간내에서 테스트 메소드가 수행완료되지 않으면 실패한 테스트 케이스로 간주한다.6)테스트 무시@Ignore 애노테이션을 붙이면 지우기 전까지 수행하지 않는다.7)배열 지원원소의 자리 순서 기준으로 equals 비교가 이뤄지기 때문에 배열안의 값이 동일하더라도 순서가 다르면 테스트가 실패한다.@Testpublic void testArrayAssertEquals() throws Exception { String [] names = {\"Tom\", \"JIMMY\", \"JOHIN\"} String [] anotherNames = {\"Tom\", \"JIMMY\", \"JOHIN\"} assertArrayEquals(name, anotherNames);}8)@RunWith각각의 테스트 메소드 실행을 담당하고 있는 클래스를 테스트 러너라고 한다. @RunWith 애노테이션은 JUnit에 내장된 기본 테스트 러너인 BlockJUnit4ClassRunner 대신 @RunWith 로 지정된 클래스를 이용해 클래스 내의 테스트 메소드들을 수행하도록 지정해주는 애노테이션이다.예를 들면 스프링 프레임워크에서 제공하는 SpringJUnit4ClassRunner.class를 지정하면 스프링에서 자체적으로 만들어놓은 추가적인 테스트 기능을 이용할 수 있게 된다.9)@SuiteClasses여러개의 테스트 클래스를 일괄적으로 수행할 수 있다.//4버전@RunWith(Suite.class)@SuiteClasses(ATest.class, BTest.class, CTest.class)public class ABCSuite{...}//3버전public class ABCSuite extends TestCase{ public static Test suite() { TestSuite suite = new TestSuite(); suite.addTestSuite(ATest.claa); suite.addTestSuite(BTest.claa); suite.addTestSuite(CTest.claa); return suite; }}10)파라미터화된 테스트하나의 메소드에 대해 다양한 테스트 값을 하꺼번에 실행시키고자 할 때 사용한다.11)룰(Rule)하나의 테스트 클래스 내에서 각 테스트 메소드의 동작 방식을 재정의하거나 추가하기 위해 사용하는 기능이다. TemporaryFolder : 테스트 메소드 내에서만 사용 가능한 임시 폴더나 임시 파일을 만들어 준다. ExternResource : 외부 자원을 명시적으로 초기화한다. ErrorCollector : 테스트 실패에도 테스트를 중단하지 않고 진행할 수 있게 도와준다. Verifier : 테스트 케이스와는 별개의 조건을 만들어서 확인할 때 사용한다. TestWatchman : 테스트 실행 중간에 사용자가 끼어들 수 있게 도와준다. TestName : 테스트 메소드의 이름을 알려준다. Timeout : 일괄적인 타임아웃을 설정한다. ExpectedException : 테스트 케이스 내에서 예외와 예외 메시지를 직접 확인할 때 사용한다.12)이론(Theory)테스트 데이터와 상관없이 작성 대상 메소드를 항상 유지해야 하는 논리적인 규직을 표현할 때 사용한다.2.2 비교표현의 확장 : Hamacrest(햄크레스트)jMock이라는 Mock 라이브러리 저자들이 참여해 만들고 있는 Matcher 라이브러리로 테스트 표현식을 작성할 때 좀 더 문맥적으로 자연스럽고 우아한 문장을 만들 수 있게 도와준다.Matcher는 이름 그대로 어떤 값들의 상호 일치 여부나 특정한 규칙 준수 여부 등을 판별하기 위해 만들어진 메소드나 객체를 지칭한다.Hamacrest는 다양한 Matcher들이 모인 Matcher 집합체다. 단위 테스트와 함께 사용하면 테스트 케이스 작성시 문맥적으로 좀 더 자연스러운 문장을 만들어준다.기본적으로 assertEquals 보다는 assertThat이라는 구문 사용을 권장한다.예) assertThat(account.getBalance(), is(equalTo(10000)));, assertThat(resource.newConnection(), is(notNullValue())); assertThat(account.getBalance(), isGreaterThan(0));위 예제에서 is, equalTo, isGreaterThan 등의 메소드가 Matcher 구문에 해당한다. 이 구문은 static으로 선언되어 있고, 리턴 값은 Matcher 클래스로 되어있다.따라서 사용하려면 import static org.junit.Assert.*;, import static org.hamcrest.CoreMatchers.*;Hamacrest 라이브러리를 사용시 실패 메시지는 예상 값이 이것인데 실제로는 이 값이 나왔음의 형태로 보여준다.[Hamacrest 패키지] org.hamcrest.core : 오브젝트나 값들에 대한 기본적인 Matcher org.hamcrest.beans : Java Bean과 그 값 비교에 사용되는 Matcher org.hamcrest.collection : 배열과 컬렉션 Matcher org.hamcrest.number : 수를 비교하기 위한 Matcher org.hamcrest.object : 오브젝트와 클래스를 비교하는 Matcher org.hamcrest.text : 문자열 비교 org.hamcrest.xml : XML 문서 비교[Matcher 종류에 따른 분류]사용자 정의 Matcher 만들기자신만의 비교 구문 Matcher를 만들고 싶다면 TypeSageMatcher를 상속받아서 matchesSafely, describeTo를 재정의하면 된다.package main;import org.hamcrest.Description;import org.hamcrest.Factory;import org.hamcrest.Matcher;import org.hamcrest.TypeSafeMatcher;public class IsNotANumber extends TypeSafeMatcher&lt;Double&gt; { @Override protected boolean matchesSafely(Double number) { return number.isNaN(); } @Override public void describeTo(Description description) { description.appendText(\"not a number\"); } @Factory public static &lt;T&gt; Matcher&lt;Double&gt; notANumber() { return new IsNotANumber(); }}public void testSquareRootOfMinusOneIsNotANumber() { assertThat(Math.sqrt(-1), is(notANumber()));}" }, { "title": "1장 테스트 주도 개발", "url": "/posts/1%EC%9E%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C/", "categories": "BOOK, TDD 실천법과 도구", "tags": "tdd", "date": "2022-05-03 21:30:16 +0900", "snippet": "1.1 흔하디 흔한 소프트웨어 개발 방식전통적인 소프트웨어 개발 방식에서는 문제가 발생하고, 문제를 해결하고, 검증을 위한 테스트를 진행시 대표적으로 ‘콘솔’ 화면에 값을 찍어보는 방식을 사용했다.대개 이런 경우 작성된 코드의 문제 유무 판단을 개발자 자신의 두뇌에 상당 부분 의존하게 된다.이러한 전통적인 개발 및 테스트에서는 다음의 문제들을 흔히 볼 수 있다. 특정 모듈의 개발 기간이 길어질수록 개발자의 목표의식이 흐려진다. 작업 분량이 늘어날수록 확인이 어려워진다. 개발자의 집중력이 필요해진다. 논리적인 오류를 찾기가 어렵다. 코드의 사용방법과 변경 이력을 개발자의 기억력에 의존하게 되는 경우가 많다. 테스트 케이스가 적혀 있는 엑셀 파일을 보며 매번 테스트를 실행하는 게 점점 귀찮아져서 점차 간소화하는 항목들이 늘어난다. 코드 수정시에 기존 코드의 정상 동작에 대한 보장이 어렵다. 테스트를 해보려면 소스코드에 변경을 가하는 등, 번거로운 선행 작업이 필요할 수 있다. 그래서 소스코드 변경시 해야하는 회귀 테스트(기존 동작하던 부분의 소스코드 변경시 정상적으로 동작하는지 확인하기 위해 수행하는 테스트)는 희귀 테스트가 되기 쉽다. 테스트는 개발자의 귀중한 노동력을 적지 않게 소모하게 된다.1.2 테스트 주도 개발(TDD)TDD는 프로그램을 작성하기 전에 테스트 먼저 하라! -켄트 벡 즉 ‘업무 코드를 작성하기 전에 테스트 코드를 먼저 만드는 것’으로 얘기할 수 있다.메소드나 함수 같은 프로그램 모듈을 작성할 때 작성 종료조건을 먼저 정해놓고 코딩을 시작한다는 의미로 받아들이면 편하다.public class Calculator { //컴파일시 에러만 나지 않도록 하고, 내부는 비워둔 상태 public int sum(int a, int b) { return 0; } public static void main(String[] args) { //검증 코드를 먼저 작성하고 해당 조건이 모두 만족하면 sum 메소드가 정상적으로 작성된 것으로 판단한다. Calculator calc = new Calculator(); System.out.println(calc.sum(10,20) === 30); System.out.println(calc.sum(1, 2) === 3); System.out.println(calc.sum(-10,20) === 10); System.out.println(calc.sum(0,0) === 0); }}TDD는 위와 같이 명시적인 코드로 개발 종료조건을 정해놓은 것이다. 테스트 케이스 작성으로 구현을 시작하는 것 그게 바로 TDD 이다.1.3 테스트 주도 개발의 목표TDD 방식을 통해 얻고자 하는 최종 목적은 잘 동작하는 깔끔한 코드 -론 제프리 이다. 즉 정상적으로 동작하는 코드만이 개발 목표가 아니라 작성된 코드도 명확한 의미를 전달할 수 있게 작성되어야 한다.이는 소프트웨어의 품질을 비롯한 유지보수의 편의성, 가독성, 그리고 그에 따른 소프트웨어의 비용과 안정성 등 여러가지 측면의 의미를 내포한다.1.4 테스트 주도 개발의 기원애자일 개발 방식 중 하나인 XP의 실천 방식 중 하나다. XP는 애자일 소프트웨어 개발론의 하나로 고객에게 최고의 가치를 빨리 전달하는 것을 목표로 삼는다. 다양한 실천방법을 제시하고 있으나일부 극단적인 실천 방법을 요구하기도 하여 모든 내용을 적용하는 기업은 많지 않다.1.5 개발에 있어 테스트 주도 개발의 위치개발에서 TDD는 개발자가 자신을 위해 처음으로 수행하는 테스트에 해당한다. TDD에서 개발자는 자신이 작성한 프로그램에 대해 메소드 또는 함수 단위 로 테스트(단위 테스트)를 수행하고, 이후 발생하는 테스트 단계에서의 결함발생 비용을 줄여준다.1.6 테스트 주도 개발의 진행 방식 질문(Ask) : 테스트 작성을 통해 시스템에 질문 테스트 수행 결과는 실패 응답(Respond) : 테스트를 통과하는 코드를 작성해서 질문에 대답한다. 테스트 수행 결과는 성공 정제(Refine) : 아이디어 통합, 불필요한 것 제거, 모호한 것은 명확히하여 정제한다. 리팩토링 반복(Repeat) : 다음 질문을 통해 대화를 계속 진행TDD 개발은 크게 질문 -&gt; 응답 -&gt; 정제 라는 세 단계가 반복적으로 이루어진다.1.7 실습 먼저 시작해보기은행계좌 클래스 만들기[요구사항] 계좌잔고 조회 입금/출금 예상 복리 이자1) 질문 : 계좌 생성 테스트TDD에서는 테스트의 최소 작성 단위를 최하위 모듈의 단위와 일치시킨다. Java 기준 최하위 모듈은 ‘메소드’이다. 질문 단계에서는 이 메소드 수준의 단위 테스트를 작성하게 된다.실제로 해야하는 일은 작성하고자 하는 메소드나 기능이 무엇인지 선별하고 작성 완료 조건을 정해서 실패하는 테스트 케이스를 작성하는 것이다.이때 리턴 타입은 기본 초기값 null, 0 등의 위주로 설정해놓으면 편하다.뚜렷한 설계서가 없는 경우 구현해야 하는 기능과 유의 사항을 생각 나는대로 적는다 =&gt; 클래스의 이름은 Account, 기능은 잔고조회, 입금, 출금, 금액은 원단위로 한다.테스트 케이스 작성시 두 가지 접근 방식이 있다. 구현 대상 클래스 외형에 해당하는 메소드들을 먼저 만들고 테스트 케이스를 일괄적으로 만드는 방식 테스트 케이스를 하나씩 추가해나가면서 구현 클래스를 점진적으로 만드는 방식 (책에서는 2번 방식으로 진행한다.)테스트 케이스는 테스트하고자 하는 대상에 대해 간단한 시나리오를 만들고 그것을 코드로 표현한 모습이다. TDD에서는 하나의 테스트 케이스가 하나의 기능을 테스트하도록 만드는 것이 기본 원칙이고, 대부분 하나의 테스트 케이스는 하나의 메소드로 표현된다.package test;public class AccountTest { //1. 계좌를 생성한다 -&gt; 계좌가 정상적으로 생성되었는지 확인한다. public void testAccount() throws Exception { Account account = new Account(); if(account == null) { throw new Exception(\"계좌생성 실패\"); } } public static void main(String[] args) { AccountTest test = new AccountTest(); test.testAccount(); //테스트 케이스 실행 }}main 메소드를 실행하여 올바르게 동작하는지 확인한다. 이 작업이 바로 시스템에 대해 개발자가 하는 질문이다. 하지만 Account 클래스가 없으므로 시스템에서는 에러를 발생한다. 따라서 이제 시스템의 메시지에 응답할 시간이다.1) 응답위에서 실행한 테스트 케이스는 에러와 함께 실패한다. 따라서 이번엔 테스트를 성공시켜본다.package main;public class Account {}package test;import main.Account;public class AccountTest { //1. 계좌를 생성한다 -&gt; 계좌가 정상적으로 생성되었는지 확인한다. public void testAccount() throws Exception { Account account = new Account(); if(account == null) { throw new Exception(\"계좌생성 실패\"); } } public static void main(String[] args) { AccountTest test = new AccountTest(); try { test.testAccount(); //테스트 케이스 실행 } catch (Exception e) { System.out.println(\"실패(X)\"); return; } System.out.println(\"성공(O)\"); }}1) 최초의 정제 리팩토링을 적용할 부분이 있는지 찾아본다. 요구사항 목록에서 완료된 부분을 지운다.리팩토링을 수행하게 되는 정제 단계에서는 다음과 같은 질문에 대해 고민해보는 시간을 갖는다.-소스의 가독성이 적절한가?-중복된 코드는 없는가?-이름이 잘못 부여된 메소드나 변수명은 없는가?-구조의 개선이 필요한 부분은 없는가?(현재 예제에서는 리팩토링이 딱히 필요 없으므로 넘어간다.)JUnit 단위테스트 프레임워크 적용코드내에 main 메소드를 지운 뒤 testAccount() 메소드 위에 @Test 애노테이션을 작성한다.package test;import main.Account;import org.junit.Test;public class AccountTest { @Test public void testAccount() throws Exception { Account account = new Account(); if(account == null) { throw new Exception(\"계좌생성 실패\"); } }}JUnit은 테스트 케이스 실행의 성공과 실패를 글자 대신에 색깔이 있는 막대로 표시해준다. 실패일 경우 녹색 대신 붉은색 막대로 표시한다.JUnit의 기본 사상 중 하나는 테스트의 성공 여부를 글자를 이해해서 머리로 판단하는 것이 아니라 O/X 개념의 막대로 단순하게 판단하도록 만든다는 것이다. 따라서 개발자의 오해와 잘못된 판단의 여지를 줄여준다.**클래스 설계시 중요한 것은 속성이 아니라 동작이다. 동작을 먼저 정하고, 동작에 필요한 속성을 고현하는 식으로 접근하는 것이 불필요한 속성이 클래스 내에 섞여 들어가는 것을 줄여준다.2) 질문 : 잔고조회잔고 조회 테스트 시나리오 : 1만원으로 계좌 생성, 잔고 조회 결과 일치//2. 1만원으로 계좌 생성 -&gt; 잔고 조회 결과 일치@Testpublic void testGetBalance() throws Exception { Account account = new Account(10000); if(account.getBalance() != 10000) { fail(); //JUnit에서 제공하는 메소드, 호출시 해당 테스트 케이스는 무조건 실패한다. }}package main;public class Account { public Account(int i) { } public int getBalance() { return 0; }}테스트 케이스 결과 중 오류와 실패의 차이점은 무엇일까? 실패는 AssertEquals 등의 테스트 조건식을 만족시키지 못했다는 것을 의미하고, 오류는 테스트 케이스 수행 중 예상치 못한 예외가 발생해서 테스트 수행을 멈췄다는 것을 뜻한다.테스트 케이스가 가치를 지니기 위해서는, 어떠한 경우에도 테스트 케이스 그 자체는 정상적으로 끝까지 수행되어야 한다. 따라서 결과는 실제값이 예상값과 다르다는 신호인 실패가 나오도록 테스트 케이스를 작성해야 한다.오류는 작성자가 의도하지 않은 예상치 못한 실패를 뜻하므로 이 경우엔 테스트 케이스 자체가 문제가 있음을 시사한다.2) 응답질문에 대한 응답으로 녹색 막대를 볼 수 있도록 계좌의 잔고를 알려주는 getBalance 메소드를 구현한다.public int getBalance() { return 10000;}getBalance 메서드를 하드코딩하여 작성하였다. 이렇게 하드 코딩하면 테스트 케이스를 엉성하게 만들면 테스트 자체를 신뢰할 수 없게 된다. 하지만 하드코딩으로 시작하는 것도 괜찮은 출발점이다.이렇게 하면 적어도 두 가지 이상의 테스트 케이스를 작성하도록 자연스럽게 유도해준다.//2. 1만원으로 계좌 생성 -&gt; 잔고 조회 결과 일치@Testpublic void testGetBalance() throws Exception { Account account = new Account(10000); if(account.getBalance() != 10000) { fail(); } //실패 account = new Account(1000); if(account.getBalance() != 1000) { fail(); } //실패 account = new Account(0); if(account.getBalance() != 0) { fail(); }}문제가 있는 부분에 대한 로직을 수정한다.package main;public class Account { private int balance; public Account(int i) { this.balance = i; } public int getBalance() { return this.balance; }}2) 두 번째 정제package main;public class Account { private int balance; //파라미터 명을 의미있는 단어로 변경한다. public Account(int money) { this.balance = money; } public int getBalance() { return this.balance; }}JUnit 테스트 프레임워크에서 제공하는 assertEquals() 메소드를 사용하면 if문을 사용할 필요없이 편리하게 값을 비교할 수 있다. assertEquals(예상값, 실제값),assertEquals(\"설명\",예상값, 실제값)@Testpublic void testGetBalance() throws Exception { Account account = new Account(10000); assertEquals(10000, account.getBalance()); account = new Account(1000); assertEquals(1000, account.getBalance()); account = new Account(0); assertEquals(0, account.getBalance());}3) 질문 : 입금과 출금 테스트테스트 시나리오 : 입금(10000원으로 계좌 생성, 1000원 입금, 잔고 11000원 확인) / 출금(10000원으로 계좌 생성, 1000원 출금, 잔고 9000원 확인)//3-1. 입금(10000원으로 계좌 생성, 1000원 입금, 잔고 11000원 확인)@Testpublic void testDeposit() throws Exception { Account account = new Account(10000); account.deposit(1000); assertEquals(11000, account.getBalance());}//3-2. 출금(10000원으로 계좌 생성, 1000원 출금, 잔고 9000원 확인)@Testpublic void testWithdraw() throws Exception { Account account = new Account(10000); account.withdraw(1000); assertEquals(9000, account.getBalance());}public void deposit(int i) { }public void withdraw(int i) { }3) 응답public void deposit(int i) { this.balance += i;}public void withdraw(int i) { this.balance -= i;}3) 정제public void deposit(int money) { this.balance += money;}public void withdraw(int money) { this.balance -= money;}AccountTest 클래스 리팩토링 : 반복되는 Account 생성 부분을 따로 뺀다.package test;import main.Account;import org.junit.Test;import static org.junit.Assert.assertEquals;import static org.junit.Assert.fail;public class AccountTest { private Account account; //1. 계좌를 생성한다 -&gt; 계좌가 정상적으로 생성되었는지 확인한다. @Test public void testAccount() throws Exception { setup(); } //2. 1만원으로 계좌 생성 -&gt; 잔고 조회 결과 일치 @Test public void testGetBalance() throws Exception { setup(); assertEquals(10000, account.getBalance()); account = new Account(1000); assertEquals(1000, account.getBalance()); account = new Account(0); assertEquals(0, account.getBalance()); } private void setup() { account = new Account(10000); } //3-1. 입금(10000원으로 계좌 생성, 1000원 입금, 잔고 11000원 확인) @Test public void testDeposit() throws Exception { setup(); account.deposit(1000); assertEquals(11000, account.getBalance()); } //3-2. 출금(10000원으로 계좌 생성, 1000원 출금, 잔고 9000원 확인) @Test public void testWithdraw() throws Exception { setup(); account.withdraw(1000); assertEquals(9000, account.getBalance()); }}테스트에 사용할 자원이나 객체들을 준비해놓는 부분을 ‘픽스처’ 라고 부른다. JUnit에서는 Before와 After라는 개념(JUnit4부터 제공)으로 준비와 정리 작업에 해당하는 처리방법을 제공한다.최종 : setup()메소드를 public으로 바꾸고 @Before 애노테이션을 붙인다, 각 테스트 케이스마다 setup();을 호출하던 메소드를 제거한다.package test;import main.Account;import org.junit.Before;import org.junit.Test;import static org.junit.Assert.assertEquals;import static org.junit.Assert.fail;public class AccountTest { private Account account; //테스트 케이스 실행되기 전에 가장 먼저 실행된다. 이때 접근자를 private -&gt; public @Before public void setup() { account = new Account(10000); } //1. 계좌를 생성한다 -&gt; 계좌가 정상적으로 생성되었는지 확인한다. @Test public void testAccount() throws Exception { } //2. 1만원으로 계좌 생성 -&gt; 잔고 조회 결과 일치 @Test public void testGetBalance() throws Exception { assertEquals(10000, account.getBalance()); account = new Account(1000); assertEquals(1000, account.getBalance()); account = new Account(0); assertEquals(0, account.getBalance()); } //3-1. 입금(10000원으로 계좌 생성, 1000원 입금, 잔고 11000원 확인) @Test public void testDeposit() throws Exception { account.deposit(1000); assertEquals(11000, account.getBalance()); } //3-2. 출금(10000원으로 계좌 생성, 1000원 출금, 잔고 9000원 확인) @Test public void testWithdraw() throws Exception { account.withdraw(1000); assertEquals(9000, account.getBalance()); }}**TDD는 간결함을 추구하는 경제성의 원리가 내포되어 있는 개발 방식이다. 따라서 현재 필요한 기능이 아니라면 절대 미리 만들지 말자, 현재 작성한 소스코드를 개선하는 데 좀 더 시간을 투자하자!11.8 TDD의 장점 개발의 방향을 잃지 않게 유지해준다 : 현재 자신이 어떤 기능을 개발하고 있고, 또 어디까지 와 있는지를 항상 살펴볼 수 있다. 또 남은 단계와 목표를 잊지 않게 도와준다. 품질 높은 소프트웨어 모듈 보유 : 필요한 만큼 테스트를 거친 품질이 검증된 부품을 갖게 되는 것과 마찬가지다. 자동화된 단위 테스트 케이스를 갖게 된다 : 자동화된 단위 테스트 케이스들은 개발자가 필요한 시점에 언제든지 수행해볼 수 있다. 또 현재까지 작성된 시스템에 대한 이상 유무를 바로 확인할 수 있고, 회귀 테스트에 대한 부담도 줄어든다. 사용설명서 &amp; 의사소통의 수단 : 테스트 코드들의 가치는 시간이 지나면서 두고두고 빛을 발한다. 이는 현재 자신과 주위의 개발자, 미래의 개발자에게 제공되는 상세화된 모듈 사용 설명서라는 부분도 포함된다. 설계 개선 : 테스트 케이스를 작성함으로써 개발에 포함된 다양한 설계 요소들에 대해 미리부터 고민하게 되고, 테스트가 가능하도록 설계 구조를 고민하다 보면 자연스럽게 디자인을 개선하게 된다. 보다 자주 성공한다 : TDD는 매 주기를 짧게 설정하도록 권장한다. 그러면 성공 케이스를 자주 보고, 성취감도 느낄 수 있다.로버트 마틴은 반드시 따르기 원하는 TDD의 원칙을 다음과 같이 말한다. 실패하는 테스트를 작성하기 전에는 절대로 제품 코드를 작성하지 않는다. 실패하는 테스트 코드를 한 번에 하나 이상 작성하지 않는다. 현재 실패하고 있는 테스트를 통과하기에 충분한 정도를 넘어서는 제품 코드를 작성하지 않는다." }, { "title": "11장 웹 콘텐츠에서 사용하는 기술", "url": "/posts/11%EC%9E%A5-%EC%9B%B9-%EA%B3%B5%EA%B2%A9-%EA%B8%B0%EC%88%A0/", "categories": "BOOK, 그림으로 배우는 Http & Network", "tags": "http, network", "date": "2022-05-01 20:35:31 +0900", "snippet": "11.1 웹 공격 기술주로 공격이 대상이 되는 것은 HTTP를 사용하는 서버와 클라이언트 그리고 서버 상에서 동작하는 웹 애플리케이션 등의 리소스이다. 인터넷에서 벌어지는 공격의 대부분이 웹 사이트를 노린 것이다. HTTP에는 보안 기능이 없다 : HTTP는 구조가 단순한 프로토콜로 현재의 웹 사이트 대부분에서는 인증, 세션관리, 암호화 등의 보안 기능이 필요하지만 HTTP에는 없다. 리퀘스트는 클라이언트에서 변조 가능 : HTTP 리퀘스트의 내용은 모든 클라이언트에서 자유롭게 변경하고 변조할 수 있다. 웹 애플리케이션에 대한 공격 패턴 능동적 공격 : 공격자가 직접 웹 애플리케이션에 액세스해서 공격 코드를 보내는 타입의 공격이다. (예. SQL 인젝션, OS 커맨드 인젝션) 수동적 공격 : 함정을 이용해서 유저에게 공격 코드를 실행시키는 공격이다. (예. XSS, CSRF) 11.2 출력 값의 이스케이프 미비로 인한 취약성웹 애플리케이션의 보안 대책을 실시하는 장소를 크게 클라이언트에서 체크, 웹 애플리케이션(서버)에서 체크로 나눌 수 있다. 클라이언트 측에서 체크 : 대부분 JavaScript를 사용한다. 그러나 변조되거나 무효화될 가능성이 있기 때문에 근본적인 보안 대책으로 적합하지 않다. 웹 애플리케이션 측에서 체크 : 입력 값 체크는 근본적인 보안 대책으로 적합하지 않고, 단지 제대로된 값인지 아닌지에 대한 체크, 문자코드의 체크등을 실시한다. 출력할 때 체크는 값을 이스케이프 처리하는 출력 값의 이스케이프가 보안 대책으로 중요하다.1)크로스 사이트 스크립팅(XSS) : XSS는 취약성 있는 웹 사이트를 방문한 사용자의 브라우저에서 부정한 HTML 태그, JavaScript 등을 동작시키는 공격이다.주로 가짜 입력 폼 등에 의해 유저의 개인 정보를 도둑 맞거나, 스크립트에 의해 유저의 쿠키값이 도둑 맞거나 가짜 이미지, 문장등이 표시되는 경우가 있다.2)SQL 인젝션 : 웹 애플리케이션을 이용하고 있는 데이터베이스에 SQL을 부정하게 실행하는 공격이다. 데이터베이스 내의 데이터 부정 열람이나 변조, 인증회피, 데이터베이스 서버를 경유한 프로그램 실행 등의 영향을 받을 수 있다.3)OS 커맨드 인젝션 : 웹 애플리케이션을 경유하여 OS 명령을 부정하게 실행하는 공격이다. 쉘을 호출하는 함수가 있는 곳에서 발생할 가능성이 있다. 윈도우나 리눅스 등의 커맨드 라인에서 프로그램을 기동하는 쉘에 대해 커맨드를 보낼 수 있어 다양한 프로그램을 실행할 수 있다.4)HTTP 헤더 인젝션 : 공격자가 리스폰스 헤더 필드에 개행 문자 등을 삽입함으로써 임의의 리스폰스 헤더 필드나 바디를 추가하는 수동적 공격이다.5)메일 헤더 인젝션 : 웹 애플리케이션의 메일 송신 기능에 공격자가 임의의 To 및 Subject 등의 메일 헤더를 부정하게 추가하는 공격6)디렉토리 접근 공격 : 비공개 디렉토리의 파일에 대해서 부정하게 디렉토리 패스를 가로질러 액세스하는 공격이다. ‘패스 트래버설’이라 부르기도 한다.7)리모트 파일 인틀루션 : 스크립트의 일부를 다른 파일에서 읽어올 때 공격자가 지정한 외부 서버의 URL을 파일에서 읽게 함으로써 임의의 스크립트를 동작시키는 공격이다.11.3 웹 서버의 설정이나 설계 미비로 인한 취약성1)강제 브라우징 : 웹 서버의 공개 디렉토리에 있는 파일 중에서 공개 의도가 없는 파일이 열람되게 되는 취약성이다. 고객 정보등 중요 정보 누설, 본래 액세스 권한이 있는 사용자에게만 표시하지 않는 정보 누설, 어디에서도 링크되지 않은 파일 누설 등의 영향을 받을 수 있다.2)부적절한 에러 메시지 처리 : 공격자에게 유익한 정보가 웹 애플리케이션의 에러 메시지에 포함된다는 취약성이다. 웹 애플리케이션에 의한 에러 메시지, 데이터베이스 등의 시스템에 의한 에러메시지 등3)오픈 리다이렉트 : 지정한 임의의 URL로 리다이렉트 하는 기능이다. 리다이렉트되는 곳의 URL에 악의가 있는 웹 사이트가 지정된 경우 유저가 그 웹사이트로 유도되는 취약성과 연결된다.11.4 세션 관리 미비로 인한 취약성1)세션 하이잭 : 공격자가 어떠한 방법으로 유저의 세션 ID를 입수해서 악용하는 것으로, 유저로 위장하는 공격이다. 세션ID를 입수하는 방법으로는 부적절한 생성 방법에 의한 세션ID 추측, 도청이나 XSS 등에 의한 세션 ID 도용, 세션 고정 공격에 의한 세션ID 강제가 있다.2)세션 픽세이션 : 공격자가 지정한 세션 ID를 유저에게 강제적으로 사용하게 하는 공격으로 수동적 공격이다.3)크로스 사이트 리퀘스트 포저리 : 인증된 유저가 의도하지 않은 개인 정보나 설정 정보 등을 공격자가 설치해 둔 함정에 의해 어떤 상태를 갱신하는 처리를 강제로 실행시키는 공격으로 수동적 공격이다.11.5 기타1)패스워트 크래킹 : 패스워드를 논리적으로 이끌어내서 인증을 돌파하는 공격으로 네트워크 경유로 패스워드 시행, 암호화된 패스워드를 해독하는 등의 방법이 있다. 네트워크 경유로 패스워드 시행 무차별 대입 공격 : 비밀번호 시스템에서 취할 수 있는 모든 패스워드 후보를 시험해서 인증을 돌파하는 공격 사전 공격 : 사전에 패스워드 후보를 준비해 두고 그것을 시험해 봄으로써 인증을 돌파하는 공격 암호화된 패스워드를 해독 : 패스워드를 어떠한 수단으로 훔쳤다하더라도 암호화되어 있기 때문에 이를 이용하기 위해서는 해독하는 등 평문을 손에 넣어야 한다. 평문을 도출하는 방법으로는 다음과 같이 있다. 무차별 대입 공격/사전 공격에 의한 유추 : 암호화에 해시 함수를 사용한 경우 패스워드 후보에 같은 해시 함수를 적용하여 패스워드를 유추하낟. 레인보우 테이블 : 평문과 그에 대응하는 해시 값으로 구성된 데이터베이스 테이블이다. 사전에 거대한 테이블을 만들어 무차별 대입 공격/사전 공격 등에 걸리는 시간을 단축하는 테크닉이다. 열쇠 입수 : 암호화된 키를 입수하는 것 암호 알고리즘의 취약성 2)클릭 재킹 : 투명한 버튼이나 링크를 함정으로 사용할 웹 페이지에 심어 두고, 유저에게 링크를 클릭하게 함으로써 의도하지 않은 콘텐츠에 액세스 시키는 공격이다.3)DoS 공격 : 서비스 제공을 정지 상태로 만드는 공격이다. 주로 액세스를 집중시켜 부하를 걸어 리소스를 다 소비하게 해 사실상 서비스를 정지 상태로 만들거나, 취약성을 공격해 서비스를 정지시키는 방법이 있다.4)백도어 : 제한된 기능을 정규 절차를 밟지 않고 이용하기 위해 설치된 뒷문이다. 개발 단계에 디버그용으로 추가한 백도어 개발자가 자기 자신의 이익을 위해 추가한 백도어 공격자가 어떠한 방법을 써서 설치한 백도어" }, { "title": "10장 웹 콘텐츠에서 사용하는 기술", "url": "/posts/10%EC%9E%A5-%EC%9B%B9-%EC%BD%98%ED%85%90%EC%B8%A0%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0/", "categories": "BOOK, 그림으로 배우는 Http & Network", "tags": "http, network", "date": "2022-04-30 19:59:31 +0900", "snippet": "10.1 HTMLHTML은 웹 상에서 하이퍼텍스트를 보내기 위해서 개발된 언어이다. 2015년에 HTML5가 나왔고, 이는 브라우저간의 호환성 문제를 해결하거나 텍스트를 데이터로 다룰 수 있도록 하여 재사용하기 쉽게하거나 애니메이션 등의 효과를 충실히 하는 것이 사양에 포함된다.디자인을 적용하는 CSSHTML의 각 요소를 어떻게 표시할지를 지시하는 것으로 브라우저에서 보이는 외관을 변경할 수 있다.10.2 다이나믹 HTML다이나믹 HTML은 정적인 HTML 내용을 클라이언트 사이드 스크립트를 사용해서 동적으로 변경하는 기술을 말한다. (예.클릭하면 펼쳐지는 메뉴, 구글맵스 같이 스크롤해서 보여지는 지도 등)동적으로 바꾸고 싶은 HTML 요소를 지정하기 위해서 DOM이라는 구조를 사용한다.DOM은 HTML의 문서 XML 문서를 위한 API이다. DOM을 사용하면 HTML내의 요소를 오브젝트로 다룰 수 있어 요소내의 문자열 추출이나 CSS를 프로퍼티로서 변경해 디자인을 변경할 수 있다.10.3 웹 애플리케이션 웹 애플리케이션은 웹 기능을 사용해서 제공되는 프로그램을 지칭한다. 프로그램에 의해 생성된 콘텐츠를 동적 콘텐츠라 부르고, 사전에 준비된 콘텐츠는 정적 콘텐츠라 부르고 있다. 웹 애플리케이션은 동적 콘텐츠에 해당한다. CGI는 웹 서버가 클라이언트에서 받은 리퀘스트를 프로그램에 전달하기 위한 구조로 리퀘스트 내용에 맞게 HTML을 생성하는 등 동적으로 콘텐츠를 생성할 수 있다. 서블릿은 서버상에서 HTML등 동적 콘텐츠를 생성하기 위한 프로그램을 가리킨다. Java 프로그래밍 언어 사양의 하나고, CGI의 문제점(요청마다 프로그램을 실행하여 부하가 걸리게 됨)을 해결하기 위해 보급되었다.10.4 데이터 송신에 이용되는 포맷이나 언어 범용적으로 사용할 수 있는 마크업 언어 XML : 태그를 사용한 트리구조로 되어 있고, 독자적으로 확장된 태그가 정의되어 있다. 또 파서 기능에 의해 데이터 추출을 쉽게 할 수 있다. 또 데이터를 재사용하기 쉽다. 갱신 정보를 송신하는 RSS/Atom : 뉴스나 블로그의 기사 등 갱신 정보를 송신하기 위한 문서 포맷의 총칭으로 XML을 이용하고 있다. JavaScript에서 이용하기 쉽고 가벼운 JSON : 경량 데이터 기술 언어로 JavaScript에 있어서 오브젝트 표기법을 바탕으로 하고 있다." }, { "title": "9장 HTTP에 기능을 추가한 프로토콜", "url": "/posts/9%EC%9E%A5-HTTP%EC%97%90-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EC%B6%94%EA%B0%80%ED%95%9C-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C/", "categories": "BOOK, 그림으로 배우는 Http & Network", "tags": "http, network", "date": "2022-04-23 16:03:02 +0900", "snippet": "9.1 HTTP를 기본으로 하는 프로토콜HTTP 규격이 만들어졌을 때 주로 HTML로 작성된 문서를 전송하기 위한 프로토콜로 HTTP를 생각했다. 하지만 시간이 흐르면서 웹의 용도는 크게 변하고 있고, 그로인해 HTTP라는 프로코톨의 제한이나 한계가 생겨났다.그래서 HTTP를 기반으로 추가하는 형태로 새로운 프로토콜이 몇 가지가 구현되었다.9.2 HTTP의 병목 현상을 해소하는 SPDYHTTP의 병목 현상페이스북, 트위터 등의 SNS에서는 많은 사람들이 작성한 정보를 실시간으로 볼 수 있다. 이렇게 갱신된 정보를 가능한 빨리 실시간으로 표시하기 위해서는 서버상의 정보가 갱신되었을 때, 그것을 클라이언트 화면에 반영할 필요가 있다.하지만 HTTP에서는 이러한 처리를 제대로 할 수가 없다.HTTP에서는 서버의 정보가 변경되었는지 확인하기 위해서 클라이언트가 항상 서버측에 확인하러 가야한다. 서버상의 정보가 갱신되지 않은 경우 불필요한 통신이 발생하게 된다. Ajax에 의한 해결방법 : Ajax는 웹 페이지의 일부분만 고쳐쓸 수 있는 비동기 통신 방법이다. 페이지의 일부분만 갱신되기 때문에 리스폰스로 전송되는 데이터 양이 줄어든다. Comet에 의한 해결방법 : 서버 측의 콘텐츠 갱신이 있는 경우 클라이언트의 리퀘스트를 기다리지 않고 클라이언트에 보내기 위한 방법으로 리스폰스를 보류 상타로 해두고 갱신시 리스폰스를 반환한다. 단 리스폰스를 보류하기 위해 커낵션을 유지하는 시간이 길어진다.위 방법을 통해 어느정도 개선은 되었으나 HTTP 프로토콜의 제약은 없앨 수 없었다. 근본적인 개선을 위해서는 프로토콜 레벨에서의 개선이 필요하다. SPDY는 HTTP가 안고 있던 병목 현상을 프로토콜 레벨에서 해소하기 위해 개발되고 있는 프로토콜이다.SPDY 설계와 기능SPDY는 TCP/IP의 애플리케이션 계층과 트랜스포트 계층 사이에 새로운 세션 계층을 추가하는 형태로 동작한다. 또 보안을 위해서 표준으로 SSL을 사용하도록 되어 있다.SPDY를 사용하면 다음과 같은 기능을 HTTP에 추가할 수 있다. 다중화 스트림 리퀘스트의 우선 순위 부여 HTTP 헤더 압축 서버 푸시 기능 서버 힌트 기능SPDY를 사용하려면 웹 콘텐츠 측은 할게 없는데 웹 브라우저와 웹 서버는 SPDY에 대응하고 있어야 한다. SPDY는 기본적으로 한 개의 도메인과의 통신을 다중화할 뿐 웹 사이트에서 복수의 도메인으로 리소스를 사용하고 있는 경우에는 그 효과가 한정적이다.또 SPDY는 HTTP의 병목현상을 해결하는 좋은 기술이지만 대부분 웹 사이트의 문제는 HTTP의 병목현상 때문만은 아니다.9.3 브라우저에서 양방향 통신을 하는 WebSocketWebSocket은 웹 브라우저와 웹 서버를 위한 양방향 통신 규격으로 Ajax, Comet에서 사용하는 XMLHttpRequest의 결점을 해결하기 위한 기술로서 개발이 진행되고 있다.WebSocket은 한 번 접속을 확립하고 나면 그 뒤에 통신은 어느쪽에서도 할 수 있다. 주요 특징으로는 다음과 같은 것이 있다. 서버 푸시 기능 통신량의 삭감 핸드쉐이크/리퀘스트 핸스쉐이크/리스폰스 WebSocket API9.4 등장이 기다려지는 HTTP/2.09.5 웹 서버 상의 파일을 관리하는 WebDAVWebDAV는 웹 서버의 콘텐츠로 직접 파일 복사나 편집 작업 등을 할 수 있는 분산 파일 시스템이다.HTTP/1.1을 확장한 WebDVA 컬렉션 Collection : 여러 개의 리소스를 한꺼번에 관리하기 위한 개념 자원 Resource : 파일이나 컬렉션 프로퍼티 Property : 리소스의 프로퍼티를 정의 ‘이름=값’의 형식으로 이루어짐 잠금 Lock : 파일을 편집할 수 없는 상태로 한다.WebDAV에서 추가된 메소드와 상태코드 PROPFIND : 프로퍼티 취득 PROPPATCH : 프로퍼티 변경 MKCOL : 컬렉션 작성 COPY : 리소스 및 프로퍼티 복제 MOVE : 리소스 이동 LOCK : 리소스 잠금 UNLOCK : 리소스 잠금 해제 102 Processing 207 Multi-Status 422 Locked 424 Failed Dependency 507 Insufficient Storage" }, { "title": "8장 누가 액세스하고 있는지를 확인하는 인증", "url": "/posts/8%EC%9E%A5-%EB%88%84%EA%B0%80-%EC%95%A1%EC%84%B8%EC%8A%A4%ED%95%98%EA%B3%A0-%EC%9E%88%EB%8A%94%EC%A7%80%EB%A5%BC-%ED%99%95%EC%9D%B8%ED%95%98%EB%8A%94-%EC%9D%B8%EC%A6%9D/", "categories": "BOOK, 그림으로 배우는 Http & Network", "tags": "http, network", "date": "2022-04-22 13:19:02 +0900", "snippet": "8.1 인증이란?서버에 액세스하고 있는 사람이 누군지 알려면 상대방 클라이언트에 이름을 알려달라고 해야 한다. 하지만 이름을 밝히더라도 그것이 정말인지 알 수가 없다. 그래서 본인인지 확인하기 위해 본인만 알고있는 정보나 본인만이 가지고 있는 정보등으로 확인할 필요가 있다.이러한 정보는 주로 패스워드, 원타임 토큰, 전자 증명서, 바이오 매트릭스, IC 카드 등이 있다.HTTP/1.1 에서 이용할수 있는 인증 방법으로는 BASIC 인증, DIGEST 인증, SSL 클라이언트 인증, 폼 베이스 인증이 있다.8.2 BASIC 인증BASIC 인증은 웹 서버와 대응하고 있는 클라이언트 사이에서 이뤄지는 인증 방식이다. BASIC 인증이 필요한 리소스에 리퀘스트가 있을 경우 서버는 401 상태코드와 함께 인증이 필요하나는 것을 필드에 포함해서 리스폰스를 반환한다. 클라이언트는 인증을 위해 ID, 패스워드를 서버에 송신해야한다. 이때 송신하는 문자열은 : 콜론으로 연결하여 Base64 형식으로 인코딩한다. 리퀘스트를 수신한 서버는 인증 정보가 정확한지 여부를 판단하고 정확하다면 리스폰스를 반환한다.BASIC에서 사용하는 Base64 인코딩 방식은 암호화는 아니기 때문에 아무런 부가 정보 없이도 복호화 할 수 있다. 그리고 한 번 인증을 하면 일반 브라우저에서는 로그아웃할 수 없다는 문제도 있다. 그래서 그다지 사용되고 있지는 않다.8.3 DIGEST 인증DIGEST 인증은 챌린지 리스폰스 방식이 사용되고 있어 BASIC 인증과 같이 패스워드를 있는 그대로 직접 보내는 일은 없다.챌린지 리스폰스 방식이란 최초에 상대방에게 인증 요구를 보내고 상대방 측에서 받은 챌린지 코드를 사용해서 리스폰스 코드를 계산하고, 이 값을 상대에게 송신하여 인증을 하는 방법이다. BASIC에 비하면 패스워드가 누출될 가능성이 줄어든다. 인증이 필요한 리소스에 리퀘스트가 있을 경우 서버는 401 상태코드와 함께 ‘챌린지 코드(nonce)’를 필드에 포함하려 리스폰스를 반환한다. 이때 반드시 포함되어야 하는 정보는 realm, nonce이다. (nonce는 401 리스폰스 반환시마다 생성되는 유일한 문자열이다.) 클라이언트는 인증을 위해 필요한 정보를 헤더에 담아 리스폰스를 반환한다. 이때 반드시 포함되어야 하는 정보는 username, realm, nonce, uri, response이다. 리퀘스트를 받은 서버는 인증 정보가 정확한 것인지 아닌지 판단하고 정확한 경우 리소스를 포함한 리스폰스를 반환한다.DIGEST 인증은 BASIC에 비해서는 높은 보안 등급을 제공하고 있지만 HTTPS의 클라이언트 인증등과 비교하면 낮다. 따라서 BASIC과 마찬가지로 그다지 사용되고 있지는 않다.8.3 SSL 클라이언트 인증유저의 id나 패스워드를 사용한 인증 방식은 도난되었을 때 제3자가 위장을 하는 경우가 있어 이를 방지하기 위한 대책으로 SSL 클라이언트 인증이 사용된다. 이 인증은 HTTPS의 클라이언트 인증서를 이용한 인증 방식이다.SSL 클라이언트 인증을 할 땐 사전에 클라이언트에 증명서를 배포하고 install을 해야한다. 인증이 필요한 리소스의 리퀘스트가 있는 경우 서버는 클라이언트에게 증명서를 요구하는 ‘Certificate Request’ 메시지를 송신한다. 유저는 클라이언트 증명서를 선택하고 ‘Client Certificate’ 메시지를 송신한다. 증명서를 검증하여 정확하다면 클라이언트의 공개키를 취득하고 이후 HTTPS에 의한 암호를 개시한다.SSL 클라이언트 인증은 2-factor 인증에서 사용되는데 이는 패스워드란 한 개의 요소로만 인증하는 것이 아닌 이용자가 가진 다른 정보를 병용해서 인증을 하는 방법이다.(즉 인증 정보가 2개)그리고 SSL 클라이언트 인증은 클라이언트 증명서를 이용해야 하는데 이를 이용하기 위해서는 비용이 필요하다. 따라서 안전하게 운용하기 위해서는 상당한 비용이 발생하게 된다.8.4 폼 베이스 인증클라이언트가 서버 상의 웹 애플리케이션에 자격정보를 송신하여 그 자격 정보의 검증 결과에 따라 인증하는 방식이다.인증의 대부분은 폼 페이스 인증을 사용한다. HTTP 표준인 BASIC, DIGEST 인증은 사용상의 문제와 보안적인 문제로 거의 사용되지 않고 SSL 클라이언트 인증은 비용 등의 문제로 널리 사용되고 있지 못하다.그리고 폼 페이스 인증은 표준 사양이 결정되어 있지 않지만 일반적으로 자주 사용되는 방법이 세션 관리를 위해서 쿠키를 사용하는 방법이다. 서버에 id, 패스워드 등의 자격정보를 포함한 리퀘스트 송신 서버 측에서는 유저를 식별하기 위해 세션 ID 발행, 클라이언트 측에 송신시 Set-Coookie 헤더 필드에 세션 ID를 저장해서 리스폰스를 반환한다. 서버 측에서 세션 ID를 받은 클라이언트는 쿠키로 저장한다. 그리고 이후 리퀘스트 송신시 쿠키에 저장한 세션ID를 서버에 전송한다." }, { "title": "7장 웹을 안전하게 지켜주는 HTTPS", "url": "/posts/7%EC%9E%A5-%EC%9B%B9%EC%9D%84-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EC%A7%80%EC%BC%9C%EC%A3%BC%EB%8A%94-HTTPS/", "categories": "BOOK, 그림으로 배우는 Http & Network", "tags": "http, network", "date": "2022-04-20 15:14:02 +0900", "snippet": "7.1 HTTP의 약점HTTP에는 다음과 같은 약점을 가지고 있다.1.암호화 하지 않은 평문 통신이기 때문에 도청 가능TCP/IP 구조의 통신은 내용을 통신 도중에 엿볼 수 있다. 인터넷은 전 세계를 경유하는 네트워크로 되어 있고, 네트워크 기기나 케이블 컴퓨터 등을 전부 자신이 소유하고 있지 않으므로 악의를 가진 누군가가 엿볼 수 있다.암호화로 도청을 피할 수 있다.1)통신 암호화 : SSL(Secure Socket Layer), TLS(Transport Layer Security)와 같은 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화할 수 있다. SSL을 조합한 HTTP를 ‘HTTPS’, ‘HTTP over SSL’ 이라 부른다.2)콘텐츠 암호화 : 통신하고 있는 콘텐츠의 내용 자체를 암호화해 버리는 방법으로 HTTP 메시지에 포함되는 콘텐츠만 암호화 하는 것이다. 콘텐츠 암호화를 유효하게 하기 위해서는 클라이언트와 서버가 콘텐츠의 암호화나 복호화 구조를 가지고 있는 것이 전제가 되므로 주로 웹 서비스 등에서 이용되는 방법이다.2.통신 상대를 확인하지 않기 때문에 위장 가능누구나 리퀘스트를 보낼 수 있는데 리퀘스트가 오면 상대가 누군지 상관 없이 무언가의 리스폰스를 반환한다. 이처럼 상대를 확인하지 않는 점이 약점이 될 수가 있다.1)위장한 웹서버일 우려가 있다.2)위장한 클라이언트일 우려가 있다.3)접근이 허가된 상대인지 아닌지를 확인할 수 없다.4)누가 리퀘스트를 했는지 확인할 수 없다.5)대량의 리퀘스트에 의한 Dos 공격을 방지할 수 없다.HTTP에서는 통신 상대를 확인할 수 없지만 SSL로 상대를 확인할 수 있다. SSL은 암호화뿐만 아니라 상대를 확인하는 수단으로 증명서를 제공하고 있다. 이 증명서를 위조하는 것은 기술적으로 어렵기 때문에통신 상대의 서버나 클라이언트가 가진 증명서를 확인함으로써 통신 상대가 내가 통신하고자 하는 상대인지 아닌지를 판단할 수 있다.3.완전성을 증명할 수 없기 때문에 변조 가능완전성은 정보의 정확성을 가리키는 것으로 정보가 정확한지 아닌지를 확인할 수 없음을 나타낸다.상대가 수신전에 변조되었다고 하더라도 이를 알 수가 없기 때문에 발신된 리퀘스트, 리스폰스와 수신된 리퀘스트, 리스폰스가 같은지 아닌지를 확인할 수 없다.이와 같이 공격자가 중간에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 ‘중간자 공격(Man in the Middle 공격)’ 이라고 한다.변조를 방지하려면 자주 사용되는 방법으로 MD5, SHA-1등의 해시 값을 확인하는 방법과 디지털 서명을 확인하는 방법이 있다. 하지만 이 방법도 확실한 것은 아니다 이또한 적절하게 수정한다면 유저로서는 알 수가 없다.확실히 방지하기 위해서는 HTTPS를 사용하면 된다. SSL에는 인증이나 암호화 그리고 다이제스트 기능을 제공하고 있다.7.2 HTTP + 암호화 + 인증 + 완전성 보호 = HTTPSHTTP에 암호화나 인증 등의 구조를 더한 것을 HTTPS라고 부른다. 주로 웹페이지의 로그인이나 쇼핑의 결제 화면등에서 사용된다.HTTPS는 통신을 하는 소켓 부분을 SSL 또는 TLS라는 프로토콜로 대체하고 있을 뿐 새로운 프로토콜은 아니다. 보통 HTTP는 직접 TCP와 통신하지만 SSL을 사용하는 경우에 HTTP는 SSL과 통신하고 SSL이 TCP와 통신한다.SSL에서는 공개키 암호화 방식이라 불리는 암호화 방식을 사용하고 있다. 이전에는 암호화와 복호화에 하나의 키를 사용하는 공통키 암호화 방식을 사용했으나 하나의 키를 사용하므로써 키를 전달하는 과정에서 키를 도청 당할 수 있는 문제가 있어이러한 문제를 해결하기 위해 나온 방식이 공개키 암호화 방식이다. 공개키 암호화 방식은 서로 다은 두 개의 키를 사용하고, 한쪽은 비밀키(누구에게도 알려지면 안되는 키), 공개키(누구에게나 알려져도 괜찮은 키)이다.암호를 보내는 측이 상대의 공개키로 암호화를 하고 암호화된 정보를 받아들이는 상대는 자신의 비밀키를 사용해 복호화를 실시한다. 이 방식은 비밀키를 통신으로 보낼 필요가 없기 때문에 도청에 의해 키를 빼앗길 걱정이 없다.HTTP는 공통키 암호화와 공개키 암호의 양쪽 성질을 가진 하이브리드 암호 시스템이다. 키를 교환하는 곳에서는 공개키 암호를 사용하고, 그 후의 동신에서 메시지를 교환하는 곳에서는 공통키 암호를 사용한다.[증명서]공개키 암호에도 문제점이 있는데 그 문제점은 공개키가 진짜인지 아닌지를 증명할 수 없다는 점이다. 공격자가 도중에 공개키를 바꿔치기 하면 알 방법이 없다. 그래서 이러한 문제를 해결하기 위해 인증기관과 인증기관이 발행한 공개키 증명서가 이용된다.유명한 인증기관은로 ‘VeriSign’사가 있다.인증 기관의 공개키는 안전하게 클라이언트에 전달되지 않으면 안된다. 통신 중에는 어떤 방법을 사용하더라도 안전하게 전달하는 것은 어렵기 때문에 많은 브라우저가 주요 인증기관의 공개키를 사전에 내장한 상태로 제품을 내놓고 있다. 위의 증명서의 역할은 서버가 올바른 통신 상대임을 증명하지만 상대방이 실제로 있는 기업인지를 확인하는 역할도 있다. 그 역할을 가진 증명서를 EV SSL 증명서 라고 한다. 브라우저의 주소창이 녹색으로 변하면 EV SSL 증명서로 증명된 웹사이트인 것을 시각적으로 알 수 있다. 서버가 통신하고 있는 상대가 의도한 클라이언트인 것을 증명하는 클라이언트 증명서 도 있으나 문제점으로 증명서의 입수와 배포가 있다. 유저가 클라이언트 증명서를 install 해야하고, 유료로 구입해야하기 때문에 많은 비용이 든다. SSL 인증 기관은 신용이 중요한데 가짜 증명서가 발행되 버린 사건이 있었다. 잘못 발행된 증명서라 해도 믿을 수 있는 인증 기관의 서명이 있기 때문에 브라우저는 올바른 증명서로 인식한다. OpenSSL 등의 소프트웨어를 사용하면 누구든지 인증 기관을 구축할 수 있어 서버 증명서를 발행할 수 있으나 인터넷상에서 증명서로 구실을 하지 못하고 쓸모가 없다.[HTTPS의 구조] 클라이언트가 메시지를 송신하면서 SSL 통신이 시작된다. 메시지에는 SSL의 버전을 지정하고 암호 스위트가 포함되어 있다. 서버가 SSL 통신이 가능한 경우 메시지로 응답하고 SSL 버전, 암호 스위트를 내용에 포함한다. 메시지에 공개키 증명서를 포함하여 송신한다. 최초의 SSL 네고시에이션 부분이 끝났음을 통지 최초 네고시에이션이 종료되면 클라이언트가 Client Key Exchange 메시지로 응답한다. 클라이언트는 Change Cipher Spec 메시지를 송신한다. 클라이언트는 Finished 메시지를 송신한다. 이 메시지는 접속 전체의 체크 값을 포함하고 있다. 서버에서 Change Cipher Spec 메시지를 송신한다. 서버에서 Finished 메시지를 송신한다. 서버와 클라이언트의 Finished 메시지 교환이 완료되면 SSL에 의해서 접속은 확립된다. 그리고 이제부터 애플리케이션 계층의 프로토콜에 의해 통신을 한다. 즉 HTTP 리퀘스트 송신 HTTP 리스폰스 송신 클라이언트가 마지막으로 접속을 끊는다.[SSL, TLS]HTTPS에서는 SSL과 TLS라는 두 개의 프로토콜이 사용되고 있다. TLS는 SSL을 바탕으로 한 프로토콜로 이 프로토콜을 총칭해서 SSL이라 부르기도 한다.SSL통신은 HTTP에 비해 통신속도가 떨어지고, CPU나 메모리 등의 리소스를 다량으로 소비함으로써 처리가 느려진다. 또 반드시 암호화 처리를 하고 있기 때문에 서버나 클라이언트에서는 암호화나 복호화를 위한 계산을 할 필요가 있어 리소스를 소비하게 되어 HTTP에 비해 부담이 커진다.느려지는 것에 근본적인 해결방법은 없기 때문에 SSL 엑셀레이터라는 하드웨어를 사용해서 이 문제를 해결하기도 한다." }, { "title": "6장 HTTP 헤더", "url": "/posts/6%EC%9E%A5-HTTP-%ED%97%A4%EB%8D%94/", "categories": "BOOK, 그림으로 배우는 Http & Network", "tags": "http, network", "date": "2022-04-16 22:57:32 +0900", "snippet": "6.1 HTTP 메시지 헤더HTTP 프로토콜의 리퀘스트, 리스폰스에는 반드시 메시지 헤더가 포함되어 있는데 메시지 헤더에는 클라이언트나 서버가 리퀘스트나 리스폰스를 처리하기 위한 정보가 들어있다. 이러한 정보의 대부분은 클라이언트를 이용하는 사용자가 직접 볼 필요는 없다. 리퀘스트의 HTTP 메시지 : 메소드, URI, HTTP 버전, HTTP 헤더 필드 등으로 구성되어 있다. 리스폰스의 HTTP 메시지 : HTTP 메시지와 HTTP 버전, 상태코드, HTTP 헤더 필드 등으로 구성되어 있다.이중 가장 다양한 정보를 가지고 있는 것이 HTTP 헤더 필드로 헤더 필드는 리퀘스트와 리스폰스 양쪽에 모두 존재하고 HTTP 메시지에 관한 정보를 가지고 있다.6.2 HTTP 헤더 필드 HTTP 헤더 필드는 중요한 정보를 전달한다. HTTP 메시지를 구성하는 요소의 하나로 클라이언트와 서버간의 통신에서 리퀘스트에도 리스폰스에도 사용되고 있고, 부가적으로 중요한 정보를 전달하는 역할을 담당하고 있다. HTTP 헤더 필드의 구조 HTTP 헤더 필드는 헤더 필드 명과 필드 값으로 구성되어 있고 콜론(:)으로 나뉘어져 있다. 헤더 필드명 : 필드값 4종류의 HTTP 헤더 필드 a. 일반적 헤더 필드 : 리퀘스트 메시지와 리스폰스 메시지 둘 다 사용되는 헤더이다. b. 리퀘스트 헤더 필드 : 리퀘스트 메시지에 사용되는 헤더로 리퀘스트의 부가적 정보와 클라이언트의 정보, 리스폰스의 콘텐츠에 관한 우선 순위 등을 부가한다. c. 리스폰스 헤더 필드 : 리스폰스 메시지에 사용되는 헤더로 리스폰스의 정보와 서버의 정보, 클라이언트의 추가 정보 요구 등을 부가한다. d. 엔티티 헤더 필드 : 리퀘스트, 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더로 콘텐츠 갱신 시간 등의 엔티티에 관한 정보를 부가한다. HTTP/1.1 헤더 필드 일람 HTTP/1.1 이외의 헤더 필드 헤더가 RFC2616에서 정의된 47종류만 있는 것은 아니다. 쿠키와 Set-Cookie, Content-Disposition과 같이 그 외에 RFC에 정의되어 폭 넓게 사용되고 있는 것도 있다. 이런 비표준 헤더 필드는 RFC4229 HTTP Header Field Registrations에 정리되어 있다. End-to-end 헤더와 Hop-by-hop 헤더 End-to-end : 리퀘스트나 리스폰스의 최종 수신자에게 전송된다. Hop-by-hop: 한 번 전송에 대해서만 유효하고 캐시와 프록시에 의해서 전송되지 않는 것도 있다.6.3 HTTP/1.1 일반 헤더 필드1.Cache-Control이 헤더는 디렉티브로 불리는 명령을 사용하여 캐싱 동작을 지정한다. 디렉티브에는 파라미터가 있는 것과 없는 것도 있고 여러개의 디렉티브를 지정하는 경우에는 콤마로 구분한다.[● 캐시가 가능한지 여부를 나타내는 디렉티브] public 디렉티브 : 캐시를 해도 좋다 private 디렉티브 : 리스폰스는 특정 유저만을 대상으로 하고 있다. 따라서 특정 유저를 위해서 리소스를 캐시할 수 있지만 다른 유저로부터 같은 리퀘스트가 온다고 하더라도 그 캐시를 반환하지 않음 no-cache 디렉티브 : 캐시로부터 오래된 리소스가 반환되는 것을 막기 위해 사용된다. 클라이언트의 리퀘스트에 사용된 경우 캐시된 리스폰스를 클라이언트가 받아들이지 않음을 의미하고 서버의 리스폰스에 사용된 경우 캐시서버는 리소스를 저장할 수 없다.[● 캐시로 보존 가능한 것을 제어하는 디렉티브] no-store 디렉티브 : 리퀘스트 또는 리스폰스에 기밀정보가 포함되어 있다는 의미를 나타냄[● 캐시 기한이나 검증을 지정하는 디렉티브] s-maxage 디렉티브 : max-age 디렉티브와 동일한데 다른 점은 여러 유저가 이용할 수 있는 공유 캐시 서버에만 적용된다는 점이다.(같은 유저에 반복해서 리스폰스를 반환하는 캐시 서버는 무효) max-age 디렉티브 : 리퀘스트에서 사용한 경우 지정된 값보다 새로운 경우에는 캐시되었던 리소스를 받아들일 수 있다. 지정한 값이 0이면 캐시 서버는 리퀘스트를 항상 오리진 서버에 넘길 필요가 있다.서버에서 사용되는 경우 캐시 서버가 유효성의 재확인을 하지 않고 리소스를 캐시에 보존해 두는 최대 시간을 나타낸다.HTTP/1.1 캐시 서버는 동시에 Expires 헤더 필드가 달린 경우에는 max-age 디렉티브의 지정을 우선하고 Expires 헤더 필드를 무시한다. HTTP/1.0 캐시 서버는 반대로 max-age 디렉티브가 무시된다. min-fresh 디렉티브 : 캐시된 리소스가 적어도 지정된 시간은 최신 상태의 것을 반환하도록 캐시 서버에 요구한다. (지정된 시간 이상 유효한지) max-stale 디렉티브 : 캐시된 리소스의 유효기간이 끝났더라도 받아들일 수 있음 only-if-cached 디렉티브 : 클라이언트는 캐시 서버에 대해서 목적한 리소스가 로컬 캐시에 있는 경우만 리스폰스를 반환하도록 요구한다. must-revalidate 디렉티브 : 리스폰스의 캐시가 현재도 유효한지 아닌지의 여부를 오리진 서버에 조회를 요구한다. proxy-revalidate 디렉티브 : 모든 캐시 서버에 대해서 이후의 리퀘스트로 해당 리스폰스를 반환할 때는 반드시 유효성 재확인을 하도록 요구한다. no-transform 디렉티브 : 리퀘스트, 리스폰스의 어느 쪽에 있어서도 캐시가 엔티티 바디의 미디어 타입을 변경하지 않도록 지정한다. 그래서 캐시 서버 등에 의해서 이미지가 압축되는 것을 방지한다.[● Cache-Control 확장] cache-extension 토큰 : 이해할 수 있는 캐시 서버에 대해서만 의미가 있다.2.ConnectionConnection 헤더 필드는 다음의 두 가지 역할을 한다. 프록시에 더 이상 전송하지 않는 헤더 필드를 지정 : 예) Connection: 더이상 전송하지 않는 헤더 필드 명 지속적 접속 관리 : 예) Connection: Close -&gt; 서버측에서 명시적으로 접속을 끊고 싶을 경우HTTP/1.1 이전 버전의 HTTP에서는 지속적 접속이 기본이 아니였다. 그래서 이전 버전의 경우 지속적 접속이 하고 싶은 경우 Connection 필드에 Keep-Alive를 붙여서 리스폰스 하였다.3.DateHTTP 메시지를 생성한 날짜를 나타낸다.4.PragmaHTTP/1.1 보다 오래된 버전의 흔적으로 HTTP/1.0 와의 후방 호환성만을 위해 정의된 헤더 필드이다. 클라이언트의 리퀘스트에서만 사용 가능하고, 캐시된 리소스의 리스폰스를 원하지 않음을 모든 중간 서버에 알리기 위해 사용된다.5.Trailer메시지 바디 뒤에 기술되어 있는 헤더 필드를 미리 전달할 수 있다.6.Transfer-Encoding메시지 바디의 전송 코딩 형식을 지정하는 경우에 사용된다. (HTTP/1.1 에서는 청크 전송만 정의되어 있다.)7.UpgradeHTTP 및 다은 프로토콜의 새로운 버전이 통신에 이용되는 경우에 사용된다.8.Via클라이언트와 서버 간의 리퀘스트 혹은 리스폰스 메시지의 경로를 알기 위해서 사용된다. 프록시, 게이트웨이는 자신의 서버 정보를 Via 헤더 필드에 추가한 뒤에 메시지를 전송한다.9.WarningHTTP/1.0 리스폰스 헤더가 HTTP/1.1에서 변경된 것으로 리스폰스에 관한 추가 정보를 전달한다.6.4 리퀘스트 헤더 필드리퀘스트 헤더 필드는 클라이언트 측에서 서버측으로 송신된 리퀘스트 메시지에 사용되는 헤더로, 리퀘스트의 부가정보, 클라이언트의 정보, 리스폰스의 콘텐츠 에 관한 우선순위 등 추가한다. Accept : 유저 에이전트에 처리할 수 있는 미디어 타입과 미디어 타입의 상대적인 우선순위를 전달하기 위해 사용된다. 타입/서브타입으로 설정 (예. text/html, image/jpeg …), 우선순위를 붙이고 싶은 경우 세미콜론으로 구분하고, ‘q=’로 표시할 품질 지수를 더한다. Accept-Charset : 유저 에이전트에서 처리할 수 있는 문자셋으로 상대적인 우선순위를 전달하기 위해 사용된다. 또 한 번에 여러개를 지정할 수 있다. Accept-Encoding : 유저 에이전트에서 처리할 수 있는 콘텐츠 코딩과 콘텐츠 코딩의 상대적인 우선 순위를 전달하기 위해서 사용된다. (gzip, compress, deflate, identity) ‘*’ 애스터 리스크를 지정하면 와일드 카드로써 모든 인코팅 포맷을 가리킨다. Accept-Language : 유저 에이전트가 처리할 수 있는 자연어 세트와 상대적인 우선순위를 전달하기 위해 사용 Authorization : 인증 정보를 전달하기 위해 사용된다. 서버에 인증을 받으려는 유저 에이전트는 상태 코드 401 리스폰스의 뒤에 리퀘스트에 Authorization 헤더 필드를 포함한다. Expect : 클라이언트가 서버에 특정 동작 요구를 전달한다. From : 유저의 메일 주소를 전달한다. Host : 리퀘스트한 리소스의 인터넷 호스트와 포트 번호를 전달한다. HTTP/1.1에서 유일한 필수 헤더 필드이다.(같은 IP주소에 복수의 도메인이 적용된 경우에 대비하기 위해 명확히 호스트명을 기재할 필요가 있다.) If-Match : 조건부 리퀘스트로 서버는 If-Match의 필드 값과 리소스의 ETag 값이 일치하는 경우에만 리퀘스트를 받아들일 수 있다. If-Modified-Since : 리소스 갱신 날짜가 필드 값보다 새롭지 않다면 리퀘스트를 받아들이겠다는 뜻을 전달한다. If-None-Match : If-Match 헤더 필드와는 반대로 동작한다. If-Range : 지정한 필드 값과 지정한 리소스의 ETag 값 혹은 날짜가 일치하면 Range 리퀘스트로서 처리하고 싶다는 것을 전달 한다. 일치하지 않는 경우 리소스 전체를 반환한다. If-Unmodified-Since : If-Modified-Since와 반대로 동작한다. Max-Forwards : TRACE or OPTIONS 메소드에 의한 리퀘스트시 전송해도 좋은 서버 수의 최대치를 10진수 정수로 지정한다. HTTP를 사용한 통신시 여러대의 서버를 경유해가는 경우가 있다. 이때 리스폰스가 되돌아 오지 않기 때문에 클라이언트쪽에서 알 수가 없어 이러한 문제를 해결하기 위해 사용된다. Proxy-Authorization : 인증에 필요한 클라이언트의 정보를 전달한다. Range : 리소스의 일부분만 취득하는 Range 리퀘스트를 할 때 지정 범위를 전달한다. Referer : 리퀘스트가 발생한 본래 리소스의 URI를 전달한다. TE : 리스폰스로 받을 수 있는 전송 코딩의 형식과 상대적인 우선순위를 전달한다. User-Agent : 리퀘스트를 생성한 브라우저와 유저 에이전트의 이름 등을 전달하기 위한 필드이다.6.5 리스폰스 헤더 필드 Accept-Ranges : Range 리퀘스트를 접수할 수 있는지 여부를 전달한다. 수신 가능한 경우엔 ‘bytes’, 수신 불가능한 경우에는 ‘none’ Age : 얼마나 오래 전에 오리진 서버에서 리스폰스가 생성되었는지를 전달, 필드 값의 단위는 초이다. ETag : 엔티티 태그라고 불리면 리소스를 특정하기 위한 문자열을 전달한다. 서버는 리소스마다 ETag 값을 할당한다. ETag에는 강한 ETag(조금 다르더라도 반드시 값은 변화)와 약한 ETag(리소스가 같다는 것만을 나타냄) 값으로 구별되어 있다 Location : 클라이언트가 Request-URI 이외의 리소스 액세스를 유도하는 경우 사용된다. Location 헤더 필드를 포함한 리스폰스를 받으면 강제로 리다이렉트 하는 곳의 리소스에 액세스를 시도한다. Proxy-Authenticate : 클라이언트와 프록시 사이에서 인증이 이루어지는 경우 인증요구를 클라이언트에 전달한다. Retry-After : 클라이언트가 일정 시간 후에 리퀘스트를 다시 시행해야 하는지 전달한다. Server : HTTP 서버의 소프트웨어를 전달한다. Vary : 캐시를 컨트롤하기 위해 사용된다. 오리진 서버로부터 Vary에 지정되었던 리스폰스를 받아들인 프록시 서버는 이후 캐시된 때 리퀘스트와 같은 Vary에 지정되어 있는 헤더 필드를 가진 리퀘스트에 대하여만 캐시를 반환할 수 있다. WWW-Authenticate : HTTP 액세스 인증에 사용되는데 리소슷에 적용할 수 있는 인증 스키마와 파라미터를 전달한다.6.6 엔티티 헤더 필드엔티티 헤더 필드는 리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더로 콘텐츠의 갱신시간 같은 엔티티에 관한 정보를 포함한다. Allow : Request-URI에 지정된 리소스가 제공하는 메소드의 일람을 전달한다. (예. Allow:GET, HEAD) Content-Encoding : 서버가 엔티티 바디에 대해서 실시한 콘텐츠 코딩 형식을 전달한다. Content-Language : 엔티티 바디에 사용된 자연어를 전달 Content-Length : 엔티티 바디의 크기를 전달 Content-Location : 메시지 바디에 대응하는 URI를 전달한다. Content-MD5 : 메시지 바디가 변경되지 않고 도착했는지 확인하기 위해 MD5 알고리즘에 의해 생성된 값을 전달한다. Content-Range : 범위를 지정해서 일부분만 리퀘스트하는 Range 리퀘스트에 대해 리스폰스를 할 때에 사용된다. Content-Type : 엔티티 바디에 포함되는 오브젝트의 미디어 타입을 전달한다. Expires : 리소스의 유효기한 날짜를 전달한다. 캐시서버가 이 헤더필드를 포함한 리소스 수신시 지정된 날짜까지 리스폰스의 복사본을 유지하고 리퀘스트에는 캐시로 응답한다. Last-Modified : 리소스가 마지막으로 갱신되었던 날짜 정보를 전달한다.6.7 쿠키를 위한 헤더 필드서버와 클라이언트 간의 상태를 관리하는 쿠키는 유저 식별과 상태 관리에 사용되고 있는 기능이다.[쿠키의 사양서] 넷스케이프사에 의한 사양 : 쿠키를 고안한 넷스케이프 커뮤니케이션스 사의 사양 RFC2109 : 현재 사용하지 않음 RFC2965 : 거의 사용되지 않음 RFC6265Set-Cookie서버가 클라이언트에 대해서 상태 관리를 시작할 때 다양한 정보를 전달한다.Cookie클라이언트가 HTTP의 상태 관리 지원을 원할 때 서버로부터 수신한 쿠키를 이후의 리퀘스트에 포함해서 전달한다.6.8 그 이외의 헤더 필드HTTP 헤더 필드는 독자적으로 확장할 수 있다. 다음은 자주 사용되는 헤더 필드이다. X-Frame-Option : 클릭 재킹 공격을 막는 것을 목적으로 하고 있다.(DENY-거부, SAMEORIGIN) X-XSS-Protection : XSS 대책으로 브라우저의 XSS 보호 기능을 제어하는 HTTP 리스폰스 헤더이다. DNT : 개인 정보 수집을 거부하는 의사를 나타내는 HTTP 리퀘스트 헤더이다.(0-트래킹동의, 1-트래킹거부) P3P : 웹 사이트 상의 프라이버시 정책에 P3P를 사용한 것" }, { "title": "5장 HTTP와 연계하는 웹 서버", "url": "/posts/5%EC%9E%A5-HTTP%EC%99%80-%EC%97%B0%EA%B3%84%ED%95%98%EB%8A%94-%EC%9B%B9-%EC%84%9C%EB%B2%84/", "categories": "BOOK, 그림으로 배우는 Http & Network", "tags": "http, network", "date": "2022-04-15 20:57:32 +0900", "snippet": "5.1 1대로 멀티 도메인을 가능하게 하는 가상 호스트HTTP/1.1에서는 하나의 HTTP 서버에 여러 개의 웹 사이트를 실행할 수 있다. 이를 위해 ‘가상 호스트’ 라는 기능을 사용하고 있다. 가상 호스트 기능을 사용하면 물리적으로는 서버가 1대지만 가상으로 여러대가 있는 것처럼 설정하는 것이 가능하다.클라이언트가 서버에 액세스할 때는 호스트 명이나 도메인 명이 자주 사용된다. 이때 DNS는 도메인 명을 IP 주소로 변환하여 액세스한다. 결국 리퀘스트가 서버에 도착해서는 IP 주소를 기준으로 액세스 하는데 이때 1대의 서버 안에 여러개의 도메인이 있는 경우 어느 쪽에 대한 액세스인지 알 수 없기 때문에 리퀘스트를 보낼 때 호스트 명과 도메인 명을 완전히 포함한 URI를 지정하거나, Host 헤더 필드에서 지정해야 한다.5.2 통신을 중계하는 프로그램 : 프록시, 게이트웨이, 터널 프록시 : 서버와 클라이언트의 양쪽 역할을 하는 중계 프로그램, 클라이언트로부터 받은 리퀘스트를 다른 서버에 전송하는 것이다. 사용하는 이유는 캐시를 사용해서 네트워크 대역 등을 효율적으로 사용하는 것과 조직 내에 특정 웹 사이트에 대한 액세스 제한, 액세스 로그를 획득하는 정책을 철저하게 지키려는 목적으로 사용하는 경우도 있다. 캐싱 프록시 : 리스폰스를 중계하는 경우 프록시 서버 상에 리소스 캐시를 보존해 두는 타입의 프록시이다. 따라서 같은 리소스에 리퀘스트가 온 경우 서버로부터 리소스를 획득하는 것이 아니라 캐시를 리스폰스로서 되돌려 주는 것이다. 투명 프록시 : 리퀘스트와 리스폰스를 중계할 때 메시지 변경을 하지 않는 타입의 프록시를 가리킨다. 게이트웨이 : 다른 서버를 중계하는 서버로 클라이언트로부터 수신한 리퀘스트를 리소스를 보유한 서버인 것처럼 수신한다. 동작은 프록시와 매우 유사하나 게이트웨이의 경우에는 다음에 있는 서버가 HTTP 이외의 서비스를 제공하는 서버가 된다. 또 클라이언트와 게이트웨이 사이를 암호화하는 등으로 안전하게 접속함으로써 통신의 안전성을 높이는 역할 등도 한다. 터널 : 두 대의 클라이언트와 서버 사이를 중계하며 접속을 주선하는 중계 프로그램이다. 요구에 따라 다른 서버와의 경로를 확립한다. 이때 클라이언트는 SSL 같은 암호화 통신을 통해 서버와 안전하게 통신을 하기위해 사용" }, { "title": "4장 결과를 전달하는 HTTP 상태코드", "url": "/posts/4%EC%9E%A5-%EA%B2%B0%EA%B3%BC%EB%A5%BC-%EC%A0%84%EB%8B%AC%ED%95%98%EB%8A%94-HTTP-%EC%83%81%ED%83%9C%EC%BD%94%EB%93%9C/", "categories": "BOOK, 그림으로 배우는 Http & Network", "tags": "http, network", "date": "2022-04-13 23:34:32 +0900", "snippet": "4.1 상태 코드는 서버로부터 리퀘스트 결과를 전달한다클라이언트가 서버에 리퀘스트를 보내면 서버는 그 결과가 어떻게 되었는지 알려주기 위해 상태코드를 보낸다. 그래서 상태코드를 보고 정상 처리 되었는지, 에러가 났는지 알 수 있다.[상태코드 클래스]   클래스 설명 1XX Informational 리퀘스트를 받아들여 처리중 2XX Success 리퀘스트를 정상적으로 처리했음 3XX Redirection 리퀘스트를 완료하기 위해서 추가 동작이 필요 4XX Client Error 서버는 리퀘스트 이해 불가능 5XX Server Error 서버는 리퀘스트 처리 실패 4.2 2XX 성공(Success) 200 OK : 클라이언트가 보낸 리퀘스트를 서버가 정상 처리하였음을 나타낸다. 그리고 리스폰스에서 상태 코드와 함께 되돌아 오는 정보는 메소드에 따라 다르다. 204 No Content :서버가 리퀘스트를 받아서 처리하는 데는 성공했지만 리스폰스에 엔티티 바디를 포함하지 않는다. 206 Partial Content : Range에 의해서 범위가 지정된 리퀘스트에 의해 서버가 부분적 GET 리퀘스트를 받았음을 나타낸다.4.3 3XX 리다이렉트(Redirection)3XX 리스폰스는 리퀘스트가 정상적으로 처리를 종료하기 위해 브라우제 측에서 특별한 처리를 수행해야 함을 나타낸다. 301 Moved Permanently : 리퀘스트된 리소스에는 새로운 URI가 부여되어 있기 때문에 이후로는 그 리소를 참조하는 URI를 사용해야 한다는 것을 나타낸다. 302 Found : 리퀘스트된 리소스에는 새로운 URI가 할당되어 있기 때문에 그 URI를 참조해주길 바란다는 의미를 나타낸다. 301과 비슷하지만 302는 영구적인 이동이 아닌 일시적 이동이다. 303 See Other : 리퀘스트에 대한 리소스는 다른 URI에 있기 때문에 GET 메소드를 사용해서 얻어야 한다는 것을 나타낸다. 304 Not Modified : 클라이언트가 조건부 리퀘스트를 했을 때 리소스에 대한 액세스는 허용하지만, 조건이 충족되지 않음을 표시한다. 307 Temporary Redirect : 302와 같은 의미를 지님 다른점은 POST에서 GET으로 치환하지 않는다.4.4 4XX 클라이언트 에러(Client Error)클라이언트의 원인으로 에러 발생 400 Bad Request : 리퀘스트 구문이 잘못되었음을 나타낸다. 401 Unauthorized : 송신한 리퀘스트에 대하여 HTTP 인증 정보가 필요하다는 것을 나타낸다. 또 한 번 리퀘스트가 이루어진 경우 유저 인증에 실패했음을 표시한다. 403 Forbidden : 리퀘스트된 리소스의 액세스가 거부되었음을 나타냄 거부된 이유는 엔티티 바디에 기재한다. 404 Not Found4.5 5XX 서버 에러(Server Error)서버의 원인으로 에러가 발생했음을 나타냄 500 Internal Server Error : 서버에서 리퀘스트 처리 도중 에러 발생 503 Service Unavaliable : 일시적으로 서버가 과부하 상태이거나 점검중이기 때문에 현재 리퀘스트를 처리할 수 없음을 나타냄**상태 코드가 현재 상황과 불일치할 수도 있다." }, { "title": "3장 HTTP 정보는 HTTP 메시지에 있다", "url": "/posts/3%EC%9E%A5-HTTP%EC%A0%95%EB%B3%B4%EB%8A%94-HTTP%EB%A9%94%EC%8B%9C%EC%A7%80%EC%97%90-%EC%9E%88%EB%8B%A4/", "categories": "BOOK, 그림으로 배우는 Http & Network", "tags": "http, network", "date": "2022-04-12 23:29:32 +0900", "snippet": "3.1 HTTP 메시지HTTP에서 교환하는 정보를 HTTP 메시지라 한다. HTTP 메시지는 크게 메시지 헤더와 메시지 바디로 구성되고 최초에 나타나는 개행 문자로 헤더와 바디를 구분한다.3.2 리퀘스트 메시지와 리스폰스 메시지의 구조 리퀘스트 라인 : 메소드, 리퀘스트 URI와 HTTP 버전이 포함됨 상태 라인 : 리스폰스 결과를 나타내는 상태 코드와 설명, 사용하는 HTTP 버전이 포함됨 헤더 필드 : 리퀘스트와 리스폰스의 여러 조건과 속성 등을 나타내는 각종 헤더 필드가 포함됨3.3 인코딩으로 전송 효율을 높이다HTTP로 데이터 전송시 인코딩을 실시함으로써 전송 효율을 높일 수 있다.1.메시지 바디와 엔티티의 차이 : 메시지 바디는 HTTP통신의 기본 단위로 옥텟 시퀀스로 구성되고 통신을 통해 전송된다. 엔티티는 리퀘스트와 리스폰스의 페이로드로 전송되는 정보이다. 헤더 필드와 바디로 구성된다.HTTP 메시지 바디의 역할은 엔티티 바디를 운반하는 일이다.2.압축해서 보내는 콘텐츠 코딩 : 메일에 파일을 첨부해서 전송시 용량을 줄이기 위하여 압축해서 보내는 일이 있다. HTTP에는 이와 같은 일을 해주는 ‘콘텐츠 코딩’이라 불리는 기능이 구현되어 있다. 콘텐츠 코딩은 엔티티에 적용하는 인코딩을 가리키는 것으로 엔티티 정보를 유지한채 압축한다.종류)gzip, compress, deflate, identity3.분해해서 보내는 청크 전송 코딩 : 통신시 리퀘스트 리소스 전부에서 엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시되지 않는데 사이즈가 큰 데이터를 전송하는 경우 데이터를 분해해서 조금씩 표시할 수 있다. 이를 ‘청크 전송 코딩’이라고 부른다.청크 전송 코딩은 엔티티 바디를 청크로 분해하고 수신한 클라이언트 쪽에서 원래의 엔티티 바디로 디코딩한다.3.4 여러 데이터를 보내는 멀티파트메일은 본문이나 복수의 첨부파일을 붙여서 함께 보낼 수 있다. 이것은 MIME로 불리는 메일로 텍스트나 영상, 이미지와 같은 여러 다른 데이터를 다루기 위한 기능을 사용하고 있다.HTTP도 멀티파트에 대응하고 있어 하나의 메시지 바디 내부에 엔티티를 여러 개 포함시켜 보낼 수 있어 주로 이미지나 텍스트 파일 등을 업로드할 때 사용된다.⇒ multipart/form-data, multipart/byteranges멀티파트 각각의 엔티티를 구분하기 위해 boundary 문자열을 사용하고 이 문자열 앞에 ‘—’를 삽입한다. 멀티파트는 파트마다 헤더 필드가 포함된다.3.5 일부분만 받는 레인지 리퀘스트이전에는 대용량의 이미지와 데이터를 다운로드할 때 중간에 커넥션이 끊어지는 경우 처음부터 다시 다운로드를 해야 해서 힘들었다. 이러한 문제를 해결하기 위해 리줌이라는 기능이 필요하게 되었고 이를 통해 이전에 다운로드한 곳에서 부터 다운로드를 재개할 수 있었다.이와 같이 범위를 지정하여 리퀘스트 하는 것을 레인지 리퀘스트라고 부른다. Range 헤더 필드를 사용하여 리소스의 바이트 레인지를 지정한다.3.6 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션같은 콘텐츠이지만 여러 개의 페이지를 지닌 웹페이지의 경우(예 언어 형식이 한국어, 영어 등으로 나뉜경우) 브라우저가 같은 URI에 액세스할 때에 각각의 웹페이지를 표시하는데 이와 같은 구조를 ‘콘텐츠 네고시에이션’이라고 부른다.콘텐츠 네고시에이션은 클라이언트와 서버가 제공하는 리소스의 내용에 대해서 교섭하는 것이고 클라이언트에 더욱 적합한 리소스를 제공하기 위한 구조이다. 이 콘텐츠 네고시에이션은 제공하는 리소스를 언어와 문자 세트, 인코딩 방식등을 기준으로 판단한다. 서버 구동형 네고시에이션 : 서버측에서 콘텐츠 네고시에이션을 하는 방식, 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해서 자동적으로 처리한다. 에이전트 구동형 네고시에이션 : 클라이언트 측에서 콘텐츠 네고시에이션을 하는 방식, 브라우저에 표시된 선택지 중 유저가 수동으로 선택한다. 트랜스페어런트 네고시에이션 : 서버 구동형과 에이전트 구동형을 혼합한 것 각각 콘텐츠 네고시에이션을 하는 방식이다." }, { "title": "2장 간단한 프로토콜 HTTP", "url": "/posts/2%EC%9E%A5-%EA%B0%84%EB%8B%A8%ED%95%9C-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-HTTP/", "categories": "BOOK, 그림으로 배우는 Http & Network", "tags": "http, network", "date": "2022-04-10 19:55:10 +0900", "snippet": "2.1 HTTP는 클라이언트와 서버 간에 통신을 한다.텍스트와 이미지 등과 같은 리소스를 필요하다고 요구하는 쪽이 클라이언트가 되고, 이러한 리소스를 제공하는 쪽이 서버가 된다. HTTP는 클라이언트와 서버의 역할을 명확하게 구별하고 있다.2.2 리퀘스트와 리스폰스를 교환하여 성립HTTP는 클라이언트로부터 리퀘스트가 송신되며, 그 결과가 서버로부터 리스폰스로 되돌아온다. 즉 반드시 클라이언트 측으로부터 통신이 시작된다.2.3 HTTP는 상태를 유지하지 않는 프로토콜HTTP는 상태를 계속 유지하지 않는 stateless 프로토콜이다. 따라서 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해서는 전혀 기억하지 않는다.이는 많은 데이터를 매우 빠르고 확실하게 처리하는 범위성을 확보하기 웨해서 이와 같이 간단하게 설계되어 있는 것이다.하지만 stateless 특성만으로 처리하기 어려운 일이 증가하게 되었고(예. 로그인 상태 유지 등) 상태를 유지하고 싶은 요구에 부응하기 위해 ‘쿠키’라는 기술이 도입되었다.2.4 리퀘스트 URI로 리소스를 식별클라이언트는 리소스를 호출시마다 리퀘스트를 송신할 때에 리퀘스트 안에 URI를 포함한다. 모든 URI를 리퀘스트 URI에 포함하던가 Host 헤더 필드에 네트워크 로케이션을 포한하는 등의 방법이 있다.2.5 서버에 임무를 부여하는 HTTP 메소드HTTP/1.1 에서 사용할 수 있는 메소드 GET(리소스 획득) : GET 메소드는 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구한다. POST(엔티티 전송) : POST는 엔티티를 전송하기 위해서 사용된다. PUT(파일 전송) : FTP에 의한 파일 업로드와 같이 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구한다. HEAD(메시지 헤더 취득) : GET과 같은 기능이지만 메시지 바디는 돌려주지 않는다. 주로 URI 유효성과 리소스 갱신 시간을 확인하는 목적등으로 사용된다. DELETE(파일 삭제) : PUT 메소드와 반대로 동작, PUT 메소드와 같이 인증 기능이 없기 때문에 일반적인 웹 사이트에서는 사용되고 있지 않다. OPTIONS(제공하고 있는 메소드의 문의) : 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용된다. TRACE(경로 조사) : Web 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백을 발생시킨다. CONNECT(프록시에 터널링 요구) : 프록시에 터널 접속 확립을 요함으로써 TCP 통신을 터널링 시키기 위해서 사용된다. 주로 SSL, TLS 등의 프로토콜 암호화된 것을 터널링 시키기 위해서 사용2.6 메소드를 사용해서 지시를 내린다리퀘스트 URI로 지정한 리소스에 리퀘스트를 보내는 경우에는 메소드라 불리는 명령이 있다. 메소드는 리소스에 어떠한 행동을 하기 원하는지를 지시하기 위해 존재한다. 또 메소드는 대소문자를 구별하기 때문에 대문자로 기재해야 한다.2.7 지속 연결로 접속량을 절약HTTP 초기 버전에서는 HTTP 통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 할 필요가 있었다. 그로인해 리퀘스트를 보낼 때마다 매번 TCP 연결과 종료를 하게 되는 쓸모없는 일이 발생되어 통신량이 늘어나게 된다.이러한 문제를 해결하기 위해 지속 연결이라는 방법을 고안하였다. 이는 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다. 지속 연결을 하는 이점으로 TCP 커넥션의 연결과 종료의반복되는 오버헤드를 줄여주기 때문에 서버에 대한 부하가 경감된다. 또 오버헤드를 줄인 만큼 요청과 응답이 빠르게 완료되기 때문에 웹 페이지를 빨리 표시할 수 있다. (지속 연결은 HTTP 1.1에서 표준)또 지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인화를 가능하게 한다. (예전에는 1요청 1응답이여서 응답이 없으면 요청을 더 못보냈다. 이러한 단점을 보안한 것이 파이프라인화이다.)2.8 쿠키를 사용한 상태 관리HTTP는 상태를 관리하지 않기 때문에 인증이 필요한 웹 페이지 등에서 문제를 일으킬 수 있다. 이로 인하여 쿠키라는 시스템이 도입되었는데 이는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템이다.서버에서 쿠키를 발행하여 클라이언트에 보존하게 된다. 이후 클라이언트가 같은 서버로 리퀘스트를 보낼때 자동으로 쿠키값을 넣어서 송신하고 서버에서 이를 확인하여 이전 상태를 알 수 있다." }, { "title": "1장 웹과 네트워크의 기본에 대해 알아보자", "url": "/posts/1%EC%9E%A5-%EC%9B%B9%EA%B3%BC-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9D%98-%EA%B8%B0%EB%B3%B8%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90/", "categories": "BOOK, 그림으로 배우는 Http & Network", "tags": "http, network", "date": "2022-04-09 19:55:10 +0900", "snippet": "1.1 웹은 HTTP로 나타낸다웹 브라우저는 주소 입력란에 지정된 URL에 의지해서 웹 서버로부터 리소스라 불리는 파일등의 정보를 얻는다. 이때 서버에 의뢰하는 웹 브라우저를 ‘클라이언트’ 라고 부른다.클라이언트에서 서버까지 일련의 흐름을 결정하고 있는 것이 웹에서 HTTP(HyperText Transfer Protocol)이라 불리는 프로토콜이다.1.2 HTTP는 이렇게 태어났고 성장했다CERN의 팀 버너스 리 박사는 멀리 떨어져 있는 동료 연구자와 지식을 공유하게 할 수 있도록 시스템을 고안했고, 하이퍼 텍스트에 의해 상호간에 참조할 수 있는 WWW(World Wide Web)의 기본 개념이 되는 것이다.이 때 WWW를 구성하는 기술로 HTML, HTTP, URL이 있다.1.3 네트워크의 기본은 TCP/IP인터넷을 포함하여 일반적으로 사용하고 있는 네트워크는 TCP/IP 라는 프로토콜에서 움직인다. (HTTP도 그중 하나)TCP/IP는 프로토콜의 집합컴퓨터와 네트워크 기기가 상호간에 통신하기 위해서는 서로 같은 방법으로 통신하여야 한다. 서로 다른 하드웨어와 운영체제를 가지고 서로 통신을 하기 위해서는 모든 요소에 규칙이 필요하고 이러한 규칙을 ‘프로토콜’이라 부른다.그리고 인터넷과 관련된 프로토콜들을 모은 것을 TCP/IP라고 부른다.계층으로 관리하는 TCP/IPTCP/IP에서 중요한 개념 중 하나가 계층이다. ‘애플리케이션 계층’, ‘트랜스포트 계층’, ‘네트워크 계층’, ‘링크 계층’ 이렇게 4계층으로 나뉘어 있다.계층화 되어 있는 것은 메리트가 있는데 어디선가 사양이 변경되었을 때 전체를 바꾸지 않고 변경된 해당 계층만 바꾸면 된다. 또 계층화하면 각자의 역할만 고려하면 되기 때문에 설계를 편하게 할 수 있다. 애플리케이션 계층 : 유저에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정한다. (FTP, DNS, HTTP) 트랜스포트 계층 : 애플리케이션 계층에 네트워크로 접속되어 있는 2대의 컴퓨터 사이의 데이터 흐름을 제공한다. (TCP, UDP) 네트워크 계층 : 네트워크 상에서 패킷의 이동을 다룬다. 패킷은 전송하는 데이터의 최소 단위이다. 이 계층에서는 어떠한 경로로 상대의 컴퓨터까지 패킷을 보낼지 결정한다. 링크 계층 : 네트워크에 접속하는 하드웨어적인 면을 다룬다.TCP/IP 통신의 흐름TCP/IP로 통신을 할 때 계층을 순서대로 거쳐서 상대와 통신을 한다.예) 송신측 클라이언트의 애플리케이션 계층에서 어느 웹 페이지를 보고 싶다는 HTTP 리퀘스트를 보낸다. -&gt; 트랜스포트 계층에서는 데이터를 통신하기 쉽게 조각내어 안내번호와 포트번호를 붙여 네트워크 계층에 전달한다. -&gt;네트워크 계층에는 수신지 MAC 주소를 추가해서 링크 계층에 전달한다.각 계층을 거칠 때 헤더로 불려지는 계층마다 필요한 정보를 추가하고, 반대로 수신측에서는 각 계층을 거칠 때마다 해당 계층에서 사용한 헤더를 삭제한다.(캡슐화)1.4 HTTP와 관계가 깊은 프로토콜은 IP/TCP/DNS배송을 담당하는 IPIP(Internet Protocol)은 네트워크 계층에 해당되고, 역할은 개개의 패킷을 상대방에게 전달하는 것이다.상대방에게 패킷을 전달하기 위해서는 IP 주소와 MAC 주소가 필요하다.IP는 각 노드에 부여된 주소를 가리키고, MAC은 각 네트워크 카드에 할당된 고유의 주소를 나타낸다. 그리고 IP는 변경이 가능하고, MAC은 변경이 불가능하다.IP 통신은 MAC 주소에 의존해서 통신을 한다. 통신시 여러 대의 컴퓨터와 네트워크 기기를 중계해서 상대방에게 도착하는데 중계하는 동안에는 다음에 중계할 곳의 MAC 주소를 사용하여 목적지를 찾아간다.그리고 이때 ARP(Address Resolution Protocol)가 사용된다. ARP는 수신자의 IP 주소를 바탕으로 MAC 주소를 조사할 수 있다.목적지까지 중계를 하는 도중 컴퓨터와 라우터 등의 네트워크 기기는 목적지에 도착하기까지 대략적인 목적지만을 알고 있다. 이러한 시스템을 ‘라우팅’이라 부른다.결국 어떤 컴퓨터나 네트워크 기기도 인터넷 전체를 상세하게 파악하고 있지는 못한다.신뢰성을 담당하는 TCPTCP(Transfer Control Protocol)는 트랜스포트 계층에 해당하고, 신뢰성 있는 바이트 스트림 서비스(용량이 큰 데이터를 작게 분해하여 관리하는 것)를 제공한다.즉 대용량의 데이터를 보내기 쉽게 작게 분해하여 상대방에게 보내고, 정확하게 도착했는지 확인하는 역할을 담당하고 있다.상대에게 확실하게 데이터를 보내기 위해서 TCP는 Three Way HandShaking 방법을 사용한다. 이 방법은 패킷을 보내고 보내졌는지 여부를 상대방에게 확인까지 하는 것이다.송신측에서 SYN 플래그로 상대에게 패킷을 보내고, 수신측에서는 SYN/ACK 플래그로 송신측에 패킷을 수신한 사실을 전한다. 그리고 마지막으로 송신측에서 ACK 플래그를 보내 패킷 교환이 완료되었음을 확인한다.1.5 이름 해결을 담당하는 DNSDNS(Domain Name System)은 HTTP와 같이 응용 계층 시스템에서 도메인 이름과 IP 주소 이름 확인을 제공한다. 이는 도메인명에서 IP 주소를 조사하거나 IP 주소로부터 도메인명을 조사하는 서비스를 제공한다.1.6 각각과 HTTP와의 관계1.7 URI 와 URL웹 페이지를 표시하기 위해 입력하는 주소가 URL이다. URI는 리소스 식별자로 스키마(http)를 나타내는 리소스를 식별하기 위한 식별자이다.정리하면 URI는 리소스를 식별하기 위해 문자열 전반을 나타내는데, URL은 리소스의 장소 즉 네트워크상의 위치를 나타낸다." }, { "title": "JavaScript", "url": "/posts/Js/", "categories": "기술면접", "tags": "js", "date": "2022-04-03 16:32:10 +0900", "snippet": "호이스팅호이스팅은 코드가 실행하기 전 변수선언, 함수선언이 해당 스코프의 최상단으로 끌러올려진 것 같은 현상을 말한다. 또한 단지 선언문만 끌어올려질 뿐 할당은 끌어올리지 않는다.호이스팅은 자바스크립트의 모든 선언에서 발생하고, let, const, class를 이용한 선언문에서는 호이스팅이 발생하지 않은 것처럼 동작한다.이들 키워드로 선언된 변수를 선언문 이전에 참조하면 참조에러가 발생한다.var키워드의 경우 선언과 동시에 undefined로 초기화 되어 메모리에 저장되는데 let, const의 경우 초기화 되지 않은 상태로 선언만 메모리에 저장되기 때문에 참조 에러를 일으키는 것이다.참고var / let / constvar : 변수를 중복으로 선언을 하여도 에러가 발생하지 않고, 각기 다른 값을 출력한다. 또 기본적으로 function scope를 가지고 있다.변수 선언시 선언 단계와 초기화 단계가 한 번에 이뤄진다.(undefined로 초기화)let : 변수의 재선언이 불가하다. block scope를 가지고 있다.선언 단계와 초기화 단계가 분리되어 있어 실제 변수선언문 위치에 도달하였을 때 초기화가 이루어진다.호이스팅으로 인한 스코프의 시작지점부터 초기화 시작 지점의 위치가 다른데 초기화 시작 지점까지는 변수를 참조할 수 없다. 이 구간을 일시적 사각지대(TDZ)라 부른다.const : 변수의 재선언이 불가하고, 불변값으로 값의 재할당이 불가능하다. block scope를 가지고 있다.클로저자바스크립트에서는 함수를 어디서 호출했는지가 아닌 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다(렉시컬 스코프)렉시컬 스코프가 가능하기 위해서는 함수는 자신이 호출된 환경과 상과없이 자신이 정의된 환경 즉 상위 스코프를 기억해야한다.외부 함수보다 중첩된 이너 함수가 더 오래 유지되는 경우 중첩함수는 이미 생명주기가 종료된 외부 함수의 변수를 참조 할 수 있다.이러한 중첩함수를 클로저라고 한다.[클로저의 조건] 중첩 함수가 상위 스코프의 식별자를 참조해야한다. 중첩 함수가 외부 함수보다 더 오래 유지되야 한다.클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. 상태가 의도치 않게 변경되지 않도록 상태를 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.[참고 : 모던자바스크립트 deep dive]this기본 바인딩 : 전역객체 window암시적 바인딩 : 어떤 객체를 통해 함수가 호출된다면 그 객체가 바로 this가 된다.명시적 바인딩 : 함수는 call, apply, bind 메서드를 가지고 있는데 첫 번째 인자로 넘겨주는 것이 this가 된다.new 바인딩 : new 키워드를 사용하여 생성자 함수로 사용하면 this는 빈 객체를 가리킨다.참고1null / undefinednull : 원시 값 중 하나로 어떤 값이 의도적으로 비어있음을 표현한다. 즉 어떤 객체도 가리키고 있지 않다는 것을 의미한다. null은 타입이 object다undefined : 변수를 선언하고 값을 할당하지 않은 상태로 자료형이 없는 상태다. 타입이 없기 때문에 undefined 타입은 undefined이다.**두 값 모두 메모리적으로 차이가 없음 =&gt; 참고깊은 복사, 얕은 복사얕은 복사 : 얕은 복사는 참조 값의 복사를 의미한다. 해당 데이터의 참조 값을 전달하여 원본객체와 복사객체가 한 데이터를 공유하는 것이다. 예)call by reference깊은 복사 : 값 자체의 복사를 의미한다. 원본 값과, 복사 값은 별도로 존재한다. 예)call by value객체를 그대로 복사하여 사용하는 경우 기존 객체의 원본 데이터가 변질될 수 있어 객체의 깊은 복사가 중요하다.객체의 깊은 복사를 하기 위해서 Object.assign(생성할 객체, 복사할 객체)를 사용하면 된다. 하지만 2차원 객체의 경우 복사가 이루어지지 않는다.참고Ajax / PromiseAjax : 브라우저에 동기처리 방식으로 인한 문제점을 해결하기 위해 나온 비동기 통신으로 변경된 부분의 데이터만 Ajax를 통해 갱신하여 문제점을 해결할 수 있다.비동기 처리 중 API를 호출했지만 서버에서는 응답값을 줄지 모른다. Ajax는 비동기적 처리로 서버에 요청후 응답을 기다리지 않고 다음 코드를 수행하여 문제가 발생할 수 있다.이로 인하여 비동기적 처리의 실행순서를 제어하는 것이 필요했고 그 방법으로 콜백함수가 있다. 콜백함수를 이용하면 여러 콜백함수가 중첩되면서 콜백지옥 상황이 생기고가독성이 떨어지게 된다.Promise : Ajax의 콜백지옥의 단점을 개선도 하고 이전보다 간결하게 비동기 처리를 할 수 있도록 Promise가 나왔다. 사용방법은 Promise 객체를 사용하여 생성하고 인자로 함수를 담는다.함수에는 resolve(처리가 성공적으로 끝난 경우 호출), reject(처리가 실패하여 끝난 경우 호출)라는 인수를 갖고 있다. promise 객체를 호출하는 부분에서 .then()을 사용하는 부분에서는 resolve 함수가, .catch()를 사용하는 부분에서는 reject 함수가 실행된다.ES6 문법 const, let 화살표 함수 템플릿 리터럴 기본 매개변수 import, export Promise class Spread 연산자 Iterator / Generatorasync / awaitasync : 함수선언 앞에 async 키워드를 붙이면 해당 함수는 항상 프로미스를 반환한다. 프로미스가 아닌 것은 프로미스로 감싸서 반환await : await 키워드는 async 함수안에서만 동작 한다. 함수 내에서 await 키워드를 만나면 프로미스가 처리될 때까지 기다리고 결과는 그 이후에 반환된다.참고forEach / MapforEach는 배열을 순회하면서 배열의 각 원소들을 출력하나 map은 배열을 순회하면서 출력한 원소들을 새 배열로 반환해 준다." }, { "title": "Baekjoon_9498(부제:BufferedReader, BufferedWriter)", "url": "/posts/Baekjoon_9498/", "categories": "Algorithm, BaekJoon", "tags": "if, bufferedreader, bufferedwriter", "date": "2022-03-29 16:55:34 +0900", "snippet": "문제백준에서 단계별로 풀어보기 진행 중 새로 알게된 사실 하나!1단계에서부터 입력 받은 값으로 결과를 내는 문제가 있었는데 나는 계속 java.util 패키지의 Scanner를 사용하여 문제를 풀었다.그런데 다른 사람과 결과를 비교했을 때 속도에서 차이가 발생하여 다른 사람의 답지를 보고 새로운 것을 알았다.1)Scanner를 사용한 방식 -&gt; 208ms 시간 / 17716KB 메모리import java.util.*;class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int score = scanner.nextInt(); String result = \"\"; if(score &gt;= 90 &amp;&amp; score &lt;= 100) result = \"A\"; else if(score &gt;= 80 &amp;&amp; score &lt;= 89) result = \"B\"; else if(score &gt;= 70 &amp;&amp; score &lt;= 79) result = \"C\"; else if(score &gt;= 60 &amp;&amp; score &lt;= 69) result = \"D\"; else result = \"F\"; System.out.println(result); scanner.close(); }}2)BufferedReader 사용한 방식 -&gt; 124ms시간 / 14372KB 메모리import java.io.*;class Main { public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int score = Integer.parseInt(br.readLine()); String result = \"\"; if(score &gt;= 90 &amp;&amp; score &lt;= 100) result = \"A\"; else if(score &gt;= 80 &amp;&amp; score &lt;= 89) result = \"B\"; else if(score &gt;= 70 &amp;&amp; score &lt;= 79) result = \"C\"; else if(score &gt;= 60 &amp;&amp; score &lt;= 69) result = \"D\"; else result = \"F\"; System.out.println(result); }}3)BufferedReader, BufferedWriter 사용한 방식 -&gt; 124ms 시간 / 14212KB 메모리import java.io.*;class Main { public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int score = Integer.parseInt(br.readLine()); String result = \"\"; if(score &gt;= 90 &amp;&amp; score &lt;= 100) result = \"A\"; else if(score &gt;= 80 &amp;&amp; score &lt;= 89) result = \"B\"; else if(score &gt;= 70 &amp;&amp; score &lt;= 79) result = \"C\"; else if(score &gt;= 60 &amp;&amp; score &lt;= 69) result = \"D\"; else result = \"F\"; bw.write(result); bw.flush(); //버퍼에 남아있는 데이터를 출력(비움) br.close(); bw.close(); }}BufferedReader / BufferedWriter버퍼를 이용해서 읽고 쓰는 함수로 버퍼를 이용하기 때문에 입출력의 효율이 비교할 수 없을 정도로 좋아진다.키보드로 입력한 글자를 버퍼에 하나씩 담아 버퍼가 가득 차거나, 개행 문자가 나타나면 버퍼의 내용을 한 번에 전송한다.BufferedReader는 Scanner와 유사하나 Scanner는 스페이스, 엔터를 경계로 입력 값을 인식하기 때문에 따로 가공할 필요 없어서 편리하다.반면 BufferedReader는 엔터만 경계로 인식하고 받은 데이터가 String으로 고정되기 때문에 데이터를 따로 가공해야 하는 경우 번거롭다. 하지만 Scanner에 비해 상대적으로 빠르다.readLine()를 사용하여 데이터를 라인 단위 로 읽을 수 있으나 리턴 값이 String으로 고정되어 있기 때문에 다른 타입으로 입력 받으려면 형변환을 해주어야 한다. 또한 예외처리를 꼭 해주어야 한다.라인 단위로 읽은 데이터를 공백 단위로 가공하고자 할 때 다음의 방법을 사용할 수 있다.// 1) StringTokenizerBufferedReader br = new BufferedReader(new InputStreamReader(System.in));StringTokenizer st = new StringTokenizer(br.readLine());System.out.println(st.nextToken());System.out.println(st.nextToken());// String.split() 함수String arr[] = br.readLine().split(\" \");BufferedWriter는 System.out.println() 과 유사한 것으로 System.out.println()보다 속도가 빠르다.write() 메서드 를 사용하여 출력할 내용을 담고, flush() 메서드 를 통해 버퍼를 비워내고 동시에 콘솔에 출력한다. 그리고 BufferedWriter도 반드시 예외처리가 필요하다.참고1참고2" }, { "title": "Network", "url": "/posts/Network/", "categories": "기술면접", "tags": "network", "date": "2022-03-28 17:57:11 +0900", "snippet": "TCP / UDPTCP : 연결형 서비스로 3-way handshaking 과정을 통해 연결을 설정한다. 데이터가 유실될 경우 재전송을 통해 복구하고, 순서가 바뀌더라도 순서 번호를 이용하여 제대로 맞춰 전달한다.그래서 높은 신뢰성을 보장한다. 또 데이터의 흐름과 혼잡을 제어한다. 단점으로는 비교적 속도가 느리다는 점이 있다.UDP : 비연결형 서비스로 전송한 데이터가 유실될 수 있고, 순서가 바뀌어 도착할 수 있다. 그래서 신뢰성이 떨어진다는 단점을 갖고 있으나 수신여부를 확인하지 않기 때문에 속도가 빠르다.따라서 TCP는 신뢰성이 중요한 파일 교환 같은 경우에 쓰이고 UDP는 실시간성이 중요한 스트리밍에 자주 사용된다.참고프로토콜프로토콜은 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계이다.OSI 7계층프로토콜을 기능별로 나눈 것으로 각 계층은 하위 계층의 기능만 이용하고, 상위 계층에게 기능을 제공한다. 물리 계층 : 네트워크 데이터가 전송되는 물리적인 매체이다. 0과 1의 비트열로 전기적 신호 상태로 이루어져 있다. 데이터 링크 계층 : 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당하는 계층 네트워크 계층 : 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층 전송 계층 : 최종 수신 프로세스로 데이터의 전송을 담당하는 계층 세션 계층 : 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층 표현 계층 : 데이터의 형식을 정의하는 계층 응용 계층 : 사용자와 직접 상호작용하는 응용 프로그램들이 포함된 계층TCP/IPTCP/IP는 데이터가 의도된 목적지에 닿을 수 있도록 보장해주는 통신 규약이다. 패킷 통신 방식의 인터넷 프로토콜인 IP와 전송 조절 프로토콜인 TCP로 이루어져 있다.IP는 패킷 전달 여부를 보증하지 않고, 패킷을 보낸 순서와 받은 순서가 다를 수 있는데 TCP가 데이터 전달을 보증하고, 보낸 순서로 받을 수 있게 해준다.참고HTTP / HTTPSHypertext Transfer Protocol : 웹 서버와 웹 브라우저 사이에 문서를 전송하기 위한 통신 규약이다. 기본 포트인 80번 포트를 사용하며, 정보를 단순 텍스트로 주고받기 때문에 데이터가 쉽게 도난당할 수 있다.상태를 갖지 않은 프로토콜로 Method, Path, Version, Headers, Body로 구성된다. 클라이언트 요청을 서버에 보내고 서버는 클라이언트에게 적절한 응답을 주고 연결을 끊는 특성이 있다.(Connectionless 비연결지향)1.1버전에서 커넥션을 계속 유지하고 요청을 재활용하는 기능이 추가됨 (keep-alive), 또 커넥션을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는 특성을 가지고 있다.(Stateless 상태 없음)Hypertext Transfer Protocol Secure : 기본 골격은 HTTP와 거의 동일하지만 SSL 보안 소켓 계층을 사용함으로써 서버와 브라우저 사이에 안전하게 암호화(대칭키 암호화, 비대칭키 암호화 모두 사용)된 연결을 만들어주고, 정보가 도난당하는 것을 막아준다.HTTP와 다르게 443번 포트를 사용한다. SSL 인증서로 정보를 암호화 하고, TLS(전송 계층 보안) 프로토콜을 통해서도 보안을 유지한다. TLS는 데이터 무결성을 제공하여 데이터가 전송 중 수정이나 손상되는 것을 방지한다.참고참고대칭키 암호화 / 비대칭키 암호화대칭키 암호화 : 암호화 / 복호화에 사용하는 키가 동일한 암호화 방식이다. 대표적인 알고리즘으로 DES, AES, SEED 등이 있고, 비대칭키 암호화 방식에 비해 속도가 빠르다는 장점이 있지만 키를 교환하는 과정에서 키가 탈취되거나 사용자가 증가하면키를 관리하는데 어려울 수 있다는 단점이 있다.비대칭키 암호화 : 공개키 암호화 방식이라고도 부르며 암호화/복호화에 사용하는 키가 서로 다르다. 따라서 송수신자 모두 한 쌍의 키(개인키, 공개키)를 갖고 있게 된다. 대칭키와 다르게 키가 공개되어 있어 키를 교환할 필요가 없고,개인키를 가지고 있는 수신자만이 데이터를 복호화할 수 있어 일종의 인증 기능도 제공한다는 장점이 있지만 속도가 느리다는 단점이 있다. 대표적인 알고리즘으로 RSA, DSA, ECC 등**개인키-사용자만이 가지고 있는 키 / 공개키-모든 사람이 접근 가능한 키참고HTTP Method GET : 주로 데이터를 읽거나 검색할 때 사용되는 메소드이다. 오로지 데이터를 읽을 때만 사용되고 수정할 때는 사용하지 않는다. 같은 요청을 여러번 보내도 항상 같은 응답을 받는다.(Idempotence 하다.) POST : 주로 새로운 리소스를 생성할 때 사용된다. post요청은 Idempotence 하지 않다.(post 요청 반복시 같은 결과물이 나오는 것을 보장하지 않음) PUT : 지정된 데이터를 전부 수정할 때 사용된다. Idempotence 하다. / PATCH : 정보의 일부분이 수정된다. Idempotence하지 않다. DELETE : 지정된 리소스를 삭제한다.Idempotent : 멱등성이란 뜻으로 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다.참고HTTP1.1 / HTTP2HTTP1.1은 기본적으로 연결당 하나의 요청과 응답을 처리하기 때문에 동시전송이 불가능하고, 요청과 응답이 순차적으로 이루어진다.따라서 단점으로 1)HOL Blocking 특정 응답의 지연, 2)RTT 증가, 3)무거운 Header 구조HTTP2는 성능뿐만 아니라 속도면에서도 월등하다. Multiplexed Streams의 특징을 갖고 있어 한 커넥션으로 동시에 여러 개의 메세지를 주고 받을 수 있고 응답은 순서에 상관없이 stream으로 주고 받는다.참고1참고2GET / POSTGET은 데이터를 읽거나 검색할 때 사용하는 메서드로 요청을 전송할 때 URL 주소 끝에 파라미터로 포함되어 전송되고 이를 ‘쿼리 스트링’이라 부른다.파라미터에 내용이 URL을 통해 노출되기 때문에 민감한 데이터를 다룰 때는 GET 방식을 사용하면 안 된다. 또 데이터 길이에 제한이 있고, 요청이 브라우저 기록에 남는다.POST는 요청을 전송시 HTTP 메세지의 Body에 담아서 전송한다. body는 길이의 제한이 없이 데이터를 전송할 수 있어 GET 방식과 달리 대용량 데이터를 전송할 수 있다. body로 전송되어 내용이 눈에 보이지 않아 GET 방식 보다는보안적인 면에서 안전하다고 할 수 있지만 암호화되어 있지 않기 때문에 개발자 도구를 통해 내용을 확인할 수 있다.Cookie / SessionCookie : 정보를 유지할 수 없는 성격을 가진 HTTP의 단점을 해결하기 위해 쿠키라는 개념이 도입되었다. 쿠키는 클라이언트 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일이다.클라이언트의 상태 정보를 로컬에 저장했다가 요청할 때 참조된다. 이로인해 탈취, 변조될 위험이 있어 보안이 취약하다.서버측에서 만료날짜/시간을 지정하여 정해진 시간 동안 데이터를 유지할 수 있고, 프로세스가 종료되더라도 특정 시간까지 유효하므로 지속된다.Session : 서버에 클라이언트의 상태 정보를 저장하는 기술로 논리적인 연결을 세션이라고 한다. 클라이언트 정보가 서버에 저장되어 있어 비교적 안전하다. 또 세션은 브라우저를 종료한 경우 사라진다.서버의 자원을 사용하기 때문에 사용자가 몰리는 경우 서버에 부하를 줄 수 있다.참고1참고2도메인ip는 사람이 이해하고 기억하기 어렵기 때문에 각 ip에 이름을 부여할 수 있는데 이것을 도메인이라고 한다.‘인터넷상에서 개인이 소유하고 있는 인터넷 주소’URL / URI / URNURI : 통합 자원 식별자의 줄임말이다. URI의 하위 개념으로 URL과 URN이 있다.URL : 프로토콜을 포함하고, 네트워크 상에서 웹 페이지, 이미지, 동영상 등의 파일이 위치한 정보를 나타낸다. 일반적으로 사이트 도메인을 자주 의미한다.URN : 이름으로 리소스를 특정하는 URI이다. 프로토콜을 포함하지 않고, 해당 자원의 이름을 의미한다.참고1참고2DNS사용자는 도메인 이름을 통해 온라인으로 정보를 액세스 한다. 웹 브라우저는 ip 주소를 통해 상호작용 한다. 이에 따라 DNS는 브라우저가 인터넷 자원을 로드할 수 있도록 도메인 이름을 IP 주소로 변환한다.참고웹 동작방식 사용자가 웹 브라우저를 통해 찾고 싶은 웹 페이지의 URL 주소를 입력 (예. www.naver.com) 입력한 URL 주소 중 도메인 부분을 DNS 서버에서 검색한다. 해당 도메인 이름에 해당하는 IP주소를 찾아 사용자가 입력한 URL 정보와 함께 전달 URL 정보와 IP 주소는 HTTP 프로토콜을 통해 요청 메시지 생성 -&gt; TCP 프로토콜을 사용하여 해당 IP 주소의 컴퓨터로 전송 도착한 HTTP 요청 메시지는 웹 페이지 URL 정보로 변환 웹 서버는 도착한 웹페이지 URL 정보에 해당하는 데이터 검색 HTTP 프로토콜을 사용하여 응답 메시지 생성 -&gt; TCP 프로토콜을 사용하여 원래 컴퓨터로 전송됨 도착한 응답 메시지는 HTTP를 사용하여 웹 페이지 데이터로 변환 변환된 웹 페이지 데이터는 웹 브라우저에 의해 사용자가 볼 수 있음참고세션 기반 인증 / 토큰 기반 인증세션 기반 인증 : 서버 기반 인증 방식으로 서버 측에서 세션에 사용자들의 정보를 저장해두고 서비스를 제공할 때 사용한다.토큰 기반 인증 : 인증 받은 사용자들에게 토큰을 발급하고, 서버에 요청을 할 때 헤더에 토큰을 함께 보내도록하여 유효성 검사를 한다토큰 기반 방식은 사용자의 인증 정보를 서버나 세션에 유지하지 않고, 클라이언트에서 들어오는 요청만으로 작업을 처리한다.또 상태를 유지하이 않으므로 stateless한 구조를 갖는다.참고JWT 토큰인터넷 표준 인증 방식으로 인증에 필요한 정보들을 토큰에 담아 암호화시켜 사용하는 토큰이다. JWT는 서명된 토큰이다.Json 형태로 Header, Payload, Signature의 3부분으로 이루어 진다. 각 부분은 . 점으로 구분한다.공인 IP / 사설 IP공인 IP : 전 세계에서 유일한 IP 주소를 갖는다. 공인 IP 주소는 외부에 공개되어 있기 때문에 인터넷에 연결된 다른 PC로부터 접근이 가능하다. 따라서 방화벽 등 보안 프로그램을 설치할 필요가 있다.사설 IP : 일반 가정이나 회사내 등에 할당된 네트워크의 IP 주소로 로컬 IP, 가상 IP라고도 한다.참고3 Way-HandshakeTCP에서 장치들 사이에 논리적인 접속을 성립하기 위해 사용한다. 통신을 하는 장치간에 서로 연결이 잘 되어있는지 확인하는 과정, 방법이다.3번 신호를 주고 받는다고 해서 3 Way-Handshake라 하고, seq 넘버를 보내서 순서가 뒤바뀌지 않도록 해준다.SSLSSL은 암호화 기반 인터넷 보안 프로토콜로 개인정보 보호, 인증, 데이터 무결성을 보장한다. 대표적으로 HTTPS가 있다.IP 주소 / HOST통신을 하려고 할 때 데이터를 보내고 받는 고유한 주소를 IP라고 한다. HOST는 IP주소를 갖는 시스템이라 할 수 있다.네트워크에 연결되어 있는 컴퓨터들을 host라 칭하고, 통신을 할 때 목적지와 출발지가 없으면 데이터를 주고 받을 수 없다. 이때 IP라는 고유한 주소를 통해 지정할 수 있다.참고CACHE사용자가 웹사이트에 접속시 정적 컨텐츠를 특정 위치에 저장해두고, 필요할 때 매번 서버에 요청하는 것이 아닌 특정 위치에 저장해둔 데이터를 불러옴으로써응답시간을 줄이고, 트래픽 감소 효과를 볼 수 있다.참고" }, { "title": "Java", "url": "/posts/Java/", "categories": "기술면접", "tags": "java", "date": "2022-03-24 17:23:46 +0900", "snippet": "OOP현실세계의 사물, 개념을 객체로 표현하고 객체들간의 유기적인 상호작용을 통해 프로그래밍 하는 방법이다.사람의 사고와 가장 비슷하게 프로그래밍을 하기 위해 생성된 기법이고, 코드의 재사용성과 중복제거, 유지보수에 용이하다.[특징] 추상화 : 불필요한 세부사항을 제거하고, 객체의 공통된 속성들을 하나의 클래스로 정의하여 단순하게 만드는 것 캡슐화 : 외부에 노출할 필요가 없는 정보들은 은닉하는 것으로 데이터에 직접적으로 접근하는 것을 막고 오로지 메소드를 통해서만 접근할 수 있다. 상속 : 부모 클래스가 자손 클래스에게 속성을 물려줌으로써 코드를 재사용하는 것이다. 다형성 : 같은 형태이지만 다른 기능을 하는 것으로 오버로딩, 오버라이딩이 있다.[장점] 강한 응집력, 약한 결합력을 가짐 코드가 간결해지고, 재사용성, 확장성이 높다.[단점] 각 모듈의 높은 독립성을 권장하여 여러 클래스를 상속해 중복코드를 최소화하고 유지보수성을 높인다 그렇기 때문에 실행 속도가 느리다. 객체가 많으면 용량이 커질 수 있다. 설계에 시간과 노력이 필요하다.oop_참고추상화_참고OOP 설계의 원칙[SOLID] Single Responsibility Principle (단일 책임 원칙) : 객체는 단 하나의 책임만 가져야 한다. Open Closed Principle (개방-폐쇄 원칙) : 소프트웨어의 요소는 확장에는 열려 있고(기능의 추가), 변경에는 닫혀 있어야 한다.(기존 코드를 변경하지 않는) Liskove Substitution Principle (리스코프 치환 원칙) : 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다. -&gt; 부모 클래스와 자식 클래스 사이의 행위에는 일관성이 있어야 한다는 원칙 Interface Segregation Principle (인터페이스 분리 원칙) : 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. -&gt; 자신이 사용하지 않는 기능에는 영향을 받지 말아야 한다. Dependency Inversion Principle (의존 역전 원칙) : 의존 관계를 맺을 때 변화하기 쉬운것(구체적인 것) 보다는 변화하기 어려운 것(추상적인 것)에 의존해야 한다. -&gt; 의존 관계를 맺을 때 구체적인 클래스보다는 인터페이스나 추상 클래스와 관계를 맺는 다는 것을 의미참고Overriding / Overloading오버라이딩 : 부모 클래스 상속시 상속받은 메소드를 자식 클래스에서 재정의 하는 것으로 부모 클래스의 메소드 선언부(이름, 매개변수, 반환타입)와 일치해야 한다.오버로딩 : 하나의 클래스안에 동일한 이름의 메소드를 여러개 정의하는 것으로 메소드의 이름이 같아야 하고, 매개변수의 갯수 또는 타입이 달라야 한다. (반환타입은 상관 없음)Static 키워드어떠한 값이 메모리에 한 번 할당되어 프로그램이 종료될 때까지 메모리에 값이 유지되는 것을 나타낸다. static 키워드를 통해 생성된 정적 멤버는 Heap 영역이 아닌 static 영역에 할당되고static 영역에 할당된 메모리는 모든 객체가 공유하는 메모리라는 장점을 지니지만 가비지 컬렉터가 관리하는 영역 밖이므로 자주 사용하게 되면 시스템 성능에 악영향을 주게 된다.*메서드에 사용시 객체의 생성 없이 호출 가능하다.참고직렬화직렬화는 자바에서 입출력시 스트림을 통해 데이터가 이동하는데 이때 바이트 배열로 변환하여 보내주어야 한다. 즉 객체를 바이트 배열로 변환하는 것을 나타내는 것이다.↔ 역직렬화는 직렬화와 반대로 바이트로 변환된 데이터를 다시 객체로 변환하는 것이다.String / StringBuffer / StringBuilderString : 한 번 생성되어 할당된 메모리 공간이 변하지 않는다. 그래서 새로운 값이 할당된 경우 메모리 공간을 새롭게 차지하여 많은 연산이 발생시 성능이 떨어진다.StringBuffer : 문자열 연산등으로 기존 객체의 공간이 부족한 경우 버퍼 크기를 늘려 유연하게 동작한다. 멀티 쓰레드 환경에서 동기화를 지원함StringBuilder : StringBuffer와 같으나 멀티 쓰레드 환경에서 동기화를 지원하지 않는다.JVMJVM은 자바 가상 머신의 약자로 자바 컴파일러가 자바 파일을 컴파일 하면 자바 바이트 코드로 변환시켜 준다. 이때 바이트 코드는 기계어가 아니기 때문에 OS가 이해할 수 있도록 해석해주는 작업을 해주는 것이 JVM 이다.자바와 OS 사이에 중개자 역할을 수행하여 자바가 OS에 구애받지 않고 프로그램을 실행할 수 있도록 도와준다. 또 가비지 컬렉터를 사용한 메모리 관리도 자동으로 수행된다.[구성] Class Loader : JVM 내로 클래스 파일을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다. 런타임 시에 동적으로 클래스를 로드한다. execution Engine(실행 엔진) : 클래스 로더를 통해 JVM 메모리 내에 배치된 바이트 코드들을 명령어 단위로 읽어서 기계가 실행할 수 있는 형태로 변경한다. Garbage Collector : heap 메모리 영역에 생성된 객체 중 참조되지 않은 객체들을 탐색 후 제거하는 역할을 한다. Runtime Data Area : 자바 애플리케이션을 실행할 때 사용되는 데이터를 적재하는 메모리 영역이다. Method Area - 모든 쓰레드가 공유하는 메모리 영역, 클래스, 인터페이스, 필드, static 변수 등 바이트 코드를 보관 Heap Area - 모든 쓰레드가 공유, new 키워드로 생성된 객체, 배열이 생성되는 영역이다. 가비지 컬렉터가 관리하는 영역 Stack Area - 지역변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값 등이 생성되는 영역이다. 메서드 호출시 개별적으로 스택이 생성됨 PC register - 쓰레드가 생성될 때마다 생성되는 영역으로 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역이다. Native Method Stack - 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역 class / 객체 / 인스턴스의 차이class : 객체를 만들어 내기 위한 설계도, 틀, 연관되어 있는 변수와 메서드의 집합이다.객체 : ‘클래스의 인스턴스’로 불리며 소프트웨어 세계에 구현할 대상 클래스에 선언된 실체이다.인스턴스 : 객체가 실제로 구현된 ‘구체적인 실체’를 의미한다.클래스는 설계도, 객체는 설계도로 구현한 모든 대상을 의미한다. 클래스 타입으로 선언되었을 때 객체라 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.참고생성자생성자는 인스턴스가 생성될 때 호출되는 ‘인스턴스 초기화 메서드’ 이다. 따라서 반환 값이 없고, 하나의 클래스에는 반드시 하나 이상의 생성자가 존재해야 한다.클래스 이름과 동일하고, 인스턴스 생성시 딱 한 번 호출된다. 기본 생성자 : 파라미터가 하나도 없는 생성자 묵시적 생성자 : 컴파일시 생성자가 하나도 정의되어 있지 않은 경우 컴파일러가 자동으로 기본 생성자를 생성해서 컴파일해준다. 명시적 생성자 : 개발자가 직접 선언한 생성자, 명시적 생성자 작성시 기본 생성자를 자동으로 생성해주지 않음thisthis는 객체, 자기 자신을 가리킨다.[특징] 객체 자신의 대한 참조값을 가진다. 즉, 자기자신을 가리킨다. 메소드 내에서만 사용된다. 객체 자신을 메소드에 전달하거나 리턴하기 위해 사용된다. 생성자 내에서 사용시 다른 생성자를 호출한다. 매개 변수와 객체 자신이 가진 변수의 이름이 동일한 경우 이를 구분하기 위해 자신의 변수에 this를 사용한다. static 메소드에서는 사용할 수 없다.Interface / Abstract인터페이스 : 함수의 구현을 강제하여 구현 객체의 같은 동작을 보장하는 목적을 가지고 있다. 다중 상속이 가능하고, 추상 클래스보다 추상화 정도가 높다. 또 일반 메서드, 일반 멤버 변수를 가질 수 없다는 특징을 갖고 있다.추상클래스 : 추상 클래스는 추상 클래스를 상속받아서 기능을 이용하고 확장시키는 목적을 가지고 있다. 반드시 하나 이상의 추상메서드를 가지며 상속을 위한 클래스이기 때문에 객체를 생성할 수 없고, 다중 상속이 불가하다.=&gt; 어떨때 인터페이스를 사용하고 어떨때 추상클래스를 사용하는 거지..??제네릭제네릭은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법이다.클래스나 메서드에서 사용할 내부 데이터 타입을 미리 지정하여 객체의 타입 안전성을 높일 수 있고 반환값에 대한 타입 변환, 타입 검사에 들어가는 노력을 줄일 수 있다.런타임이 아닌 컴파일시에 타입체크를 하기 때문에 오류를 빨리 발견할 수 있다.지역변수 / 인스턴스변수 / 클래스 변수지역 변수 : 메서드 내에 선언되고 해당 메서드 안에서만 사용할 수 있다. 따라서 메서드가 종료되면 소멸되어 사용할 수 없다.인스턴스 변수 : 클래스 내에 선언된 변수로 객체를 생성 할 때 만들어 진다. 독립적인 저장공간을 가지므로 생성된 객체마다 서로 다른 값을 가진다.클래스 변수 : static 키워드로 선언된 변수로 공통된 저장공간을 공유하게 된다. JVM이 처음 실행되어 클래스가 메모리에 올라가서 종료될 때까지 유지되고, 클래스가 여러번 생성되어도 static 변수는 처음에 딱 한 번만 생성된다.가비지 컬렉션Heap 메모리에 동적으로 할당되었으나 시스템에서 더이상 사용하지 않는 즉 참조되지 않는 대상을 찾아 메모리에서 해제하는 JVM의 기능이다.참고Call by Reference, Call by Value함수가 호출될 때 메모리 공간안에 임시의 공간이 생성되고 함수가 종료하면 해당 공간은 사라진다. 이때 함수 호출시 전달되는 변수의 값을 사용하는 방법이 두 가지가 있다.1)Call by Reference : ‘참조에 의한 호출’은 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 준다. 복사하지 않고 직접 참조하기 때문에 빠르지만 원본 값이 바뀔 수 있다는 단점이 있다.2)Call by Value : ‘값에 의한 호출’은 인자로 받은 값을 복사하여 함수 안에서 지역적으로 사용된다. 값을 복사하여 사용하기 때문에 안전하고 원본 값이 보존이 되지만 메모리 사용량이 늘어난다는 단점이 있다.**Java에서는 Call by Reference가 없음 직접적으로 참조를 넘기는 것이 아닌 주소 값을 복사해서 넘기기 때문에 call by value다.참고1참고2참고3Collection (Map, Set, List)컬렉션이란 데이터의 집합, 그룹을 의미하고 Collection 인터페이스는 List, Set, Queue로 3가지 상위 인터페이스를 분류한다.Map의 경우 Collention 인터페이스를 상속받고 있지 않지만 Collection으로 분류된다. Set : 순서를 유지하지 않는 데이터의 집합으로 데이터의 중복을 허용하지 않는다. HashSet TreeSet : 자동으로 정렬을 해준다. LinkedHashSet : 저장 순서를 유지할 수 있다. List : 순서가 있는 데이터의 집합으로 데이터의 중복을 허용한다. LinkedList : 양방향 포인터 구조로 데이터 삽입, 삭제가 빈번할 경우 유용하다. ArrayList : 단방향 포인터 구조로 각 데이터에 대한 인덱스 구조를 가지고 있어 조회 성능은 뛰어나나 배열의 중간에 데이터의 삽입, 삭제시 데이터의 이동이 필요하기 때문에 빈번한 경우 성능이 떨어짐 Map : 키와 값의 쌍으로 이루어진 데이터의 집합으로 순서는 유지되지 않으며 키는 중복을 허용하지 않고, 값은 중복을 허용한다. HashTable : HashMap보다 느리지만 동기화 지원, null 불가 HashMap : 중복, 순서 허용X, null 값이 올 수 있다. TreeMap : 정렬이 되어 있어 검색시 성능이 빠르다. **Collections 클래스는 Collection 인터페이스를 리턴하거나 인터페이스에서 동작하는 메서드를 모아놓은 클래스이다.Thread스레드란 하나의 프로세스내에 독립적으로 실행되는 하나의 작업 단위이다. JVM에 의해 하나의 프로세스가 발생하고 main 메서드 안의 실행문이 하나의 스레드이다.main 이외의 다른 스레드를 만들려면 Thread 클래스를 상속하거나 Runnable 인터페이스를 구현한다.[스레드의 6가지 상태] NEW - 스레드가 생성되었지만 아직 실행할 준비가 되지 않음 RUNNABLE - 실행 대기 상태 WAITING - 다른 스레드가 통지할 때까지 기다리는 상태 TIMED_WAITING - 주어진 시간동안 기다리는 상태 BLOCK - 사용하고자 하는 객체의 락이 풀릴 때까지 기다리는 상태 TERMINATED - 실행을 마친 상태참고참고접근 제한자객체의 속성들을 대외적으로 공개하는 것은 좋지 않다. 따라서 객체의 멤버들에게 접근 제한을 걸 수 있는데 그 종류로는 public : 모든 접근을 허용한다. protected : 같은 패키지에 있는 객체와 상속 관계의 객체들만 허용 default : 같은 패키지에 있는 객체들만 허용 private : 현재 객체내에서만 허용Stack / QueueStack : Last In First Out 구조로 마지막에 저장된 데이터를 가장 먼저 꺼내는 구조이다. 순차적으로 데이터를 추가하고 삭제하기 때문에배열 기반인 ArrayList 같은 컬렉션 클래스가 적합하다.Queue : First In First Out 구조로 먼저 들어간 데이터를 먼저 꺼내는 구조다. 데이터를 꺼낼때 항상 첫 번째 데이터를 삭제하기 때문에 배열 기반보다 데이터의 추가 삭제가 쉬운 LinkedList가 적합하다.Deque : Queue의 변형으로 양쪽 끝에서 추가, 삭제가 가능하다.Singleton인스턴스를 불필요하게 생성하지 않고, 오직 JVM 내에 한 개의 인스턴스만 생성하여 재사용을 위해 사용되는 디자인 패턴이다.한 번의 객체 생성으로 재사용이 가능하기 때문에 메모리 낭비를 방지할 수 있다. 또 한 번 생성으로 전역성을 띄기 때문에 다른 객체와 공유가 용이하다.하지만 싱글톤에게 많은 일을 하게 하거나 많은 데이터를 공유시키면 다른 클래스의 인스턴스간 결합도가 높아지면서 개방-폐쇄 원칙을 위배하는 문제가 발생한다.하지만 멀티스레드 환경에서 동기화 처리를 해주지 않는 경우 인스턴스가 두 개 생성되는 등 문제가 생길 가능성이 있기 때문에 Thread-safe(멀티스레드 환경에서 동작해도 원래 의도한 형태로 동작하는 코드)가 보장되어야 한다.또 수정이 어려워지고 테스트하기 어렵다는 단점이 존재한다.synchronized 키워드 사용을 통해 문제 해결 -&gt; 찾아보기..참고참고’==’ / equals()== 연산자는 int, boolean 같은 기본 자료형 타입에 대해서는 값을 비교하고, 객체 등 참조타입에 대해서는 주소값을 비교한다.equals() 메서드는 비교하고자 하는 두개의 대상의 값 자체를 비교한다.hashcodehashcode는 일반적으로 각 객체의 주소값을 변환하여 생성한 객체의 고유한 정수값이다. 따라서 두 객체가 동일 객체인지 비교할 때 사용할 수 있다.String의 경우 hashcode()가 재정의 되어 있는데 서로 다른 String 객체도 문자열이 같으면 hashcode()가 같다.*equals()는 두 객체의 내용이 같은지 확인 / hashcode()는 두 객체가 같은 객체인지 확인참고변수 표기법 파스칼 표기법 - 자바에서 클래스 명명 규칙으로 첫 클자를 대문자로 하고 + 카멜 표기법이 합쳐진 형태 언더스코프 표기법(스네이크) - 단어 사이에 밑줄을 표기하는 형태 카멜 표기법 - 두 단어 이상의 변수명 표현시 두 번째 단어부터 첫 글자를 대문자로 표기법, 변수 명명 규칙에서 첫 글자는 반드시 소문자로 한다는 규칙 + 카멜표기법 헝가리언 표기법 - 변수 표기시 앞에 접두어로 자료형을 쉽게 알아볼 수 있도록 표기하는 방식 케밥 표기법 - 하이픈 ‘-‘ 을 이용하여 단어를 연결하는 표기법참고참고동기화 / 비동기화작업을 수행하는 A, B가 있을 때 동기식 처리는 A의 작업이 끝나면 B의 작업이 시작하는 것이고, 비동기식 처리는 A의 작업이 끝나든 말든 상관없이 B의 작업이 시작되는 것이다.즉 동기는 작업이 순차적으로 진행되는 것이 보장되고, 요청에 따른 결과가 한 자리에서 동시에 일어난다 따라서 결과가 나올때까지 대기한다. 비동기는 요청에 따른 응답을 기다리지 않고 바로 다음 동작이 실행되는 것으로 결과가 나올 때까지 다른 작업을 수행할 수 있어 자원을 효율적으로 사용할 수 있다.참고버전별 차이점큰 특징으로 java 7 : switch 문의 인자로 String 허용 제네릭 인스턴스 생성시 type 생략 가능 java 1.8 : 인터페이스 내부에 로직을 포함할 수 있는 default 메서드를 작성할 수 있다. 람다표현식 새로운 날짜와 시간 API (LocalDate, LocalTime, LocalDateTime) java 10 : var 키워드를 통한 타입 추론 병렬처리 가비지 컬렉션 도입으로 인한 성능 향상 참고" }, { "title": "Spring", "url": "/posts/Spring/", "categories": "기술면접", "tags": "spring", "date": "2022-03-21 17:23:46 +0900", "snippet": "프레임워크 / 라이브러리프레임워크는 소프트웨어의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게끔 뼈대를 제공하는 것이다. 애플리케이션의 전체적인 흐름을 쥐고 필요한 개발자의 코드를 가져온다.라이브러리는 자주 사용되는 로직을 재사용하기 편리하도록 잘 정리한 일련의 코드들의 집합이다. 개발자가 필요하다고 생각하는 기능을 구현하기 위해 라이브러리를 가져온다.제어의 주체가 누구냐에 따라 구분 했을 때 개발자가 코드를 제어할 수 있다면 ‘라이브러리’, 개발자의 코드를 제어한다면 ‘프레임워크’이다.스프링 프레임워크 란?자바 엔터프라이즈 개발을 편하게 해주는 경량화된 오픈 소스 애플리케이션 프레임워크이다. 자바 객체를 직접 관리하여 Spring 컨테이너로부터 필요한 객체를 가져와 사용한다.경량화 되어 있다는 말은 스프링 자체가 가볍거나 작은 규모라는 의미가 아니라 불필요하게 무겁지 않다는 의미로 스프링 전에 사용하던 EJB의 과도한 개발환경과 코드를 대비시키기 위한 의미이다.스프링의 장점은 가볍고 단순한 환경 (톰캣, 제티 등)에서도 엔터프라이즈 개발의 고급 기술을 대부분 사용할 수 있다는 점이다.엔터프라이즈 개발을 편하게 한다 는 말은 EJB가 처음 등장했을 때도 나왔던 말이지만 EJB와 다르게 스프링은 개발자들이 프레임워크가 제공하는 기술이 아닌 자신이 작성하는 애플리케이션의 로직에 더 많은 관심과 시간을 쏟게 해준다.초기 스프링의 기본 설정과 적용 기술만 잘 선택한다면 개발자가 신경 쓸 일이 거의 없다. 따라서 엔터프라이즈 개발에서 필연적으로 요구되는 기술적인 요구를 충족하면서도 개발을 복잡하게 만들지 않는다.일반적인 라이브러리나 프레임워크는 특정 업무 분야나 한 가지 기술에 특화된 목표를 가지고 만들어진다. 그래서 특정 계층에서 주로 동작하는 한 가지 기술분야에 집중되는데애플리케이션 프레임워크 는 특정 계층이나 기술, 업무 분야에 국한되지 않고 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크를 말한다. 개발의 전 과정을 빠르고 편리하며 효율적으로 진행하는데 일차적인 목표를 두는 프레임워크다.**EJB-기업 환경의 시스템을 구현하기 위한 서버 측 컴포넌트 모델, 일반적으로 업무 로직을 가지고 있는 서버 어플리케이션을 지칭한다.참고프레임워크 사용 목적?개발자 간의 능력 차이, 개발자의 구성에 따라 프로젝트 결과에도 큰 차이가 발생할 수 있다. 이러한 상황을 극복하기 위해 미리 기본 흐름이나 구조가 정해진 프레임워크를 사용한다면 결과물에 일정한 품질이 보장되고, 개발시간 단축이라는 장점이 생긴다.스프링 특징 경량 컨테이너 IoC기반의 프레임워크 POJO 기반의 프레임워크 AOP 지원 MVC 패턴 WAS에 독립적인 개발 환경IoC제어의 역전이란 뜻으로 자바 기반의 개발 초기에는 자바 객체를 생성하고 의존관계를 연결하는 등의 제어권을 개발자가 가지고 있었으나 이 제어권을 컨테이너 쪽으로 넘어가객체의 생성부터 생명주기의 관리까지 모든 객체의 제어권이 바뀌었다는 것을 의미한다.객체의 의존성을 역전시키게 되면 객체간의 결합도를 줄이고 유연한 코드를 작성할 수 있어 가독성이 좋아지고, 코드의 중복을 제거하며, 유지 보수를 편하게 할 수 있게 한다.IoC 컨테이너기본적으로 객체를 생성하고 객체간의 의존성을 이어주는 역할을 한다. BeanFactory : IoC컨테이너의 기능을 정의한 인터페이스로 Bean(IoC컨테이너에 의해 생성되고 관리되는 객체)의 생성, 의존성 주입, 생명주기 관리 등의 기능을 제공한다. ApplicationContext : BeanFactory 인터페이스를 상속받는데 BeanFactory가 제공하는 기능 외에 AOP, 메세지 처리, 이벤트 처리등의 기능을 제공한다.DI의존성 주입이라는 의미로 객체간의 의존성을 컨테이너가 자동으로 연결해주는 것이다. 개발자가 Bean 설정 파일에 의존관계가 필요한 정보를 추가하면 컨테이너가 자동으로 연결해준다.Field 주입 / 생성자 주입 / Setter 주입 Field 주입 : 객체의 인스턴스 필드에 의존성이 주입되는 것으로 변수 선언부에 @Autowired 어노테이션을 붙여 사용한다. 코드가 간결해서 많이 이용하지만 참조관계를 눈으로 확인하기 어렵고, 의존성 주입이 간단하기 때문에의존성 주입을 막 추가하는 경우 단일책임의 원칙을 위반하게 된다. final을 붙일 수 없기 때문에 객체가 변할 수 있다. 생성자 주입 : 객체가 생성되는 시점에 의존성이 주입되는 것으로 생성자의 호출 시점에 1회 호출되는 것이 보장된다. 주입받은 객체가 변하지 않거나 반드시 객체의 주입이 필요한 경우에 강제하기 위해 사용한다. Setter 주입 : 객체의 set 메서드가 호출되는 시점에 의존성이 주입되는 것으로 주입받는 객체가 변경될 가능성이 있는 경우에 사용한다.DI 프레임워크의 대부분이 생성자 주입을 권장하는데 그 이유는 변경가능성을 배제하고 불변성을 보장해 준다. 테스트 코드의 작성이 용이해진다. final 키워드 작성 가능 및 Lombok과 결합을 통해 코드를 간결하게 작성할 수 있다. 순환참조 문제를 애플리케이션 구동 시점에 파악하여 방지할 수 있다.POJOPlain Old Java Object 의 약자로 평범하고 오래된 자바 객체라는 뜻이다. 이는 다른 클래스나 인터페이스를 상속받아 메서드가 추가된 클래스가 아닌 일반적으로 알고 있는 getter, setter 같이 기본적인 기능만 가진 자바 객체를 말한다.진정한 POJO란 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 말한다.[위키백과 참고] POJO는 다음과 같은 행동을 해서는 안 된다. 미리 정의된 클래스의 확장 public class Foo extends javax.servlet.http.HttpServlet { ... 미리 정의된 인터페이스의 구현 public class Bar implements javax.ejb.EntityBean { ... 미리 정의된 애너테이션을 포함 @javax.persistence.Entity public class Baz { ...AOPAOP는 관점지향 프로그래밍으로 불린다. 기능별로 클래스를 분리했음에도 불구하고, 로그, 트랙잭션, 자원해제 등 공통적으로 반복되는 중복코드가 발생하게 되는데이를 해결하기 위해 개발 코드에서는 비즈니스 로직에 집중하고, 실행시 비즈니스 로직의 앞 뒤에 해당 공통 관심사를 수행할 수 있게 하여 중복 코드를 줄이는 방식을 AOP라 한다.AOP는 프록시 패턴을 사용하는데 프록시 패턴은 어떤 기능을 추가하려 할 때 기존 코드를 변경하지 않고 기능을 추가할 수 있다.**프록시 패턴 : 대리인이라는 뜻으로 무엇인가 대신 처리한다는 의미이다. 어떤 객체를 사용하고자 할 때 객체를 직접적으로 참조하는 것이 아니라 해당 객체를 대행하는 객체 를 통해 대상객체에 접근하는 방식을 사용하여해당 객체가 메모리에 존재하지 않아도 기본 정보를 참조하거나 설정할 수 있고 객체가 실제 필요한 시점까지 생성을 미룰 수 있다.Interceptor / Filter개발시 공통 업무에 관한 코드들을 따로 빼서 관리하는 방법으로 filter, interceptor, AOP가 있다. 이 세 방법은 요청 흐름에 따라 차이가 발생한다.순서) Filter → Interceptor → AOP → Interceptor → Filter Filter : 웹 어플리케이션에 등록하고(web.xml), 요청이 서블릿 컨테이너에 도착하기 전에 수행된다. 사용자의 요청 정보에 대한 검증하고 필요에 따라 그 정보에 데이터를 추가하거나 변조할 수 있다. 주로 전역적으로 처리하는 인코딩, 보안 등을 수행한다.예) 오류처리, 인코딩처리, 보안관련 기능처리, 데이터 압축, 변환, 로그, 로그인여부 권한 검사 등 Interceptor : 스프링 컨텍스트에 등록하고, 서블릿 컨테이너를 통과한 후 컨트롤러에게 요청이 전달되기 전, 후에 대한 처리를 수행한다. 스프링 컨텍스트 내에 존재하기 때문에 모든 bean 객체에 접근할 수 있고, 여러개의 인터셉터를 사용할 수 있어로그인처리, 권한체크 등을 수행할 수 있다. 또 필터와 다르게 handlerMethod 파라미터를 이용하여 AOP와 같은 기능 수행이 가능하다.참고1Bean 등록 방법Bean은 Spring IOC Container가 관리하는 객체들을 의미한다. new 연산자를 사용하지 않고 컨테이너가 객체를 만들어서 사용할 수 있게 해준다.Bean 등록방법으로 Component Scan : 클래스에 @Component 어노테이션을 명시하는 방법이다. 자바로 직접 등록 : 클래스에 @Configuration을 붙이고 메서드에 @Bean을 붙여 구현한다. 이때 메서드에 리턴 객체가 Bean으로 등록된다. xml 설정 파일에 직접 등록 : Bean 태그 또는 componentScan 태그 사용참고1Spring MVCSpring은 MVC 패턴을 따르는데 이는 Model, View, Controller로 이루어진 구조이다.Model은 데이터를 담고 있는 객체이고, View는 화면을 담당하여 클라이언트 쪽이 처리를 한다. Controller는 데이터 흐름과 제어를 처리하여 사용자의 요청에 대한 처리를 한다.뷰의 영역과 비즈니스 로직이 분리되어 있다는 점이 큰 장점이다.Model1 / Model2 Model1 : view와 controller가 합쳐진 것으로 비즈니스 영역에서 프레젠테이션 영역을 같이 처리하는 것이다. 개발이 쉽고 간단하지만 유지보수가 어렵다. Model2 : Model, View, Controller로 나누어진 것으로 자신이 수행하는 기능에 따라 분리되어 모듈화 되어 있어 각 영역별로 개발을 수행하는 개발자들의 역할도 분리된다. 따라서 동시에 여러 분야를 개발할 수 있다는 장점을 갖고, 개발 시간이 오래 걸린다는 단점을 갖는다.따라서 규모가 작고 개발 후 주기적인 유지보수가 거의 없는 경우에는 Model1 프로젝트가 적합하고, 반대의 경우에는 Model2가 적합하다고 할 수 있다.VO / DTOVO : Value Object 값 그 자체를 표현하는 객체이다. 로직을 포함할 수 있고, 객체의 불변성을 보장한다. 핵심 역할은 equlas(), hashcode()를 오버라이딩 하는 것이다.DTO : Data Transfer Object 계층 간 데이터 교환을 위해 사용하는 객체이다. 데이터 교환만을 위해 사용하므로 로직을 갖지 않고, getter/setter 메소드만 갖는다.단순히 데이터를 전달하는 객체라는 것에서는 동일한 개념이나, VO는 객체 안의 값을 통해서도 비교해야하는 중요 로직에서 사용할 데이터를 담기 위해 사용하고, DTO는 단순히 데이터를 전달하는 용도로 사용한다.DAOData Access Object의 약자로 DB 데이터에 접근하는 객체이다.Controller, RestControllerController : 주로 View를 반환하기 위해 사용된다. Data를 반환해야 하는 경우에는 @ResposeBody 어노테이션을 사용하여 JSON 데이터로 반환한다.RestController : Controller에 @ResponseBody가 추가된 것으로 주 용도는 JSON 또는 XML 객체 데이터 형태로 HTTP 응답에 담아 반환하는 것이다.RESTful APIREST는 URL을 통해 자원을 명시하고 HTTP Method(GET, POST, DELETE, PUT)를 통해 자원에 대한 CRUD 동작을 표시하고 적용하는 것을 의미한다.웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍쳐 스타일이다.특징은 1)클라이언트는 유저와 관련된 처리, 서버는 REST API를 제공함으로써 역할이 구분됨 2)HTTP의 특성을 이용하기 때문에 무상태성을 갖는다. 3)캐시처리가 가능하여 응답이 빠름 4)HTTP 표준에만 따른다면 모든 플랫폼에서 사용 가능RESTful 은 REST 아키텍처를 구현하는 웹서비스를 나타내는 것으로 Client에서 바로 객체로 치환 가능한 형태의 데이터 통신을 지향하게 되면서 Server와 Client의 역할을 분리하게 되었다.[RESTful API 제약조건] URL은 자원을 표현해야 한다. URL은 최대한 명사만 사용, 동사의 역할은 method가 할 수 있도록 한다. 언더바 사용X, 필요한 경우 하이픈(-) 사용 소문자 사용 파일 확장자는 포함하지 않는다.참고1Maven, gradleMaven : Java용 프로젝트 관리 도구로 다양한 외부 라이브러리 종속성 관계를 pom.xml 파일에 명시한다.Gradle : Maven보다 코드가 간결하고, 멀티 프로젝트에 용이하다.Maven은 설정 내용이 길어지고 가독성이 떨어진다. 의존관계가 복잡한 프로젝트 설정에 부적절하다. 또 특정 설정을 소수의 모듈에서 공유하기 위해서는부모 프로젝트를 생성하여 상속하게 해야한다.Gradle은 공통 모듈을 상속해서 사용하는 단점을 커버했고, 설정 주입시 프로젝트의 조건을 체크할 수 있어서 프로젝트별로 주입되는 설정을 다르게 할 수 있다.또 빌드와 테스트 실행시 속도가 빠르다.Spring SecuritySpring 기반 애플리케이션의 인증과 권한, 인가 등을 담당하는 스프링 하위 프레임워크이다. 어플리케이션의 보안과 관련해서 체계적으로 많은 기능들을 가지고 있어 자체적으로 구현할 필요가 없어 편하다.filter 기반으로 동작하기 때문에 Spring MVC와 분리되어 관리 및 동작한다. 일반 filter와 다른 점은 filter는 서블릿 컨테이너에 직접 등록하나 sercurity filter는 DelegatingFilterProxy가 filter 작업을 sercurity filter chain으로 위임해서 실행된다.인증-사용자가 본인이 맞는지 확인하는 절차인가-인증된 사용자가 요청한 자원에 접근 가능한지를 결정하는 절차JWTJson Web Token은 인터넷 표준 인증 방식으로 인증에 필요한 정보들을 Token에 담아 암호화시켜 사용한다. JWT는 구성요소가 점(.)으로 구분되어 있고 각 Header, Payload, Signature로 구성되어 있다. Header : 토큰 타입, 서명 생성에 사용된 알고리즘 정보를 저장 Payload : 토큰에 대한 property를 key-value의 형태로 저장한다. Signature : 서명, Header, Payload를 디코딩한 값을 합쳐 서버가 가지고 있는 개인키를 가지고 암호화 한 상태이다. 서명은 서버에 있는 개인키로만 암호화할 수 있으므로 다른 클라이언트는 임의로 복호화할 수 없다.참고1스프링 vs 스프링 부트스프링 프레임워크는 기능이 많은 만큼 환경설정이 복잡하다. 이에 스프링 부트는 설정의 많은 부분을 자동화하여 사용자가 편하게 사용할 수 있도록 돕는다.starter dependency만 추가해주면 호환되는 버전을 일일히 맞출 필요가 없이 starter가 버전관리를 해준다. 내장 톰캣을 가지고 있어 별도의 톰캣을 설치할 필요가 없다.**starter란 사전에 미리 정의한 의존성 조합이다. 다수의 의존성을 이미 starter가 포함하고 있기 때문에 개발자는 starter에 대한 의존성만 추가하면 된다." }, { "title": "DB", "url": "/posts/DB/", "categories": "기술면접", "tags": "db, oracle, mysql, mariadb", "date": "2022-03-17 16:36:44 +0900", "snippet": "데이터베이스 란?다수의 사람이 공유하여 사용할 목적으로 체계화해 통합 관리하는 데이터의 집합이다.[특징] 실시간 접근성 : 수시적으로 비정형적인 질의에 대하여 실시간 처리에 의한 응답이 가능해야 한다. 계속적인 변화 : 데이터의 삽입, 삭제, 수정으로 항상 최신 데이터를 유지해야 한다. 동시공용 : 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 한다. 내용에 의한 참조 : 데이터베이스에 있는 데이터를 참조할 때 위치가 아닌, 사용자가 요구하는 데이터의 내용으로 찾는다.DBMS 란?DBMS는 데이터베이스 관리 시스템으로 다수의 사용자가 데이터베이스 내의 데이터를 접근할 수 있도록 해주는 소프트웨어 도구의 집합이다.RDBMS 란?관계형 데이터베이스 관리 시스템으로 행과 열로 구성된 2차원 테이블 형식을 이용하여 데이터를 관리하는 소프트웨어이다. (관계형 데이터 모델 : 테이블 형태의 저장구조를 가지고 데이터 사이의 연관관계를 테이블의 키, 열을 통해 표현하는 저장방식)*DBMS와 RDBMS의 차이점DBMS 데이터를 파일로 저장한다. 계층적 형식 또는 탐색 형식으로 저장된다. 표준화 되어있지 않다. 데이터 보관시 보안을 제공하지 않는다. 데이터 저장시 파일 시스템을 사용하여 테이블간의 관계가 없다. 적은 데이터 처리시 좋다. 예) XMLRDBMS 데이터를 테이블 형식으로 저장한다. PK라는 식별자가 존재하고, 데이터의 값들을 테이블 형식으로 저장한다. 표준화 되어 있다. 보안에 대해 임의의 액세스 제어 또는 강제 액세스 제어를 제공한다. 데이터에 접근하기 위해 데이터의 테이블 형식 구조를 지원한다. 많은 데이터 처리시 좋다. 예) oracle, sql, mysql 등*관계형 데이터베이스, 비관계형 데이터베이스관계형 데이터베이스 : 엄격한 데이터 스키마(구조)를 따라 데이터베이스 테이블에 저장되고(데이터 무결성 보장), 데이터는 관계를 통해 연결된 여러 테이블에 분산된다.비관계형 데이터베이스 : 스키마가 없어 다른 구조의 데이터를 같은 컬렉션(table)에 저장할 수 있다.(유연성이 좋다) 필요한 형식으로 저장할 수 있기 때문에 속도가 빠르다. 관계가 없기 때문에 조인이라는 개념이 없다.트랜잭션트랜잭션은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업 단위이다.트랜잭션의 성질 (ACID) 원자성(Atomicity) : 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다. 일관성(Consistency) : 트랜잭션이 성공적으로 완료되면 일관성 있는 데이터베이스 상태로 변환되어야 한다.(트랜잭션 수행 전과 수행 후의 상태가 같아야 한다.) 격리성(Isolation) : 트랜잭션 작업 중 다른 트랜잭션에 영향을 주거나 간섭을 받아서는 안 된다. 지속성(Durablility) : 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.트랜잭션의 격리 수준(Transaction Isolation Level)트랜잭션의 격리 수준은 트랜잭션들끼리 얼마나 고립되었는지, 잠금수준을 나타내는 것으로 특정 트랜잭션이 다른 트랜잭션에 의해 변경된 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다. 읽기 일관성을 지키기 위해서 격리 수준이 필요하다. READ UNCOMMITTED : 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있다. (트랜잭션의 변경 내용이 commit, rollback 상관없이 다른 트랜잭션에 보여진다) READ COMMITTED : 다른 트랜잭션에서 커밋된 내용만 참조할 수 있다. (트랜잭션의 변경 내용이 commit 되어야만 다른 트랜잭션에서 조회할 수 있다.) REPETABLE READ : 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있다. SERIALIZABLE : 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 한다. (가장 엄격한 수준으로 읽기 작업에서도 공유 잠금을 설정하여 다른 트랜잭션에서 변경작업을 못하게 한다. 성능저하 발생)참고1참고2로킹(Locking) 기법트랜잭션을 병행으로 처리하려고 하면 갱신 내용 손실(동시에 하나의 데이터를 갱신할 때 하나의 갱신이 누락되는 경우), 현황 파악 오류(데이터 갱신이 끝나지 않은 시점에 데이터를 조회하는 경우),모순성(트랜잭션 동시 실행시 데이터베이스가 일관성이 없는 모순 상태로 남는 문제), 연쇄 복귀 문제(두 트랜잭션이 하나의 레코드 갱신할 때 하나의 트랜잭션이 롤백되면 다른 트랜잭션마저 롤백됨)가 발생할 수 있다.이 때 로킹 제어 기법을 사용한다. 로킹 제어 기법은 하나의 트랜잭션이 실행되는 동안 데이터 항목에 대해서 데이터를 Lock 시켜서 다른 트랜잭션이 접근하지 못하도록 하고, 트랜잭션이 완료될 때 해당 부분을 Unlock 시키는 방법이다.로킹 제어 기법에는 공유 로킹(Lock한 부분을 읽기는 가능, 쓰기는 불가능), 배타 로킹(읽기 쓰기 불가능)이 있다.로킹 단위가 크면 제어 기법이 간단해지고, 병행성이 감소한다. 반대로 로킹 단위가 작으면 제어하기가 까다롭고, 병행성이 증가한다.로킹기법의 한계로는1) 직렬 가능한 스케줄이 항상 보장되지 않는다. (2단계 로킹 규약으로 해결 가능)2) 교착상태(DeadLock)가 발생할 수 있다.*2단계 로킹 규약 : 확장단계(트랜잭션은 새로운 lock 연산만 실행 가능, unlock 불가), 축소단계(트랜잭션은 새로운 unlock 연산만 실행가능, unlock 연산 실행시 lock 연산은 더이상 실행 불가)참고1데드락둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황이다.해결 방법으로는 트랜잭션을 자주 커밋, 정해진 순서로 테이블 접근, 읽기 잠금 획득 사용을 피함 등이 있다.회복기법트랜잭션 수행 중 장애(트랜잭션장애, 시스템장애, 미디어장애)로 인하여 데이터베이스가 손상을 입은 경우 정상적인 상태로 복구 시키는 작업을 가리킨다. 로그기반 회복기법 지연갱신 회복기법 : 트랜잭션의 부분 완료 상태에서는 변경 내용을 로그 파일에만 저장하고 커밋 발생 전까지는 데이터베이스에 기록하지 않는다. 회복 과정에서 undo가 필요 없고 트랜잭션의 원자성을 보장할 수 있다. 즉시갱신 회복기법 : 트랜잭션 수행 도중에도 변경 내용을 즉시 데이터베이스와 로그에 기록, 커밋 발생 전 장애 발생시 undo, 커밋 후 장애 발생시 redo 체크포인트 회복기법 : 장애 발생시 checkpoint 이전에 처리된 트랜잭션은 회복에서 제외, checkpoint 이후 처리된 트랜잭션은 회복 작업 수행 그림자 페이징 회복 기법 : 트랜잭션 실행시 현재 페이지 테이블과 동일한 그림자 페이지 테이블을 생성하여 트랜잭션이 성공하면 그림자 페이지 테이블을 삭제하고, 장애 발생시 그림자 페이지 테이블을 현재 페이지 테이블로 한다. 미디어 회복 기법 : 디스크 같은 저장장치가 손상되는 장애에 대비하여 데이터베이스 내용을 별도의 물리적 저장장치에 백업하고, 장애 발생시 가장 최근 백업 데이터로 복구하고 로그파일을 참조하여 백업 이후 작업에 대하여 redo참고1무결성무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말한다. 개체 무결성 : 기본키(PK)로 선택된 필드는 빈 값을 허용하지 않고, 유일한 값이여야 한다. 참조 무결성 : 외래키(FK) 값은 Null 이거나 참조할 테이블의 기본키 값과 동일해야 한다. 또 참조할 수 없는 값을 지닐 수 없다. 도메인 무결성 : 테이블의 존재하는 필드의 타입, Null 값 허용 등에 대한 사항 정의하여 올바른 데이터가 입력되었는지 확인 고유 무결성 : Unique 테이블의 특정 속성에 대해 각 레코드들이 갖는 값들은 서로 달라야한다. -&gt; 유일 해야 한다. NULL 무결성 : 특정 속성 값이 Null이 될 수 없게 하는 조건 키 무결성 : 하나의 테이블엔 적어도 하나의 키가 존재해야 한다.정규화, 반정규화정규화 란 무결성을 유지하기 위하여 테이블을 분할하여 중복된 데이터를 제거하는 프로세스이다. 데이터 변경시 이상 현상을 제거하고, 구조 확장시 재디자인을 최소화한다.[이상현상] 삽입이상 : 데이터를 삽입시 원하지 않는 값도 같이 삽입되는 현상 삭제이상 : 원하는 데이터만 삭제하고 싶은데 삭제를 원치 않는 속성 값도 같이 지워지는 현상 갱신이상 : 속성값을 갱신할 때 일부 정보만 갱신되어 정보의 모순이 발생하는 현상[정규화 과정] 제1정규형 : 각 컬럼의 값은 원자값을 가져야 한다. (유일한 값, 식별성 o) 제2정규형 : 부분 함수적 종속 제거 (예. {X1, X2} -&gt; Y일 경우, X1와 X2가 Y의 값을 결정할 때 이를 완전 함수적 종속 이라고 하고, X1, X2 중 하나만 Y의 값을 결정할 때 이를 부분 함수적 종속 이라고 한다.) 제3정규형 : 이행적 함수 종속 제거 (예. 이행적 함수 종속이란 A -&gt; B, B -&gt; C가 성립할 때 A -&gt; C가 성립되는 것) 보이스코드 정규형 : 결정자이면서 후보키가 아닌것을 제거해야한다. (예. [학번+과목] =&gt; 교수를 결정, 교수는 과목을 결정, 교수도 결정자인데 교수는 학번을 결정지을 수 없으므로 후보키가 아님) 제4정규형 : 다치 종속성 제거 제5정규형 : 조인 종속성 제거반정규화 란 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 시스템의 성능을 향상시키고 관리의 효율성을 증대시킨다. (단, 과도한 반정규화는 성능을 저하시킴)[반정규화 방법] 테이블 통합 : 두 개의 테이블이 조인되는 경우가 많은 경우에 하나의 테이블로 합치는 것이 성능향상에 도움이 되는 경우 테이블을 통합한다. 테이블 분할 : 테이블을 수직(한 테이블에 속성이 너무 많은 경우 속성을 기준으로 분할) 또는 수평(레코드 기준으로 사용빈도의 차이가 큰 경우 분할)으로 분할하는 것 중복 테이블 추가 : 여러 테이블에서 데이터를 추출해서 사용하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 중복 테이블을 추가한다. 중복 속성 추가 : 조인해서 데이터 처리시 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 추가한다.**수평분할 예) 고객 테이블에서 성별에 따라 남녀로 나누어 두 개의 테이블로 분할한다.파티셔닝데이터베이스 분할(partitioning)은 데이터베이스에서 크기가 큰 테이블을 작은 단위로 분할하는 것이다. 데이터가 너무 커져서 조회 시간이 길어지는 경우 또는 관리 용이성, 성능, 가용성 등의 향상을 이유로 행해진다.[파티셔닝 분할 기준] Range Partitioning(범위 분할) : 컬럼 값의 범위를 기준으로 행을 분할하는 형태로 달, 분기 등의 범위의 분산에 주로 사용됨 List Partitioning(목록 분할) : 특정한 값을 기준으로 데이터를 분할 예) 서울, 경기.. 지역명 등 Hash Partitioning(해시 분할) : Hash 함수 결과값을 기준으로 데이터 분할한다. hash 함수를 사용하므로 데이터가 어느 파티션으로 들어가는지 알 수 없어 관리 목적에는 맞지 않으나 데이터를 여러 위치에 분산 배치하여 디스크 IO 성능을 개선한다. Composite Partitioning(합성 분할) : 파티셔닝 기법을 결합한 것 예) 범위분할 + 해시분할옵티마이저옵티마이저는 개발자가 작성한 SQL의 실행계획을 수립하고 여러개의 실행계획 중 최적의 처리 경로를 선택하여 SQL을 실행하는 DBMS의 핵심 엔진이다.동일한 결과가 나오는 SQL이라도 실행계획에 따라 성능이 달라질 수 있다.[실행순서]1) SQL문을 작성2) Parser가 SQL문을 문법검사, 구문분석을 한다.3) 옵티마이저가 여러 계획을 생성하고 여러 통계정보를 이용하여 최소 비용의 실행계획을 결정4) SQL 실행엔진이 옵티마이저가 결정한 실행계획대로 데이터를 처리 후 사용자에게 전달옵티마이저에는 비용기반 옵티마이저(비용이 가장 적은 실행계획을 선택), 규칙기반 옵티마이저(우선순위가 높은 규칙을 가지고 실행계획을 선택)가 있다.참고1인덱스인덱스는 데이터베이스 테이블에 대한 검색 속도를 높여주는 자료구조이다. 특정 컬럼에 인덱스를 생성하면 데이터를 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다.인덱스의 가장 큰 특징은 데이터들이 정렬되어 있다는 것으로 이로 인해 where 절에서 테이블을 full scan하지 않고 조건에 맞는 데이터를 빠르게 찾을 수 있다.또한 데이터가 정렬되어 있기 때문에 Sort 과정을 피할 수 있어 자원소비를 줄일 수 있다.단점으로는 정렬된 상태를 계속 유지시켜 주어야하기 때문에 데이터가 추가, 삭제, 수정으로 인해 변경되면 값들을 다시 정렬해한다. 그리고 인덱스를 관리하기 위해별도의 저장공간이 추가로 필요하기 때문에 무조건 인덱스를 만드는 것이 좋은 것은 아니다.수정이 빈번하지 않고, where, join, order by, group by, union이 빈번한 컬럼과테이블의 전체 데이터 중에서 10~15% 이하의 데이터를 처리하는 경우에 인덱스를 사용하면 효율적이다.참고1참고2View뷰는 한 개 이상의 기본 테이블이나 다른 뷰를 이용하여 생성되는 가상 테이블이다. 뷰에 대한 정의인 SQL문만 저장되어 있어 디스크 저장공간이 할당되지 않는다.일부 데이터에만 접근할 수 있도록 제한하기 위한 기법이다.뷰의 장점은 논리적인 독립성을 제공하고, 데이터의 접근을 제어함으로써 보안이 좋다. 복잡한 질의문을 단순화할 수 있다.단점으로는 뷰의 정의를 변경할 수 없고(변경하려면 삭제후 재 생성해야험), insert, delete, update에 많은 제한이 있다.조인관계형 데이터베이스에서는 중복 데이터를 피하기 위해 데이터를 쪼개 여러 테이블로 나눠 저장하는데,원하는 결과를 도출하기 위해 다시 두 개 이상의 테이블을 조합할할필요가 있다. 이때 join 연산자를 사용하여 관련있는 컬럼 기준으로 테이블을 연결해서 데이터를 검색하는 방법이다.[조인 종류] INNER JOIN : 교집합으로 두 테이블의 공통적인 부분만 SELECT 한다. LEFT / RIGHT JOIN : 부분집합으로 조인 기준이 LEFT or RIGHT에 따라 SELECT 됨 OUTER JOIN : 합집합으로 두 테이블이 가지고 있는것 모두 SELECT 한다.트리거특정 테이블에 insert, delete, update 문이 수행되었을 때, 데이터베이스에 자동으로 동작하도록 작성된 프로그램이다.트리거는 데이터베이스에 의해 자동으로 호출되지만 특정 테이블의 이벤트 발생과 하나의 트랜잭션 안에서 일어나는 일련의 작업으로 이벤트가 ROLLBACK 되면트리거로 동작한 작업도 취소된다.[트리거의 종류] 행 트리거 : 데이터 변화가 생길 때마다 실행 문장 트리거 : 트리거에 의해 단 한 번 실행**COMMIT, ROLLBACK을 트리거 안에서 사용시 에러 발생함프로시저자주 사용하는 특정 작업에 대하여 필요할 때 호출하기 위해 절차적인 언어를 이용하여 작성한 프로그램이다.장점) 하나의 요청으로 여러 SQL을 실행할 수 있으며 그로 인해 네트워크 부하를 줄일 수 있다.단점) DB 확장이 어렵고 유지보수가 어렵다.함수절차형 SQL을 활용하여 일련의 SQL 처리를 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 절차형 SQL이다.SQLSQL은 관계형 데이터베이스 시스템에서 사용하는 질의 언어이다. 문법이 다른 언어보다 단순하고, 대소문자를 구별하지 않는다.[분류] DDL - 데이터 정의어, 테이블이나 관계의 구조를 생성하는데 사용한다. 예)CREATE, ALTER, DROP DML - 데이터 조작어, 테이블에 있는 데이터를 직접 조작하는데 사용한다. 데이터 입력, 조회, 수정, 삭제 예)INSERT, SELECT, DELETE, UPDATE DCL - 데이터에 접근할 수 있는 권한을 관리하는 언어 예)GRANT, REVOKE / 가진 권한을 남에게 주는 경우 ‘with grant option’, 참조 객체에 사용된 참조 무결성 제약 함께 삭제 ‘casecade constraints’ TCL - 트랜잭션 제어어 예)COMMIT, ROLLBACK, SAVEPOINT …NoSQL다양한 의견이 있지만 ‘Not Only SQL’이 의견의 다수를 차지하고 있다. 단순히 RDBMS가 가진 특성뿐만 아니라 다른 특성들을 부가적으로 지원한다는 것을 의미한다.테이블간의 관계를 정의하지 않아 일반적으로 테이블간 join도 불가능하다.장점) 유연성, 확장성, 고성능, 고기능성[종류] Key Value DB : 해시 테이블을 사용하여 키 값의 쌍을 저장하여 사용 예)Redis, Amazon Dynamo DB Document DB : JSON, XML과 같은 Collection 데이터 모델 구조를 채택하고 있다. 예)MongoDB Graph DB : 개체과 관계를 그래프 형태로 표현 예)Neo4J Wide Columnar Store : Key Value에서 발전된 형태의 Column Family 데이터 모델을 사용한다. 예)HBase, Cassandra..Oracle, MySQL, MariaDB, PostgreSQL 차이점, 특징ORACLE : 1)대량의 정보 관리를 할 때 좋은 성능을 보인다. 2)고성능 트랜잭션 처리 지원하여 속도가 빠르다. 3)가격이 비싸다.오라클 버전별 특징 참고MySQL : 오픈소스로 다중 사용자 다중 스레드를 지원한다. 무료로 사용할 수 있고, 표준 SQL형식을 사용한다.MariaDB : MySQL을 만든 개발자가 만든것으로 따라서 MySQL과 매우 유사하다. MySQL의 단점을 개선하였다 =&gt; 어떤??PostgreSQL : 대용량 데이터 처리를 위한 기능을 구현, 신뢰성과 안전성이 매우 높다. 오픈소스로 무료로 사용가능하다.[문법차이]1) 공백치환 : Oracle -&gt; NVL(), MySQL -&gt; IFNULL()2) 현재날짜 : Oracle -&gt; SYSDATE, MySQL -&gt; NOW()3) 문자 합치기 : Oracle -&gt; ||, MySQL -&gt; CONCAT()4) Oracle -&gt; ROWNUM, MySQL -&gt; LIMIT" } ]
